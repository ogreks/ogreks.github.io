{"meta":{"title":"Cat at ngint","subtitle":"夜の猫","description":"夜の猫<br>分享技术和生活之中的琐事 <br> 记录生活和随笔","author":"ogreks","url":"https://bawcat.wiki","root":"/"},"pages":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"categories/index.html","permalink":"https://bawcat.wiki/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"link/index.html","permalink":"https://bawcat.wiki/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"tags/index.html","permalink":"https://bawcat.wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"竞争条件检测","slug":"golang/竞争条件检测","date":"2021-07-22T08:57:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2021/07/22/golang/竞争条件检测/","link":"","permalink":"https://bawcat.wiki/2021/07/22/golang/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%B5%8B/","excerpt":"","text":"竞争条件检测 (摘抄自 GO语言圣经) 转载地址:原版: http://www.gopl.io/中文: https://book.itsfun.top/gopl-zh/ 即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。 只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：https://golang.org/ref/mem ） 竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。 竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。 由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的程序（工作）来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。（译注：多少服务端C和C++程序员为此竞折腰。）","categories":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/tags/golang/"},{"name":"go","slug":"go","permalink":"https://bawcat.wiki/tags/go/"},{"name":"协程","slug":"协程","permalink":"https://bawcat.wiki/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"进程锁","slug":"进程锁","permalink":"https://bawcat.wiki/tags/%E8%BF%9B%E7%A8%8B%E9%94%81/"},{"name":"debug 方法","slug":"debug-方法","permalink":"https://bawcat.wiki/tags/debug-%E6%96%B9%E6%B3%95/"},{"name":"竞争调试","slug":"竞争调试","permalink":"https://bawcat.wiki/tags/%E7%AB%9E%E4%BA%89%E8%B0%83%E8%AF%95/"}]},{"title":"Golang 关于变量","slug":"golang/变量","date":"2021-06-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2021/06/03/golang/变量/","link":"","permalink":"https://bawcat.wiki/2021/06/03/golang/%E5%8F%98%E9%87%8F/","excerpt":"","text":"关于 Golang 变量的理解(摘抄自 GO语言圣经) 转载地址:原版: http://www.gopl.io/中文: https://book.itsfun.top/gopl-zh/ 指针一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。 一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。 如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。 12345x := 1p := &amp;x // p, of type *int, points to xfmt.Println(*p) // &quot;1&quot;*p = 2 // equivalent to x = 2fmt.Println(x) // &quot;2&quot; 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。 变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。 任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。 12var x, y intfmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil) // &quot;true false false&quot; 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。 123456var p = f()func f() *int &#123; v := 1 return &amp;v&#125; 每次调用f函数都将返回不同的结果： 1fmt.Println(f() == f()) // &quot;false&quot; 因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。例如下面这个例子就是通过指针来更新变量的值，然后返回更新后的值，可用在一个表达式中（译注：这是对C语言中++v操作的模拟，这里只是为了说明指针的用法，incr函数模拟的做法并不推荐）： 12345678func incr(p *int) int &#123; *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！ return *p&#125;v := 1incr(&amp;v) // side effect: v is now 2fmt.Println(incr(&amp;v)) // &quot;3&quot; (and v is 3) 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如，*p就是变量v的别名。指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。 指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的echo版本中，就包含了两个可选的命令行参数：-n用于忽略行尾的换行符，-s sep用于指定分隔字符（默认是空格）。下面这是第四个版本，对应包路径为gopl.io/ch2/echo4。 gopl.io/ch2/echo4 12345678910111213141516171819// Echo4 prints its command-line arguments.package mainimport ( &quot;flag&quot; &quot;fmt&quot; &quot;strings&quot;)var n = flag.Bool(&quot;n&quot;, false, &quot;omit trailing newline&quot;)var sep = flag.String(&quot;s&quot;, &quot; &quot;, &quot;separator&quot;)func main() &#123; flag.Parse() fmt.Print(strings.Join(flag.Args(), *sep)) if !*n &#123; fmt.Println() &#125;&#125; 调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），最后是该标志参数对应的描述信息。如果用户在命令行输入了一个无效的标志参数，或者输入-h或-help参数，那么将打印所有标志参数的名字、默认值和描述信息。类似的，调用flag.String函数将创建一个对应字符串类型的标志参数变量，同样包含命令行标志参数对应的参数名、默认值、和描述信息。程序中的sep和n变量分别是指向对应命令行标志参数变量的指针，因此必须用*sep和*n形式的指针语法间接引用它们。 当程序运行时，必须在使用标志参数对应的变量之前先调用flag.Parse函数，用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用flag.Args()函数来访问，返回值对应一个字符串类型的slice。如果在flag.Parse函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序。 让我们运行一些echo测试用例： 123456789101112$ go build gopl.io/ch2/echo4$ ./echo4 a bc defa bc def$ ./echo4 -s / a bc defa/bc/def$ ./echo4 -n a bc defa bc def$$ ./echo4 -helpUsage of ./echo4:-n omit trailing newline-s string separator (default &quot; &quot;) 2.3.3. new函数另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 1234p := new(int) // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // &quot;0&quot;*p = 2 // 设置 int 匿名变量的值为 2fmt.Println(*p) // &quot;2&quot; 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。 下面的两个newInt函数有着相同的行为： 12345678func newInt() *int &#123; return new(int)&#125;func newInt() *int &#123; var dummy int return &amp;dummy&#125; 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的： 123p := new(int)q := new(int)fmt.Println(p == q) // &quot;false&quot; 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct&#123;&#125;和[0]int，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）。 new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）。 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子： 1func delta(old, new int) int &#123; return new - old &#125; 由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。 2.3.4. 变量的生命周期变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 例如，下面是从1.4节的Lissajous程序摘录的代码片段： 123456for t := 0.0; t &lt; cycles*2*math.Pi; t += res &#123; x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)&#125; 译注：函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样： 12345678for t := 0.0; t &lt; cycles*2*math.Pi; t += res &#123; x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex( size+int(x*size+0.5), size+int(y*size+0.5), blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性 ) // 小括弧另起一行缩进，和大括弧的风格保存一致&#125; 在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。 那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。 因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。 123456789101112var global *intfunc f() &#123; var x int x = 1 global = &amp;x&#125;func g() &#123; y := new(int) *y = 1&#125; f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。 Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。","categories":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/tags/golang/"},{"name":"go","slug":"go","permalink":"https://bawcat.wiki/tags/go/"},{"name":"指针","slug":"指针","permalink":"https://bawcat.wiki/tags/%E6%8C%87%E9%92%88/"},{"name":"变量","slug":"变量","permalink":"https://bawcat.wiki/tags/%E5%8F%98%E9%87%8F/"},{"name":"gc","slug":"gc","permalink":"https://bawcat.wiki/tags/gc/"}]},{"title":"FFmpeg Tutorial","slug":"程序人生/ffmpeg-2020-11-29-FFmpeg-Tutorial","date":"2020-11-29T11:38:11.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/11/29/程序人生/ffmpeg-2020-11-29-FFmpeg-Tutorial/","link":"","permalink":"https://bawcat.wiki/2020/11/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/ffmpeg-2020-11-29-FFmpeg-Tutorial/","excerpt":"","text":"FFmpeg_TutorialFFmpeg工具和sdk库的使用demogithub link (https://github.com/MagicConch17/FFmpeg_Tutorial)[https://github.com/MagicConch17/FFmpeg_Tutorial] 一、使用FFmpeg命令行工具和批处理脚本进行简单的音视频文件编辑1、基本介绍对于每一个从事音视频技术开发的工程师，想必没有一个人对FFmpeg这个名称感到陌生。FFmpeg是一套非常知名的音视频处理的开源工具，它包含了开发完成的工具软件、封装好的函数库以及源代码供我们按需使用。FFmpeg提供了非常强大的功能，可以完成音视频的编码、解码、转码、视频采集、后处理（抓图、水印、封装/解封装、格式转换等），还有流媒体服务等诸多功能，可以说涵盖了音视频开发中绝大多数的领域。原生的FFmpeg是在Linux环境下开发的，但是通过各种方法（比如交叉编译等）可以使它运行在多种平台环境上，具有比较好的可移植性。 FFmpeg项目的官方网址为：https://ffmpeg.org/。在它的官网上我们可以找到许多非常有用的内容，如项目的简介、版本更新日志、库和源代码的地址、使用文档等信息。官方的使用文档是我们在开发时必不可少的信息来源，其重要性不言而喻。除了官方网站以外，我们下载的FFmpeg的程序包中也有使用参考文档的离线版本。 2、FFmpeg组成构成FFmpeg主要有三个部分，第一部分是四个作用不同的工具软件，分别是：ffmpeg.exe，ffplay.exe，ffserver.exe和ffprobe.exe。 ffmpeg.exe：音视频转码、转换器 ffplay.exe：简单的音视频播放器 ffserver.exe：流媒体服务器 ffprobe.exe：简单的多媒体码流分析器 第二部分是可以供开发者使用的SDK，为各个不同平台编译完成的库。如果说上面的四个工具软件都是完整成品形式的玩具，那么这些库就相当于乐高积木一样，我们可以根据自己的需求使用这些库开发自己的应用程序。这些库有： libavcodec：包含音视频编码器和解码器 libavutil：包含多媒体应用常用的简化编程的工具，如随机数生成器、数据结构、数学函数等功能 libavformat：包含多种多媒体容器格式的封装、解封装工具 libavfilter：包含多媒体处理常用的滤镜功能 libavdevice：用于音视频数据采集和渲染等功能的设备相关 libswscale：用于图像缩放和色彩空间和像素格式转换功能 libswresample：用于音频重采样和格式转换等功能 第三部分是整个工程的源代码，无论是编译出来的可执行程序还是SDK，都是由这些源代码编译出来的。FFmpeg的源代码由C语言实现，主要在Linux平台上进行开发。FFmpeg不是一个孤立的工程，它还存在多个依赖的第三方工程来增强它自身的功能。在当前这一系列的博文/视频中，我们暂时不会涉及太多源代码相关的内容，主要以FFmpeg的工具和SDK的调用为主。到下一系列我们将专门研究如何编译源代码并根据源代码来进行二次开发。 3、FFMpeg工具的下载和使用(1)FFmpeg工具的下载：在官网上我们可以找到”Download”页面，该页上可以下载FFmpeg的工具、库和源代码等。在选择”Windows Packages”下的Windows Builds后，会跳转到Windows版本的下载页面： 在下载页面上，我们可以看到，对于32位和64位版本，分别提供了三种不同的模式：static、shared和dev static: 该版本提供了静态版本的FFmpeg工具，将依赖的库生成在了最终的可执行文件中；作为工具而言此版本就可以满足我们的需求； share: 该版本的工具包括可执行文件和dll，程序运行过程必须依赖于提供的dll文件； dev: 提供了库的头文件和dll的引导库； (2)ffplay.exe的使用ffplay是一个极为简单的音视频媒体播放器。ffplay.exe使用了ffmpeg库和SDL库开发成的，可以用作FFmpeg API的测试工具。ffplay的使用方法，最简单的是直接按照默认格式播放某一个音视频文件或流： ffplay.exe -i ../video/IMG_0886.MOV 除此之外，ffplay还支持传入各种参数来控制播放行为。比较常用的参数有： -i input_file：输入文件名 -x width -y height：控制播放窗口的宽高 -t duration：控制播放的时长 -window_title title：播放窗口的标题，默认为输入文件名 -showmode mode：设置显示模式，0:显示视频;1:显示音频波形；2：显示音频频谱 -autoexit：设置视频播放完成后自动退出 其他参数可以参考官网的文档：https://www.ffmpeg.org/ffplay.html或下载包里的文档 (3)ffprobe的使用ffprobe可以提供简单的音视频文件分析功能。最简单的方法同ffplay类似： ffprobe.exe -i ../video/IMG_0886.MOV 分析完成后，ffprobe会显示音视频文件中包含的每个码流的信息，包括编码格式、像素分辨率、码率、帧率等信息： (4)ffmpeg的使用ffmpeg.exe可谓是整个工程的核心所在，它的主要功能是完成音视频各种各样的转换操作。视频转码：ffmpeg.exe可以将视频文件由原格式转换为其他格式，如从avi转为mp4等： ffmpeg -i ../video/IMG_0886.MOV ../video/output_mpeg4_mp3.avi 这里，ffmpeg默认将视频编码格式选择为mpeg4，音频转码格式为mp3。如果我们希望保留原始编码，需要增加参数-c copy，表明不做任何转码操作： ffmpeg -i ../video/IMG_0886.MOV -c copy ../video/output_copy.avi 如果我们希望将视频转换为其他编码格式，则需要在参数中指定目标格式-c:v libx265或-vcodec libx265。ffmpeg支持的所有编码器格式可以通过以下命令查看： ffmpeg.exe -encoders 实际操作： ffmpeg -i ../video/IMG_0886.MOV -c:v mjpeg ../video/output_mjpeg.avi 视频解封装：ffmpeg可以将视频中的音频和视频流分别提取出来。需要在命令行中添加参数-an和-vn，分别表示屏蔽音频和视频流： @REM 提取视频流 ffmpeg -i ../video/IMG_0886.MOV -c:v copy -an ../video/IMG_0886_v.MOV @REM 提取音频流 ffmpeg -i ../video/IMG_0886.MOV -c:a copy -vn ../video/IMG_0886_a.aac 视频截取：使用ffmpeg命令并指定参数-ss和-t，分别表示截取开始时刻和截取时长 @REM 视频截取 ffmpeg -ss 5 -t 5 -i ../video/IMG_0886.MOV -c copy ../video/IMG_0886_cut.MOV 二、调用FFmpeg SDK对YUV视频序列进行编码视频由像素格式编码为码流格式是FFMpeg的一项基本功能。通常，视频编码器的输入视频通常为原始的图像像素值，输出格式为符合某种格式规定的二进制码流。 1、FFMpeg进行视频编码所需要的结构： AVCodec：AVCodec结构保存了一个编解码器的实例，实现实际的编码功能。通常我们在程序中定义一个指向AVCodec结构的指针指向该实例。 AVCodecContext：AVCodecContext表示AVCodec所代表的上下文信息，保存了AVCodec所需要的一些参数。对于实现编码功能，我们可以在这个结构中设置我们指定的编码参数。通常也是定义一个指针指向AVCodecContext。 AVFrame：AVFrame结构保存编码之前的像素数据，并作为编码器的输入数据。其在程序中也是一个指针的形式。 AVPacket：AVPacket表示码流包结构，包含编码之后的码流数据。该结构可以不定义指针，以一个对象的形式定义。 在我们的程序中，我们将这些结构整合在了一个结构体中： /************************************************* Struct: CodecCtx Description: FFMpeg编解码器上下文 *************************************************/ typedef struct &#123; AVCodec *codec; //指向编解码器实例 AVFrame *frame; //保存解码之后/编码之前的像素数据 AVCodecContext *c; //编解码器上下文，保存编解码器的一些参数设置 AVPacket pkt; //码流包结构，包含编码码流数据 &#125; CodecCtx; 2、FFMpeg编码的主要步骤：(1)、输入编码参数这一步我们可以设置一个专门的配置文件，并将参数按照某个事写入这个配置文件中，再在程序中解析这个配置文件获得编码的参数。如果参数不多的话，我们可以直接使用命令行将编码参数传入即可。 (2)、按照要求初始化需要的FFMpeg结构首先，所有涉及到编解码的的功能，都必须要注册音视频编解码器之后才能使用。注册编解码调用下面的函数： avcodec_register_all(); 编解码器注册完成之后，根据指定的CODEC_ID查找指定的codec实例。CODEC_ID通常指定了编解码器的格式，在这里我们使用当前应用最为广泛的H.264格式为例。查找codec调用的函数为avcodec_find_encoder，其声明格式为： AVCodec *avcodec_find_encoder(enum AVCodecID id); 该函数的输入参数为一个AVCodecID的枚举类型，返回值为一个指向AVCodec结构的指针，用于接收找到的编解码器实例。如果没有找到，那么该函数会返回一个空指针。调用方法如下： /* find the mpeg1 video encoder */ ctx.codec = avcodec_find_encoder(AV_CODEC_ID_H264); //根据CODEC_ID查找编解码器对象实例的指针 if (!ctx.codec) &#123; fprintf(stderr, &quot;Codec not found\\n&quot;); return false; &#125; AVCodec查找成功后，下一步是分配AVCodecContext实例。分配AVCodecContext实例需要我们前面查找到的AVCodec作为参数，调用的是avcodec_alloc_context3函数。其声明方式为： AVCodecContext *avcodec_alloc_context3(const AVCodec *codec); 其特点同avcodec_find_encoder类似，返回一个指向AVCodecContext实例的指针。如果分配失败，会返回一个空指针。调用方式为： ctx.c = avcodec_alloc_context3(ctx.codec); //分配AVCodecContext实例 if (!ctx.c) &#123; fprintf(stderr, &quot;Could not allocate video codec context\\n&quot;); return false; &#125; 需注意，在分配成功之后，应将编码的参数设置赋值给AVCodecContext的成员。 现在，AVCodec、AVCodecContext的指针都已经分配好，然后以这两个对象的指针作为参数打开编码器对象。调用的函数为avcodec_open2，声明方式为： int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options); 该函数的前两个参数是我们刚刚建立的两个对象，第三个参数为一个字典类型对象，用于保存函数执行过程总未能识别的AVCodecContext和另外一些私有设置选项。函数的返回值表示编码器是否打开成功，若成功返回0，失败返回一个负数。调用方式为： if (avcodec_open2(ctx.c, ctx.codec, NULL) &lt; 0) //根据编码器上下文打开编码器 &#123; fprintf(stderr, &quot;Could not open codec\\n&quot;); exit(1); &#125; 然后，我们需要处理AVFrame对象。AVFrame表示视频原始像素数据的一个容器，处理该类型数据需要两个步骤，其一是分配AVFrame对象，其二是分配实际的像素数据的存储空间。分配对象空间类似于new操作符一样，只是需要调用函数av_frame_alloc。如果失败，那么函数返回一个空指针。AVFrame对象分配成功后，需要设置图像的分辨率和像素格式等。实际调用过程如下： ctx.frame = av_frame_alloc(); //分配AVFrame对象 if (!ctx.frame) &#123; fprintf(stderr, &quot;Could not allocate video frame\\n&quot;); return false; &#125; ctx.frame-&gt;format = ctx.c-&gt;pix_fmt; ctx.frame-&gt;width = ctx.c-&gt;width; ctx.frame-&gt;height = ctx.c-&gt;height; 分配像素的存储空间需要调用av_image_alloc函数，其声明方式为： int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align); 该函数的四个参数分别表示AVFrame结构中的缓存指针、各个颜色分量的宽度、图像分辨率（宽、高）、像素格式和内存对其的大小。该函数会返回分配的内存的大小，如果失败则返回一个负值。具体调用方式如： ret = av_image_alloc(ctx.frame-&gt;data, ctx.frame-&gt;linesize, ctx.c-&gt;width, ctx.c-&gt;height, ctx.c-&gt;pix_fmt, 32); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not allocate raw picture buffer\\n&quot;); return false; &#125; (3)、编码循环体到此为止，我们的准备工作已经大致完成，下面开始执行实际编码的循环过程。用伪代码大致表示编码的流程为： while (numCoded &lt; maxNumToCode) &#123; read_yuv_data(); encode_video_frame(); write_out_h264(); &#125; 其中，read_yuv_data部分直接使用fread语句读取即可，只需要知道的是，三个颜色分量Y/U/V的地址分别为AVframe::data[0]、AVframe::data[1]和AVframe::data[2]，图像的宽度分别为AVframe::linesize[0]、AVframe::linesize[1]和AVframe::linesize[2]。需要注意的是，linesize中的值通常指的是stride而不是width，也就是说，像素保存区可能是带有一定宽度的无效边区的，在读取数据时需注意。 编码前另外需要完成的操作时初始化AVPacket对象。该对象保存了编码之后的码流数据。对其进行初始化的操作非常简单，只需要调用av_init_packet并传入AVPacket对象的指针。随后将AVPacket::data设为NULL，AVPacket::size赋值0. 成功将原始的YUV像素值保存到了AVframe结构中之后，便可以调用avcodec_encode_video2函数进行实际的编码操作。该函数可谓是整个工程的核心所在，其声明方式为： int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr); 其参数和返回值的意义： avctx: AVCodecContext结构，指定了编码的一些参数； avpkt: AVPacket对象的指针，用于保存输出码流； frame：AVframe结构，用于传入原始的像素数据； got_packet_ptr：输出参数，用于标识AVPacket中是否已经有了完整的一帧； 返回值：编码是否成功。成功返回0，失败则返回负的错误码 通过输出参数*got_packet_ptr，我们可以判断是否应有一帧完整的码流数据包输出，如果是，那么可以将AVpacket中的码流数据输出出来，其地址为AVPacket::data，大小为AVPacket::size。具体调用方式如下： /* encode the image */ ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), ctx.frame, &amp;got_output); //将AVFrame中的像素信息编码为AVPacket中的码流 if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error encoding frame\\n&quot;); exit(1); &#125; if (got_output) &#123; //获得一个完整的编码帧 printf(&quot;Write frame %3d (size=%5d)\\n&quot;, frameIdx, ctx.pkt.size); fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout); av_packet_unref(&amp;(ctx.pkt)); &#125; 因此，一个完整的编码循环提就可以使用下面的代码实现： /* encode 1 second of video */ for (frameIdx = 0; frameIdx &lt; io_param.nTotalFrames; frameIdx++) &#123; av_init_packet(&amp;(ctx.pkt)); //初始化AVPacket实例 ctx.pkt.data = NULL; // packet data will be allocated by the encoder ctx.pkt.size = 0; fflush(stdout); Read_yuv_data(ctx, io_param, 0); //Y分量 Read_yuv_data(ctx, io_param, 1); //U分量 Read_yuv_data(ctx, io_param, 2); //V分量 ctx.frame-&gt;pts = frameIdx; /* encode the image */ ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), ctx.frame, &amp;got_output); //将AVFrame中的像素信息编码为AVPacket中的码流 if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error encoding frame\\n&quot;); exit(1); &#125; if (got_output) &#123; //获得一个完整的编码帧 printf(&quot;Write frame %3d (size=%5d)\\n&quot;, frameIdx, ctx.pkt.size); fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout); av_packet_unref(&amp;(ctx.pkt)); &#125; &#125; //for (frameIdx = 0; frameIdx &lt; io_param.nTotalFrames; frameIdx++) (4)、收尾处理如果我们就此结束编码器的整个运行过程，我们会发现，编码完成之后的码流对比原来的数据少了一帧。这是因为我们是根据读取原始像素数据结束来判断循环结束的，这样最后一帧还保留在编码器中尚未输出。所以在关闭整个解码过程之前，我们必须继续执行编码的操作，直到将最后一帧输出为止。执行这项操作依然调用avcodec_encode_video2函数，只是表示AVFrame的参数设为NULL即可： /* get the delayed frames */ for (got_output = 1; got_output; frameIdx++) &#123; fflush(stdout); ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), NULL, &amp;got_output); //输出编码器中剩余的码流 if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error encoding frame\\n&quot;); exit(1); &#125; if (got_output) &#123; printf(&quot;Write frame %3d (size=%5d)\\n&quot;, frameIdx, ctx.pkt.size); fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout); av_packet_unref(&amp;(ctx.pkt)); &#125; &#125; //for (got_output = 1; got_output; frameIdx++) 此后，我们就可以按计划关闭编码器的各个组件，结束整个编码的流程。编码器组件的释放流程可类比建立流程，需要关闭AVCocec、释放AVCodecContext、释放AVFrame中的图像缓存和对象本身： avcodec_close(ctx.c); av_free(ctx.c); av_freep(&amp;(ctx.frame-&gt;data[0])); av_frame_free(&amp;(ctx.frame)); 3、总结使用FFMpeg进行视频编码的主要流程如： 首先解析、处理输入参数，如编码器的参数、图像的参数、输入输出文件； 建立整个FFMpeg编码器的各种组件工具，顺序依次为：avcodec_register_all -&gt; avcodec_find_encoder -&gt; avcodec_alloc_context3 -&gt; avcodec_open2 -&gt; av_frame_alloc -&gt; av_image_alloc; 编码循环：av_init_packet -&gt; avcodec_encode_video2(两次) -&gt; av_packet_unref 关闭编码器组件：avcodec_close，av_free，av_freep，av_frame_free 三、调用FFmpeg SDK对H.264格式的视频压缩码流进行解码经过了上篇调用FFMpeg SDK对视频进行编码的过程之后，我们可以比较容易地理解本篇的内容，即上一篇的逆过程——将H.264格式的裸码流解码为像素格式的图像信息。 1、FFMpeg视频解码器所包含的结构同FFMpeg编码器类似，FFMpeg解码器也需要编码时的各种结构，除此之外，解码器还需要另一个结构——编解码解析器——用于从码流中截取出一帧完整的码流数据单元。因此我们定义一个编解码上下文结构为： /************************************************* Struct: CodecCtx Description: FFMpeg编解码器上下文 *************************************************/ typedef struct &#123; AVCodec *pCodec; //编解码器实例指针 AVCodecContext *pCodecContext; //编解码器上下文，指定了编解码的参数 AVCodecParserContext *pCodecParserCtx; //编解码解析器，从码流中截取完整的一个NAL Unit数据 AVFrame *frame; //封装图像对象指针 AVPacket pkt; //封装码流对象实例 &#125; CodecCtx; 2、FFMpeg进行解码操作的主要步骤(1). 参数传递和解析同编码器类似，解码器也需要传递参数。不过相比编码器，解码器在运行时所需要的大部分信息都包含在输入码流中，因此输入参数一般只需要指定一个待解码的视频码流文件即可 (2). 按照要求初始化需要的FFMpeg结构首先，所有涉及到编解码的的功能，都必须要注册音视频编解码器之后才能使用。注册编解码调用下面的函数： avcodec_register_all(); 编解码器注册完成之后，根据指定的CODEC_ID查找指定的codec实例。CODEC_ID通常指定了编解码器的格式，在这里我们使用当前应用最为广泛的H.264格式为例。查找codec调用的函数为avcodec_find_encoder，其声明格式为： AVCodec *avcodec_find_encoder(enum AVCodecID id); 该函数的输入参数为一个AVCodecID的枚举类型，返回值为一个指向AVCodec结构的指针，用于接收找到的编解码器实例。如果没有找到，那么该函数会返回一个空指针。调用方法如下： /* find the mpeg1 video encoder */ ctx.codec = avcodec_find_encoder(AV_CODEC_ID_H264); //根据CODEC_ID查找编解码器对象实例的指针 if (!ctx.codec) &#123; fprintf(stderr, &quot;Codec not found\\n&quot;); return false; &#125; AVCodec查找成功后，下一步是分配AVCodecContext实例。分配AVCodecContext实例需要我们前面查找到的AVCodec作为参数，调用的是avcodec_alloc_context3函数。其声明方式为： AVCodecContext *avcodec_alloc_context3(const AVCodec *codec); 其特点同avcodec_find_encoder类似，返回一个指向AVCodecContext实例的指针。如果分配失败，会返回一个空指针。调用方式为： ctx.c = avcodec_alloc_context3(ctx.codec); //分配AVCodecContext实例 if (!ctx.c) &#123; fprintf(stderr, &quot;Could not allocate video codec context\\n&quot;); return false; &#125; 我们应该记得，在FFMpeg视频编码的实现中，AVCodecContext对象分配完成后，下一步实在该对象中设置编码的参数。而在解码器的实现中，基本不需要额外设置参数信息，因此这个对象更多地作为输出参数接收数据。因此对象分配完成后，不需要进一步的初始化操作。 解码器与编码器实现中不同的一点在于，解码器的实现中需要额外的一个AVCodecParserContext结构，用于从码流中截取一个完整的NAL单元。因此我们需要分配一个AVCodecParserContext类型的对象，使用函数av_parser_init，声明为： AVCodecParserContext *av_parser_init(int codec_id); 调用方式为： ctx.pCodecParserCtx = av_parser_init(AV_CODEC_ID_H264); if (!ctx.pCodecParserCtx) &#123; printf(&quot;Could not allocate video parser context\\n&quot;); return false; &#125; 随后，打开AVCodec对象，然后分配AVFrame对象： //打开AVCodec对象 if (avcodec_open2(ctx.pCodecContext, ctx.pCodec, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not open codec\\n&quot;); return false; &#125; //分配AVFrame对象 ctx.frame = av_frame_alloc(); if (!ctx.frame) &#123; fprintf(stderr, &quot;Could not allocate video frame\\n&quot;); return false; &#125; (3)、解码循环体完成必须的codec组件的建立和初始化之后，开始进入正式的解码循环过程。解码循环通常按照以下几个步骤实现： 首先按照某个指定的长度读取一段码流保存到缓存区中。 由于H.264中一个包的长度是不定的，我们读取一段固定长度的码流通常不可能刚好读出一个包的长度。所以我们就需要使用AVCodecParserContext结构对我们读出的码流信息进行解析，直到取出一个完整的H.264包。对码流解析的函数为av_parser_parse2，声明方式如： int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos); 这个函数的各个参数的意义： AVCodecParserContext *s：初始化过的AVCodecParserContext对象，决定了码流该以怎样的标准进行解析； *AVCodecContext avctx：预先定义好的AVCodecContext对象； uint8_t **poutbuf：AVPacket::data的地址，保存解析完成的包数据； int *poutbuf_size：AVPacket的实际数据长度；如果没解析出完整的一个包，这个值为0； const uint8_t *buf, int buf_size：输入参数，缓存的地址和长度； int64_t pts, int64_t dts：显示和解码的时间戳； nt64_t pos ：码流中的位置； 返回值为解析所使用的比特位的长度； 具体的调用方式为： len = av_parser_parse2(ctx.pCodecParserCtx, ctx.pCodecContext, &amp;(ctx.pkt.data), &amp;(ctx.pkt.size), pDataPtr, uDataSize, AV_NOPTS_VALUE, AV_NOPTS_VALUE, AV_NOPTS_VALUE); 如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。 在最终解析出一个完整的包之后，我们就可以调用解码API进行实际的解码过程了。解码过程调用的函数为avcodec_decode_video2，该函数的声明为： int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, const AVPacket *avpkt); 这个函数与前篇所遇到的编码函数avcodec_encode_video2有些类似，只是参数的顺序略有不同，解码函数的输入输出参数与编码函数相比交换了位置。该函数各个参数的意义： AVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成； AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好； int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了 const AVPacket *avpkt: 前面解析好的码流包； 实际调用的方法为： int ret = avcodec_decode_video2(ctx.pCodecContext, ctx.frame, &amp;got_picture, &amp;(ctx.pkt)); if (ret &lt; 0) &#123; printf(&quot;Decode Error.\\n&quot;); return ret; &#125; if (got_picture) &#123; //获得一帧完整的图像，写出到输出文件 write_out_yuv_frame(ctx, inputoutput); printf(&quot;Succeed to decode 1 frame!\\n&quot;); &#125; 最后，同编码器一样，解码过程的最后一帧可能也存在延迟。处理最后这一帧的方法也跟解码器类似：将AVPacket::data设为NULL，AVPacket::size设为0，然后在调用avcodec_encode_video2完成最后的解码过程： ctx.pkt.data = NULL; ctx.pkt.size = 0; while(1) &#123; //将编码器中剩余的数据继续输出完 int ret = avcodec_decode_video2(ctx.pCodecContext, ctx.frame, &amp;got_picture, &amp;(ctx.pkt)); if (ret &lt; 0) &#123; printf(&quot;Decode Error.\\n&quot;); return ret; &#125; if (got_picture) &#123; write_out_yuv_frame(ctx, inputoutput); printf(&quot;Flush Decoder: Succeed to decode 1 frame!\\n&quot;); &#125; else &#123; break; &#125; &#125; //while(1) ####(4). 收尾工作收尾工作主要包括关闭输入输出文件、关闭FFMpeg解码器各个组件。其中关闭解码器组件需要： avcodec_close(ctx.pCodecContext); av_free(ctx.pCodecContext); av_frame_free(&amp;(ctx.frame)); 3、总结解码器的流程与编码器类似，只是中间需要加入一个解析的过程。整个流程大致为： 1.读取码流数据 -&gt; 2.解析数据，是否尚未解析出一个包就已经用完？是返回1，否继续 -&gt; 3.解析出一个包？是则继续，否则返回上一步继续解析 -&gt; 4.调用avcodec_decode_video2进行解码 -&gt; 5.是否解码出一帧完整的图像？是则继续，否则返回上一步继续解码 -&gt; 6.写出图像数据 -&gt; 返回步骤2继续解析。 四、调用FFmpeg SDK解析封装格式的视频为音频流和视频流我们平常最常用的音视频文件通常不是单独的音频信号和视频信号，而是一个整体的文件。这个文件会在其中包含音频流和视频流，并通过某种方式进行同步播放。通常，文件的音频和视频通过某种标准格式进行复用，生成某种封装格式，而封装的标志就是文件的扩展名，常用的有mp4/avi/flv/mkv等。 从底层考虑，我们可以使用的只有视频解码器、音频解码器，或者再加上一些附加的字幕解码等额外信息，却不存在所谓的mp4解码器或者avi解码器。所以，为了可以正确播放视频文件，必须将封装格式的视频文件分离出视频和音频信息分别进行解码和播放。 事实上，无论是mp4还是avi等文件格式，都有不同的标准格式，对于不同的格式并没有一种通用的解析方法。因此，FFMpeg专门定义了一个库来处理设计文件封装格式的功能，即libavformat。涉及文件的封装、解封装的问题，都可以通过调用libavformat的API实现。这里我们实现一个demo来处理音视频文件的解复用与解码的功能。 1. FFMpeg解复用-解码器所包含的结构这一过程实际上包括了封装文件的解复用和音频/视频解码两个步骤，因此需要定义的结构体大致包括用于解码和解封装的部分。我们定义下面这样的一个结构体实现这个功能： /************************************************* Struct: DemuxingVideoAudioContex Description: 保存解复用器和解码器的上下文组件 *************************************************/ typedef struct &#123; AVFormatContext *fmt_ctx; AVCodecContext *video_dec_ctx, *audio_dec_ctx; AVStream *video_stream, *audio_stream; AVFrame *frame; AVPacket pkt; int video_stream_idx, audio_stream_idx; int width, height; uint8_t *video_dst_data[4]; int video_dst_linesize[4]; int video_dst_bufsize; enum AVPixelFormat pix_fmt; &#125; DemuxingVideoAudioContex; 这个结构体中的大部分数据类型我们在前面做编码/解码等功能时已经见到过，另外几个是涉及到视频文件的复用的，其中有： AVFormatContext：用于处理音视频封装格式的上下文信息。 AVStream：表示音频或者视频流的结构。 AVPixelFormat：枚举类型，表示图像像素的格式，最常用的是AV_PIX_FMT_YUV420P 2、FFMpeg解复用-解码的过程(1)、相关结构的初始化与使用FFMpeg进行其他操作一样，首先需注册FFMpeg组件： av_register_all(); 随后，我们需要打开待处理的音视频文件。然而在此我们不使用打开文件的fopen函数，而是使用avformat_open_input函数。该函数不但会打开输入文件，而且可以根据输入文件读取相应的格式信息。该函数的声明如下： int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options); 该函数的各个参数的作用为： ps：根据输入文件接收与格式相关的句柄信息；可以指向NULL，那么AVFormatContext类型的实例将由该函数进行分配。 url：视频url或者文件路径； fmt：强制输入格式，可设置为NULL以自动检测； options：保存文件格式无法识别的信息； 返回值：成功返回0，失败则返回负的错误码； 该函数的调用方式为： if (avformat_open_input(&amp;(va_ctx.fmt_ctx), files.src_filename, NULL, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not open source file %s\\n&quot;, files.src_filename); return -1; &#125; 打开文件后，调用avformat_find_stream_info函数获取文件中的流信息。该函数的声明为： int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options); 该函数的第一个参数即前面的文件句柄，第二个参数也是用于保存无法识别的信息的AVDictionary的结构，通常可设为NULL。调用方式如： /* retrieve stream information */ if (avformat_find_stream_info(va_ctx.fmt_ctx, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not find stream information\\n&quot;); return -1; &#125; 获取文件中的流信息后，下一步则是获取文件中的音频和视频流，并准备对音频和视频信息进行解码。获取文件中的流使用av_find_best_stream函数，其声明如： int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec **decoder_ret, int flags); 其中各个参数的意义： ic：视频文件句柄； type：表示数据的类型，常用的有AVMEDIA_TYPE_VIDEO表示视频，AVMEDIA_TYPE_AUDIO表示音频等； wanted_stream_nb：我们期望获取到的数据流的数量，设置为-1使用自动获取； related_stream：获取相关的音视频流，如果没有则设为-1； decoder_ret：返回这一路数据流的解码器； flags：未定义； 返回值：函数执行成功返回流的数量，失败则返回负的错误码； 在函数执行成功后，便可调用avcodec_find_decoder和avcodec_open2打开解码器准备解码音视频流。该部分的代码实现如： static int open_codec_context(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx, enum AVMediaType type) &#123; int ret, stream_index; AVStream *st; AVCodecContext *dec_ctx = NULL; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(va_ctx.fmt_ctx, type, -1, -1, NULL, 0); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not find %s stream in input file &#39;%s&#39;\\n&quot;, av_get_media_type_string(type), files.src_filename); return ret; &#125; else &#123; stream_index = ret; st = va_ctx.fmt_ctx-&gt;streams[stream_index]; /* find decoder for the stream */ dec_ctx = st-&gt;codec; dec = avcodec_find_decoder(dec_ctx-&gt;codec_id); if (!dec) &#123; fprintf(stderr, &quot;Failed to find %s codec\\n&quot;, av_get_media_type_string(type)); return AVERROR(EINVAL); &#125; /* Init the decoders, with or without reference counting */ av_dict_set(&amp;opts, &quot;refcounted_frames&quot;, files.refcount ? &quot;1&quot; : &quot;0&quot;, 0); if ((ret = avcodec_open2(dec_ctx, dec, &amp;opts)) &lt; 0) &#123; fprintf(stderr, &quot;Failed to open %s codec\\n&quot;, av_get_media_type_string(type)); return ret; &#125; switch (type) &#123; case AVMEDIA_TYPE_VIDEO: va_ctx.video_stream_idx = stream_index; va_ctx.video_stream = va_ctx.fmt_ctx-&gt;streams[stream_index]; va_ctx.video_dec_ctx = va_ctx.video_stream-&gt;codec; break; case AVMEDIA_TYPE_AUDIO: va_ctx.audio_stream_idx = stream_index; va_ctx.audio_stream = va_ctx.fmt_ctx-&gt;streams[stream_index]; va_ctx.audio_dec_ctx = va_ctx.audio_stream-&gt;codec; break; default: fprintf(stderr, &quot;Error: unsupported MediaType: %s\\n&quot;, av_get_media_type_string(type)); return -1; &#125; &#125; return 0; &#125; 整体初始化的函数代码为： int InitDemuxContext(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx) &#123; int ret = 0, width, height; /* register all formats and codecs */ av_register_all(); /* open input file, and allocate format context */ if (avformat_open_input(&amp;(va_ctx.fmt_ctx), files.src_filename, NULL, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not open source file %s\\n&quot;, files.src_filename); return -1; &#125; /* retrieve stream information */ if (avformat_find_stream_info(va_ctx.fmt_ctx, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not find stream information\\n&quot;); return -1; &#125; if (open_codec_context(files, va_ctx, AVMEDIA_TYPE_VIDEO) &gt;= 0) &#123; files.video_dst_file = fopen(files.video_dst_filename, &quot;wb&quot;); if (!files.video_dst_file) &#123; fprintf(stderr, &quot;Could not open destination file %s\\n&quot;, files.video_dst_filename); return -1; &#125; /* allocate image where the decoded image will be put */ va_ctx.width = va_ctx.video_dec_ctx-&gt;width; va_ctx.height = va_ctx.video_dec_ctx-&gt;height; va_ctx.pix_fmt = va_ctx.video_dec_ctx-&gt;pix_fmt; ret = av_image_alloc(va_ctx.video_dst_data, va_ctx.video_dst_linesize, va_ctx.width, va_ctx.height, va_ctx.pix_fmt, 1); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not allocate raw video buffer\\n&quot;); return -1; &#125; va_ctx.video_dst_bufsize = ret; &#125; if (open_codec_context(files, va_ctx, AVMEDIA_TYPE_AUDIO) &gt;= 0) &#123; files.audio_dst_file = fopen(files.audio_dst_filename, &quot;wb&quot;); if (!files.audio_dst_file) &#123; fprintf(stderr, &quot;Could not open destination file %s\\n&quot;, files.audio_dst_filename); return -1; &#125; &#125; if (va_ctx.video_stream) &#123; printf(&quot;Demuxing video from file &#39;%s&#39; into &#39;%s&#39;\\n&quot;, files.src_filename, files.video_dst_filename); &#125; if (va_ctx.audio_stream) &#123; printf(&quot;Demuxing audio from file &#39;%s&#39; into &#39;%s&#39;\\n&quot;, files.src_filename, files.audio_dst_filename); &#125; /* dump input information to stderr */ av_dump_format(va_ctx.fmt_ctx, 0, files.src_filename, 0); if (!va_ctx.audio_stream &amp;&amp; !va_ctx.video_stream) &#123; fprintf(stderr, &quot;Could not find audio or video stream in the input, aborting\\n&quot;); return -1; &#125; return 0; &#125; 随后要做的，是分配AVFrame和初始化AVPacket对象： va_ctx.frame = av_frame_alloc(); //分配AVFrame结构对象 if (!va_ctx.frame) &#123; fprintf(stderr, &quot;Could not allocate frame\\n&quot;); ret = AVERROR(ENOMEM); goto end; &#125; /* initialize packet, set data to NULL, let the demuxer fill it */ av_init_packet(&amp;va_ctx.pkt); //初始化AVPacket对象 va_ctx.pkt.data = NULL; va_ctx.pkt.size = 0; (2)、循环解析视频文件的包数据解析视频文件的循环代码段为： /* read frames from the file */ while (av_read_frame(va_ctx.fmt_ctx, &amp;va_ctx.pkt) &gt;= 0) //从输入程序中读取一个包的数据 &#123; AVPacket orig_pkt = va_ctx.pkt; do &#123; ret = Decode_packet(files, va_ctx, &amp;got_frame, 0); //解码这个包 if (ret &lt; 0) break; va_ctx.pkt.data += ret; va_ctx.pkt.size -= ret; &#125; while (va_ctx.pkt.size &gt; 0); av_packet_unref(&amp;orig_pkt); &#125; 这部分代码逻辑上非常简单，首先调用av_read_frame函数，从文件中读取一个packet的数据，并实现了一个Decode_packet对这个packet进行解码。Decode_packet函数的实现如下： int Decode_packet(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx, int *got_frame, int cached) &#123; int ret = 0; int decoded = va_ctx.pkt.size; static int video_frame_count = 0; static int audio_frame_count = 0; *got_frame = 0; if (va_ctx.pkt.stream_index == va_ctx.video_stream_idx) &#123; /* decode video frame */ ret = avcodec_decode_video2(va_ctx.video_dec_ctx, va_ctx.frame, got_frame, &amp;va_ctx.pkt); if (ret &lt; 0) &#123; printf(&quot;Error decoding video frame (%d)\\n&quot;, ret); return ret; &#125; if (*got_frame) &#123; if (va_ctx.frame-&gt;width != va_ctx.width || va_ctx.frame-&gt;height != va_ctx.height || va_ctx.frame-&gt;format != va_ctx.pix_fmt) &#123; /* To handle this change, one could call av_image_alloc again and * decode the following frames into another rawvideo file. */ printf(&quot;Error: Width, height and pixel format have to be &quot; &quot;constant in a rawvideo file, but the width, height or &quot; &quot;pixel format of the input video changed:\\n&quot; &quot;old: width = %d, height = %d, format = %s\\n&quot; &quot;new: width = %d, height = %d, format = %s\\n&quot;, va_ctx.width, va_ctx.height, av_get_pix_fmt_name((AVPixelFormat)(va_ctx.pix_fmt)), va_ctx.frame-&gt;width, va_ctx.frame-&gt;height, av_get_pix_fmt_name((AVPixelFormat)va_ctx.frame-&gt;format)); return -1; &#125; printf(&quot;video_frame%s n:%d coded_n:%d pts:%s\\n&quot;, cached ? &quot;(cached)&quot; : &quot;&quot;, video_frame_count++, va_ctx.frame-&gt;coded_picture_number, va_ctx.frame-&gt;pts); /* copy decoded frame to destination buffer: * this is required since rawvideo expects non aligned data */ av_image_copy(va_ctx.video_dst_data, va_ctx.video_dst_linesize, (const uint8_t **)(va_ctx.frame-&gt;data), va_ctx.frame-&gt;linesize, va_ctx.pix_fmt, va_ctx.width, va_ctx.height); /* write to rawvideo file */ fwrite(va_ctx.video_dst_data[0], 1, va_ctx.video_dst_bufsize, files.video_dst_file); &#125; &#125; else if (va_ctx.pkt.stream_index == va_ctx.audio_stream_idx) &#123; /* decode audio frame */ ret = avcodec_decode_audio4(va_ctx.audio_dec_ctx, va_ctx.frame, got_frame, &amp;va_ctx.pkt); if (ret &lt; 0) &#123; printf(&quot;Error decoding audio frame (%s)\\n&quot;, ret); return ret; &#125; /* Some audio decoders decode only part of the packet, and have to be * called again with the remainder of the packet data. * Sample: fate-suite/lossless-audio/luckynight-partial.shn * Also, some decoders might over-read the packet. */ decoded = FFMIN(ret, va_ctx.pkt.size); if (*got_frame) &#123; size_t unpadded_linesize = va_ctx.frame-&gt;nb_samples * av_get_bytes_per_sample((AVSampleFormat)va_ctx.frame-&gt;format); printf(&quot;audio_frame%s n:%d nb_samples:%d pts:%s\\n&quot;, cached ? &quot;(cached)&quot; : &quot;&quot;, audio_frame_count++, va_ctx.frame-&gt;nb_samples, va_ctx.frame-&gt;pts); /* Write the raw audio data samples of the first plane. This works * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However, * most audio decoders output planar audio, which uses a separate * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P). * In other words, this code will write only the first audio channel * in these cases. * You should use libswresample or libavfilter to convert the frame * to packed data. */ fwrite(va_ctx.frame-&gt;extended_data[0], 1, unpadded_linesize, files.audio_dst_file); &#125; &#125; /* If we use frame reference counting, we own the data and need * to de-reference it when we don&#39;t use it anymore */ if (*got_frame &amp;&amp; files.refcount) av_frame_unref(va_ctx.frame); return decoded; &#125; 在该函数中，首先对读取到的packet中的stream_index分别于先前获取的音频和视频的stream_index进行对比来确定是音频还是视频流。而后分别调用相应的解码函数进行解码，以视频流为例，判断当前stream为视频流后，调用avcodec_decode_video2函数将流数据解码为像素数据，并在获取完整的一帧之后，将其写出到输出文件中。 3、总结相对于前文讲述过的解码H.264格式裸码流，解封装+解码过程看似多了一个步骤，然而在实现起来实际上并无过多差别。这主要是由于FFMpeg中的多个API已经很好地实现了封装文件的解析和读取过程，如打开文件我们使用avformat_open_input代替fopen，读取数据包使用av_read_frame代替fread，其他方面只需要多一步判断封装文件中数据流的类型即可，剩余部分与裸码流的解码并无太多差别。 ##五、调用FFMpeg SDK封装音频和视频为视频文件 音频和视频的封装过程为解封装的逆过程，即将独立的音频数据和视频数据按照容器文件所规定的格式封装为一个完整的视频文件的过程。对于大多数消费者来说，视频封装的容器是大家最为熟悉的，因为它直接体现在了我们使用的音视频文件扩展名上，比较常见的有mp4、avi、mkv、flv等等。 在进行音频和视频封装时，我们将实际操作一系列音频或视频流数据的生成和写入。所谓流，指的是一系列相关联的包的集合，这些包一般同属于一组按照时间先后顺序进行解码/渲染等处理的数据。在一个比较典型的视频文件中，我们通常至少会包含一个视频流和一个音频流。 在FFMpeg中，表示音频流或视频流有一个专门的结构，即”AVStream”实现。该结构主要对音频和视频数据的处理进行管理和控制。另外，”AVFormatContext”结构也是必须的，因为它包含了控制输入和输出的信息。 音频和视频数据封装为视频文件的主要步骤为： 1. 相关数据结构的准备首先，根据输出文件的格式获取AVFormatContext结构，获取AVFormatContext结构使用函数avformat_alloc_output_context2实现。该函数的声明为： int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename); 其中： ctx：输出到AVFormatContext结构的指针，如果函数失败则返回给该指针为NULL； oformat：指定输出的AVOutputFormat类型，如果设为NULL则使用format_name和filename生成； format_name：输出格式的名称，如果设为NULL则使用filename默认格式； filename：目标文件名，如果不使用，可以设为NULL； 分配AVFormatContext成功后，我们需要添加希望封装的数据流，一般是一路视频流+一路音频流（可能还有其他音频流和字幕流等）。添加流首先需要查找流所包含的媒体的编码器，这需要传入codec_id后使用avcodec_find_encoder函数实现，将查找到的编码器保存在AVCodec指针中。 之后，调用avformat_new_stream函数向AVFormatContext结构中所代表的媒体文件中添加数据流。该函数的声明如下： AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c); 其中各个参数的含义： s：AVFormatContext结构，表示要封装生成的视频文件； c：上一步根据codec_id产生的编码器指针； 返回值：指向生成的stream对象的指针；如果失败则返回NULL指针。 此时，一个新的AVStream便已经加入到输出文件中，下面就可以设置stream的id和codec等参数。AVStream::codec是一个AVCodecContext类型的指针变量成员，设置其中的值可以对编码进行配置。整个添加stream的例子如： /* Add an output stream. */ static void add_stream(OutputStream *ost, AVFormatContext *oc, AVCodec **codec, enum AVCodecID codec_id) &#123; AVCodecContext *c; int i; /* find the encoder */ *codec = avcodec_find_encoder(codec_id); if (!(*codec)) &#123; fprintf(stderr, &quot;Could not find encoder for &#39;%s&#39;\\n&quot;, avcodec_get_name(codec_id)); exit(1); &#125; ost-&gt;st = avformat_new_stream(oc, *codec); if (!ost-&gt;st) &#123; fprintf(stderr, &quot;Could not allocate stream\\n&quot;); exit(1); &#125; ost-&gt;st-&gt;id = oc-&gt;nb_streams - 1; c = ost-&gt;st-&gt;codec; switch ((*codec)-&gt;type) &#123; case AVMEDIA_TYPE_AUDIO: c-&gt;sample_fmt = (*codec)-&gt;sample_fmts ? (*codec)-&gt;sample_fmts[0] : AV_SAMPLE_FMT_FLTP; c-&gt;bit_rate = 64000; c-&gt;sample_rate = 44100; if ((*codec)-&gt;supported_samplerates) &#123; c-&gt;sample_rate = (*codec)-&gt;supported_samplerates[0]; for (i = 0; (*codec)-&gt;supported_samplerates[i]; i++) &#123; if ((*codec)-&gt;supported_samplerates[i] == 44100) c-&gt;sample_rate = 44100; &#125; &#125; c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout); c-&gt;channel_layout = AV_CH_LAYOUT_STEREO; if ((*codec)-&gt;channel_layouts) &#123; c-&gt;channel_layout = (*codec)-&gt;channel_layouts[0]; for (i = 0; (*codec)-&gt;channel_layouts[i]; i++) &#123; if ((*codec)-&gt;channel_layouts[i] == AV_CH_LAYOUT_STEREO) c-&gt;channel_layout = AV_CH_LAYOUT_STEREO; &#125; &#125; c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout); &#123; AVRational r = &#123; 1, c-&gt;sample_rate &#125;; ost-&gt;st-&gt;time_base = r; &#125; break; case AVMEDIA_TYPE_VIDEO: c-&gt;codec_id = codec_id; c-&gt;bit_rate = 400000; /* Resolution must be a multiple of two. */ c-&gt;width = 352; c-&gt;height = 288; /* timebase: This is the fundamental unit of time (in seconds) in terms * of which frame timestamps are represented. For fixed-fps content, * timebase should be 1/framerate and timestamp increments should be * identical to 1. */ &#123; AVRational r = &#123; 1, STREAM_FRAME_RATE &#125;; ost-&gt;st-&gt;time_base = r; &#125; c-&gt;time_base = ost-&gt;st-&gt;time_base; c-&gt;gop_size = 12; /* emit one intra frame every twelve frames at most */ c-&gt;pix_fmt = AV_PIX_FMT_YUV420P; if (c-&gt;codec_id == AV_CODEC_ID_MPEG2VIDEO) &#123; /* just for testing, we also add B frames */ c-&gt;max_b_frames = 2; &#125; if (c-&gt;codec_id == AV_CODEC_ID_MPEG1VIDEO) &#123; /* Needed to avoid using macroblocks in which some coeffs overflow. * This does not happen with normal video, it just happens here as * the motion of the chroma plane does not match the luma plane. */ c-&gt;mb_decision = 2; &#125; break; default: break; &#125; /* Some formats want stream headers to be separate. */ if (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER; &#125; 2. 打开音视频打开音视频主要涉及到打开编码音视频数据所需要的编码器，以及分配相应的frame对象。其中打开编码器如之前一样，调用avcodec_open函数，分配frame对象调用av_frame_alloc以及av_frame_get_buffer。分配frame对象的实现如下： static AVFrame *alloc_picture(enum AVPixelFormat pix_fmt, int width, int height) &#123; AVFrame *picture; int ret; picture = av_frame_alloc(); if (!picture) &#123; return NULL; &#125; picture-&gt;format = pix_fmt; picture-&gt;width = width; picture-&gt;height = height; /* allocate the buffers for the frame data */ ret = av_frame_get_buffer(picture, 32); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not allocate frame data.\\n&quot;); exit(1); &#125; return picture; &#125; 而上层打开音视频部分的实现如： void Open_video(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg, IOParam &amp;io) &#123; int ret; AVCodecContext *c = ost-&gt;st-&gt;codec; AVDictionary *opt = NULL; av_dict_copy(&amp;opt, opt_arg, 0); /* open the codec */ ret = avcodec_open2(c, codec, &amp;opt); av_dict_free(&amp;opt); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not open video codec: %d\\n&quot;, ret); exit(1); &#125; /* allocate and init a re-usable frame */ ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height); if (!ost-&gt;frame) &#123; fprintf(stderr, &quot;Could not allocate video frame\\n&quot;); exit(1); &#125; /* If the output format is not YUV420P, then a temporary YUV420P * picture is needed too. It is then converted to the required * output format. */ ost-&gt;tmp_frame = NULL; if (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123; ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height); if (!ost-&gt;tmp_frame) &#123; fprintf(stderr, &quot;Could not allocate temporary picture\\n&quot;); exit(1); &#125; &#125; //打开输入YUV文件 fopen_s(&amp;g_inputYUVFile, io.input_file_name, &quot;rb+&quot;); if (g_inputYUVFile == NULL) &#123; fprintf(stderr, &quot;Open input yuv file failed.\\n&quot;); exit(1); &#125; &#125; 3. 打开输出文件并写入文件头如果判断需要写出文件的话，则需要打开输出文件。在这里，我们可以不再定义输出文件指针，并使用fopen打开，而是直接使用FFMpeg的API——avio_open来实现输出文件的打开功能。该函数的声明如下： int avio_open(AVIOContext **s, const char *url, int flags); 该函数的输入参数为： s：输出参数，返回一个AVIOContext；如果打开失败则返回NULL； url：输出的url或者文件的完整路径； flags：控制文件打开方式，如读方式、写方式和读写方式； 实际的代码实现方式如下： /* open the output file, if needed */ if (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;oc-&gt;pb, io.output_file_name, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Could not open &#39;%s&#39;: %d\\n&quot;, io.output_file_name, ret); return 1; &#125; &#125; 写入文件头操作是生成视频文件中极为重要的一步，而实现过程却非常简单，只需要通过函数avformat_write_header即可，该函数的声明为： int avformat_write_header(AVFormatContext *s, AVDictionary **options); 其输入参数实际上重要的只有第一个，即标记输出文件的句柄对象指针；options用于保存无法识别的设置项，可以传入一个空指针。其返回值表示写文件头成功与否，成功则返回0，失败则返回负的错误码。 实现方式如： /* Write the stream header, if any. */ ret = avformat_write_header(oc, &amp;opt); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error occurred when opening output file: %d\\n&quot;,ret); return 1; &#125; ###4. 编码和封装循环 以视频流为例。编解码循环的过程实际上可以封装在一个函数Write_video_frame中。该函数从逻辑上可以分为3个部分：获取原始视频信号、视频编码、写入输出文件。 (1) 读取原始视频数据这一部分主要实现根据时长判断是否需要继续进行处理、读取视频到AVFrame和设置pts。其中时长判断部分根据pts和AVCodecContext的time_base判断。实现如下： AVCodecContext *c = ost-&gt;st-&gt;codec; /* check if we want to generate more frames */ &#123; AVRational r = &#123; 1, 1 &#125;; if (av_compare_ts(ost-&gt;next_pts, ost-&gt;st-&gt;codec-&gt;time_base, STREAM_DURATION, r) &gt;= 0) &#123; return NULL; &#125; &#125; 读取视频到AVFrame我们定义一个fill_yuv_image函数实现： static void fill_yuv_image(AVFrame *pict, int frame_index, int width, int height) &#123; int x, y, i, ret; /* when we pass a frame to the encoder, it may keep a reference to it * internally; * make sure we do not overwrite it here */ ret = av_frame_make_writable(pict); if (ret &lt; 0) &#123; exit(1); &#125; i = frame_index; /* Y */ for (y = 0; y &lt; height; y++) &#123; ret = fread_s(&amp;pict-&gt;data[0][y * pict-&gt;linesize[0]], pict-&gt;linesize[0], 1, width, g_inputYUVFile); if (ret != width) &#123; printf(&quot;Error: Read Y data error.\\n&quot;); exit(1); &#125; &#125; /* U */ for (y = 0; y &lt; height / 2; y++) &#123; ret = fread_s(&amp;pict-&gt;data[1][y * pict-&gt;linesize[1]], pict-&gt;linesize[1], 1, width / 2, g_inputYUVFile); if (ret != width / 2) &#123; printf(&quot;Error: Read U data error.\\n&quot;); exit(1); &#125; &#125; /* V */ for (y = 0; y &lt; height / 2; y++) &#123; ret = fread_s(&amp;pict-&gt;data[2][y * pict-&gt;linesize[2]], pict-&gt;linesize[2], 1, width / 2, g_inputYUVFile); if (ret != width / 2) &#123; printf(&quot;Error: Read V data error.\\n&quot;); exit(1); &#125; &#125; &#125; 然后进行pts的设置，很简单，就是上一个frame的pts递增1： ost-&gt;frame-&gt;pts = ost-&gt;next_pts++; 整个获取视频信号的实现如： static AVFrame *get_video_frame(OutputStream *ost) &#123; AVCodecContext *c = ost-&gt;st-&gt;codec; /* check if we want to generate more frames */ &#123; AVRational r = &#123; 1, 1 &#125;; if (av_compare_ts(ost-&gt;next_pts, ost-&gt;st-&gt;codec-&gt;time_base, STREAM_DURATION, r) &gt;= 0) &#123; return NULL; &#125; &#125; fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height); ost-&gt;frame-&gt;pts = ost-&gt;next_pts++; return ost-&gt;frame; &#125; (2) 视频编码视频编码的方式同之前几次使用的方式相同，即调用avcodec_encode_video2，实现方法如： /* encode the image */ ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error encoding video frame: %d\\n&quot;, ret); exit(1); &#125; (3) 写出编码后的数据到输出视频文件这部分的实现过程很简单，方式如下： /* rescale output packet timestamp values from codec to stream timebase */ av_packet_rescale_ts(pkt, *time_base, st-&gt;time_base); pkt-&gt;stream_index = st-&gt;index; /* Write the compressed frame to the media file. */ // log_packet(fmt_ctx, pkt); return av_interleaved_write_frame(fmt_ctx, pkt); av_packet_rescale_ts函数的作用为不同time_base度量之间的转换，在这里起到的作用是将AVCodecContext的time_base转换为AVStream中的time_base。av_interleaved_write_frame函数的作用是写出AVPacket到输出文件。该函数的声明为： int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt); 该函数的声明也很简单，第一个参数是之前打开并写入文件头的文件句柄，第二个参数是写入文件的packet。返回值为错误码，成功返回0，失败则返回一个负值。 Write_video_frame函数的整体实现如： int Write_video_frame(AVFormatContext *oc, OutputStream *ost) &#123; int ret; AVCodecContext *c; AVFrame *frame; int got_packet = 0; AVPacket pkt = &#123; 0 &#125;; c = ost-&gt;st-&gt;codec; frame = get_video_frame(ost); av_init_packet(&amp;pkt); /* encode the image */ ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error encoding video frame: %d\\n&quot;, ret); exit(1); &#125; if (got_packet) &#123; ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt); &#125; else &#123; ret = 0; &#125; if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error while writing video frame: %d\\n&quot;, ret); exit(1); &#125; return (frame || got_packet) ? 0 : 1; &#125; 以上是写入一帧视频数据的方法，写入音频的方法于此大同小异。整个编码封装的循环上层实现如： while (encode_video || encode_audio) &#123; /* select the stream to encode */ if (encode_video &amp;&amp; (!encode_audio || av_compare_ts(video_st.next_pts, video_st.st-&gt;codec-&gt;time_base, audio_st.next_pts, audio_st.st-&gt;codec-&gt;time_base) &lt;= 0)) &#123; encode_video = !Write_video_frame(oc, &amp;video_st); if (encode_video) &#123; printf(&quot;Write %d video frame.\\n&quot;, videoFrameIdx++); &#125; else &#123; printf(&quot;Video ended, exit.\\n&quot;); &#125; &#125; else &#123; encode_audio = !Write_audio_frame(oc, &amp;audio_st); if (encode_audio) &#123; printf(&quot;Write %d audio frame.\\n&quot;, audioFrameIdx++); &#125; else &#123; printf(&quot;Audio ended, exit.\\n&quot;); &#125; &#125; &#125; ###5. 写入文件尾，并进行收尾工作 写入文件尾的数据同写文件头一样简单，只需要调用函数av_write_trailer即可实现： int av_write_trailer(AVFormatContext *s); 该函数只有一个参数即视频文件的句柄，当返回值为0时表示函数执行成功。 整个流程的收尾工作包括关闭文件中的数据流、关闭输出文件和释放AVCodecContext对象。其中关闭数据流的实现方式如： void Close_stream(AVFormatContext *oc, OutputStream *ost) &#123; avcodec_close(ost-&gt;st-&gt;codec); av_frame_free(&amp;ost-&gt;frame); av_frame_free(&amp;ost-&gt;tmp_frame); sws_freeContext(ost-&gt;sws_ctx); swr_free(&amp;ost-&gt;swr_ctx); &#125; 关闭输出文件和释放AVCodecContext对象： if (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) /* Close the output file. */ avio_closep(&amp;oc-&gt;pb); /* free the stream */ avformat_free_context(oc); 至此，整个处理流程便结束了。正确设置输入的YUV文件就可以获取封装好的音视频文件。 ##六、调用FFMpeg SDK实现视频文件的转封装 有时候我们可能会面对这样的一种需求，即我们不需要对视频内的音频或视频信号进行什么实际的操作，只是希望能把文件的封装格式进行转换，例如从avi转换为mp4格式或者flv格式等。实际上，转封装不需要对内部的音视频进行解码，只需要根据从输入文件中获取包含的数据流添加到输出文件中，然后将输入文件中的数据包按照规定格式写入到输出文件中去。 1、解析命令行参数如同之前的工程一样，我们使用命令行参数传入输入和输出的文件名。为此，我们定义了如下的结构体和函数来实现传入输入输出文件的过程： typedef struct _IOFiles &#123; const char *inputName; const char *outputName; &#125; IOFiles; static bool hello(int argc, char **argv, IOFiles &amp;io_param) &#123; printf(&quot;FFMpeg Remuxing Demo.\\nCommand format: %s inputfile outputfile\\n&quot;, argv[0]); if (argc != 3) &#123; printf(&quot;Error: command line error, please re-check.\\n&quot;); return false; &#125; io_param.inputName = argv[1]; io_param.outputName = argv[2]; return true; &#125; 在main函数执行时，调用hello函数解析命令行并保存到IOFiles结构中： int main(int argc, char **argv) &#123; IOFiles io_param; if (!hello(argc, argv, io_param)) &#123; return -1; &#125; //...... &#125; 2、所需要的结构与初始化操作为了实现视频文件的转封装操作，我们需要以下的结构： AVOutputFormat *ofmt = NULL; AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVPacket pkt; 然后所需要的初始化操作有打开输入视频文件、获取其中的流信息和获取输出文件的句柄： av_register_all(); //按封装格式打开输入视频文件 if ((ret = avformat_open_input(&amp;ifmt_ctx, io_param.inputName, NULL, NULL)) &lt; 0) &#123; printf(&quot;Error: Open input file failed.\\n&quot;); goto end; &#125; //获取输入视频文件中的流信息 if ((ret = avformat_find_stream_info(ifmt_ctx, NULL)) &lt; 0) &#123; printf(&quot;Error: Failed to retrieve input stream information.\\n&quot;); goto end; &#125; av_dump_format(ifmt_ctx, 0, io_param.inputName, 0); //按照文件名获取输出文件的句柄 avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, io_param.outputName); if (!ofmt_ctx) &#123; printf(&quot;Error: Could not create output context.\\n&quot;); goto end; &#125; ofmt = ofmt_ctx-&gt;oformat; 3、 向输出文件中添加Stream并打开输出文件在我们获取到了输入文件中的流信息后，保持输入流中的codec不变，并以其为依据添加到输出文件中： for (unsigned int i = 0; i &lt; ifmt_ctx-&gt;nb_streams ; i++) &#123; AVStream *inStream = ifmt_ctx-&gt;streams[i]; AVStream *outStream = avformat_new_stream(ofmt_ctx, inStream-&gt;codec-&gt;codec); if (!outStream) &#123; printf(&quot;Error: Could not allocate output stream.\\n&quot;); goto end; &#125; ret = avcodec_copy_context(outStream-&gt;codec, inStream-&gt;codec); outStream-&gt;codec-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) &#123; outStream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER; &#125; &#125; av_dump_format(ofmt_ctx, 0, io_param.outputName, 1); 这里调用了函数avcodec_copy_context函数，该函数的声明如下： int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src); 该函数的作用是将src表示的AVCodecContext中的内容拷贝到dest中。 随后，调用avio_open函数打开输出文件： av_dump_format(ofmt_ctx, 0, io_param.outputName, 1); if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;ofmt_ctx-&gt;pb, io_param.outputName, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; printf(&quot;Error: Could not open output file.\\n&quot;); goto end; &#125; &#125; 4、写入文件的音视频数据首先向输出文件中写入文件头: ret = avformat_write_header(ofmt_ctx, NULL); if (ret &lt; 0) &#123; printf(&quot;Error: Could not write output file header.\\n&quot;); goto end; &#125; 写入文件的视频和音频包数据，其实就是将音频和视频Packets从输入文件中读出来，正确设置pts和dts等时间量之后，再写入到输出文件中去： while (1) &#123; AVStream *in_stream, *out_stream; ret = av_read_frame(ifmt_ctx, &amp;pkt); if (ret &lt; 0) break; in_stream = ifmt_ctx-&gt;streams[pkt.stream_index]; out_stream = ofmt_ctx-&gt;streams[pkt.stream_index]; /* copy packet */ pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt); if (ret &lt; 0) &#123; fprintf(stderr, &quot;Error muxing packet\\n&quot;); break; &#125; av_free_packet(&amp;pkt); &#125; 最后要做的就是写入文件尾： av_write_trailer(ofmt_ctx); 5、 收尾工作写入输出文件完成后，需要对打开的结构进行关闭或释放等操作。主要有关闭输入输出文件、释放输出文件的句柄等： avformat_close_input(&amp;ifmt_ctx); /* close output */ if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) avio_closep(&amp;ofmt_ctx-&gt;pb); avformat_free_context(ofmt_ctx); if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123; fprintf(stderr, &quot;Error failed to write packet to output file.\\n&quot;); return 1; &#125; ##七、 FFMpeg实现视频水印 视频的水印通常指附加在原始视频上的可见或者不可见的，与原始视频无直接关联的标识。通常在有线电视画面上电视台的台标以及视频网站上的logo就是典型的视频水印的应用场景。通常实现视频水印可以通过FFMpeg提供的libavfilter库实现。libavfilter库实际上实现的是视频的滤镜功能，除了水印之外，还可以实现视频帧的灰度化、平滑、翻转、直方图均衡、裁剪等操作。 我们这里实现的视频水印等操作，完全在视频像素域实现，即从一个yuv文件中读取数据到AVFrame结构，对AVFrame结构进行处理后再输出到另一个yuv文件。中间不涉及封装或编码解码等操作。 ###1. 解析命令行，获取输入输出文件信息 我们通过与之前类似的方式，在命令行中获取输入、输出文件名，图像宽高。首先定义如下的结构体用于保存配置信息： typedef struct _IOFiles &#123; const char *inputFileName; //输入文件名 const char *outputFileName; //输出文件名 FILE *iFile; //输入文件指针 FILE *oFile; //输出文件指针 uint8_t filterIdx; //Filter索引 unsigned int frameWidth; //图像宽度 unsigned int frameHeight; //图像高度 &#125;IOFiles; 在这个结构体中，filterIdx用于表示当前工程选择哪一种filter，即希望实现哪一种功能。 在进入main函数之后，调用hello函数来解析命令行参数： static int hello(int argc, char **argv, IOFiles &amp;files) &#123; if (argc &lt; 4) &#123; printf(&quot;usage: %s output_file input_file filter_index\\n&quot; &quot;Filter index:.\\n&quot; &quot;1. Color component\\n&quot; &quot;2. Blur\\n&quot; &quot;3. Horizonal flip\\n&quot; &quot;4. HUE\\n&quot; &quot;5. Crop\\n&quot; &quot;6. Box\\n&quot; &quot;7. Text\\n&quot; &quot;\\n&quot;, argv[0]); return -1; &#125; files.inputFileName = argv[1]; files.outputFileName = argv[2]; files.frameWidth = atoi(argv[3]); files.frameHeight = atoi(argv[4]); files.filterIdx = atoi(argv[5]); fopen_s(&amp;files.iFile, files.inputFileName, &quot;rb+&quot;); if (!files.iFile) &#123; printf(&quot;Error: open input file failed.\\n&quot;); return -1; &#125; fopen_s(&amp;files.oFile, files.outputFileName, &quot;wb+&quot;); if (!files.oFile) &#123; printf(&quot;Error: open output file failed.\\n&quot;); return -1; &#125; return 0; &#125; 该函数实现了输入输出文件的文件名获取并打开，并读取filter索引。 ###2. Video Filter初始化 在进行初始化之前，必须调用filter的init函数，之后才能针对Video Filter进行各种操作。其声明如下： void avfilter_register_all(void); 为了实现视频水印的功能，所需要的相关结构主要有： AVFilterContext *buffersink_ctx; AVFilterContext *buffersrc_ctx; AVFilterGraph *filter_graph; 其中AVFilterContext用于表示一个filter的实例上下文，AVFilterGraph表示一个video filtering的工作流。Video Filter的初始化实现如以下函数： //初始化video filter相关的结构 int Init_video_filter(const char *filter_descr, int width, int height) &#123; char args[512]; AVFilter *buffersrc = avfilter_get_by_name(&quot;buffer&quot;); AVFilter *buffersink = avfilter_get_by_name(&quot;buffersink&quot;); AVFilterInOut *outputs = avfilter_inout_alloc(); AVFilterInOut *inputs = avfilter_inout_alloc(); enum AVPixelFormat pix_fmts[] = &#123; AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE &#125;; AVBufferSinkParams *buffersink_params; filter_graph = avfilter_graph_alloc(); /* buffer video source: the decoded frames from the decoder will be inserted here. */ snprintf(args, sizeof(args), &quot;video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:pixel_aspect=%d/%d&quot;, width,height,AV_PIX_FMT_YUV420P, 1, 25,1,1); int ret = avfilter_graph_create_filter(&amp;buffersrc_ctx, buffersrc, &quot;in&quot;, args, NULL, filter_graph); if (ret &lt; 0) &#123; printf(&quot;Error: cannot create buffer source.\\n&quot;); return ret; &#125; /* buffer video sink: to terminate the filter chain. */ buffersink_params = av_buffersink_params_alloc(); buffersink_params-&gt;pixel_fmts = pix_fmts; ret = avfilter_graph_create_filter(&amp;buffersink_ctx, buffersink, &quot;out&quot;, NULL, buffersink_params, filter_graph); av_free(buffersink_params); if (ret &lt; 0) &#123; printf(&quot;Error: cannot create buffer sink\\n&quot;); return ret; &#125; /* Endpoints for the filter graph. */ outputs-&gt;name = av_strdup(&quot;in&quot;); outputs-&gt;filter_ctx = buffersrc_ctx; outputs-&gt;pad_idx = 0; outputs-&gt;next = NULL; inputs-&gt;name = av_strdup(&quot;out&quot;); inputs-&gt;filter_ctx = buffersink_ctx; inputs-&gt;pad_idx = 0; inputs-&gt;next = NULL; if ((ret = avfilter_graph_parse_ptr(filter_graph, filter_descr, &amp;inputs, &amp;outputs, NULL)) &lt; 0) &#123; printf(&quot;Error: avfilter_graph_parse_ptr failed.\\n&quot;); return ret; &#125; if ((ret = avfilter_graph_config(filter_graph, NULL)) &lt; 0) &#123; printf(&quot;Error: avfilter_graph_config&quot;); return ret; &#125; return 0; &#125; ###3. 初始化输入输出AVFrame并分配内存 我们首先声明AVFrame类型的对象和指向像素缓存的指针： AVFrame *frame_in = NULL; AVFrame *frame_out = NULL; unsigned char *frame_buffer_in = NULL; unsigned char *frame_buffer_out = NULL; 然后分配AVFrame对象，并分配其中的缓存区： void Init_video_frame_in_out(AVFrame **frameIn, AVFrame **frameOut, unsigned char **frame_buffer_in, unsigned char **frame_buffer_out, int frameWidth, int frameHeight) &#123; *frameIn = av_frame_alloc(); *frame_buffer_in = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, frameWidth,frameHeight,1)); av_image_fill_arrays((*frameIn)-&gt;data, (*frameIn)-&gt;linesize,*frame_buffer_in, AV_PIX_FMT_YUV420P,frameWidth,frameHeight,1); *frameOut = av_frame_alloc(); *frame_buffer_out = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, frameWidth,frameHeight,1)); av_image_fill_arrays((*frameOut)-&gt;data, (*frameOut)-&gt;linesize,*frame_buffer_out, AV_PIX_FMT_YUV420P,frameWidth,frameHeight,1); (*frameIn)-&gt;width = frameWidth; (*frameIn)-&gt;height = frameHeight; (*frameIn)-&gt;format = AV_PIX_FMT_YUV420P; &#125; ###4. Video Filtering循环体 这一部分主要包括三大部分： 读取原始的YUV数据到输入的frame； 使用预先定义好的filter_graph处理输入frame，生成输出frame； 将输出frame中的像素值写入输出yuv文件； 第一部分，读取原始yuv的实现由自定义函数Read_yuv_data_to_buf实现： //从输入yuv文件中读取数据到buffer和frame结构 bool Read_yuv_data_to_buf(unsigned char *frame_buffer_in, const IOFiles &amp;files, AVFrame **frameIn) &#123; AVFrame *pFrameIn = *frameIn; int width = files.frameWidth, height = files.frameHeight; int frameSize = width * height * 3 / 2; if (fread_s(frame_buffer_in, frameSize, 1, frameSize, files.iFile) != frameSize) &#123; return false; &#125; pFrameIn-&gt;data[0] = frame_buffer_in; pFrameIn-&gt;data[1] = pFrameIn-&gt;data[0] + width * height; pFrameIn-&gt;data[2] = pFrameIn-&gt;data[1] + width * height / 4; return true; &#125; 第二部分实际上分为两部分，即将输入frame送入filter graph，以及从filter graph中取出输出frame。实现方法分别为： //将待处理的输入frame添加进filter graph bool Add_frame_to_filter(AVFrame *frameIn) &#123; if (av_buffersrc_add_frame(buffersrc_ctx, frameIn) &lt; 0) &#123; return false; &#125; return true; &#125; //从filter graph中获取输出frame int Get_frame_from_filter(AVFrame **frameOut) &#123; if (av_buffersink_get_frame(buffersink_ctx, *frameOut) &lt; 0) &#123; return false; &#125; return true; &#125; 第三部分，写出输出frame到输出yuv文件： //从输出frame中写出像素数据到输出文件 void Write_yuv_to_outfile(const AVFrame *frame_out, IOFiles &amp;files) &#123; if(frame_out-&gt;format==AV_PIX_FMT_YUV420P) &#123; for(int i=0;i&lt;frame_out-&gt;height;i++) &#123; fwrite(frame_out-&gt;data[0]+frame_out-&gt;linesize[0]*i,1,frame_out-&gt;width,files.oFile); &#125; for(int i=0;i&lt;frame_out-&gt;height/2;i++) &#123; fwrite(frame_out-&gt;data[1]+frame_out-&gt;linesize[1]*i,1,frame_out-&gt;width/2,files.oFile); &#125; for(int i=0;i&lt;frame_out-&gt;height/2;i++) &#123; fwrite(frame_out-&gt;data[2]+frame_out-&gt;linesize[2]*i,1,frame_out-&gt;width/2,files.oFile); &#125; &#125; &#125; 该部分的综合实现如下： while (Read_yuv_data_to_buf(frame_buffer_in, files, &amp;frame_in)) &#123; //将输入frame添加到filter graph if (!Add_frame_to_filter(frame_in)) &#123; printf(&quot;Error while adding frame.\\n&quot;); goto end; &#125; //从filter graph中获取输出frame if (!Get_frame_from_filter(&amp;frame_out)) &#123; printf(&quot;Error while getting frame.\\n&quot;); goto end; &#125; //将输出frame写出到输出文件 Write_yuv_to_outfile(frame_out, files); printf(&quot;Process 1 frame!\\n&quot;); av_frame_unref(frame_out); &#125; ###5、 收尾工作 整体实现完成后，需要进行善后的收尾工作有释放输入和输出frame、关闭输入输出文件，以及释放filter graph： //关闭文件及相关结构 fclose(files.iFile); fclose(files.oFile); av_frame_free(&amp;frame_in); av_frame_free(&amp;frame_out); avfilter_graph_free(&amp;filter_graph); 八、 FFMpeg实现视频缩放视频缩放是视频开发中一项最基本的功能。通过对视频的像素数据进行采样或插值，可以将低分辨率的视频转换到更高的分辨率，或者将高分辨率的视频转换为更低的分辨率。通过FFMpeg提供了libswscale库，可以轻松实现视频的分辨率转换功能。除此之外，libswscale库还可以实现颜色空间转换等功能。 通常情况下视频缩放的主要思想是对视频进行解码到像素域后，针对像素域的像素值进行采样或差值操作。这种方式需要在解码端消耗一定时间，但是通用性最好，不需要对码流格式作出任何特殊处理。在FFMpeg中libswscale库也是针对AVFrame结构进行缩放处理。 1. 解析命令行参数输入输出的数据使用以下结构进行封装： typedef struct _IOFiles &#123; char *inputName; //输入文件名 char *outputName; //输出文件名 char *inputFrameSize; //输入图像的尺寸 char *outputFrameSize; //输出图像的尺寸 FILE *iFile; //输入文件指针 FILE *oFile; //输出文件指针 &#125; IOFiles; 输入参数解析过程为： static bool hello(int argc, char **argv, IOFiles &amp;files) &#123; printf(&quot;FFMpeg Scaling Demo.\\nCommand format: %s input_file input_frame_size output_file output_frame_size\\n&quot;, argv[0]); if (argc != 5) &#123; printf(&quot;Error: command line error, please re-check.\\n&quot;); return false; &#125; files.inputName = argv[1]; files.inputFrameSize = argv[2]; files.outputName = argv[3]; files.outputFrameSize = argv[4]; fopen_s(&amp;files.iFile, files.inputName, &quot;rb+&quot;); if (!files.iFile) &#123; printf(&quot;Error: cannot open input file.\\n&quot;); return false; &#125; fopen_s(&amp;files.oFile, files.outputName, &quot;wb+&quot;); if (!files.oFile) &#123; printf(&quot;Error: cannot open output file.\\n&quot;); return false; &#125; return true; &#125; 在参数读入完成后，需要从表示视频分辨率的字符串中解析出图像的宽和高两个值。我们在命令行中传入的视频分辨率字符串的格式为“width x height”，例如”720x480”。解析过程需要调用av_parse_video_size函数。声明如下： int av_parse_video_size(int *width_ptr, int *height_ptr, const char *str); 例如，我们传入下面的参数： int frameWidth, frameHeight; av_parse_video_size(&amp;frameWidth, &amp;frameHeight, &quot;720x480&quot;); 函数将分别把720和480传入frameWidth和frameHeight中。 在获取命令行参数后，调用该函数解析图像分辨率： int srcWidth, srcHeight, dstWidth, dstHeight; if (av_parse_video_size(&amp;srcWidth, &amp;srcHeight, files.inputFrameSize)) &#123; printf(&quot;Error: parsing input size failed.\\n&quot;); goto end; &#125; if (av_parse_video_size(&amp;dstWidth, &amp;dstHeight, files.outputFrameSize)) &#123; printf(&quot;Error: parsing output size failed.\\n&quot;); goto end; &#125; 这样，我们就获得了源和目标图像的宽和高度。 2. 创建SwsContext结构进行视频的缩放操作离不开libswscale的一个关键的结构，即SwsContext，该结构提供了缩放操作的必要参数。创建该结构需调用函数sws_getContext。该函数的声明如下： struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param); 该函数的前两行参数分别表示输入和输出图像的宽、高、像素格式，参数flags表示采样和差值使用的算法，常用的有SWS_BILINEAR表示双线性差值等。剩余的不常用参数通常设为NULL。创建该结构的代码如： //创建SwsContext结构 enum AVPixelFormat src_pix_fmt = AV_PIX_FMT_YUV420P; enum AVPixelFormat dst_pix_fmt = AV_PIX_FMT_YUV420P; struct SwsContext *sws_ctx = sws_getContext(srcWidth, srcHeight, src_pix_fmt, dstWidth, dstHeight, dst_pix_fmt, SWS_BILINEAR, NULL,NULL,NULL ); if (!sws_ctx) &#123; printf(&quot;Error: parsing output size failed.\\n&quot;); goto end; &#125; 3. 分配像素缓存视频缩放实际上是在像素域实现，但是实际上我们没有必要真的建立一个个AVFrame对象，我们只需要其像素缓存空间即可，我们定义两个指针数组和两个保存stride的数组，并为其分配内存区域： //分配input和output uint8_t *src_data[4], *dst_data[4]; int src_linesize[4], dst_linesize[4]; if ((ret = av_image_alloc(src_data, src_linesize, srcWidth, srcHeight, src_pix_fmt, 32)) &lt; 0) &#123; printf(&quot;Error: allocating src image failed.\\n&quot;); goto end; &#125; if ((ret = av_image_alloc(dst_data, dst_linesize, dstWidth, dstHeight, dst_pix_fmt, 1)) &lt; 0) &#123; printf(&quot;Error: allocating dst image failed.\\n&quot;); goto end; &#125; 4. 循环处理输入frame循环处理的代码为： //从输出frame中写出到输出文件 int dst_bufsize = ret; for (int idx = 0; idx &lt; MAX_FRAME_NUM; idx++) &#123; read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 0, files); read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 1, files); read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 2, files); sws_scale(sws_ctx, (const uint8_t * const*)src_data, src_linesize, 0, srcHeight, dst_data, dst_linesize); fwrite(dst_data[0], 1, dst_bufsize, files.oFile); &#125; 其核心函数为sws_scale，其声明为： int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[]); 该函数的各个参数比较容易理解，除了第一个是之前创建的SwsContext之外，其他基本上都是源和目标图像的缓存区和大小等。在写完一帧后，调用fwrite将输出的目标图像写入输出yuv文件中。 5. 收尾工作收尾工作除了释放缓存区和关闭输入输出文件之外，就是需要释放SwsContext结构，需调用函数：sws_freeContext。实现过程为： fclose(files.iFile); fclose(files.oFile); av_freep(&amp;src_data[0]); av_freep(&amp;dst_data[0]); sws_freeContext(sws_ctx);","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://bawcat.wiki/tags/ffmpeg/"}]},{"title":"关于php 编译安装 遇到的坑总结","slug":"php/php-php-install-log-2020-07-03","date":"2020-07-03T18:16:04.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/07/03/php/php-php-install-log-2020-07-03/","link":"","permalink":"https://bawcat.wiki/2020/07/03/php/php-php-install-log-2020-07-03/","excerpt":"","text":"关于php 编译安装 遇到的坑总结 每一次记录都是成长的过程 因为公司服务器问题，我们临时打算将测试环境的php 环境 先升级到 7.0 左右 ，然后我就接下了这个坑。 我的系统环境： 123456DISTRIB_ID=UbuntuDISTRIB_RELEASE=14.04DISTRIB_CODENAME=trustyDISTRIB_DESCRIPTION=&quot;Ubuntu 14.04.6 LTS&quot;Linux iZbp13psr6fb9tfovzicnmZ 3.2.0-126-generic #169-Ubuntu SMP Fri Mar 31 14:15:21 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 话不多说，首先贴出我这次遇到的问题 问题一： 1configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution 问题二：1E: Unable to locate package libxslt1-devel 问题三：1php 7.0 make: *** [ext/gd/libgd/gd_png.lo] error 1 问题四：12collect2: error: ld returned 1 exit statusmake: *** [sapi/cli/php] Error 1 具体问题 我就不过多阐述了，上述问题也不是最终的问题指向，其他因为扩展的问题，我也不多说了。总之一句话，直接升级除了坑就是麻烦 老系统建议直接升级 问题一、问题二 这个问题其实很简单，但是对于 一个 浅度的 Ubuntu 用户来说，其实这是致命的一个问题 看到这个问题 我们可以直接去 用系统的命令去安装，可是 ubuntu 使用 apt-get install 的时候 就会出现第二个问题。 发生这种情况的时候，我们有两个解决方案 直接去 google 上面 搜索对应的扩展包，执行编译 安装到系统 搜索大佬的解决方案 本着能偷懒就偷懒的性格，我选择了第二个方案 然后 我就看到各种 关于 ubuntu 的系统 search package 的解决方案 有 提示 让我直接 apt-get update 的。（公司服务器 阿里云）当我直接 更新后，第二个问题基本没有解决，而且，还更严重了，直接 就是 对应的 libgd 的扩展 全部都找不到了 这让我如何是好啊。 1sudo apt-get install libbz2-dev libcurl4-gnutls-dev libssl-dev libc-client2007e libc-client2007e-dev libcurl4-openssl-dev libpq-dev libxslt1-dev libxpm-dev build-essential 然后我发现 在 ubuntu 上 需要这样去找 你敢信 libbz2-dev libxslt1-dev 还有先后顺序 不过好在 问题 顺利解决了 魔鬼出在细节里为了保证 有一个 良好的周六日 不会被公司的小伙伴们 用远程电话叫醒 这次安装环境 原先的环境 我并没有删除 然后 问题三 出现了 （原报错非常多，没有一一记录） 大致的问题就是 我使用的 gd_png 出现了不可知的意外错误 看到这里 我已经开始怀疑 php 关于gd 库的bug 是不是没有解决的问题了。熟练的上 php.net 搜索了一会儿 版本记录。发现这个问题已经被解决了。那就很奇怪，我这里的问题又是怎么发生的呢？ 上面的 php 环境没有删除 划重点 &lt;\\-_-/&gt; 仔细 看了看错误信息 因为 ./configure 已经通过了 现在是 make 失败 说明 php 不存在 bug 那么多半出在 扩展上 ext/gd/libgd/gd_png.c 我根据提示错误信息 找到了 对应文件 然后 搜索了自己的系统 发现存在多个 png.h 的文件 难道是 png.h 引用错误？ 上面图片 请根据 自己系统中的文件 更换 绝对路径 发生了问题，多半都是基础知识的复习当解决掉一大堆问题之后，我们终于来到了最后一步，看着终端不停的输出 我甚至在 make 后面 加上了 j4 然后就发生了第四个问题 这次的报错还是 gd 库的问题 无奈，我们已经排除了所有的答案，但是 这个错误很迷惑 因为它涉及到了 sapi 的问题 说明 已经进入了编译的后半段阶段，按道理来说 gd 库已经编译成功了，应该已经进入 其他阶段了，请看下面的示意图： 在安裝 PHP 到系统中时要是发生「undefined reference to libiconv_open’」之类的错误信息，那表示在「./configure 」沒抓好一些环境变数值。错误发生点在建立「-o sapi/cli/php」是出错，没給到要 link 的 iconv 函式库参数。 解决方法：编辑Makefile 大约77 行左右的地方: EXTRA_LIBS = ….. -lcrypt 在最后加上 -liconv，例如: EXTRA_LIBS = ….. -lcrypt -liconv 然后重新再次 make 即可。 或者用另一种办法 make ZEND_EXTRA_LIBS=’-liconv’ ln -s /usr/local/lib/libiconv.so.2 /usr/lib64/ 记得先make clean一下 成功12345678910111213141516171819202122232425262728293031root@iZbp13psr6fb9tfovzicnmZ:/alidata/server/php-7.0.23# make installInstalling shared extensions: /alidata/server/php70/lib/php/extensions/no-debug-non-zts-20151012/Installing PHP CLI binary: /alidata/server/php70/bin/Installing PHP CLI man page: /alidata/server/php70/php/man/man1/Installing PHP FPM binary: /alidata/server/php70/sbin/Installing PHP FPM defconfig: /alidata/server/php70/etc/Installing PHP FPM man page: /alidata/server/php70/php/man/man8/Installing PHP FPM status page: /alidata/server/php70/php/php/fpm/Installing phpdbg binary: /alidata/server/php70/bin/Installing phpdbg man page: /alidata/server/php70/php/man/man1/Installing PHP CGI binary: /alidata/server/php70/bin/Installing PHP CGI man page: /alidata/server/php70/php/man/man1/Installing build environment: /alidata/server/php70/lib/php/build/Installing header files: /alidata/server/php70/include/php/Installing helper programs: /alidata/server/php70/bin/ program: phpize program: php-configInstalling man pages: /alidata/server/php70/php/man/man1/ page: phpize.1 page: php-config.1Installing PEAR environment: /alidata/server/php70/lib/php/[PEAR] Archive_Tar - installed: 1.4.3[PEAR] Console_Getopt - installed: 1.4.1[PEAR] Structures_Graph- installed: 1.1.1[PEAR] XML_Util - installed: 1.4.2[PEAR] PEAR - installed: 1.10.5Wrote PEAR system config file at: /alidata/server/php70/etc/pear.confYou may want to add: /alidata/server/php70/lib/php to your php.ini include_path/alidata/server/php-7.0.23/build/shtool install -c ext/phar/phar.phar /alidata/server/php70/binln -s -f phar.phar /alidata/server/php70/bin/pharInstalling PDO headers: /alidata/server/php70/include/php/ext/pdo/ 附属链接-帮助记录软件包: libxslt1-dev (1.1.28-2.1ubuntu0.3 以及其他的) [security] https://packages.ubuntu.com/xenial/libxslt1-dev Ubuntu 16.04 编译安装Nginx-1.10.3、 PHP7.0.9、Redis3.0 扩展、Phalcon3.1 扩展、Swoole1.9.8 扩展、ssh2扩展（全程编译安装）https://www.cnblogs.com/tinywan/p/6607395.html 下载必要软件包 libxml2-2.6.30.tar.gz （一个xml c语言版的解析器）ftp://ftp.gnome.org/pub/GNOME/sources/libxml2/2.6/libxml2-2.6.30.tar.gz libmcrypt-2.5.8.tar.gz （php中mcrypt扩展,libmcrypt是加密算法扩展库）http://prdownloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?use_mirror=peterhost zlib-1.2.7.tar.gz （提供数据压缩用的函式库，为安装gd库做准备）http://zlib.net/fossils/zlib-1.2.7.tar.gz libpng-1.2.31.tar.gz （软件包包含 libpng 库.这些库被其他程式用于读写png文件，为安装gd库做准备）ftp://194.54.81.27/services/customapache/libpng-1.2.31.tar.gz jpegsrc.v6b.tar.gz （为安装gd库做准备）http://www.ijg.org/files/jpegsrc.v6b.tar.gz freetype-2.3.5.tar.gz （字体库文件，为GD库做准备） http://download.savannah.gnu.org/releases/freetype/freetype-2.3.5.tar.gz autoconf-2.61.tar.gz （是用来产生configure文件的。）ftp://ftp.gnu.org/gnu/autoconf/autoconf-2.61.tar.gz libgd-2.1.0.tar.gz（是php处理图形的扩展库）https://bitbucket.org/libgd/gd-libgd/downloads/libgd-2.1.0.tar.gz ngnixhttp://nginx.org/download/nginx-1.0.15.tar.gz pcre （一个正则表达式库，nginx伪静态可以用到）http://ftp.exim.llorien.org/pcre/pcre-8.36.tar.gz mysqlhttp://mysql.mirror.kangaroot.net/Downloads/MySQL-5.6/mysql-5.6.27.tar.gz phphttp://cn2.php.net/get/php-5.6.9.tar.gz/from/a/mirror cmake （编译mysql）http://www.cmake.org/files/v3.2/cmake-3.2.2.tar.gz zend guard （php脚本加密）http://downloads.zend.com/guard/5.5.0/ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz下载apachehttp://www.apache.org/dist/httpd/httpd-2.4.17.tar.gz下载apr（Apache库文件）http://mirror.bit.edu.cn/apache/apr/apr-1.5.2.tar.gz下载apr-util（Apache库文件）http://mirror.bit.edu.cn/apache/apr/apr-util-1.5.4.tar.gzphp7https://github.com/php/php-src/archive/php-7.0.0.tar.gz 一些排错的坑1make &amp;&amp; makeinstall 错误处理： 12make[1]: *** [nanohttp.lo] Error 1打开目录下的nanohttp.c，第1588行由fd = open(filename, O_CREAT | O_WRONLY);更换为 fd = open(filename, O_CREAT | O_WRONLY,0777); cd /usr/local/src/libmcrypt-2.5.8./configure –prefix=/usr/local/libmcrypt出现错误：checking for C++ compiler default output file name… configure: error: C++ compiler cannot create executablesSee `config.log’ for more details.解决办法：sudo apt-get install g++make &amp;&amp; make install cd /usr/local/src/zlib-1.2.312./configure --prefix=/usr/local/zlibmake &amp;&amp; make install cd /usr/local/src/libpng-1.2.312./configure --prefix=/usr/local/libpngmake &amp;&amp; make install cd /usr/local/src/zlib-1.2.312./configure --prefix=/usr/local/zlibmake &amp;&amp; make install 在安装过程中会出现如下错误： 1error: zlib not installed 解决的办法是： 12345cd /usr/local/src/zlib-1.2.3 make clean 清除上一次make产生的文件，然后 ./configure make &amp;&amp; make install cd /usr/local/src/libpng-1.2.3./configure --prefix=/usr/local/libpngmake &amp;&amp; make install 安装jpeg6库文件12345678910mkdir /usr/local/jpeg6mkdir /usr/local/jpeg6/binmkdir /usr/local/jpeg6/libmkdir /usr/local/jpeg6/includemkdir -p /usr/local/jpeg6/man/man1cd /usr/local/src/jpeg6/jpeg-6b./configure --prefix=/usr/local/jpeg6 --enable-shared 建立共享库使用的GNU libtool--enable-static 建立静态库使用的libtoolmake &amp;&amp; make insall cd /usr/local/src/freetype-2.3.512./configure --prefix=/usr/local/freetypemake &amp;&amp; make install cd /usr/local/src/autoconf-2.611./configure make &amp;&amp; makeinstall 安装GD库12345678cd /usr/local/src/libgd-2.1.0./configure \\ --prefix=/usr/local/gd2/ \\ --with-zlib=/usr/local/zlib/ \\ --with-jpeg=/usr/local/jpeg6/ \\ --with-png=/usr/local/libpng/ \\ --with-freetype=/usr/local/freetype/ make &amp;&amp; make install 以上子make过程中会出现如下错误： 123456“gd_png.c:16:53: error: png.h: No such file or directorygd_png.c:47: error: expected specifier-qualifier-list before &#x27;jmp_buf&#x27;gd_png.c:54: error: expected &#x27;)&#x27; before &#x27;png_ptr&#x27;gd_png.c:82: error: expected &#x27;)&#x27; before &#x27;png_ptr&#x27;gd_png.c:92: error: expected &#x27;)&#x27; before &#x27;png_ptr&#x27;gd_png.c:98: error: expected &#x27;)&#x27; before &#x27;png_ptr&#x27;” 处理方法：vi gd_png.c将#include “png.h”替换成：#include “/usr/local/libpng/include/png.h”然后再make就可以了注：include“”双引号里包含的是libpng安装的路径里的include文件夹里的png.h文件 cmake12345cd /usr/local/srctar zxvf cmake-2.8.9.tar.gzcd cmake-2.8.9./configuremake &amp;&amp; make install pcre1234567cd /usr/local/srcmkdir /usr/local/pcre #创建安装目录tar zxvf pcre-8.30.tar.gzcd pcre-8.30./configure --prefix=/usr/local/pcre #配置makemake install 安装apr123cd /usr/local/srctar zxvf apr-1.4.6.tar.gzcd apr-1.4.6./configure --prefix=/usr/local/apr makemake install 安装apr-util123tar zxvf apr-util-1.4.1.tar.gzcd apr-util-1.4.1./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr/bin/apr-util./configure make &amp;&amp; make install mysql groupadd mysql #添加mysql组 useradd -g mysql mysql -s /bin/false #创建用户mysql并加入到mysql组，不允许mysql用户直接登录系统 mkdir -p /data/mysql #创建MySQL数据库存放目录 chown -R mysql:mysql /data/mysql #设置MySQL数据库目录权限 mkdir -p /usr/local/mysql #创建MySQL安装目录1234cd /usr/local/srctar zxvf mysql-5.5.27.tar.gzcd mysql-5.5.27cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc #配置 *出现如下错误：**1234567CMake Error at cmake/readline.cmake:83 (MESSAGE): ... cmake/readline.cmake:127 (FIND_CURSES) cmake/readline.cmake:217 (MYSQL_USE_BUNDLED_LIBEDIT) CMakeLists.txt:268 (MYSQL_CHECK_READLINE) Configuring incomplete, errors occurred! 如回显所示，ubuntu下安装libncurses5-dev；redhat下安装ncurses-devel，并删除当前目录CMakeCache.txt(必须删除，否则报错依旧)并重新运行：$ cmake . *解决：** remove CMakeCache.txt； yum install ncurses-devel 或 sudo apt-get install libncurses5-dev 重新运行cmake . make &amp;&amp; make install 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 配置mysql: cd /usr/local/mysqlcp ./support-files/my-huge.cnf /etc/my.cnf #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可）vi /etc/my.cnf #编辑配置文件,在 [mysqld] 部分增加 datadir = /data/mysql #添加MySQL数据库路径./scripts/mysql_install_db --user=mysql #生成mysql系统数据库cp ./support-files/mysql.server /etc/init.d/mysqld #把Mysql加入系统启动chmod 755 /etc/init.d/mysqld #增加执行权限chkconfig mysqld on #加入开机启动vi /etc/init.d/mysqld #编辑basedir = /usr/local/mysql #MySQL程序安装路径datadir = /data/mysql #MySQl数据库存放目录service mysqld start #启动vi /etc/profile #把mysql服务加入系统环境变量：在最后添加下面这一行 export PATH=$PATH:/usr/local/mysql/bin下面这两行把myslq的库文件链接到系统默认的位置，这样你在编译类似PHP等软件时可以不用指定mysql的库文件地址。ln -s /usr/local/mysql/lib/mysql /usr/lib/mysqlln -s /usr/local/mysql/include/mysql /usr/include/mysqlshutdown -r now #需要重启系统，等待系统重新启动之后继续在终端命令行下面操作mysql_secure_installation #设置Mysql密码根据提示按Y 回车输入2次密码或者直接修改密码/usr/local/mysql/bin/mysqladmin -u root -p password &quot;123456&quot; #修改密码service mysqld restart #重启到此，mysql安装完成！ 安装apache212cd /usr/local/srctar -zvxf httpd-2.4.1.tar.gzcd httpd-2.4.1mkdir -p /usr/local/apache2 #创建安装目录1 配置一： 1./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-ssl --enable-ssl --enable-module=so --enable-rewrite --enable-cgid --enable-cgi --with-pcre=/usr/local/pcre 配置二： 12./configure --prefix=/usr/local/apache2 --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-zlib=/usr/local/zlib --with-pcre=/usr/local/pcre --enable-so --enable-rewrite=shared --enable-deflate=shared --enable-expires=shared --enable-static-support make &amp;&amp; make install 配置apache 123456789101112131415161718192021222324/usr/local/apache2/bin/apachectl -k start #启动vi /usr/local/apache2/conf/httpd.conf #编辑配置文件找到：#ServerName www.example.com:80修改为：ServerName www.osyunwei.com:80找到：DirectoryIndex index.html修改为：DirectoryIndex index.html index.php找到：Options Indexes FollowSymLinks修改为：Options FollowSymLinks #不显示目录结构找到AllowOverride None 修改为：AllowOverride All #开启apache支持伪静态，有两处都做修改LoadModule rewrite_module modules/mod_rewrite.so #取消前面的注释，开启apache支持伪静态vi /etc/profile #添加apache服务系统环境变量在最后添加下面这一行export PATH=$PATH:/usr/local/apache2/bincp /usr/local/apache2/bin/apachectl /etc/rc.d/init.d/httpd #把apache加入到系统启动vi /etc/init.d/httpd #编辑文件在#!/bin/sh下面添加以下两行chkconfig:2345 10 90descrption:Activates/Deactivates Apache Web Serverchown daemon.daemon -R /usr/local/apache2/htdocs #更改目录所有者chmod 700 /usr/local/apache2/htdocs -R #更改apache网站目录权限chkconfig httpd on #设置开机启动/etc/init.d/httpd startservice httpd restart nginx groupadd www useradd -g www -s /bin/false www cd /usr/local/src/nginx-1.2.6 12345678./configure \\--prefix=/usr/local/nginx \\ --with-pcre=/usr/local/src/pcre-8.21\\ //pcre的源代码路径，而不是安装路径--conf-path=/usr/local/nginx/nginx.conf \\ --pid-path=/usr/local/nginx/nginx.pid \\ --with-zlib=/usr/local/src/zlib-1.2.7 \\ //zlib的源代码路径--with-http_stub_status_module --user=www --group=wwwmake &amp;&amp; make install php7123456789cd /usr/local/srctar -zvxf php-7.0.0.tar.gzcd php-7.0.0mkdir -p /usr/local/php7 #建立php安装目录 编译安装php配合apache和nginx sudo ./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-config-file-path=/usr/local/php --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-libxml-dir=/usr/local/libxml2 --with-gd=/usr/local/libgd2 --with-jpeg-dir=/usr/local/jpeg-9a --with-png-dir=/usr/local/libpng --with-bz2 --with-freetype-dir=/usr/local/freetype-2.4 --with-iconv-dir --with-pcre-dir=/usr/local/pcre --with-zlib-dir=/usr/local/zlib --with-libzip=/usr/local/libzip --enable-zip --with-openssl --with-mcrypt=/usr/local/libmcrypt --with-xmlrpc --with-curl --with-gettext --enable-xml --enable-mbregex --enable-soap --enable-gd-native-ttf --enable-ftp --enable-mbstring --enable-exif --enable-safe-mode --enable-sockets --enable-session --enable-magic-quotes --enable-bcmath --disable-rpath --disable-debug --disable-ipv6 --enable-fastcgi --enable-fpm --without-pear --enable-opcache=no --with-xpm-dir=/usr/lib/i386-linux-gnu/**选项--with-apxs2=/usr/local/apache2/bin/apxs支持apache选项 --enable-fastcgi 和 --enable-fpm 支持nginx**make &amp;&amp; make install make 过程中提示：In file included from /usr/local/packages/php-5.6.9/ext/zip/lib/zip_add.c:37:/usr/local/packages/php-5.6.9/ext/zip/lib/zipint.h:118:2: error: #error unsupported size of off_tmake: *** [ext/zip/lib/zip_add.lo] Error 1是因为 –with-zlib-dir=DIR –with-pcre-dir=DIR –with-libzip=DIR , zip都基于这三个模块，后来瞎试试发现装好后在./configure的参数加上这三个，然后成了……哎，php5.6以上才会发生这样的问题，以下貌似随便搞。 配置php 123456789101112131415161718192021222324cp php.ini-production /usr/local/php5/etc/php.ini #复制php配置文件到安装目录**rm -rf /etc/php.ini #删除系统自带配置文件ln -s /usr/local/php5/etc/php.ini /etc/php.ini #添加软链接cp /usr/local/php5/etc/php-fpm.conf.default /usr/local/php5/etc/php-fpm.conf #拷贝模板文件为php-fpm配置文件vi /usr/local/php5/etc/php-fpm.conf #编辑user = www #设置php-fpm运行账号为wwwgroup = www #设置php-fpm运行组为wwwpid = run/php-fpm.pid #取消前面的分号设置 php-fpm开机启动cp /usr/local/src/php-5.3.16/sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm #拷贝php-fpm到启动目录chmod +x /etc/rc.d/init.d/php-fpm #添加执行权限chkconfig php-fpm on #设置开机启动vi /usr/local/php5/etc/php.ini #编辑配置文件找到：;open_basedir =修改为：open_basedir = .:/tmp/ #防止php木马跨站，重要！！找到：disable_functions =修改为：disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,getservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid, posix_getppid,posix_getpwnam,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname列出PHP可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用。找到：;date.timezone =修改为：date.timezone = PRC #设置时区找到：expose_php = On修改为：expose_php = OFF #禁止显示php版本的信息找到：display_errors = On修改为：display_errors = OFF #关闭错误提示 配置apache支持php vi /usr/local/apache2/conf/httpd.conf #编辑apache配置文件 在LoadModule php5_module modules/libphp5.so这一行下面添加、 AddType application/x-httpd-php .php （注意：php .php这个点前面有一个空格） service httpd restart #重启apache service mysqld restart #重启mysql 测试篇 1234cd /usr/local/apache2/htdocsvi index.php #输入下面内容&lt;?phpphpinfo();?&gt; 配置php支持Zend Guard 安装Zend Guard 123456789101112cd /usr/local/srcmkdir /usr/local/zend #建立Zend安装目录tar xvfz ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz #解压安装文件cp ZendGuardLoader-php-5.3-linux-glibc23-i386/php-5.3.x/ZendGuardLoader.so /usr/local/zend/ #拷贝文件到安装目录vi /usr/local/php5/etc/php.ini #编辑文件在最后位置添加以下内容[Zend Guard]zend_extension=/usr/local/zend/ZendGuardLoader.sozend_loader.enable=1zend_loader.disable_licensing=0zend_loader.obfuscation_level_support=3zend_loader.license_path= ok！ 安装Zend Guardcd /usr/local/srcmkdir /usr/local/zend #建立Zend安装目录tar xvfz ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz #解压安装文件cp ZendGuardLoader-php-5.3-linux-glibc23-i386/php-5.3.x/ZendGuardLoader.so /usr/local/zend/ #拷贝文件到安装目录vi /usr/local/php5/etc/php.ini #编辑文件在最后位置添加以下内容[Zend Guard]zend_extension=/usr/local/zend/ZendGuardLoader.sozend_loader.enable=1zend_loader.disable_licensing=0zend_loader.obfuscation_level_support=3zend_loader.license_path=ok！Vimium has been updated to 1.41.x","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"php 安装","slug":"php-安装","permalink":"https://bawcat.wiki/tags/php-%E5%AE%89%E8%A3%85/"},{"name":"编译安装","slug":"编译安装","permalink":"https://bawcat.wiki/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"},{"name":"错误排坑","slug":"错误排坑","permalink":"https://bawcat.wiki/tags/%E9%94%99%E8%AF%AF%E6%8E%92%E5%9D%91/"},{"name":"php 编译错误解决","slug":"php-编译错误解决","permalink":"https://bawcat.wiki/tags/php-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"}]},{"title":"docker 命令笔记","slug":"docker/docker 命令笔记","date":"2020-06-26T15:45:17.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/26/docker/docker 命令笔记/","link":"","permalink":"https://bawcat.wiki/2020/06/26/docker/docker%20%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"docker简介(docker 命令笔记)为什么要使用docker简单粗暴的一句话，docker已经实现了在linux 容器化技术上，达到‘任何时间、任何地点’可以一键部署等完美操作，当然，这只是docker的 一部分骚操作 更快速的交付和部署 更高效的资源利用 更轻松的迁移和扩展 更简单的更新和管理 docker 核心概念docker 大部分的操作都围绕这它的三大核心概念：镜像、容器和仓库。因此、这三大概念也尤为重要 安装docker 官方教程:https://docs.docker.com/install/linux/docker-ce/centos/ 使用docker镜像镜像是docker 三大核心概念中最重要的 docker 运行容器前需要本地存在对应的镜像，如果镜像不存在，docker 会尝试先从默认镜像仓库下载（默认使用docker hub 公共注册服务器中的仓库） 如果你的服务器在国外（香港也算 台湾也算，非大陆）推荐docker hub 如果在国内 推荐阿里云的镜像仓库 地址:请自行百度 命令格式docker [image] pull1docker [image] pull 例如： 1docker pull ubuntu:18.04 对于docker 镜像而言 如果不显式指定tag 则默认会选择latest标签，这回下载仓库中最新版本的镜像 如果从非官方的仓库进行下载，则需要在仓库名称钱指定完整的仓库地址。例如从网易蜂巢的镜像源来下载ubuntu:18.04: 1docker pull hub.c.163.com/public/ubuntu:18.04 pull 子命令支持的选型主要包括： -a , –all-tags=true|false:是否获取仓库中的所有镜像，默认为否； –disable-content-trust:取消镜像的内容校验，默认为真。 另外，有时需要使用镜像代理服务来加速 docker 镜像获取过程，可以在docker服务启动配置中增加–registry-mirror=proxy_URL来指定镜像代理服务地址（如https://registry.docker-cn.com） docker images | docker image ls使用docker images 或者 docker image ls 命令可以列出本地主机上已有镜像的基本信息。 docker tag [image] [new image]使用 tag 命令为镜像添加标签为了方便在后续的工作中使用特定镜像，还可以使用 docker tag 命令来为本地镜像任意的添加新的名称或者标签。 docker [image] inspect使用该命令可以获取镜像的详细信息，包括制作者、适应框架、各层的数字摘要等 docker history [image]使用该命令则可以查看历史镜像 docker search [option] keyword命令选项支持 -f –filter filter:过滤输出内容 –format string:格式化输出内容； –limit int: 限制输出结果个数,默认25个 –no-trunc: 不截断输出结果 docker rm | rmi | prune通过标签删除镜像123# 删除镜像（注意：镜像）docker rmi docker image rm 命令选项支持 -f ,-force: 强制删除镜像，即使存在依赖容器 -no-prune: 不要清理未带标签的父镜像 通过镜像id 删除镜像当使用docker rmi 命令，并且后面跟上镜像的ID(也可以是能够区分的部分ID串前缀）时，会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身 清理镜像当镜像使用超过一段时间之后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过docker image prune来进行清理 命令的选项支持 -a , -all 删除所有无用镜像，不光是临时镜像 -filter filter 只清理符合给定过滤器的镜像 -f , -force 强制删除镜像，而不进行提示确认 docker ps -a该命令可以让你看到本机上面存在的所有容器","categories":[],"tags":[]},{"title":"初识 Swing","slug":"java/java-swing-helloSwing-2020-04-14","date":"2020-06-26T15:36:05.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/26/java/java-swing-helloSwing-2020-04-14/","link":"","permalink":"https://bawcat.wiki/2020/06/26/java/java-swing-helloSwing-2020-04-14/","excerpt":"","text":"初识 Swing什么是Swing?Swing 是一个为Java设计的GUI工具包。 Swing是JAVA基础类的一部分。 Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。 Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。 Swing 和 AWTAWT（Abstract Window Toolkit，抽象窗口工具）是一套早期的 Java GUI 开发工具，Swing 也是在 AWT 的基础上发展起来的。 AWT 的初衷是用来开发小型的图形界面程序，提供的功能较少，诸如剪切板、打印支持、键盘导航、弹出式菜单、滚动窗格等很多重要的功能在 AWT 中都不具备；此外，AWT 发生错误的几率也很高 Java 官方看到了 AWT 的不足，就开始着手开发新的 GUI 类库，以继续占领 Java GUI 开发的市场，这就是后来的 Swing。 Swing 弥补了 AWT 的不足，并对 AWT 进行了扩充，几乎支持了所有的常用控件和功能，它们不但更加漂亮，而且更加易用，真正实现了“一次编译，到处运行”的承诺。 目前，Swing 已经代替 AWT 成为 Java 图形界面设计的首选，相对于 AWT 来说，Swing 有过之而无不及。 Swing 概念Swing 是新一代的图形界面工具。使用 Swing 来开发图形界面比 AWT 更加优秀，因为 Swing 是一种轻量级组件，它采用纯 Java 实现，不再依赖于本地平台的图形界面，所以可以在所有平台上保持相同的运行效果，对跨平台支持比较出色。除此之外，Swing 提供了比 AWT 更多的图形界面组件，因此可以开发出美观的图形界面程序。 Swing 类库结构 从图 1 可以看出，Swing 组件除了 AbstmctButton 类之外都以 J 开头。Swing 容器组件直接继承 AWT 类库中的容器组件类，其他大部分组件都是继承 JComponet 组件。组件可以划分为容器组件和非容器组件，容器组件包括 JFmme 和 JDialog。其中 JComponent 定义了非容器类的轻量级组件（JBntton、JPanel、JMenu 等） Swing 包Swing 类库由许多包组成，通过这些包中的类相互协作来完成 GUI 设计。其中，javax.swing 包是 Swing 提供的最大包，它包含将近 100 个类和 25 个接口。几乎所有 Swing 组件都在该包中。表 1 列出了常用的 Swing 包。 包名称 描述 javax.swing 提供一组“轻量级”组件，尽量让这些组件在所有平台上的工作方式都相同 javax.swing.border 提供围绕 Swing 组件绘制特殊边框的类和接口 javax.swing.event 提供 Swing 组件触发的事件 javax.swing.filechooser 提供 JFileChooser 组件使用的类和接口 javax.swing.table 提供用于处理 javax.swing.JTable 的类和接口 javax.swing.text 提供类 HTMLEditorKit 和创建 HTML 文本编辑器的支持类 javax.swing.tree 提供处理 javax.swingJTree 的类和接口 javax.swing.event 包中定义了事件和事件监听器类，javax.swing.event 包与 AWT 的 event 包类似。Java.awt.event 和 javax.swing.event 都包含事件类和监听器接口，它们分别响应由 AWT 组件和 Swing 组件触发的事件。 例如，当在树组件中需要节点扩展（或折叠）的通知时，则要实现 Swing 的 TreeExpansionListener 接口，并把一个 TreeExpansionEvent 实例传送给 TreeExpansionListener 接口中定义的方法，而 TreeExpansionListener 和 TreeExpansionEvent 都是在 swing.event 包中定义的。 虽然 Swing 的表格组件（JTable）在 javax.swing 包中，但它的支持类却在 javax.swing.table 包中。表格模型、图形绘制类和编辑器等也都在 javax.swing.table 包中。 与 JTable 类一样，Swing 中的树 JTree（用于按层次组织数据的结构组件）也在 javax.swing 包中，而它的支持类却在 javax.swing.tree 包中。javax.swing.tree 包提供树模型、树节点、树单元编辑类和树绘制类等支持类。 Swing 容器创建图形用户界面程序的第一步是创建一个容器类以容纳其他组件，常见的窗口就是一种容器。容器本身也是一种组件，它的作用就是用来组织、管理和显示其他组件。 Swing 中容器可以分为两类：顶层容器和中间容器。顶层容器是进行图形编程的基础，一切图形化的东西都必须包括在顶层容器中。顶层容器是任何图形界面程序都要涉及的主窗口，是显示并承载组件的容器组件。在 Swing 中有三种可以使用的顶层容器，分别是 JFrame、JDialog 和 JApplet。 JFrame：用于框架窗口的类，此窗口带有边框、标题、关闭和最小化窗口的图标。带 GUI 的应用程序至少使用一个框架窗口。 JDialog：用于对话框的类。 JApplet：用于使用 Swing 组件的 Java Applet 类。 中间容器是容器组件的一种，也可以承载其他组件，但中间容器不能独立显示，必须依附于其他的顶层容器。常见的中间容器有 JPanel、JScrollPane、JTabbedPane 和 JToolBar。 JPanel：表示一个普通面板，是最灵活、最常用的中间容器。 JScrollPane：与 JPanel 类似，但它可在大的组件或可扩展组件周围提供滚动条。 JTabbedPane：表示选项卡面板，可以包含多个组件，但一次只显示一个组件，用户可在组件之间方便地切换。 JToolBar：表示工具栏，按行或列排列一组组件（通常是按钮）。 Swing 优缺点 与直觉不太一致：Swing的GUI上的各种组件如果添加的面板过多的话，就造成各个组件的层次很深，处理类似focus管理这样的问题就很麻烦，坐标的转换也很复杂，由于父子关系过多，您不看代码只看GUI，凭直觉难以区分组件的父子关系。 布局上的困难：使用Swing开发界面的程序员会发现，即使Swing提供了这么多布局管理器，然而您想通过这些布局管理器做出很专业的界面却非常难，因为布局管理器非常依赖父容器和子组件的各种状态，尽管Swing最新的版本提供了类似组件和容器间隔的方法，然而还没有被大部分布局管理器采用，其实并不是布局管理器不够强大的问题，事实上，很多专业的界面需要从组件级别做出良好的定义，另外，不少Swing组件会根据容器的大小进行绘制，这也造成了很多不确定性，很多人喜欢使用NullLayout，可能就是这个原因，客户需要的是一个稳定的，可预知的界面，如果使用了布局管理器，会发现界面在不同的系统下展示的不同 使用上的困扰：Swing组件本身由于不能分清是组件还是容器，很多容器方法比如setEnabled就没有效果，需要写代码遍历所有子组件，调用所 有的子组件相同的方法，而类似设置透明的方法也有这个问题，如果设置某个容器透明，也需要设置所有的子组件的透明属性，组件和容器的很多方法没有很好的定 义，这对了解Swing结构的人不是问题，但是对于熟悉别的ＧＵＩ类库的人就产生了很大的困惑，因为不少容器上的方法调用后是没有效果的。 总得来说，对Composite设计模式应该慎用，如果一定要用，一定要良好的定义组件（Component）和容器（Container）的边界，避免很多功能陷入没有意义的父子遍历例程，增加了复杂性。 HelloWord 本示例来自菜鸟教程 1234567891011121314151617181920212223242526272829303132import javax.swing.*;public class HelloWorldSwing &#123; /**&#123; * 创建并显示GUI。出于线程安全的考虑， * 这个方法在事件调用线程中调用。 */ private static void createAndShowGUI() &#123; // 确保一个漂亮的外观风格 JFrame.setDefaultLookAndFeelDecorated(true); // 创建及设置窗口 JFrame frame = new JFrame(&quot;HelloWorldSwing&quot;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 添加 &quot;Hello World&quot; 标签 JLabel label = new JLabel(&quot;Hello World&quot;); frame.getContentPane().add(label); // 显示窗口 frame.pack(); frame.setVisible(true); &#125; public static void main(String[] args) &#123; // 显示应用 GUI javax.swing.SwingUtilities.invokeLater(new Runnable() &#123; public void run() &#123; createAndShowGUI(); &#125; &#125;); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Swing","slug":"java/Swing","permalink":"https://bawcat.wiki/categories/java/Swing/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Swing","slug":"Swing","permalink":"https://bawcat.wiki/tags/Swing/"}]},{"title":"Spring Web MVC 框架","slug":"java/spring/java-spring-web-mvc-framwork-2020-06-26","date":"2020-06-25T18:08:09.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/25/java/spring/java-spring-web-mvc-framwork-2020-06-26/","link":"","permalink":"https://bawcat.wiki/2020/06/25/java/spring/java-spring-web-mvc-framwork-2020-06-26/","excerpt":"","text":"Spring Web MVC 框架Spring MVC 框架，这个框架适用于 Web 开发的，它代替了 servlet 的页面跳转。 本篇是对 Spring MVC 框架的一个简单讲解，不会讲理论只是，如果想进一步学习的话，可以看 Spring MVC 简易教程 知识点 Spring Web Hello World 例子 Spring MVC 表单处理例子 Spring MVC 页面重定向例子 Spring MVC 异常处理例子 Spring Web Hello World 例子首先创建一个新的项目 1mvn archetype:generate -DgroupId=com.learn-DartifactId=springMVCTest -DarchetypeArtifactId=maven-archetype-webapp 修改 pom.xml 文件，添加 Spring 的依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.learn&lt;/groupId&gt; &lt;artifactId&gt;springMVCTest&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springMVCTest Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!--jetty maven 插件，为 maven 提供运行 web 程序的能力--&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.4.12.v20180830&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;webApp&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/webApp&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 修改 web.xml 文件内容如下： 123456789101112131415161718192021222324252627282930&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns = &quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web = &quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation = &quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id = &quot;WebApp_ID&quot; version = &quot;3.0&quot;&gt; &lt;display-name&gt;springMVCTest&lt;/display-name&gt; &lt;!-- 配置 Spring MVC DispatchcerServlet 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation 是参数名称，该参数的值包含 Spring MVC 的配置文件路径 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在 Web 应用启动时立即加载 Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Servlet 映射声明 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 监听当前域的所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 添加 register.jsp 为首页 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;register.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 在 web.xml 中配置了 DispatchcerServlet，DispatchcerServlet 加载时需要一个 Spring MVC 的配置文件，默认会去 WEB-INF 下查找对应的 servlet-name-servlet.xml 文件，如本例中默认查找的是 springmvc-servlet.xml。 Spring MVC 的配置文件可以放在任何地方，用 servlet 的子元素 init-param 描述即可，见上述示例代码，这时 DispatchcerServlet 就会去查找 /WEB-INF/springmvc-config.xml。 在 webapp/WEB-INF/ 目录下新建 Spring MVC 配置文件 springmvc-config.xml，配置 Spring MVC 的 Controller，添加如下代码： 1234567891011121314151617181920&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context = &quot;http://www.springframework.org/schema/context&quot; xmlns:mvc = &quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd&quot;&gt; &lt;!-- 开启注解 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置自动扫描的包，完成 Bean 的创建和自动依赖注入的功能 --&gt; &lt;context:component-scan base-package = &quot;com.learn.controller&quot; /&gt; &lt;!-- 默认静态资源处理 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id = &quot;viewResolver&quot; class = &quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name = &quot;prefix&quot; value = &quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name = &quot;suffix&quot; value = &quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在包 com.learn.controller 下新建 HelloController 类 HelloController.java，具体解释注释已经给出，代码如下： 12345678910111213141516171819202122package com.learn.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;/** * Controller 是一个基于注解的控制器 * 可以同时处理多个请求动作 */@Controllerpublic class HelloController &#123; /** * RequestMapping 用来映射一个请求和请求的方法 * value = &quot;/hello&quot; 表示请求由 hello 方法进行处理 */ @RequestMapping(value = &quot;/hello&quot;) public String hello() &#123; // 返回一个字符串 &quot;success&quot; 作为视图名称 return &quot;hello&quot;; &#125;&#125; 在 webapp/WEB-INF 目录下新建文件夹 views，并在该路径下新建一个 JSP 页面命名为 hello.jsp，代码如下： 12345&lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello World!&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 输入 mvn jetty:run 运行程序，访问 spring mvc。 地址 127.0.0.1:8080/hello 效果： 123456springMVCTest/ $ curl 127.0.0.1:8080/hello&lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello World!&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt;% Spring MVC 表单处理在项目目录 src/main/java 的包 com.learn.entity 下新建类 User.java，包含 id、username、password 和 age 属性，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.learn.entity;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private String username; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 在包 com.learn.controller 下新建 Controller 类 UserController.java，具体解释注释已经给出，代码如下： 1234567891011121314151617181920212223242526package com.learn.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import com.learn.entity.User;/** * UserController 是一个基于注解的控制器 * 可以同时处理多个请求动作 */@Controllerpublic class UserController &#123; /** * RequestMapping 用来映射一个请求和请求的方法 * value = &quot;/register&quot; 表示请求由 register 方法进行处理 */ @RequestMapping(value = &quot;/register&quot;) public String Register(User user, Model model) &#123; // user:视图层传给控制层的表单对象；model：控制层返回给视图层的对象 // 在 model 中添加一个名为 &quot;user&quot; 的 user 对象 model.addAttribute(&quot;user&quot;, user); // 返回一个字符串 &quot;success&quot; 作为视图名称 return &quot;success&quot;; &#125;&#125; 在 webapp 目录下新建一个 JSP 页面命名为 register.jsp，代码如下： 1234567891011121314151617181920212223242526272829303132&lt;%@ page language = &quot;java&quot; contentType = &quot;text/html; charset = UTF-8&quot;pageEncoding = &quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset = UTF-8&quot; /&gt; &lt;title&gt;register page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;register&quot; method=&quot;post&quot;&gt; &lt;h5&gt;User registration&lt;/h5&gt; &lt;p&gt; &lt;label&gt;name &lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; tabindex=&quot;1&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;password &lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; tabindex=&quot;2&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;age &lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot; tabindex=&quot;3&quot; /&gt; &lt;/p&gt; &lt;p id=&quot;buttons&quot;&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; tabindex=&quot;4&quot; value=&quot;register&quot; /&gt; &lt;input id=&quot;reset&quot; type=&quot;reset&quot; tabindex=&quot;5&quot; value=&quot;reset&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 在 webapp/WEB-INF/views 新建一个 JSP 页面命名为 success.jsp，代码如下： 1234567891011121314151617&lt;%@ page language = &quot;java&quot; contentType = &quot;text/html; charset = UTF-8&quot;pageEncoding = &quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset = UTF-8&quot; /&gt; &lt;title&gt;success page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h5&gt;login was successful&lt;/h5&gt; &lt;p&gt; name：$&#123;requestScope.user.username&#125;&lt;br /&gt; password：$&#123;requestScope.user.password&#125;&lt;br /&gt; age：$&#123;requestScope.user.age&#125;&lt;br /&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 输入 mvn jetty:run 运行程序 然后在 浏览器直接访问 之前的地址即可 Spring 页面重定向修改 HelloController.java 代码如下 123456789101112131415161718192021222324package com.learn.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @RequestMapping(value = &quot;/redirect&quot;) public String redirect()&#123; return &quot;redirect:finalPage&quot;; &#125; @RequestMapping(value = &quot;/finalPage&quot;) public String finalPage()&#123; return &quot;final&quot;; &#125;&#125; 修改 hello.jsp 代码如下： 123456789101112131415161718&lt;%@ page contentType = &quot;text/html; charset = UTF-8&quot; language = &quot;java&quot; %&gt;&lt;%@taglib uri = &quot;http://www.springframework.org/tags/form&quot; prefix = &quot;form&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC页面重定向&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Spring MVC页面重定向&lt;/h2&gt;&lt;p&gt;点击下面的按钮将结果重定向到新页面&lt;/p&gt;&lt;form:form method = &quot;GET&quot; action = &quot;redirect&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;input type = &quot;submit&quot; value = &quot;页面重定向&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; 在同目录下新建 final.jsp，代码如下： 12345678910&lt;%@ page contentType = &quot;text/html; charset = UTF-8&quot; language = &quot;java&quot; %&gt;&lt;%@taglib uri = &quot;http://www.springframework.org/tags/form&quot; prefix = &quot;form&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring重定向页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;重定向页面...&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 输入 mvn jetty:run 运行程序 然后访问 127.0.0.1:8080/hello 地址即可 Spring MVC 异常处理在 com.learn.controller 包下新建 ExceptionIntegratedHandleController.java，代码如下: 12345678910111213141516171819202122232425package com.learn.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class ExceptionIntegratedHandleController &#123; @RequestMapping(&quot;/exceptionIntegratedHandleController/&#123;id&#125;&quot;) @ResponseBody public Object hello(@PathVariable String id) &#123; if (id.equals(&quot;1&quot;)) &#123; throw new RuntimeException(&quot;我这里是手动抛出的异常,期望被SpringMVC集中处理&quot;); &#125; else if (id.equals(&quot;2&quot;)) &#123; int value = 1 / 0; return &quot;手动运算错误&quot;; &#125; else &#123; return &quot;no exception&quot;; &#125; &#125;&#125; 然后在 com.learn.exception 包下新建 MySpringExceptionIntegratedHandler.java，代码如下： 12345678910111213141516package com.learn.exception;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;// 自己手动编写 Java 代码来实现定制异常信息处理public class MySpringExceptionIntegratedHandler implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) &#123; // 这里可以根据异常的类型来决定什么样的对策 System.out.println(&quot;异常已经被处理了&quot;); System.out.println(&quot;异常的类型是:&quot; + ex.getClass().getName()); request.setAttribute(&quot;ex&quot;, ex); return new ModelAndView(&quot;runtimeExceptionPage&quot;); &#125;&#125; 然后在 springmvc-config.xml 中加入： 1&lt;bean id = &quot;mySpringExceptionIntegratedHandler&quot; class = &quot;com.learn.exception.MySpringExceptionIntegratedHandler&quot;/&gt; 最后在 views 目录下新建一个 runtimeExceptionPage.jsp，代码如下： 12345678910111213&lt;%@ page contentType = &quot;text/html; charset = UTF-8&quot;%&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Exception!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Exception e = (Exception)request.getAttribute(&quot;ex&quot;); %&gt; &lt;H2&gt;业务错误: &lt;%= e.getClass().getSimpleName()%&gt;&lt;/H2&gt; &lt;hr /&gt; &lt;P&gt;错误描述：&lt;/P&gt; &lt;%= e.getMessage()%&gt; &lt;P&gt;错误信息：&lt;/P&gt; &lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt;&lt;/body&gt;&lt;/html&gt; 输入 mvn jetty:run 运行程序","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"事务管理","slug":"事务管理","permalink":"https://bawcat.wiki/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"}]},{"title":"Spring 事务管理","slug":"java/spring/java-spring-事务管理-2020-06-25","date":"2020-06-25T18:06:56.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/25/java/spring/java-spring-事务管理-2020-06-25/","link":"","permalink":"https://bawcat.wiki/2020/06/25/java/spring/java-spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-2020-06-25/","excerpt":"","text":"Spring 事务管理Spring 的事务管理，事务在日常开发中非常重要，它可以对数据库中的一些异常进行回滚，这样就可以保证数据的一致性。 事务的四个特性： 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 知识点 Spring 编程式事务管理 Spring 申明式事务管理 Spring 事务Spring 中有两种事务管理的方式，一种是编程式事务管理，另一种是声明式事务管理。 编程式事务管理：所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于 JDBC 编程实现事务管理。管理使用 TransactionTemplate 或者直接使用底层的 PlatformTransactionManager。对于编程式事务管理，spring 推荐使用 TransactionTemplate。 声明式事务管理：管理建立在 AOP 之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional 注解的方式)，便可以将事务规则应用到业务逻辑中。 接下我们将通过一个转账的案例来分别讲解这两种事务管理方式。 Spring 编程式事务管理数据库准备 12345678create database transaction;use transactioncreate table account( id int, username varchar(20), money int);insert into account values(1,&#x27;Tom&#x27;,10000),(2,&#x27;Marry&#x27;,10000); 新建项目 1mvn archetype:generate -DgroupId = com.learn.tx -DartifactId = springTansaction -DarchetypeArtifactId = maven-archetype-quickstart 修改 pom.xml 文件，添加 Spring 的依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.learn.tx&lt;/groupId&gt; &lt;artifactId&gt;springTransaction&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springTransaction&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 首先创建包 com.learn.tx.dao，创建 AccountDao.java，代码如下： 123456789101112131415161718package com.learn.tx.dao;public interface AccountDao &#123; /** * 汇款 * @param outer 汇款人 * @param money 汇款金额 */ public void out(String outer,int money); /** * 收款 * @param inner 收款人 * @param money 收款金额 */ public void in(String inner,int money);&#125; 在再这个包下创建 AccountDaoImpl.java，代码如下： 12345678910111213141516171819202122232425package com.learn.tx.dao;import org.springframework.jdbc.core.support.JdbcDaoSupport;import com.learn.tx.dao.AccountDao;public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; /** * 根据用户名减少账户金额 */ @Override public void out(String outer, int money) &#123; this.getJdbcTemplate().update(&quot;update account set money = money - ? where username = ?&quot;,money,outer); &#125; /** * 根据用户名增加账户金额 */ @Override public void in(String inner, int money) &#123; this.getJdbcTemplate().update(&quot;update account set money = money + ? where username = ?&quot;,money,inner); &#125;&#125; 创建包 com.learn.tx.service，创建 AccountService.java，代码如下： 12345678910111213package com.learn.tx.service;public interface AccountService &#123; /** * 转账 * @param outer 汇款人 * @param inner 收款人 * @param money 交易金额 */ public void transfer(String outer,String inner,int money);&#125; 再在这个包下创建 AccountServiceImpl.java，代码如下： 123456789101112131415161718192021222324252627282930313233package com.learn.tx.service;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;import com.learn.tx.dao.AccountDao;import com.learn.tx.service.AccountService;public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(final String outer,final String inner,final int money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus arg0) &#123; accountDao.out(outer, money); int i = 1/0; accountDao.in(inner, money); &#125; &#125;); &#125;&#125; 我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。 编辑 SpringBeans.xml 文件如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context = &quot;http://www.springframework.org/schema/context&quot; xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id = &quot;dataSource&quot; class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost/transaction&quot;/&gt; &lt;property name = &quot;username&quot; value = &quot;root&quot;/&gt; &lt;property name = &quot;password&quot; value = &quot;&quot;/&gt; &lt;/bean&gt; &lt;bean id = &quot;accountDao&quot; class = &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;accountService&quot; class = &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt; &lt;property name = &quot;accountDao&quot; ref = &quot;accountDao&quot;&gt;&lt;/property&gt; &lt;property name = &quot;transactionTemplate&quot; ref = &quot;transactionTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 创建模板 --&gt; &lt;bean id = &quot;transactionTemplate&quot; class = &quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name = &quot;transactionManager&quot; ref = &quot;txManager&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器，管理器需要事务，事务从 Connection 获得，连接从连接池DataSource获得 --&gt; &lt;bean id = &quot;txManager&quot; class = &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 最后创建 App.java，在包路径 com.learn.tx 下，代码如下: 123456789101112131415161718package com.learn.tx;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.learn.tx.service.AccountService;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); AccountService account = (AccountService) context.getBean(&quot;accountService&quot;); // Tom 向 Marry 转账1000 account.transfer(&quot;Tom&quot;, &quot;Marry&quot;, 1000); &#125;&#125; 运行： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.tx.App&quot; 程序发生异常，此时数据库会回滚，所以没有数据的变化，查看数据库： 现在让我们修改 AccountServiceImpl.java 中的代码 1234567891011121314151617181920package com.learn.tx.service;import com.learn.tx.dao.AccountDao;import com.learn.tx.service.AccountService;public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String outer, String inner, int money) &#123; accountDao.out(outer, money); int i = 1/0; accountDao.in(inner, money); &#125;&#125; 再修改 SpringBeans.xml 中的代码： 123456789101112131415161718192021222324252627&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context = &quot;http://www.springframework.org/schema/context&quot; xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id = &quot;dataSource&quot; class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost/transaction&quot;/&gt; &lt;property name = &quot;username&quot; value = &quot;root&quot;/&gt; &lt;property name = &quot;password&quot; value = &quot;&quot;/&gt; &lt;/bean&gt; &lt;bean id = &quot;accountDao&quot; class = &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;accountService&quot; class = &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt; &lt;property name = &quot;accountDao&quot; ref = &quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.tx.App&quot; 程序发生异常，由于没有加入事务，就算发生异常，还是会更新数据库的数据 Spring 申明式事务管理首先修改 SpringBeans.xml 中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context = &quot;http://www.springframework.org/schema/context&quot; xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; xmlns:tx = &quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id = &quot;dataSource&quot; class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost/transaction&quot;/&gt; &lt;property name = &quot;username&quot; value = &quot;root&quot;/&gt; &lt;property name = &quot;password&quot; value = &quot;&quot;/&gt; &lt;/bean&gt; &lt;bean id = &quot;accountDao&quot; class = &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;accountService&quot; class = &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt; &lt;property name = &quot;accountDao&quot; ref = &quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 1 事务管理器 --&gt; &lt;bean id = &quot;txManager&quot; class = &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2 将管理器交予 spring * transaction-manager 配置事务管理器 * proxy-target-class true ： 底层强制使用 cglib 代理 --&gt; &lt;tx:annotation-driven transaction-manager = &quot;txManager&quot; proxy-target-class = &quot;true&quot;/&gt;&lt;/beans&gt; 然后修改 AccountServiceImpl.java 中的代码 123456789101112131415161718192021222324252627282930package com.learn.tx.service;import javax.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.learn.tx.dao.AccountDao;import com.learn.tx.service.AccountService;@Transactional(propagation = Propagation.REQUIRED , isolation = Isolation.DEFAULT)@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService&#123; @Resource(name = &quot;accountDao&quot;) private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void transfer(String outer, String inner, int money) &#123; accountDao.out(outer, money); // int i = 1/0; accountDao.in(inner, money); &#125;&#125; 先将 AccountServiceImpl.java 中的 int i = 1/0 注释掉，以验证代码的正确性，然后运行： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.tx.App&quot; 查看数据库：数据发生了变化，说明在没有异常的时候代码是正确的，然后再将 int i = 1/0 取消注释，运行 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.tx.App&quot; 查看数据库：由于添加了事务，发生异常过后会回滚，所以数据没有变化。","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"事务管理","slug":"事务管理","permalink":"https://bawcat.wiki/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"}]},{"title":"Spring JDBC Template","slug":"java/spring/java-spring-jdbc-template-2020-06-26","date":"2020-06-25T18:05:38.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/25/java/spring/java-spring-jdbc-template-2020-06-26/","link":"","permalink":"https://bawcat.wiki/2020/06/25/java/spring/java-spring-jdbc-template-2020-06-26/","excerpt":"","text":"Spring JDBC TemplateSpring 框架中的 JDBC Template，有了 JDBC Template 就不需要自己再手动书写很长的 JDBC 代码来访问数据库了。 知识点 Spring JDBC Template 增 Spring JDBC Template 删 Spring JDBC Template 改 Spring JDBC Template 查 Spring JDBC 框架 Spring 框架核心的思想就是建立一个 Java 对象的大工厂，用户只要给工厂一个指令，工厂就能将用户需要的对象根据配置文件组装好返还给用户。用户需要做的许多工作则可以写成简单的配置文件。传统的使用 JDBC 的方法，有时候需要组合复杂的的 SQL 语句，还需要去拼接，稍不注意空格、引号，都会导致错误。Spring Jdbc Template 正是为了减少上述的麻烦而设计出来的。它是对 JDBC 的一种封装，抽象我们常用的一些方法。Simple and Stupid 就是它的目标。 Spring Jdbc Template 使用 Spring 的注入功能，可以把 DataSource 注册到 JdbcTemplate 之中。JdbcTemplate 的全限定命名为 org.springframework.jdbc.core.JdbcTemplate。要使用 JdbcTemlate 还需一个 spring-tx 包，这个包包含了事务和异常控制。 JdbcTemplate 主要提供以下五类方法： execute 方法：可以用于执行任何 SQL 语句，一般用于执行 DDL 语句。 update 方法：用于执行新增、修改、删除等语句。 batchUpdate 方法：用于执行批处理相关语句。 queryForXXX 方法：用于执行查询相关语句。 call 方法：用于执行查询相关语句，执行存储过程、函数相关语句。 接下来我们就将依次看看 JdbcTemplate 中的常用方法，来实现对数据库的增删改查。 Spring JDBC Template 增为了方便，我们在这里新建一个数据库并取名 jdbc 用作本次编程。 1234create database jdbc;use jdbc;create tables student(id int,name varchat(20),age int);insert into student values(1,&#x27;admin&#x27;,18); 完成上面的sql 新建项目1mvn archetype:generate -DgroupId=com.learn.jdbc -DartifactId=springJdbc -DarchetypeArtifactId=maven-archetype-quickstart 修改 pom.xml 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.learn.jdbc&lt;/groupId&gt; &lt;artifactId&gt;springJdbc&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springJdbc&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。 编辑 SpringBeans.xml 文件如下： 12345678910111213141516171819202122&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context = &quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;bean id = &quot;dataSource&quot; class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost/jdbc&quot;/&gt; &lt;property name = &quot;username&quot; value = &quot;root&quot;/&gt; &lt;property name = &quot;password&quot; value = &quot;&quot;/&gt; &lt;/bean&gt; &lt;bean id = &quot;jdbcTemplate&quot; class = &quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意 上面的mysql 配置 一定要配置自己的 （如果你的环境和我不一样的话） 最后创建 App.java，在包路径 com.learn.jdbc 下，代码如下: 123456789101112131415161718package com.learn.jdbc;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;); String sql = &quot;insert into student values(?,?,?)&quot;; int count = jdbcTemplate.update(sql,new Object[]&#123;2,&quot;learn2&quot;,18&#125;); System.out.println(count); &#125;&#125; 运行程序： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.jdbc.App&quot; 然后我们去查看数据库 应该可以 查看 到数据库已经多了一条数据 Spring JDBC Template 删JdbcTemplate 删除数据还是通过调用 update() 方法实现的，修改 App.java 中的代码： 123456789101112131415161718package com.learn.jdbc;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;); String sql = &quot;delete from student where id=?&quot;; int count = jdbcTemplate.update(sql,2); System.out.println(count); &#125;&#125; 运行： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.jdbc.App&quot; 运行完毕之后 我们会发现,ID=2的数据已经被删除了. Spring JDBC Template 改JdbcTemplate 修改数据还是通过调用 update() 方法实现的，修改 App.java 中的代码： 123456789101112131415161718package com.learn.jdbc;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;); String sql = &quot;update student set name=?,age=? where id=?&quot;; int count = jdbcTemplate.update(sql,new Object[]&#123;&quot;learn1&quot;,20,1&#125;); System.out.println(count); &#125;&#125; 运行： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.jdbc.App&quot; Spring JDBC Template 查JdbcTemplate 查询数据可以通过 queryForObject 和 query 来实现，queryForObject 用于查询单条数据，query 用于查询多条语句。 查询单条语句首先创建包 com.learn.jdbc.entity，创建 Student.java，代码如下 1234567891011121314151617181920212223242526272829package com.learn.jdbc.entity;public class Student &#123; private int id; private String name; private int age; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 修改 App.java 中的代码： 1234567891011121314151617181920212223package com.learn.jdbc;import com.learn.jdbc.entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;); String sql = &quot;select * from student&quot;; RowMapper&lt;Student&gt; rowMapper = new BeanPropertyRowMapper&lt;Student&gt;(Student.class); Student student = jdbcTemplate.queryForObject(sql,rowMapper); System.out.println(student); &#125;&#125; 运行程序： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.jdbc.App&quot; 可以看到终端中已经打印出了查询到的数据 查询多条语句首先在 student 数据库中添加几条数据 修改 App.java 中的代码： 123456789101112131415161718192021222324252627package com.learn.jdbc;import com.learn.jdbc.entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.util.List;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); JdbcTemplate jdbcTemplate = (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;); String sql = &quot;select * from student&quot;; RowMapper&lt;Student&gt; rowMapper = new BeanPropertyRowMapper&lt;Student&gt;(Student.class); List&lt;Student&gt; students = jdbcTemplate.query(sql,rowMapper); for(Student student:students)&#123; System.out.println(student); &#125; &#125;&#125; 运行程序： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.jdbc.App&quot; 可以看到终端中已经打印了三条数据","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"JDBC","slug":"JDBC","permalink":"https://bawcat.wiki/tags/JDBC/"},{"name":"Templeate","slug":"Templeate","permalink":"https://bawcat.wiki/tags/Templeate/"}]},{"title":"Spring IOC 容器","slug":"java/spring/java-spring-IOC-contrion-2020-06-25","date":"2020-06-25T11:31:03.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/25/java/spring/java-spring-IOC-contrion-2020-06-25/","link":"","permalink":"https://bawcat.wiki/2020/06/25/java/spring/java-spring-IOC-contrion-2020-06-25/","excerpt":"","text":"Spring IOC 容器理论基础IoC 是什么Ioc，Inversion of Control，即“控制反转”。它不是什么技术，而是一种设计思想。在 Java 开发中，Ioc 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好 Ioc 呢？理解好 Ioc 的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： 谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 IoC 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象，还包括文件等）。 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计都是主动去创建相关对象然后再组合起来： 当有了 IoC/DI 的容器后，在客户端类中不再主动去创建这些对象了，如图： IoC 能做什么IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。 IoC 很好的体现了面向对象设计法则之一的好莱坞法则：“别找我们，我们找你”。即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC 和 DIDI，Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”。我们来深入分析一下： 谁依赖于谁：当然是某个容器管理对象依赖于 IoC 容器；“被注入对象的对象”依赖于“依赖对象”。 为什么需要依赖：容器管理对象需要 IoC 容器来提供对象需要的外部资源。 谁注入谁：很明显是 IoC 容器注入某个对象，也就是注入“依赖对象”。 注入了什么：就是注入某个对象所需要的外部资源，包括对象、资源、常量数据。 IoC 和 DI 有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。 IoC 容器IoC 容器就是具有依赖注入功能的容器，IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。 Spring IoC 容器如何知道哪些是它管理的对象呢？ 这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。 在 Spring Ioc 容器的代表就是 org.springframework.beans 包中的 BeanFactory 接口，BeanFactory 接口提供了 IoC 容器最基本功能；而 org.springframework.context 包下的 ApplicationContext 接口扩展了 BeanFactory，还提供了与 Spring AOP 集成、国际化处理、事件传播及提供不同层次的 context 实现，如针对 web 应用的 WebApplicationContext。简单说，BeanFactory 提供了 IoC 容器最基本功能，而 ApplicationContext 则增加了更多支持企业级功能支持。ApplicationContext 完全继承 BeanFactory，因而 BeanFactory 所具有的语义也适用于 ApplicationContext。 XmlBeanFactory：BeanFactory 实现，提供基本的 IoC 容器功能，可以从 classpat h 或文件系统等获取资源。123File file = new File(&quot;fileSystemConfig.xml&quot;);Resource resource = new FileSystemResource(file);BeanFactory beanFactory = new XmlBeanFactory(resource); 12Resource resource = new ClassPathResource(&quot;classpath.xml&quot;);BeanFactory beanFactory = new XmlBeanFactory(resource); ClassPathXmlApplicationContext：ApplicationContext 实现，从 classpath 获取配置文件。 1BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;classpath.xml&quot;); FileSystemXmlApplicationContext：ApplicationContext 实现，从文件系统获取配置文件。 1BeanFactory beanFactory = new FileSystemXmlApplicationContext(&quot;fileSystemConfig.xml&quot;); Spring 中 Bean 的定义及注入 ValueSpring 中，bean 的定义有三种方式： 基于 XML 的配置 基于注解的配置 基于 Java 类的配置 Bean 的注入有两种方式：基于构造函数的依赖注入和基于设值函数的依赖注入。 这里我们先给大家介绍第一种，基于 XML 的配置方法，这种方法在 Spring 中是最常见的 基于 XML 的配置方法基于 XML 的配置方法又分为三种写法：一般方法，缩写方法，pschema 方法。先看下面的 Bean：FileNameGenerator.java，其中包含两个 properties，name 和 type，我们向两个 properties 注入 value。 新建一个 Maven 项目，步骤如下： 12mvn archetype:generate -DgroupId=com.nobady.spring -DartifactId=bean -DarchetypeArtifactId=maven-archetype-quickstart 执行上述命令之后我们创建了一个 bean 的项目 然后切换工作区 修改 pom.xml 文件 12345678910111213141516171819202122232425262728293031323334&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.nobady.spring&lt;/groupId&gt; &lt;artifactId&gt;bean&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;bean&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 在 src/main/java 路径下，新建类：FileNameGenerator.java，所属包为：com.shiyanlou.spring.bean，内容为： 12345678910111213141516171819202122232425package com.shiyanlou.spring.bean;public class FileNameGenerator &#123; private String name; private String type; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; /* *打印文件名和文件类型的方法 */ public void printFileName() &#123; System.out.println(&quot;FileName &amp; FileType is : &quot;+name+&quot; &amp; &quot;+type); &#125;&#125; 我们先在 src/main/ 下新建一个 Folder，命名为 resources，接着在 src/main/resources 路径下新建 SpringBeans.xml 文件： 123456789101112131415161718192021&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--一般方法--&gt; &lt;bean id = &quot;FileNameGenerator&quot; class = &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt; &lt;property name = &quot;name&quot;&gt; &lt;value&gt;hehe&lt;/value&gt; &lt;/property&gt; &lt;property name = &quot;type&quot;&gt; &lt;value&gt;txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 另一重配置方法 缩写方法--&gt; &lt;!-- &lt;bean id = &quot;FileNameGenerator&quot; class = &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;ceshi&quot; /&gt; &lt;property name = &quot;type&quot; value = &quot;txt&quot; /&gt; &lt;/bean&gt; --&gt;&lt;/beans&gt; 第三种方法：pschema 方法。 123456789101112131415161718&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p = &quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--&lt;bean id = &quot;FileNameGenerator&quot; class = &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt; &lt;property name = &quot;name&quot;&gt; &lt;value&gt;study&lt;/value&gt; &lt;/property&gt; &lt;property name = &quot;type&quot;&gt; &lt;value&gt;txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;bean id = &quot;FileNameGenerator&quot; class = &quot;com.nobady.spring.bean.FileNameGenerator&quot; p:name = &quot;study&quot; p:type = &quot;txt&quot; /&gt;&lt;/beans&gt; 注意，这种方法需要在 bean 的配置文件 xml 中，加入声明。 1xmlns:p = &quot;http://www.springframework.org/schema/p&quot; 然后直接修改 App.java 123456789101112131415161718192021222324package com.nobady.spring;import com.nobady.spring.bean.FileNameGenerator;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Hello world! * */public class App&#123; private static ApplicationContext context; public static void main( String[] args ) &#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); FileNameGenerator obj = (FileNameGenerator) context.getBean(&quot;FileNameGenerator&quot;); obj.printFileName(); &#125;&#125; 然后打开终端开始执行 12mvn compilemvn exec:java -Dexec.mainClass=&quot;com.nobady.spring.App&quot; 基于注解的配置注解是为 Spring 容器提供 Bean 定义的信息，把 XML 定义的信息通过类注解描述出来。众所周知，Spring 容器三大要素：Bean 定义、Bean 实现类以及 Spring 框架。如果采用 XML 配置，Bean 定义和 Bean 实现类本身分离，而采用注解配置，Bean 定义在 Bean 实现类上注解就可以实现。以下先简单列举几个注解方式。 @Component被此注解标注的类将被 Spring 容器自动识别，自动生成 Bean 定义。即 123456packeage com.nobady.spring;@Component(&quot;Study&quot;)public class Study&#123;&#125; 与在 XML 中配置以下效果相同： 1&lt;bean id = &quot;shiyanlou&quot; class = &quot;com.shiyanlou.spring.shiyanlou&quot;&gt; 除此之外，Spring 有三个与 @Component 等效的注解： @Controller：对应表现层的 Bean，也就是 Action。 @Service：对应的是业务层 Bean。 @Repository：对应数据访问层 Bean。 @Autowired@Autowired 可以用来装配 bean，都可以写在字段上，或者方法上。使用 @Autowired，首先要在在 applicationContext.xml 中加入 。@Autowired 默认按类型装配，默认情况下要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false。例如： 123@Autowired()@Qualifier(&quot;studentDao&quot;)private StudentDao studentDao; @Configuration通过使用注释 @Configuration 告诉 Spring，这个 Class 是 Spring 的核心配置文件，并且通过使用注解 @Bean 定义 bean，举例说明 12345678910111213package com.nobady.spring.java_config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AppConfig &#123; @Bean(name = &quot;animal&quot;) public IAnimal getAnimal()&#123; return new Dog(); &#125;&#125; App.java 内容： 1234567891011121314151617package com.nobady.spring.java_config;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args) &#123; context = new AnnotationConfigApplicationContext(AppConfig.class); IAnimal obj = (IAnimal) context.getBean(&quot;animal&quot;); obj.makeSound(); &#125;&#125; 通过上面的 @Configuration 注解，相当于在 ApplicationContext.xml 文件中添加如下配置，使用了 @Configuration + @Bean 就不需要添加了： 1&lt;bean id = &quot;animal&quot; class = &quot;com.shiyanlou.spring.java_config.Dog&quot;&gt;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"https://bawcat.wiki/tags/IOC/"}]},{"title":"Spring Aop","slug":"java/spring/java-spring-aop-2020-06-22","date":"2020-06-21T18:09:08.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/06/21/java/spring/java-spring-aop-2020-06-22/","link":"","permalink":"https://bawcat.wiki/2020/06/21/java/spring/java-spring-aop-2020-06-22/","excerpt":"","text":"Spring Aop知识点 AOP（面向切面编程） AOP 通知 —— Advice Pointcut Advisor 自动创建 Proxy AspectJ 框架 Spring AOP 即 Aspect-oriented programming，面向切面编程，是作为面向对象编程的一种补充，专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题。简单地说，就是一个拦截器（interceptor）拦截一些处理过程。 例如，当一个 method 被执行，Spring AOP 能够劫持正在运行的 method，在 method 执行前或者后加入一些额外的功能。 在 Spring AOP 中，支持 4 种类型的通知（Advice）： Before advice - method 执行前通知。 After returning advice - method 返回一个结果后通知。 After throwing advice - method 抛出异常后通知。 Around advice - 环绕通知，结合了以上三种。 一个 Spring AOP 的实例下边这个例子解释 Spring AOP 怎样工作。首先一个简单的不使用 AOP 的例子。先创建一个简单的 Service，为了稍后演示，这个类中加了几个简单的打印 method。 创建一个 Maven 项目 SpringAop： 1mvn archetype:generate -DgroupId = com.learn.spring -DartifactId = SpringAop -DarchetypeArtifactId = maven-archetype-quickstart 添加 maven 依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.learn&lt;/groupId&gt; &lt;artifactId&gt;SpringAop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;SpringAop&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建类 CustomerService.java 如下： 12345678910111213141516171819202122232425262728package com.learn.spring.aop.advice;public class CustomerService &#123; private String name; private String url; public void setName(String name) &#123; this.name = name; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public void printName() &#123; System.out.println(&quot;Customer name : &quot; + this.name); &#125; public void printURL() &#123; System.out.println(&quot;Customer website : &quot; + this.url); &#125; public void printThrowException() &#123; throw new IllegalArgumentException(); &#125;&#125; 在 src/main/resources/ 下新建 xml 配置文件 SpringAOPAdvice.xml 如下： 123456789101112&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;learn&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;http://learn.com&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; App.java 编写如下： 12345678910111213141516171819202122232425package com.learn.spring.aop.advice;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; ApplicationContext appContext = new ClassPathXmlApplicationContext( new String[] &#123; &quot;SpringAOPAdvice.xml&quot; &#125;); CustomerService cust = (CustomerService) appContext.getBean(&quot;customerService&quot;); System.out.println(&quot;*************************&quot;); cust.printName(); System.out.println(&quot;*************************&quot;); cust.printURL(); System.out.println(&quot;*************************&quot;); try &#123; cust.printThrowException(); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 运行 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.spring.aop.advice.App&quot; 四种类型的通知（Advice）下面来介绍 4 种类型的通知（Advice）。 Before Advicemethod 运行前，将运行下面的代码。 HijackBeforeMethod.java 如下: 1234567891011121314package com.learn.spring.aop.advice;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;public class HijackBeforeMethod implements MethodBeforeAdvice &#123; public void before(Method arg0, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;HijackBeforeMethod : Before method hijacked!&quot;); &#125;&#125; 在配置文件中加入新的 bean 配置 HijackBeforeMethod，然后创建一个新的代理（proxy），命名为 customerServiceProxy。target 定义你想劫持哪个 bean；interceptorNames 定义想用哪个 class(advice) 劫持 target。ApringAOPAdvice.xml 如下： 12345678910111213141516171819202122&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;learn&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;http://learn.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackBeforeMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;hijackBeforeMethodBean&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 用 Spring proxy 之前，必须添加 CGLIB 类库，在之前的 pom.xml 文件中，已经添加到了其中，以下是 pom.xml 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.9&lt;/version&gt;&lt;/dependency&gt; App.java 如下 1234567891011121314151617181920212223242526272829package com.learn.spring.aop.advice;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; ApplicationContext appContext = new ClassPathXmlApplicationContext( new String[] &#123; &quot;SpringAOPAdvice.xml&quot; &#125;); CustomerService cust = (CustomerService) appContext.getBean(&quot;customerServiceProxy&quot;); System.out.println(&quot;使用Spring AOP 如下&quot;); System.out.println(&quot;*************************&quot;); cust.printName(); System.out.println(&quot;*************************&quot;); cust.printURL(); System.out.println(&quot;*************************&quot;); try &#123; cust.printThrowException(); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 运行： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.learn.spring.aop.advice.App&quot; 每一个 customerService 的 method 运行前，都将先执行 HijackBeforeMethod 的 before 方法。 After Returning Advice创建一个实现了接口 AfterReturningAdvice 的 class，method 运行后，直到返回结果后，才运行下边的代码，如果没有返回结果，将不运行切入的代码。 HijackAfterMethod.java 如下： 1234567891011package com.learn.spring.aop.advice;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;public class HijackAfterMethod implements AfterReturningAdvice &#123; public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;HijackAfterMethod : After method hijacked!&quot;); &#125;&#125; 修改 bean 配置文件，加入 hijackAfterMethodBean 配置，ApringAOPAdvice.xml 如下： 1234567891011121314151617181920212223&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobady&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobady.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackBeforeMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; /&gt; &lt;bean id = &quot;hijackAfterMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;hijackAfterMethodBean&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 现在再运行 App.java 后输出如下： 每一个 customerService 的 method 运行后，都将先执行 HijackAfterMethod 的 afterReturning 方法。 Afetr Throwing Advice创建一个实现了 ThrowsAdvice 接口的 class，劫持 IllegalArgumentException 异常，目标 method 运行时，抛出 IllegalArgumentException 异常后，运行切入的方法。HijackThrowExceptionMethod.java 如下： 1234567891011package com.learn.spring.aop.advice;import org.springframework.aop.ThrowsAdvice;public class HijackThrowExceptionMethod implements ThrowsAdvice &#123; public void afterThrowing(IllegalArgumentException e) throws Throwable &#123; System.out.println(&quot;HijackThrowException : Throw exception hijacked!&quot;); &#125;&#125; 修改 bean 配置文件，加入了 hijackThrowExceptionBean，ApringAOPAdvice.xml 如下： 123456789101112131415161718192021222324&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackBeforeMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; /&gt; &lt;bean id = &quot;hijackAfterMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; /&gt; &lt;bean id = &quot;hijackThrowExceptionBean&quot; class = &quot;com.learn.spring.aop.advice.HijackThrowExceptionMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;hijackThrowExceptionBean&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Around Advice结合了以上 3 种形式的 Advice，创建一个实现了接口 MethodInterceptor 的 class，你必须通过 methodInvocation.proceed() 来调用原来的方法，即通过调用 methodInvocation.proceed() 来调用 CustomerService 中的每一个方法，当然也可以不调用原方法 HijackAroundMethod.java 如下： 12345678910111213141516171819202122232425262728293031323334package com.learn.spring.aop.advice;import java.util.Arrays;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class HijackAroundMethod implements MethodInterceptor &#123; public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println(&quot;Method name : &quot; + methodInvocation.getMethod().getName()); System.out.println(&quot;Method arguments : &quot; + Arrays.toString(methodInvocation.getArguments())); // 相当于 MethodBeforeAdvice System.out.println(&quot;HijackAroundMethod : Before method hijacked!&quot;); try &#123; // 调用原方法，即调用 CustomerService 中的方法 Object result = methodInvocation.proceed(); // 相当于 AfterReturningAdvice System.out.println(&quot;HijackAroundMethod : After method hijacked!&quot;); return result; &#125; catch (IllegalArgumentException e) &#123; // 相当于 ThrowsAdvice System.out.println(&quot;HijackAroundMethod : Throw exception hijacked!&quot;); throw e; &#125; &#125;&#125; 修改 bean 配置文件，加入了 hijackAroundMethodBean，ApringAOPAdvice.xml 如下： 123456789101112131415161718192021222324&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackBeforeMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; /&gt; &lt;bean id = &quot;hijackAfterMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; /&gt; &lt;bean id = &quot;hijackThrowExceptionBean&quot; class = &quot;com.learn.spring.aop.advice.HijackThrowExceptionMethod&quot; /&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;hijackAroundMethodBean&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 改进上边的结果中，CustomerService.java 中，全部的 method 方法全部被拦截了，下边我们将展示怎样利用 Pointcuts 只拦截 printName()。 在 Spring AOP 中，有 3 个常用的概念，Advices、Pointcut、Advisor，解释如下： Advices：表示一个 method 执行前或执行后的动作。 Pointcut：表示根据 method 的名字或者正则表达式去拦截一个 method。 Advisor：Advice 和 Pointcut 组成的独立的单元，并且能够传给 proxy factory 对象。 我们可以用名字匹配法和正则表达式匹配法去匹配要拦截的 method。 Pointcut - Name match example通过 pointcut 和 advisor 拦截 printName() 方法。创建一个 NameMatchMethodPointcut 的 bean，将你想拦截的方法的名字 printName 注入到属性 mappedName，如下： 1234&lt;bean id = &quot;customerPointcut&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcut&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt;&lt;/bean&gt; 创建一个 DefaultPointcutAdvisor 的 advisor bean，将 pointcut 和 advice 关联起来。 12345&lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt; &lt;property name = &quot;pointcut&quot; ref = &quot;customerPointcut&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt;&lt;/bean&gt; 更改代理的 interceptorNames 值，将上边的 advisor（customerAdvisor）替代原来的 hijackAroundMethodBean。 1234567891011&lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 所有的配置文件如下： 12345678910111213141516171819202122232425262728293031&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;customerPointcut&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcut&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt; &lt;property name = &quot;pointcut&quot; ref = &quot;customerPointcut&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 再运行一下 App.java 运行结果显示，只拦截了 printName() 方法。 注意：以上配置中 pointcut 和 advisor 可以合并在一起配置，即不用单独配置 customerPointcut 和 customerAdvisor，只要配置 customerAdvisor 时 class 选择 NameMatchMethodPointcutAdvisor 如下： 1234&lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt;&lt;/bean&gt; 这样，整个配置文件如下： 1234567891011121314151617181920212223242526272829&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 实际上这种做法将 method 名字与具体的 advice 捆绑在一起，有悖于 Spring 松耦合理念，如果将 method 名字单独配置成 pointcut（切入点），advice 和 pointcut 的结合会更灵活，使一个 pointcut 可以和多个 advice 结合。 Pointcut - Regular exxpression match example你可以配置用正则表达式匹配需要拦截的 method，如下配置： 12345678&lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;patterns&quot;&gt; &lt;list&gt; &lt;value&gt;.*URL.*&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt;&lt;/bean&gt; 配置文件详情如下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;patterns&quot;&gt; &lt;list&gt; &lt;value&gt;.*URL.*&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 利用 BeanNameAutoProxyCreator 自动创建 proxy在前面两节的例子中，在配置文件中，我们必须手动为每一个需要 AOP 的 bean 创建 Proxy bean（ProxyFactoryBean）。 这不是一个好的体验，例如，我们想让 DAO 层的所有 bean 都支持 AOP，以便写 SQL 日志，那么必须手工创建很多的 ProxyFactoryBean，这样会直接导致 xml 配置文件内容成几何级的倍增，不利于 xml 配置维护。幸运的是，Spring 有两种方法，可以为你自动创建 proxy。 手工创建 ProxyFactoryBean 如下： 123456789101112131415161718192021222324252627&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerServiceProxy&quot; class = &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name = &quot;target&quot; ref = &quot;customerService&quot; /&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot; hijackAroundMethodBean &quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置完后要得到 customerServiceProxy，需要如下代码： 1CustomerService cust = (CustomerService) appContext.getBean(&quot;customerServiceProxy&quot;); 在自动模式中，我们需要创建 BeanNameAutoProxyCreator，将所有的 bean（通过名字或正则表达式匹配）和 advisor 形成一个独立的单元，SpringAOPAdvice.xml 配置如下： 12345678910111213141516171819202122232425262728293031&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name = &quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean class = &quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt; &lt;property name = &quot;beanNames&quot;&gt; &lt;list&gt; &lt;value&gt;*Service&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name = &quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;customerAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 以上配置中只要 bean 的 id 符合 *Service，就会自动创建 proxy，所以，可以用以下代码获得 proxy。 1CustomerService cust = (CustomerService) appContext.getBean(&quot;customerService&quot;); 利用 DefaultAdvisorAutoProxyCreator 创建 Proxy这种方式利用 DefaultAdvisorAutoProxyCreator 实现自动创建 Proxy，此种方式威力巨大，任何匹配 Advisor 的 bean，都会自动创建 Proxy 实现 AOP，所以慎用。 123456789101112131415161718192021&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;customerService&quot; class = &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;Nobody&quot; /&gt; &lt;property name =&quot;url&quot; value = &quot;Nobody.com&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;hijackAroundMethodBean&quot; class = &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; /&gt; &lt;bean id = &quot;customerAdvisor&quot; class = &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt; &lt;property name = &quot;mappedName&quot; value = &quot;printName&quot; /&gt; &lt;property name = &quot;advice&quot; ref = &quot;hijackAroundMethodBean&quot; /&gt; &lt;/bean&gt; &lt;bean class = &quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; /&gt;&lt;/beans&gt; 以上例子中，xml 中任何 bean，只要有 method 名字为 printName，使用以下代码时，都会自动创建 Proxy，来支持 AOP。 1CustomerService cust = (CustomerService) appContext.getBean(&quot;customerService&quot;); 结果同上。 使用 AspectJ 框架实现 Spring AOPAspectJ 是基于注释（Annotation）的，所以需要 JDK5.0 以上的支持。 AspectJ 支持的注解类型如下： @Before @After @AfterReturning @AfterThrowing @Around 准备工作首先定义一个简单的 bean，CustomerBo 实现了接口 ICustomerBo。ICustomerBo.java 如下： 123456789package com.learn.spring.aop.aspectj;public interface ICustomerBo &#123; void addCustomer(); void deleteCustomer(); String AddCustomerReturnValue(); void addCustomerThrowException() throws Exception; void addCustomerAround(String name);&#125; CustomerBo.java 如下： 12345678910111213141516171819202122232425262728package com.learn.spring.aop.aspectj;public class CustomerBo implements ICustomerBo &#123; public void addCustomer() &#123; System.out.println(&quot;addCustomer() is running ...&quot;); &#125; public void deleteCustomer() &#123; System.out.println(&quot;deleteCustomer() is running ...&quot;); &#125; public String AddCustomerReturnValue() &#123; System.out.println(&quot;AddCustomerReturnValue() is running ...&quot;); return &quot;abc&quot;; &#125; public void addCustomerThrowException() throws Exception &#123; System.out.println(&quot;addCustomerThrowException() is running ...&quot;); throw new Exception(&quot;Generic Error&quot;); &#125; public void addCustomerAround(String name) &#123; System.out.println(&quot;addCustomerAround() is running ,args:&quot;+name); &#125;&#125; 简单的 AspectJ，Advice 和 Pointcut 结合在一起首先没有引入 Aspect 之前，Advice 和 Pointcut 是混在一起的，步骤如下： 创建一个 Aspect 类 配置 Spring 配置文件 由于接下来要使用 aspectj 的 jar 包，首先添加 maven 依赖。需要在 pom.xml 添加： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt; 注:我们在新建项目时就已经添加了这些依赖，这里写出来只是知道这些包的作用 创建 AspectJ 类，LoggingAspect.java 如下： 123456789101112131415161718192021222324package com.learn.spring.aop.aspectj;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class LoggingAspect &#123; @Before(&quot;execution(public * com.learn.spring.aop.aspectj.CustomerBo.addCustomer(..))&quot;) public void logBefore(JoinPoint joinPoint)&#123; System.out.println(&quot;logBefore() is running ...&quot;); System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName()); System.out.println(&quot;**********&quot;); &#125; @After(&quot;execution(public * com.learn.spring.aop.aspectj.CustomerBo.deleteCustomer(..))&quot;) public void logAfter(JoinPoint joinPoint)&#123; System.out.println(&quot;logAfter() is running ...&quot;); System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName()); System.out.println(&quot;**********&quot;); &#125;&#125; 解释： 必须使用 @Aspect 在 LoggingAspect 声明之前注释，以便被框架扫描到。 此例 Advice 和 Pointcut 结合在一起，类中的具体方法 logBefore 和 logAfter 即为 Advice，是要注入的代码，Advice 方法上的表达式为 Pointcut 表达式，即定义了切入点，上例中 @Before 注释的表达式代表执行 CustomerBo.addCustomer 方法时注入 logBefore 代码。 在 LoggingAspect 方法上加入 @Before 或者 @After 等注释。 execution(public * com.learn.spring.aop.aspectj.CustomerBo.addCustomer(..)) 是 Aspect 的切入点表达式，其中，* 代表返回类型，后边的就要定义要拦截的方法名。这里写的的是 com.learn.spring.aop.aspectj.CustomerBo.addCustomer 表示拦截 CustomerBo 中的 addCustomer 方法，(..) 代表参数匹配，此处表示匹配任意数量的参数，可以是 0 个也可以是多个，如果你确定这个方法不需要使用参数可以直接用 ()，还可以使用 (*) 来匹配一个任意类型的参数，还可以使用 (* , String )，这样代表匹配两个参数，第二个参数必须是 String 类型的参数。 AspectJ 表达式，可以对整个包定义，例如 execution ( * com.learn.spring.aop.aspectj.*.*(..)) 表示切入点是 com.learn.spring.aop.aspectj 包中的任意一个类的任意方法，具体的表达式请自行搜索。 配置 SpringAopAspectj.xml 文件，如下： 12345678910111213141516&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id = &quot;customerBo&quot; class = &quot;com.learn.spring.aop.aspectj.CustomerBo&quot;/&gt; &lt;bean id = &quot;logAspect&quot; class = &quot;com.learn.spring.aop.aspectj.LoggingAspect&quot; /&gt;&lt;/beans&gt; &lt;aop:aspectj-autoproxy/&gt; 启动 AspectJ 支持，这样 Spring 会自动寻找用 @Aspect 注释过的类，其他的配置与 Spring 普通 bean 配置一样。 执行 App.java 如下： 1234567891011121314151617181920package com.learn.spring.aop.aspectj;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; ApplicationContext appContext = new ClassPathXmlApplicationContext(new String[] &#123; &quot;SpringAOPAspectJ.xml&quot; &#125;); ICustomerBo customer = (ICustomerBo)appContext.getBean(&quot;customerBo&quot;); customer.addCustomer(); System.out.println(&quot;-------------------------------------------&quot;); customer.deleteCustomer(); &#125;&#125; 控制台输入命令： 12mvn clean compilemvn exec:java -Dexec.mainClass = &quot;com.learn.spring.aop.aspectj.App&quot; 将 Advicd 和 Pointcut 分开需要三步： 创建 Pointcut 创建 Advice 配置 Spring 的配置文件 定义 Pointcut，创建 PointcutsDefinition.java，如下： 123456789101112package com.learn.spring.aop.aspectj;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class PointcutsDefinition &#123; @Pointcut(&quot;execution(* com.learn.spring.aop.aspectj.CustomerBo.*(..))&quot;) public void customerLog() &#123; &#125;&#125; 解释： 类声明前加入 @Aspect 注释，以便被框架扫描到。 @Pointcut 是切入点声明，指定需要注入的代码的位置，如上例中指定切入点为 CustomerBo 类中的所有方法，在实际业务中往往是指定切入点到一个逻辑层，例如 execution (* com.learn.spring.aop.aspectj.*.*(..)），表示 aop 切入点为 aspectj 包中所有类的所有方法，具体的表达式后边会有介绍。 方法 customerLog 是一个签名，在 Advice 中可以用此签名代替切入点表达式，所以不需要在方法体内编写实际代码，只起到助记功能，例如此处代表操作 CustomerBo 类时需要的切入点。创建 LoggingAspect.java： 123456789101112131415161718192021222324package com.learn.spring.aop.aspectj;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class LoggingAspect &#123; @Before(&quot;com.learn.spring.aop.aspectj.PointcutsDefinition.customerLog()&quot;) public void logBefore(JoinPoint joinPoint)&#123; System.out.println(&quot;logBefore() is running ...&quot;); System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName()); System.out.println(&quot;**********&quot;); &#125; @After(&quot;com.learn.spring.aop.aspectj.PointcutsDefinition.customerLog()&quot;) public void logAfter(JoinPoint joinPoint)&#123; System.out.println(&quot;logAfter() is running ...&quot;); System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName()); System.out.println(&quot;**********&quot;); &#125;&#125; 解释： @Before 和 @After 使用 PointcutsDefinition 中的方法签名代替 Pointcut 表达式找到相应的切入点，即通过签名找到 PointcutsDefinition 中 customerLog 签名上的 Pointcut 表达式，表达式指定切入点为 CustomerBo 类中的所有方法。所以此例中 Advice 类 LoggingAspect，为 CustomerBo 中的所有方法都加入了 @Before 和 @After 两种类型的两种操作。 对于 PointcutsDefinition 来说，主要职责是定义 Pointcut，可以在其中定义多个切入点，并且可以用便于记忆的方法签名进行定义。 单独定义 Pointcut 的好处是，一是通过使用有意义的方法名，而不是难读的 Pointcut 表达式，使代码更加直观；二是 Pointcut 可以实现共享，被多个 Advice 直接调用。若有多个 Advice 调用某个 Pointcut，而这个 Pointcut 的表达式在将来有改变时，只需修改一个地方，维护更加方便。 配置 Spring 配置文件。 配置 SpringAOPAspectJ.xml 文件，如下： 123456789101112131415&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop = &quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id = &quot;customerBo&quot; class = &quot;com.learn.spring.aop.aspectj.CustomerBo&quot;/&gt; &lt;bean id = &quot;logAspect&quot; class = &quot;com.learn.spring.aop.aspectj.LoggingAspect&quot; /&gt;&lt;/beans&gt;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://bawcat.wiki/tags/AOP/"}]},{"title":"pcntl 多进程扩展探寻","slug":"php/php-pcntl-多进程扩展探寻-2020-06-12","date":"2020-06-12T15:39:44.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/06/12/php/php-pcntl-多进程扩展探寻-2020-06-12/","link":"","permalink":"https://bawcat.wiki/2020/06/12/php/php-pcntl-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%89%A9%E5%B1%95%E6%8E%A2%E5%AF%BB-2020-06-12/","excerpt":"","text":"php 实现 并发-进程控制 pcntlPCNTL 是 PHP 中的一组进程控制函数，可以用来 fork（创建）进程，传输控制信号等。 在PHP中，进程控制支持默认关闭。编译时通过 –enable-pcntl 配置选项可以使 PHP的 CGI 或 CLI 版本打开进程控制支持（但是注意不要在 web 服务器中用 PCNTL，会导致不可预料的问题）。仅 Unix 类系统支持 PCNTL 模块。 PCNTL 原理简单示例123456789101112131415&lt;?php//在当前进程当前位置产生分支（子进程）$pid = pcntl_fork();//父进程和子进程都会执行下面代码if ($pid == -1) &#123; //错误处理：创建子进程失败时返回-1. die(&#x27;could not fork&#x27;);&#125; else if ($pid) &#123; //父进程会得到子进程号，所以这里是父进程执行的逻辑 pcntl_wait($status); //等待子进程中断，防止子进程成为僵尸进程。&#125; else &#123; //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。&#125; 原理PCNTL 中的一系列函数，都对应操作系统中的函数，例如 pcntl_fork 就对应 Linux 系统中的 fork 函数。 每次在进程中调用 fork 函数时，操作系统会把进程完整的复制一份，作为这个进程的子进程。此时，两个进程的唯一区别就是 PID（进程ID）和 PPID（父进程ID）。根据 fork 返回值的不同可以判断当前是在父进程还是子进程中，从而可以有不同的处理逻辑。 为了保证系统资源利用率，必须防止出现僵尸进程（进程结束后未回收资源）或孤儿进程（父进程提前结束），可以通过 pcntl_wait 或 pcntl_waitpid 函数来监控子进程。 常用函数pcntl_fork在当前进程的当前位置产生分支（子进程），父进程和子进程都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程号，而子进程得到的是0。子进程仅PID（进程号） 和PPID（父进程号）与其父进程不同。 语法： int pcntl_fork ( void ) 返回值： 成功时，产生进程分支： 在父进程执行线程内返回产生的子进程的PID 在子进程执行线程内返回0 失败时，在 父进程上下文返回-1，不会创建子进程，并且会引发一个PHP错误。 pcntl_waitpid挂起当前进程的执行，直到参数pid指定的进程号对应的进程退出， 或接收到一个信号要求中断当前进程或调用一个信号处理函数。如果pid指定的子进程在此函数调用时已经退出（僵尸进程），此函数将立刻返回。 语法： int pcntl_waitpid ( int $pid , int &amp;$status [, int $options = 0 ] ) 返回值： 正常执行时返回退出的子进程进程号 发生错误时返回-1,如果提供了 WNOHANG作为option（wait3可用的系统）并且没有可用子进程时返回0。 pcntl_wait挂起当前进程，直到当前进程的一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。如果当前进程的一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将被释放。 pcntl_wait 等同于以-1作为参数pid 的值并且没有options参数来调用pcntl_waitpid() 函数。 示例多子进程实现并发多子进程时，需要注意避免僵尸进程，浪费资源： 12345678910111213141516171819202122232425262728293031323334&lt;?php$procNum = 3;for($i = 0; $i &lt; $procNum; $i++)&#123; $nPID = pcntl_fork();//创建子进程 if ($nPID == 0)&#123; work(); exit(0); &#125; elseif ($nPID == -1) &#123; die(&#x27;could not fork&#x27;); &#125; else &#123; // 如果在这里写 pcntl_wait($status)，则只有当前进程执行完毕后才会创建下一个进程 &#125;&#125;// 父进程会执行下面的代码，等待子进程执行完毕，避免僵尸进程$n = 0;while ($n &lt; $procNum) &#123; $nStatus = -1; $nPID = pcntl_wait($nStatus); if ($nPID &gt; 0) &#123; ++$n; &#125;&#125;function work()&#123; while(true)&#123; $nPID = pcntl_fork();//创建子进程 if ($nPID == 0)&#123; echo time(); exit(0); &#125; pcntl_waitpid($nPID,$nStatus); &#125;&#125; 进程状态： 123456789[root@VM_139_38_centos ~]# ps -ef | grep phproot 26355 24175 0 23:17 pts/0 00:00:00 php pcntl2.phproot 26356 26355 3 23:17 pts/0 00:00:00 php pcntl2.phproot 26357 26355 5 23:17 pts/0 00:00:00 php pcntl2.phproot 26358 26355 3 23:17 pts/0 00:00:00 php pcntl2.phproot 27078 24819 0 23:17 pts/4 00:00:00 grep --color=auto phproot 27079 26357 0 23:17 pts/0 00:00:00 php pcntl2.phproot 27080 26358 0 23:17 pts/0 00:00:00 php pcntl2.phproot 27081 26356 0 23:17 pts/0 00:00:00 php pcntl2.php 单子进程123456789101112131415&lt;?php$pid = pcntl_fork();if ($pid == -1) &#123; die(&#x27;could not fork&#x27;);&#125; elseif ($pid) &#123; pcntl_wait($status);&#125; else &#123; while(1) &#123; sleep(1); echo time(); &#125;&#125; https://github.com/aizuyan/daemon","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"Pcntl","slug":"PHP/Pcntl","permalink":"https://bawcat.wiki/categories/PHP/Pcntl/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"pcntl","slug":"pcntl","permalink":"https://bawcat.wiki/tags/pcntl/"},{"name":"进程管理","slug":"进程管理","permalink":"https://bawcat.wiki/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"PHP文件上传源码分析(RFC1867)","slug":"php/php-优秀文章-PHP文件上传源码分析-风雪之隅","date":"2020-04-09T13:17:12.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/04/09/php/php-优秀文章-PHP文件上传源码分析-风雪之隅/","link":"","permalink":"https://bawcat.wiki/2020/04/09/php/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/","excerpt":"","text":"PHP文件上传源码分析 @author 风雪之隅 本文地址: https://www.laruence.com/2009/09/26/1103.html 转载请注明出处 文件上传,一般分为俩种方式FTP和HTTP, 对于我们的互联网应用来说: FTP上传虽然传输稳定, 但是易用性和安全性都是个问题.你总不至于在用户要上传头像的时候告诉用户”请打开FTP客户端,上传文件到http://www.laruence.com/uploads/中, 并以2dk433423l.jpg命名”吧?而基于HTTP的上传,相对来说易用性和安全性上就比FTP要增强了很多.可以应用的上传方式有PUT, WEBDAV, 和RFC1867三种,本文将分析在PHP中,是如何基于RFC1867实现文件上传的. RFC1867RCF1867是Form-based File Upload in HTML标准协议, RFC1867标准对HTML做出了两处修改： 121 为input元素的type属性增加了一个file选项。2 input标记可以具有accept属性，该属性能够指定可被上传的文件类型或文件格式列表。 另外，本标准还定义了一种新的mime类型：multipart/form-data，以及当处理一个带有enctype=”multipart/form-data”并且/或含有的标记的表单时所应该采取的行为。 举例来说，当HTML想让用户能够上传一个或更多的文件时，他可以这么写： 1234567&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot; method=post&gt;选择文件:&lt;input name=&quot;userfile&quot; type=&quot;file&quot;&gt;文件描述:&lt;input name=&quot;description&quot; type=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; 这个表单, 大家一定不陌生, 而对于PHP来说, 它自己另外定义了一个默认表单元素MAX_FILE_SIZE,用户可以通过这个隐藏的表单元素来建议PHP最多只容许上传文件的大小,比如对于上面的例子, 我们希望用户上传的文件不能大于5000(5k)字节,那么可以如下写: 12345678&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot; method=post&gt;&lt;input type=&quot;hidden&quot; value=&quot;5000&quot; name=&quot;MAX_FILE_SIZE&quot;&gt; &lt;!--文件大小--&gt;选择文件:&lt;input name=&quot;userfile&quot; type=&quot;file&quot;&gt;文件描述:&lt;input name=&quot;description&quot; type=&quot;text&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; 姑且不说, 这个MAX_FILE_SIZE是多么的不可靠(所以基于浏览器的控制,都是不可靠的), 我们单纯从实现来介绍这个MAX_FILE_SIZE是如何起作用的.当用户选择了一个文件(laruence.txt), 并填写好文件描述(“laruence的个人介绍”), 点击上传后, 发生了什么呢? 表单提交在用户确定提交以后, 浏览器会根据用户选择的输入, 读取要上传的文件, 连同表单中的其他元素,组织成一定格式(如下)的数据发送到form中action属性指定的页面(在本例中是upload.php): 123456789101112131415161718//请求头POST /upload.php HTTP/1.0\\r\\n...Host: www.laruence.com\\r\\n...Content-length: xxxxx\\r\\n...Content-type: multipart/form-data, boundary=7d51863950254\\r\\n...\\r\\n\\r\\n//开始POST数据内容--7d51863950254content-disposition: form-data; name=&quot;description&quot;\\r\\nlaruence的个人介绍--7d51863950254content-disposition: form-data; name=&quot;userfile&quot;; filename=&quot;laruence.txt&quot;Content-Type: text/plain\\r\\n... laruence.txt 的内容...--7d51863950254-- 接下来, 就是服务器, 是如何处理这些数据了 接受上传当Web服务器, 此处假设为Apache(另外假设PHP是以module方式安装在Apache上的), 接受到用户的数据时,首先它根据HTTP请求头, 通过确定MIME TYPE为PHP类型, 然后经过一些过程以后(这部分,可以参看我之前的PHP Life Cycle ppt), 最终会把控制权交给PHP模块. 这个时候, PHP会调用sapi_activate来初始化一个请求,在这个过程中, 首先判断请求类型, 此时是POST, 从而去调用sapi_read_post_data, 通过Content-type, 找到rfc1867的处理函数rfc1867_post_handler,从而调用这个handler, 来分析POST来的数据. 关于rfc1867_post_handler这部分的源代码, 可以在mian/rfc1867.c找到,另外也可以参看我之前的深入理解PHP之文件上传, 其中也列出的源代码. 然后, PHP通过boundary, 对于每一个分段, 都通过检查, 是否同时定义了: 123name和filename属性(有名文件上传)没有定义name定义了filename(无名上传)定义了name没有定义filename(普通数据), 从而进行不同的处理. 12345678910111213141516171819202122232425262728293031323334if ((cd = php_mime_get_hdr_value(header, &quot;Content-Disposition&quot;))) &#123; char *pair=NULL; int end=0; while (isspace(*cd)) &#123; ++cd; &#125; while (*cd &amp;&amp; (pair = php_ap_getword(&amp;cd, &#x27;;&#x27;))) &#123; char *key=NULL, *word = pair; while (isspace(*cd)) &#123; ++cd; &#125; if (strchr(pair, &#x27;=&#x27;)) &#123; key = php_ap_getword(&amp;pair, &#x27;=&#x27;); if (!strcasecmp(key, &quot;name&quot;)) &#123; //获取name字段 if (param) &#123; efree(param); &#125; param = php_ap_getword_conf(&amp;pair TSRMLS_CC); &#125; else if (!strcasecmp(key, &quot;filename&quot;)) &#123; //获取filename字段 if (filename) &#123; efree(filename); &#125; filename = php_ap_getword_conf(&amp;pair TSRMLS_CC); &#125; &#125; if (key) &#123; efree(key); &#125; efree(word); &#125;&#125; 在这个过程中, PHP会去检查普通数据中,是否有MAX_FILE_SIZE. 12345678910111213/* Normal form variable, safe to read all data into memory */if (!filename &amp;&amp; param) &#123; unsigned int value_len; char *value = multipart_buffer_read_body(mbuff, &amp;value_len TSRMLS_CC); unsigned int new_val_len; /* Dummy variable */ ...... if (!strcasecmp(param, &quot;MAX_FILE_SIZE&quot;)) &#123; max_file_size = atol(value); &#125; efree(param); efree(value); continue;&#125; 有的话, 就会按照它的值来检查文件大小是否超出. 12345678910if (PG(upload_max_filesize) &gt; 0 &amp;&amp; total_bytes &gt; PG(upload_max_filesize)) &#123; cancel_upload = UPLOAD_ERROR_A;&#125; else if (max_file_size &amp;&amp; (total_bytes &gt; max_file_size)) &#123;#if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;MAX_FILE_SIZE of %ld bytes exceeded - file [%s=%s] not saved&quot;, max_file_size, param, filename);#endif cancel_upload = UPLOAD_ERROR_B;&#125; 通过上面的代码,我们也可以看到, 判断分为俩部, 第一部分是检查PHP默认的上传上限. 第二部分才是检查用户自定义的MAX_FILE_SIZE, 所以表单中定义的MAX_FILE_SIZE并不能超过PHP中设置的最大上传文件大小. 通过对name和filename的判断, 如果是文件上传, 会根据php的设置, 在文件上传目录中创建一个随机名字的临时文件: 12345678910if (!skip_upload) &#123; /* Handle file */ fd = php_open_temporary_fd_ex(PG(upload_tmp_dir), &quot;php&quot;, &amp;temp_filename, 1 TSRMLS_CC); if (fd==-1) &#123; sapi_module.sapi_error(E_WARNING, &quot;File upload error - unable to create a temporary file&quot;); cancel_upload = UPLOAD_ERROR_E; &#125;&#125; 返回文件句柄, 和临时随机文件名.之后, 还会有一些验证,比如文件名合法, name合法等.如果这些验证都通过, 那么就把内容读入, 写入到这个临时文件中. 123456789101112.....else if (blen &gt; 0) &#123; wlen = write(fd, buff, blen); //写入临时文件. if (wlen == -1) &#123; /* write failed */#if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;write() failed - %s&quot;, strerror(errno));#endif cancel_upload = UPLOAD_ERROR_F; &#125;&#125;.... 当循环读入完成后, 关闭临时文件句柄. 记录临时变量名: 12zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, strlen(temp_filename) + 1, &amp;temp_filename, sizeof(char *), NULL); 并且生成FILE变量, 这个时候, 如果是有名上传, 那么就会设置: 1$_FILES[&#x27;userfile&#x27;] //name=&quot;userfile&quot; 如果是无名上传, 则会使用tmp_name来设置: 1$_FILES[&#x27;tmp_name&#x27;] //无名上传 最终交给用户编写的upload.php处理.这时在upload.php中, 用户就可以通过move_uploaded_file来操作刚才生成的文件了~","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"优秀文章","slug":"PHP/优秀文章","permalink":"https://bawcat.wiki/categories/PHP/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"文件上传","slug":"文件上传","permalink":"https://bawcat.wiki/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"上传原理","slug":"上传原理","permalink":"https://bawcat.wiki/tags/%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"}]},{"title":"curl上传文件$_FILES为空问题","slug":"php/php-curl上传文件为空问题","date":"2020-04-09T13:05:29.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/04/09/php/php-curl上传文件为空问题/","link":"","permalink":"https://bawcat.wiki/2020/04/09/php/php-curl%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%BA%E7%A9%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":"php使用curl上传文件代码如下: 1234567891011121314151617&lt;?php/* http://devtest.com/upload.php:print_r($_POST);print_r($_FILES);*/$ch = curl_init();$data = array(&#x27;name&#x27; =&gt; &#x27;Foo&#x27;, &#x27;file&#x27; =&gt; &#x27;@/home/vagrant/test.png&#x27;);curl_setopt($ch, CURLOPT_URL, &#x27;http://devtest.com/load_file.php&#x27;);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $data);curl_exec($ch);?&gt; 接收代码: 123&lt;?phpprint_r($_POST);print_r($_FILES); 运行结果: 123456789php -f demo.phpArray([name] =&gt; Foo[file] =&gt; @/home/vagrant/test.png)Array() 这时我们发现 通过 curl 发送的文件 在另一边 $_FILES 接受不到 解决方法1：123456789101112131415161718&lt;?php/* http://devtest.com/upload.php:print_r($_POST);print_r($_FILES);*/$ch = curl_init();$data = array(&#x27;name&#x27; =&gt; &#x27;Foo&#x27;, &#x27;file&#x27; =&gt; &#x27;@/home/vagrant/test.png&#x27;);curl_setopt($ch, CURLOPT_URL, &#x27;http://devtest.com/load_file.php&#x27;);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);curl_setopt($ch, CURLOPT_POSTFIELDS, $data);curl_exec($ch);?&gt; 解决方法2: 5.6版本下 123456789101112131415161718&lt;?php/* http://devtest.com/upload.php:print_r($_POST);print_r($_FILES);*/$ch = curl_init();$data = array(&#x27;name&#x27; =&gt; &#x27;Foo&#x27;, &#x27;file&#x27; =&gt; new \\CURLFile(realpath(&#x27;/home/vagrant/test.png&#x27;)));curl_setopt($ch, CURLOPT_URL, &#x27;http://devtest.com/load_file.php&#x27;);curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);curl_setopt($ch, CURLOPT_POSTFIELDS, $data);curl_exec($ch);?&gt; 最后附上完整代码 使用时建议配上域名单独使用 1234567891011121314151617181920212223242526272829&lt;?phpif ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &#x27;POST&#x27;)&#123;// var_dump(file_get_contents(&#x27;php://input&#x27;));die; var_dump($_FILES); exit(1);&#125;elseif ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &#x27;GET&#x27;) &#123; $str = &lt;&lt;&lt;EOT&lt;center&gt;&lt;h1&gt;curl 文件上传测试demo&lt;/h1&gt;&lt;/center&gt;EOT; echo $str; exit(1);&#125;function ceshi()&#123; $ch = curl_init(); $data = array(&#x27;name&#x27; =&gt; &#x27;Foo&#x27;, &#x27;file&#x27; =&gt; new \\CURLFile(&#x27;/Users/higanbana/Desktop/GM8A78.png&#x27;)); curl_setopt($ch, CURLOPT_URL, &#x27;http://devtest.com/fileTest.php&#x27;); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); return curl_exec($ch);&#125;var_dump(ceshi()); // version php 7.3.11","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"$_FILES","slug":"FILES","permalink":"https://bawcat.wiki/tags/FILES/"}]},{"title":"深入理解PHP原理之文件上传（风雪之隅）","slug":"php/php-优秀文章-深入理解PHP原理之文件上传-风雪之隅","date":"2020-04-09T12:52:02.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/04/09/php/php-优秀文章-深入理解PHP原理之文件上传-风雪之隅/","link":"","permalink":"https://bawcat.wiki/2020/04/09/php/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8E%9F%E7%90%86%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/","excerpt":"","text":"深入理解PHP原理之文件上传 @author 风雪之隅 本文地址: https://www.laruence.com/2008/11/07/586.html 转载请注明出处 今天研究PHP注册POST/GET大变量的时候，看到了关于这块的一些东西，跟踪了半天，先记录下来，免得以后再如此麻烦的跟踪 处理器注册: 123456[mod_php5.c, mod_php5模块初始化] php_init_handler(server_rec *s, pool *p) -&gt;[main/SAPI.c]sapi_startup(&amp;apache_sapi_module) -&gt;[main/SAPI.c] sapi_globals_ctor(&amp;sapi_globals) -&gt;[main/php_content_types.c]php_setup_sapi_content_types(TSRMLS_C) -&gt;[main/php_content_types.c php_post_entries如下]sapi_register_post_entries(php_post_entries TSRMLS_CC) -&gt;[main/SAPI.c]sapi_register_post_entry(p TSRMLS_CC) 如下面的代码，共注册了俩个处理器，分别处理post数据和文件上传。 注1:G(http_globals)[TRACK_VARS_COOKIE]这部分,可以参看我较早前的 在PHP Module中获取$_GET/$_POST/$_COOKIE的方法研究 1234567891011121314151617[main/rfc1867.h] #define MULTIPART_CONTENT_TYPE &quot;multipart/form-data&quot; [main/php_content_types.h] #define DEFAULT_POST_CONTENT_TYPE &quot;application/x-www-form-urlencoded&quot; [main/SAPI.c] struct _sapi_post_entry &#123; char *content_type; uint content_type_len; void (*post_reader)(TSRMLS_D); void (*post_handler)(char *content_type_dup, void *arg TSRMLS_DC); &#125;; [main/php_content_types.c] static sapi_post_entry php_post_entries[] = &#123; &#123; DEFAULT_POST_CONTENT_TYPE, sizeof(DEFAULT_POST_CONTENT_TYPE)-1, sapi_read_standard_form_data, php_std_post_handler &#125;, &#123; MULTIPART_CONTENT_TYPE, sizeof(MULTIPART_CONTENT_TYPE)-1, NULL, rfc1867_post_handler &#125;, &#123; NULL, 0, NULL, NULL &#125;&#125;; 那么对于rfc1867_post_handler函数来说,我罗列出源码如下, 加了我的注释. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503SAPI_API SAPI_POST_HANDLER_FUNC(rfc1867_post_handler)&#123; char *boundary, *s=NULL, *boundary_end = NULL, *start_arr=NULL, *array_index=NULL; char *temp_filename=NULL, *lbuf=NULL, *abuf=NULL; int boundary_len=0, total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0; int max_file_size=0, skip_upload=0, anonindex=0, is_anonymous; zval *http_post_files=NULL; HashTable *uploaded_files=NULL;#if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING) int str_len = 0, num_vars = 0, num_vars_max = 2*10, *len_list = NULL; char **val_list = NULL;#endif zend_bool magic_quotes_gpc; multipart_buffer *mbuff; zval *array_ptr = (zval *) arg; int fd=-1; zend_llist header; void *event_extra_data = NULL; int llen = 0; //检查是否超出最大上传文件大小 if (SG(request_info).content_length &gt; SG(post_max_size)) &#123; sapi_module.sapi_error(E_WARNING, &quot;POST Content-Length of %ld bytes exceeds the limit of %ld bytes&quot;, SG(request_info).content_length, SG(post_max_size)); return; &#125; //取得上传文件的分隔符 boundary = strstr(content_type_dup, &quot;boundary&quot;); if (!boundary || !(boundary=strchr(boundary, &#x27;=&#x27;))) &#123; sapi_module.sapi_error(E_WARNING, &quot;Missing boundary in multipart/form-data POST data&quot;); return; &#125; boundary++; boundary_len = strlen(boundary); if (boundary[0] == &#x27;&quot;&#x27;) &#123; boundary++; boundary_end = strchr(boundary, &#x27;&quot;&#x27;); if (!boundary_end) &#123; sapi_module.sapi_error(E_WARNING, &quot;Invalid boundary in multipart/form-data POST data&quot;); return; &#125; &#125; else &#123; /* search for the end of the boundary */ boundary_end = strchr(boundary, &#x27;,&#x27;); &#125; if (boundary_end) &#123; boundary_end[0] = &#x27;&#x27;; boundary_len = boundary_end-boundary; &#125; /* Initialize the buffer */ if (!(mbuff = multipart_buffer_new(boundary, boundary_len))) &#123; sapi_module.sapi_error(E_WARNING, &quot;Unable to initialize the input buffer&quot;); return; &#125; //初始化$_FILE变量 zend_hash_init(&amp;PG(rfc1867_protected_variables), 5, NULL, NULL, 0); ALLOC_HASHTABLE(uploaded_files); zend_hash_init(uploaded_files, 5, NULL, (dtor_func_t) free_estring, 0); SG(rfc1867_uploaded_files) = uploaded_files; ALLOC_ZVAL(http_post_files); array_init(http_post_files); INIT_PZVAL(http_post_files); PG(http_globals)[TRACK_VARS_FILES] = http_post_files; //TRACK_VARS_FILE正是_FILE在php_core_globals.http_globals中的index (注1)#if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING) if (php_mb_encoding_translation(TSRMLS_C)) &#123; val_list = (char **)ecalloc(num_vars_max+2, sizeof(char *)); len_list = (int *)ecalloc(num_vars_max+2, sizeof(int)); &#125;#endif zend_llist_init(&amp;header, sizeof(mime_header_entry), (llist_dtor_func_t) php_free_hdr_entry, 0); if (php_rfc1867_callback != NULL) &#123; multipart_event_start event_start; event_start.content_length = SG(request_info).content_length; if (php_rfc1867_callback(MULTIPART_EVENT_START, &amp;event_start, &amp;event_extra_data TSRMLS_CC) == FAILURE) &#123; goto fileupload_done; &#125; &#125; while (!multipart_buffer_eof(mbuff TSRMLS_CC)) &#123; char buff[FILLUNIT]; char *cd=NULL,*param=NULL,*filename=NULL, *tmp=NULL; size_t blen=0, wlen=0; off_t offset; zend_llist_clean(&amp;header); if (!multipart_buffer_headers(mbuff, &amp;header TSRMLS_CC)) &#123; goto fileupload_done; &#125; if ((cd = php_mime_get_hdr_value(header, &quot;Content-Disposition&quot;))) &#123; char *pair=NULL; int end=0; while (isspace(*cd)) &#123; ++cd; &#125; while (*cd &amp;&amp; (pair = php_ap_getword(&amp;cd, &#x27;;&#x27;))) &#123; char *key=NULL, *word = pair; while (isspace(*cd)) &#123; ++cd; &#125; if (strchr(pair, &#x27;=&#x27;)) &#123; key = php_ap_getword(&amp;pair, &#x27;=&#x27;); if (!strcasecmp(key, &quot;name&quot;)) &#123; if (param) &#123; efree(param); &#125; param = php_ap_getword_conf(&amp;pair TSRMLS_CC); &#125; else if (!strcasecmp(key, &quot;filename&quot;)) &#123; if (filename) &#123; efree(filename); &#125; filename = php_ap_getword_conf(&amp;pair TSRMLS_CC); &#125; &#125; if (key) &#123; efree(key); &#125; efree(word); &#125; /* Normal form variable, safe to read all data into memory */ if (!filename &amp;&amp; param) &#123; unsigned int value_len; char *value = multipart_buffer_read_body(mbuff, &amp;value_len TSRMLS_CC); unsigned int new_val_len; /* Dummy variable */ if (!value) &#123; value = estrdup(&quot;&quot;); &#125; if (sapi_module.input_filter(PARSE_POST, param, &amp;value, value_len, &amp;new_val_len TSRMLS_CC)) &#123; if (php_rfc1867_callback != NULL) &#123; multipart_event_formdata event_formdata; size_t newlength = 0; event_formdata.post_bytes_processed = SG(read_post_bytes); event_formdata.name = param; event_formdata.value = &amp;value; event_formdata.length = new_val_len; event_formdata.newlength = &amp;newlength; if (php_rfc1867_callback(MULTIPART_EVENT_FORMDATA, &amp;event_formdata, &amp;event_extra_data TSRMLS_CC) == FAILURE) &#123; efree(param); efree(value); continue; &#125; new_val_len = newlength; &#125; #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING) if (php_mb_encoding_translation(TSRMLS_C)) &#123; php_mb_gpc_stack_variable(param, value, &amp;val_list, &amp;len_list, &amp;num_vars, &amp;num_vars_max TSRMLS_CC); &#125; else &#123; safe_php_register_variable(param, value, new_val_len, array_ptr, 0 TSRMLS_CC); &#125; #else safe_php_register_variable(param, value, new_val_len, array_ptr, 0 TSRMLS_CC); #endif &#125; else if (php_rfc1867_callback != NULL) &#123; multipart_event_formdata event_formdata; event_formdata.post_bytes_processed = SG(read_post_bytes); event_formdata.name = param; event_formdata.value = &amp;value; event_formdata.length = value_len; event_formdata.newlength = NULL; php_rfc1867_callback(MULTIPART_EVENT_FORMDATA, &amp;event_formdata, &amp;event_extra_data TSRMLS_CC); &#125; if (!strcasecmp(param, &quot;MAX_FILE_SIZE&quot;)) &#123; max_file_size = atol(value); &#125; efree(param); efree(value); continue; &#125; /* If file_uploads=off, skip the file part */ if (!PG(file_uploads)) &#123; skip_upload = 1; &#125; /* Return with an error if the posted data is garbled */ if (!param &amp;&amp; !filename) &#123; sapi_module.sapi_error(E_WARNING, &quot;File Upload Mime headers garbled&quot;); goto fileupload_done; &#125; if (!param) &#123; is_anonymous = 1; param = emalloc(MAX_SIZE_ANONNAME); snprintf(param, MAX_SIZE_ANONNAME, &quot;%u&quot;, anonindex++); &#125; else &#123; is_anonymous = 0; &#125; /* New Rule: never repair potential malicious user input */ if (!skip_upload) &#123; char *tmp = param; long c = 0; while (*tmp) &#123; if (*tmp == &#x27;[&#x27;) &#123; c++; &#125; else if (*tmp == &#x27;]&#x27;) &#123; c--; if (tmp[1] &amp;&amp; tmp[1] != &#x27;[&#x27;) &#123; skip_upload = 1; break; &#125; &#125; if (c &lt; 0) &#123; skip_upload = 1; break; &#125; tmp++; &#125; &#125; total_bytes = cancel_upload = 0; if (!skip_upload) &#123; /* Handle file */ fd = php_open_temporary_fd_ex(PG(upload_tmp_dir), &quot;php&quot;, &amp;temp_filename, 1 TSRMLS_CC); if (fd==-1) &#123; sapi_module.sapi_error(E_WARNING, &quot;File upload error - unable to create a temporary file&quot;); cancel_upload = UPLOAD_ERROR_E; &#125; &#125; if (!skip_upload &amp;&amp; php_rfc1867_callback != NULL) &#123; multipart_event_file_start event_file_start; event_file_start.post_bytes_processed = SG(read_post_bytes); event_file_start.name = param; event_file_start.filename = &amp;filename; if (php_rfc1867_callback(MULTIPART_EVENT_FILE_START, &amp;event_file_start, &amp;event_extra_data TSRMLS_CC) == FAILURE) &#123; if (temp_filename) &#123; if (cancel_upload != UPLOAD_ERROR_E) &#123; /* file creation failed */ close(fd); unlink(temp_filename); &#125; efree(temp_filename); &#125; temp_filename=&quot;&quot;; efree(param); efree(filename); continue; &#125; &#125; if (skip_upload) &#123; efree(param); efree(filename); continue; &#125; if(strlen(filename) == 0) &#123; #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;No file uploaded&quot;); #endif cancel_upload = UPLOAD_ERROR_D; &#125; offset = 0; end = 0; while (!cancel_upload &amp;&amp; (blen = multipart_buffer_read(mbuff, buff, sizeof(buff), &amp;end TSRMLS_CC))) &#123; if (php_rfc1867_callback != NULL) &#123; multipart_event_file_data event_file_data; event_file_data.post_bytes_processed = SG(read_post_bytes); event_file_data.offset = offset; event_file_data.data = buff; event_file_data.length = blen; event_file_data.newlength = &amp;blen; if (php_rfc1867_callback(MULTIPART_EVENT_FILE_DATA, &amp;event_file_data, &amp;event_extra_data TSRMLS_CC) == FAILURE) &#123; cancel_upload = UPLOAD_ERROR_X; continue; &#125; &#125; if (PG(upload_max_filesize) &gt; 0 &amp;&amp; total_bytes &gt; PG(upload_max_filesize)) &#123; #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;upload_max_filesize of %ld bytes exceeded - file [%s=%s] not saved&quot;, PG(upload_max_filesize), param, filename); #endif cancel_upload = UPLOAD_ERROR_A; &#125; else if (max_file_size &amp;&amp; (total_bytes &gt; max_file_size)) &#123; #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;MAX_FILE_SIZE of %ld bytes exceeded - file [%s=%s] not saved&quot;, max_file_size, param, filename); #endif cancel_upload = UPLOAD_ERROR_B; &#125; else if (blen &gt; 0) &#123; wlen = write(fd, buff, blen); if (wlen == -1) &#123; /* write failed */ #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;write() failed - %s&quot;, strerror(errno)); #endif cancel_upload = UPLOAD_ERROR_F; &#125; else if (wlen &lt; blen) &#123; #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;Only %d bytes were written, expected to write %d&quot;, wlen, blen); #endif cancel_upload = UPLOAD_ERROR_F; &#125; else &#123; total_bytes += wlen; &#125; offset += wlen; &#125; &#125; if (fd!=-1) &#123; /* may not be initialized if file could not be created */ close(fd); &#125; if (!cancel_upload &amp;&amp; !end) &#123; #if DEBUG_FILE_UPLOAD sapi_module.sapi_error(E_NOTICE, &quot;Missing mime boundary at the end of the data for file %s&quot;, strlen(filename) &gt; 0 ? filename : &quot;&quot;); #endif cancel_upload = UPLOAD_ERROR_C; &#125; #if DEBUG_FILE_UPLOAD if(strlen(filename) &gt; 0 &amp;&amp; total_bytes == 0 &amp;&amp; !cancel_upload) &#123; sapi_module.sapi_error(E_WARNING, &quot;Uploaded file size 0 - file [%s=%s] not saved&quot;, param, filename); cancel_upload = 5; &#125; #endif if (php_rfc1867_callback != NULL) &#123; multipart_event_file_end event_file_end; event_file_end.post_bytes_processed = SG(read_post_bytes); event_file_end.temp_filename = temp_filename; event_file_end.cancel_upload = cancel_upload; if (php_rfc1867_callback(MULTIPART_EVENT_FILE_END, &amp;event_file_end, &amp;event_extra_data TSRMLS_CC) == FAILURE) &#123; cancel_upload = UPLOAD_ERROR_X; &#125; &#125; if (cancel_upload) &#123; if (temp_filename) &#123; if (cancel_upload != UPLOAD_ERROR_E) &#123; /* file creation failed */ unlink(temp_filename); &#125; efree(temp_filename); &#125; temp_filename=&quot;&quot;; &#125; else &#123; zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, strlen(temp_filename) + 1, &amp;temp_filename, sizeof(char *), NULL); &#125; /* is_arr_upload is true when name of file upload field * ends in [.*] * start_arr is set to point to 1st [ */ is_arr_upload = (start_arr = strchr(param,&#x27;[&#x27;)) &amp;&amp; (param[strlen(param)-1] == &#x27;]&#x27;); if (is_arr_upload) &#123; array_len = strlen(start_arr); if (array_index) &#123; efree(array_index); &#125; array_index = estrndup(start_arr+1, array_len-2); &#125; /* Add $foo_name */ if (llen &lt; strlen(param) + MAX_SIZE_OF_INDEX + 1) &#123; llen = strlen(param); lbuf = (char *) safe_erealloc(lbuf, llen, 1, MAX_SIZE_OF_INDEX + 1); llen += MAX_SIZE_OF_INDEX + 1; &#125; if (is_arr_upload) &#123; if (abuf) efree(abuf); abuf = estrndup(param, strlen(param)-array_len); snprintf(lbuf, llen, &quot;%s_name[%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s_name&quot;, param); &#125; #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING) if (php_mb_encoding_translation(TSRMLS_C)) &#123; if (num_vars&gt;=num_vars_max)&#123; php_mb_gpc_realloc_buffer(&amp;val_list, &amp;len_list, &amp;num_vars_max, 1 TSRMLS_CC); &#125; val_list[num_vars] = filename; len_list[num_vars] = strlen(filename); num_vars++; if(php_mb_gpc_encoding_detector(val_list, len_list, num_vars, NULL TSRMLS_CC) == SUCCESS) &#123; str_len = strlen(filename); php_mb_gpc_encoding_converter(&amp;filename, &amp;str_len, 1, NULL, NULL TSRMLS_CC); &#125; s = php_mb_strrchr(filename, &#x27;\\&#x27; TSRMLS_CC); if ((tmp = php_mb_strrchr(filename, &#x27;/&#x27; TSRMLS_CC)) &gt; s) &#123; s = tmp; &#125; num_vars--; goto filedone; &#125; #endif /* The check should technically be needed for win32 systems only where * it is a valid path separator. However, IE in all it&#x27;s wisdom always sends * the full path of the file on the user&#x27;s filesystem, which means that unless * the user does basename() they get a bogus file name. Until IE&#x27;s user base drops * to nill or problem is fixed this code must remain enabled for all systems. */ s = strrchr(filename, &#x27;\\&#x27;); if ((tmp = strrchr(filename, &#x27;/&#x27;)) &gt; s) &#123; s = tmp; &#125; #ifdef PHP_WIN32 if (PG(magic_quotes_gpc)) &#123; s = s ? s : filename; tmp = strrchr(s, &#x27;&#x27;&#x27;); s = tmp &gt; s ? tmp : s; tmp = strrchr(s, &#x27;&quot;&#x27;); s = tmp &gt; s ? tmp : s; &#125; #endif #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING) filedone: #endif if (!is_anonymous) &#123; if (s &amp;&amp; s &gt; filename) &#123; safe_php_register_variable(lbuf, s+1, strlen(s+1), NULL, 0 TSRMLS_CC); &#125; else &#123; safe_php_register_variable(lbuf, filename, strlen(filename), NULL, 0 TSRMLS_CC); &#125; &#125; /* Add $foo[name] */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s[name][%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s[name]&quot;, param); &#125; if (s &amp;&amp; s &gt; filename) &#123; register_http_post_files_variable(lbuf, s+1, http_post_files, 0 TSRMLS_CC); &#125; else &#123; register_http_post_files_variable(lbuf, filename, http_post_files, 0 TSRMLS_CC); &#125; efree(filename); s = NULL; /* Possible Content-Type: */ if (cancel_upload || !(cd = php_mime_get_hdr_value(header, &quot;Content-Type&quot;))) &#123; cd = &quot;&quot;; &#125; else &#123; /* fix for Opera 6.01 */ s = strchr(cd, &#x27;;&#x27;); if (s != NULL) &#123; *s = &#x27;&#x27;; &#125; &#125; /* Add $foo_type */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s_type[%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s_type&quot;, param); &#125; if (!is_anonymous) &#123; safe_php_register_variable(lbuf, cd, strlen(cd), NULL, 0 TSRMLS_CC); &#125; /* Add $foo[type] */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s[type][%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s[type]&quot;, param); &#125; register_http_post_files_variable(lbuf, cd, http_post_files, 0 TSRMLS_CC); /* Restore Content-Type Header */ if (s != NULL) &#123; *s = &#x27;;&#x27;; &#125; s = &quot;&quot;; /* Initialize variables */ add_protected_variable(param TSRMLS_CC); magic_quotes_gpc = PG(magic_quotes_gpc); PG(magic_quotes_gpc) = 0; /* if param is of form xxx[.*] this will cut it to xxx */ if (!is_anonymous) &#123; safe_php_register_variable(param, temp_filename, strlen(temp_filename), NULL, 1 TSRMLS_CC); &#125; /* Add $foo[tmp_name] */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s[tmp_name][%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s[tmp_name]&quot;, param); &#125; add_protected_variable(lbuf TSRMLS_CC); register_http_post_files_variable(lbuf, temp_filename, http_post_files, 1 TSRMLS_CC); PG(magic_quotes_gpc) = magic_quotes_gpc; &#123; zval file_size, error_type; error_type.value.lval = cancel_upload; error_type.type = IS_LONG; /* Add $foo[error] */ if (cancel_upload) &#123; file_size.value.lval = 0; file_size.type = IS_LONG; &#125; else &#123; file_size.value.lval = total_bytes; file_size.type = IS_LONG; &#125; if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s[error][%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s[error]&quot;, param); &#125; register_http_post_files_variable_ex(lbuf, &amp;error_type, http_post_files, 0 TSRMLS_CC); /* Add $foo_size */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s_size[%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s_size&quot;, param); &#125; if (!is_anonymous) &#123; safe_php_register_variable_ex(lbuf, &amp;file_size, NULL, 0 TSRMLS_CC); &#125; /* Add $foo[size] */ if (is_arr_upload) &#123; snprintf(lbuf, llen, &quot;%s[size][%s]&quot;, abuf, array_index); &#125; else &#123; snprintf(lbuf, llen, &quot;%s[size]&quot;, param); &#125; register_http_post_files_variable_ex(lbuf, &amp;file_size, http_post_files, 0 TSRMLS_CC); &#125; efree(param); &#125; &#125; fileupload_done: if (php_rfc1867_callback != NULL) &#123; multipart_event_end event_end; event_end.post_bytes_processed = SG(read_post_bytes); php_rfc1867_callback(MULTIPART_EVENT_END, &amp;event_end, &amp;event_extra_data TSRMLS_CC); &#125; SAFE_RETURN;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"优秀文章","slug":"PHP/优秀文章","permalink":"https://bawcat.wiki/categories/PHP/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"文件上传","slug":"文件上传","permalink":"https://bawcat.wiki/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"上传原理","slug":"上传原理","permalink":"https://bawcat.wiki/tags/%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"}]},{"title":"Spring 松耦合","slug":"java/spring/java-spring-松耦合-2020-04-02","date":"2020-04-02T09:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/04/02/java/spring/java-spring-松耦合-2020-04-02/","link":"","permalink":"https://bawcat.wiki/2020/04/02/java/spring/java-spring-%E6%9D%BE%E8%80%A6%E5%90%88-2020-04-02/","excerpt":"","text":"Spring 松耦合 在电脑运算和系统设计中，一个松耦合的系统中的每一个组件对其他独立组件的定义所知甚少或一无所知。子范围包括类、接口、数据和服务之间的耦合。 松耦合是紧耦合的对立面。 优点和缺点 优点 松耦合系统中的组件能够被提供相同服务的替代实现所替换。松耦合系统中的组件不太受相同的平台、语言、操作系统或构建环境的约束。 缺点 如果系统在时间上是解耦的，那么也很难提供事务完整性；需要额外的协调协议。跨系统的数据复制提供了松耦合性（可用性），但是造成了维护一致性（数据同步）的问题。 松耦合的目的上一部分，我们已经创建了 Maven 项目，打印出了 HelloShiyanlou。为了方便，我使用上面的工程，pom.xml 文件一致，不必修改。下面，我们实验证明 Spring 的松耦合。假设项目需要输出到 CSV 或者 JSON。 松耦合代码编写IOutputGenerator.java创建 com.study.demo.loosely_coupled 包，新建一个 IOutputGenerator 接口，接口内容如下： 12345package com.study.demo.loosely_coupled;public interface IOutputGenerator&#123; public void generateOutput();&#125; CsvOutputGenerator.javaCSV 输出，实现了 IOutputGenerator 接口。同样的包路径，新建一个 CsvOutputGenerator.java 内容如下： 123456789package com.study.demo.loosely_coupled;public class CsvOutputGenerator implements IOutputGenerator&#123; public void generateOutput()&#123; System.out.println(&quot;Creating CsvOutputGenerator Output......&quot;); &#125;&#125; JsonOutputGenerator.javaJSON 输出，实现了 IOutputGenerator 接口。同样的包路径，新建一个 JsonOutputGenerator.java。 内容如下： 12345678910package com.study.demo.loosely_coupled;public class JsonOutputGenerator implements IOutputGenerator&#123; public void generateOutput()&#123; System.out.println(&quot;Creating JsonOutputGenerator Output......&quot;); &#125;&#125; 用 Spring 依赖注入调用输出用 Spring 的松耦合实现输出相应的格式。 首先在 com.shiyanlou.demo.loosely_coupled 包内创建一个需要用到输出的类 OutputHelper.java 内容如下： 12345678910111213package com.study.demo.loosely_coupled;public class OutputHelper&#123; IOutputGenerator outputGenerator; public void generateOutput()&#123; this.outputGenerator.generateOutput(); &#125; public void setOutputGenerator(IOutputGenerator outputGenerator)&#123; this.outputGenerator = outputGenerator; &#125;&#125; 创建一个 spring 配置文件此文件用于依赖管理 src/main/resources 下创建配置文件 Spring-Output.xml。 1234567891011&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;OutputHelper&quot; class = &quot;com.study.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name = &quot;outputGenerator&quot; ref = &quot;CsvOutputGenerator&quot; /&gt; &lt;/bean&gt; &lt;bean id = &quot;CsvOutputGenerator&quot; class = &quot;com.study.demo.loosely_coupled.CsvOutputGenerator&quot; /&gt; &lt;bean id = &quot;JsonOutputGenerator&quot; class = &quot;com.study.demo.loosely_coupled.JsonOutputGenerator&quot; /&gt;&lt;/beans&gt; App.java修改此文件用于通过 Spring 调用相应的 output 内容如下： 123456789101112131415161718package com.study.demo;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.study.demo.loosely_coupled.OutputHelper;public class App&#123; private static ApplicationContext context; public static void main( String[] args )&#123; context = new ClassPathXmlApplicationContext(new String[] &#123;&quot;Spring-Output.xml&quot;&#125;); OutputHelper output = (OutputHelper)context.getBean(&quot;OutputHelper&quot;); output.generateOutput(); &#125;&#125; 现在已经实现了松耦合，当需要输出改变时，不必修改任何代码 .java 文件，只要修改 Spring-Output.xml 文件 中的 ref 值，就可以实现输出不同的内容，不修改代码就减少了出错的可能性。 运行结果输入命令： 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.study.demo.App&quot; 注意：修改文件后都要使用 mvn compile 重新编译，然后再运行。 当 Spring-Output 如下时： 123&lt;bean id = &quot;OutputHelper&quot; class = &quot;com.study.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name = &quot;outputGenerator&quot; ref = &quot;JsonOutputGenerator&quot; /&gt;&lt;/bean&gt; 输出 结果 又如何？？","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"}]},{"title":"Spring","slug":"java/spring/java-spring-helloworld-2020-04-01","date":"2020-04-01T09:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/04/01/java/spring/java-spring-helloworld-2020-04-01/","link":"","permalink":"https://bawcat.wiki/2020/04/01/java/spring/java-spring-helloworld-2020-04-01/","excerpt":"","text":"Spring什么是 Spring ? Spring 是一个容器，通过反转控制（IoC）和依赖注入（DI）来实现高内聚、低耦合的应用。除此之外它可以整合很多第三方框架，它还提供面向切面编程（AOP）的能力，对数据库事务的管理尤其方便 Spring 是什么?Spring 是一个开源的轻量级 Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。 Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 Web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（C/S 架构）应用程序还是 JAVA EE（B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？ Spring 能帮我们做什么 ?Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署。而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要修改配置文件即可，无需重新编译。 Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用。 像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。 反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。 Spring 能非常简单的帮我们管理数据库事务在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊。如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。 除以上之外，Spring 还可以 与第三方数据库访问框架（如 Hibernate、JPA）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。 与第三方 Web（如 Struts、JSF）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 Web 层搭建。 与 Java EE（如 Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring 的优点关键概念 应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。 框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。 非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。 轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 POJO：Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 控制反转：即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。 Bean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。 Spring 的优点 非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。 AOP：AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），_即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术_。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。 简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。 JDBC 抽象及 ORM（对象关系映射）框架支持：Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。灵活的 Web 层支持：Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。 简化各种技术集成：提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。 Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。 如何学好 Spring要学好 Spring，首先要明确 Spring 是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用 Spring 了。Spring 核心是 IoC 容器，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。理解好 IoC 后，接下来是面向切面编程（AOP），首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，学起来就更加轻松了。 核心容器：包括 Core、Beans、Context、EL 模块 Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。 Beans 模块：提供了框架的基础部分，包括控制反转（IOC）和依赖注入（DI）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程。所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。 Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。核心接口是 ApplicationContext。EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。 AOP、Aspects 模块 AOP 模块：Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各专其职，降低业务逻辑和通用功能的耦合。 Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。数据访问/集成模块：该模块包括了 JDBC、ORM、OXM、JMS 和事务管理。 事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。 JDBC 模块：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。 ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate、JPA、MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。 OXM 模块：提供了一个对 Object/XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象，Object/XML 映射实现包括 JAXB、Castor、XMLBeans 和 XStream。 JMS 模块：用于 JMS（Java Messaging Service），提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS。JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Web/Remoting 模块：Web/Remoting 模块包含了 Web、Web-Servlet、Web-Struts、Web-Porlet 模块。Web 模块：提供了基础的 Web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（RMI、Hessian、Burlap）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。 Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。 Web-Struts 模块：提供了与 Struts 无缝集成，Struts 1.x 和 Struts 2.x 都支持。 Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。 典型应用场景Spring 可以应用到许多场景，从最简单的标准 Java SE 程序到企业级应用程序都能使用 Spring 来构建。以下介绍几个比较流行的应用场景： 典型 Web 应用程序应用场景： 远程访问应用场景 EJB 应用场景： Hello World( Hello Spring )Maven 简介在项目开始之前，我们先来了解一下 Maven 相关知识。 Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。 在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时能够创建报表，检查、构建和测试自动化设置。 Maven 提供了开发人员的方式来管理： Builds Documentation Reporting Dependencies SCMs Releases Distribution mailing list 概括地说，Maven 简化和标准化项目建设过程，处理编译，分配，文档，团队协作和其他任务的无缝连接。Maven 增加可重用性并负责建立相关的任务。 我们使用的是 maven 所以请本地安装好 maven 导入 Maven 项目所需的包 1wget http://labfile.oss.aliyuncs.com/courses/578/m2.zip 解压完成后，将生成的 .m2 文件夹移动到 maven 本地仓库 接下来就可以使用 maven 创建项目了 1234mvn archetype:generate \\ -DgroupId = com.study.demo \\ -DartifactId = springExample \\ -DarchetypeArtifactId = maven-archetype-quickstart 在终端如果执行错误，请手动输入 一行执行 参数说明： -DgourpId: 组织名，公司网址的反写 + 项目名称 -DartifactId: 项目名-模块名 -DarchetypeArtifactId: 指定 ArchetypeId，maven-archetype-quickstart，创建一个简单的 Java 应用 -DinteractiveMode: 是否使用交互模式。 输入命令之后，maven 会提示我们输入版本号，这里可以直接定义版本号也可以直接回车，接着 maven 会提示当前要创建项目的基本信息，输入 y 然后回车确认 我们也可以 加上交互模式 false 这样就不用输入版本号 当你执行完 上面的 maven 命令 创建完成项目之后。 用你的编辑器 打开 生成的文件夹 注意这里一定要重新进入文件夹，不然无法识别工作区 然后 修改 pom.xml 添加依赖 关于 pom.xml 文件 另作文件描述 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.study.demo&lt;/groupId&gt; &lt;artifactId&gt;springExample&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springExample&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 实际上，Maven 使用以上配置来唯一指定一个项目。引用一个库文件也是通过以上配置来确定所引用的库及其版本号，比如本例引用 Spring 库版本为 5.1.1.RELEASE。 创建 HelloWorld.java然后 在你的 工作区内的 src/main/java/com/study/demo 文件内创建一个 helloworld 文件夹 然后 创建 HelloWorld.java 文件 编辑 HelloWorld.java 文件如下： 1234567891011121314package com.study.demo.helloworld;public class HelloWorld&#123; private String name; public void setName(String n)&#123; this.name = n; &#125; public void printHello()&#123; System.out.println(&quot;The first Spring :hello&quot;+name); &#125;&#125; 创建 SpringBeans.xml我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。 编辑 SpringBeans.xml 文件如下： 12345678&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;&lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id = &quot;helloBean&quot; class = &quot;com.study.demo.helloworld.HelloWorld&quot;&gt; &lt;property name = &quot;name&quot; value = &quot;maven&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试 App在 com.study.demo 包下创建一个类，类名为 App: 12345678910111213141516package com.study.demo;import com.study.demo.helloworld.HelloWorld;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App&#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;); HelloWorld obj = (HelloWorld) context.getBean(&quot;helloBean&quot;); obj.printHello(); &#125;&#125; 作为 java application 运行首先打开终端，使用 mvn compile 编译 java 程序，然后使用 12mvn compilemvn exec:java -Dexec.mainClass = &quot;com.study.demo.App&quot; 这里用 maven 执行 java 程序，-Dexec.mainClass 参数指定 main 方法所在类。 运行成功后 你就可以看到编译结果","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"}]},{"title":"Java 文件操作","slug":"java/基础教学/文件操作","date":"2020-03-23T16:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/03/23/java/基础教学/文件操作/","link":"","permalink":"https://bawcat.wiki/2020/03/23/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Java 文件操作 在平时编写程序的时候，经常会对文件进行操作，比如文件的赋值，重命名，删除等。接下来学习使用 Java 操作文件。 拷贝可以使用 Files 工具类的 copy(Path source,Path target,CopyOption… options) 拷贝文件或者目录。如果目标文件存在，那么赋值将失败，除非我们在 options 中指定了 REPLACE_EXISTING 属性。当该命令复制目录时，如果目录中已经有了文件，目录中的文件将不会被复制。CopyOption 参数支持以下 StandardCopyOption 和 LinkOption 枚举： REPLACE_EXISTING：即使目标文件已存在，也执行复制。如果目标是符号链接，则复制链接本身（而不是链接的目标）。如果目标是非空目录，则复制将失败并显示 FileAlreadyExistsException 异常。 COPY_ATTRIBUTES：将与文件关联的文件属性复制到目标文件。支持的确切 - 文件属性是文件系统和平台相关的，但 last-modified-time 跨平台支持并复制到目标文件。 NOFOLLOW_LINKS：表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）。 编程实例新建文件 1.txt。 在 项目目录下新建源代码文件 CopyDemo.java。 123456789101112131415import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class CopyDemo &#123; public static void main(String[] args) &#123; try &#123; //被拷贝的文件一定要存在 否则会抛出异常 这里的1.txt一定要存在 Files.copy(Paths.get(&quot;/home/project/1.txt&quot;), Paths.get(&quot;/home/project/2.txt&quot;), StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译运行: 12$ javac CopyDemo.java$ java CopyDemo 查看目录，如果没有报错，那么可以看到 1.txt 已经被复制了一份，叫做 2.txt。(如果 1.txt 里面输入了内容 2.txt 也会存在) 移动和重命名Files 类的 move(Path, Path, CopyOption… options) 方法移动文件或者目录，同样目标目录存在，那么比如使用REPLACE_EXISTING。 options 参数支持 StandardCopyOption 的以下枚举： REPLACE_EXISTING：即使目标文件已存在，也执行移动。如果目标是符号链接，则替换符号链接，但它指向的内容不受影响。 ATOMIC_MOVE：将移动作为原子文件操作执行。如果文件系统不支持原子移动，则抛出异常。使用，ATOMIC_MOVE 您可以将文件移动到目录中，并保证观察目录的任何进程都可以访问完整的文件。 move 方法除了可以移动之外，也可以用与重命名。 编程实例新建源代码文件 MoveDemo.java 1234567891011121314151617import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class MoveDemo &#123; public static void main(String[] args) &#123; try &#123; //将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可 Files.move(Paths.get(&quot;/home/project/1.txt&quot;), Paths.get(&quot;/home/project/3.txt&quot;), StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译运行： 12$ javac MoveDemo.java$ java MoveDemo 查看目录结构，可以看到之前的 1.txt 已经变成了 3.txt 删除可以通过 Files 的 delete(Path path) 方法或者 deleteIfExists(Path path) 方法删除文件。 编程实例新建源代码文件 DeleteDemo.java： 123456789101112131415161718192021import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class DeleteDemo &#123; public static void main(String[] args) &#123; try &#123; //删除文件，文件必须存在，否则抛出异常 Files.delete(Paths.get(&quot;/home/project/3.txt&quot;)); //删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false System.out.println(Files.deleteIfExists(Paths.get(&quot;/home/project/3.txt&quot;))); //或者使用File类的delete方法 File file = new File(&quot;/home/project/2.txt&quot;); System.out.println(file.delete()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译运行: 1234$ javac DeleteDemo.java$ java DeleteDemofalsetrue 再次查看文件目录，2.txt 、3.txt 已经不存在了。 文件属性Java 使用 File 类表示文件或者目录，可以通过 File 类获取文件或者目录的相关属性。 编程实例新建源代码文件FileInfo.java 12345678910111213141516171819import java.io.File;import java.util.Arrays;public class FileInfo &#123; public static void main(String[] args) &#123; File file = new File(&quot;/home/project&quot;); System.out.println(&quot;文件或者目录名：&quot; + file.getName()); System.out.println(&quot;绝对路径：&quot; + file.getAbsolutePath()); System.out.println(&quot;父目录：&quot; + file.getParent()); System.out.println(&quot;文件路径：&quot; + file.getPath()); //判断文件是否是目录 if (file.isDirectory()) &#123; //打印目录中的文件 Arrays.stream(file.list()).forEach(System.out::println); &#125; System.out.println(&quot;是否隐藏：&quot; + file.isHidden()); System.out.println(&quot;是否存在：&quot; + file.exists()); &#125;&#125; 上述代码，可以根据个人情况更换 File Path 直接获取结果 目录读取Java 中读取目录中的文件可以直接使用 listFiles() 方法读取，但是也只能读取当前目录中的文件，如果当前目录中还有二级目录如何解决呢？三级目录呢？接下来将使用 Java 读取当前目录和子目录中的所有文件。 编程实例新建源代码文件 ReadDir.java 1234567891011121314151617181920212223242526import java.io.File;public class ReadDir &#123; public static void main(String[] args) &#123; readDir(new File(&quot;/home&quot;)); &#125; public static void readDir(File file) &#123; if (file == null) &#123; return; &#125; //如果当前file是目录 if (file.isDirectory()) &#123; File[] files; //如果目录不为空 if ((files = file.listFiles()) != null) &#123; for (File file1 : files) &#123; //递归读取目录内容 readDir(file1); &#125; &#125; &#125; else &#123; //如果不是目录 直接输出文件名 System.out.println(file.getName()); &#125; &#125;&#125; 上述代码，可以根据个人情况更换 File Path （注意 为了更好的效果最好是三级目录读取)","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java File","slug":"java-File","permalink":"https://bawcat.wiki/tags/java-File/"},{"name":"java nio","slug":"java-nio","permalink":"https://bawcat.wiki/tags/java-nio/"},{"name":"java Files","slug":"java-Files","permalink":"https://bawcat.wiki/tags/java-Files/"},{"name":"java StandardCopyOption","slug":"java-StandardCopyOption","permalink":"https://bawcat.wiki/tags/java-StandardCopyOption/"},{"name":"java Paths","slug":"java-Paths","permalink":"https://bawcat.wiki/tags/java-Paths/"}]},{"title":"java 泛型和集合","slug":"java/基础教学/基础数据类型/泛型和集合","date":"2020-03-16T15:40:20.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/03/16/java/基础教学/基础数据类型/泛型和集合/","link":"","permalink":"https://bawcat.wiki/2020/03/16/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/","excerpt":"","text":"泛型和集合 泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。 定义泛型的规则：只能是引用类型，不能是简单数据类型。泛型参数可以有多个。可以用使用 extends 语句或者 super 语句 如 表示类型的上界，T 只能是 superClass 或其子类， 表示类型的下界，K 只能是 childClass 或其父类。可以是通配符类型，比如常见的 Class&lt;?&gt;。单独使用 ? 可以表示任意类型。也可以结合 extends 和 super 来进行限制。 接下来我们来定义一个泛型类，它有一个成员，成员的类型待定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*使用T代表类型，无论何时都没有比这更具体的类型来区分它。如果有多个类型参数，我们可能使用字母表中T的临近的字母，比如S。*/class Test&lt;T&gt; &#123; private T ob; /* 定义泛型成员变量，定义完类型参数后，可以在定义位置之后的方法的任意地方使用类型参数，就像使用普通的类型一样。 注意，父类定义的类型参数不能被子类继承。 */ //构造函数 public Test(T ob) &#123; this.ob = ob; &#125; //getter 方法 public T getOb() &#123; return ob; &#125; //setter 方法 public void setOb(T ob) &#123; this.ob = ob; &#125; public void showType() &#123; System.out.println(&quot;T的实际类型是: &quot; + ob.getClass().getName()); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; // 定义泛型类 Test 的一个Integer版本 Test&lt;Integer&gt; intOb = new Test&lt;Integer&gt;(88); intOb.showType(); int i = intOb.getOb(); System.out.println(&quot;value= &quot; + i); System.out.println(&quot;----------------------------------&quot;); // 定义泛型类Test的一个String版本 Test&lt;String&gt; strOb = new Test&lt;String&gt;(&quot;Hello Gen!&quot;); strOb.showType(); String s = strOb.getOb(); System.out.println(&quot;value= &quot; + s); &#125;&#125; 泛型使用操作例子12345678910111213141516171819202122232425262728293031323334// Animal.javapublic class Animal &#123; public Animal()&#123; System.out.println(&quot;我是动物&quot;); &#125;&#125;// Dog.javapublic class Dog extends Animal &#123; public Dog()&#123; System.out.println(&quot;我是狗&quot;); &#125;&#125;// Test.javapublic class Test &#123; /* 注意：定义带类型参数的方法，其主要目的是为了表达多个参数以及返回值之间的关系。例如本例子中T和S的继承关系， 返回值的类型和第一个类型参数的值相同。 */ public&lt;T, S extends T&gt; T testDemo(T t, S s)&#123; System.out.println(&quot;我是 T 类型，我的类型是&quot; + t.getClass().getName()); System.out.println(&quot;我是 S 类型，我的类型是&quot; + s.getClass().getName()); return t; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Test test = new Test(); Dog d = new Dog(); Animal a0 = new Animal(); Animal a1 = test.testDemo(a0, d); System.out.println(&quot;我是对象 a1，我的类型是&quot; + a1.getClass().getName()); &#125;&#125; 编译执行: 12345678$ javac Test.java Dog.java Animal.java$ java Test我是动物我是狗我是动物我是 T 类型，我的类型是Animal我是 S 类型，我的类型是Dog我是对象 a1，我的类型是Animal 上面的例子中我们对类型参数赋予了具体的类型，当然我们有时候也无法确定类型参数的类型，这个时候我们便可以使用通配符。如果仅仅是想实现多态，请优先使用通配符解决 修改 Test 类： 123456789101112131415161718192021222324252627import java.util.List;import java.util.ArrayList;public class Test &#123; // List&lt;?&gt; 表示接受一个元素为任意类型的列表 List。 public void testDemo(List&lt;?&gt; s)&#123; for(Object obj:s)&#123; System.out.println(&quot;我的类型是&quot; + obj.getClass().getName()); &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Test test = new Test(); Dog a0 = new Dog(); Animal a1 = new Animal(); // 声明一个接收元素类型是 Animal 的列表 List s。 // 然后创建一个元素类型是 Animal 的 ArrayList 赋值给 s。 List&lt;Animal&gt; s = new ArrayList&lt;Animal&gt;(); // Dog a0 是 Animal 的子类，可以向上转型为 Animal 类型 s.add(a0); s.add(a1); test.testDemo(s); &#125;&#125; 运行结果: 1234567$ javac Test.java Dog.java Animal.java$ java Test我是动物我是狗我是动物我的类型是Dog我的类型是Animal Collection 集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。 因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。Collection 接口是 Java 集合框架里的一个根接口。它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。 方法 返回值 说明 add(E e) boolean 向 collection 的尾部追加指定的元素（可选操作） addAll(Collection&lt;? extend E&gt; c) boolean 将指定 collection 中的所有元素都添加到此 collection 中（可选操作） clear() void 移除此 collection 中的所有元素（可选操作） contains(Object o) boolean 如果此 collection 包含指定的元素，则返回 true containsAll(Collection&lt;?&gt; c) boolean 如果此 collection 包含指定 collection 的所有元素，则返回 true equals(Object o) boolean 比较此 collection 与指定对象是否相等 hashCode() int 返回此 collection 的哈希码值 isEmpty() boolean 如果此 collection 不包含元素，则返回 true iterator() Iterator 返回在此 collection 的元素上进行迭代的迭代器 remove(Object o) boolean 移除此 collection 中出现的首个指定元素（可选操作） removeAll(Collection&lt;?&gt; c) boolean 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作） retainAll(Collection&lt;?&gt; c) boolean 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作） size() int 返回此 collection 中的元素数 toArray() Object[] 返回包含此 collection 中所有元素的数组 toArray(T[] a) T[] 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同 ListList 是一个接口，不能实例化，需要一个具体类来实现实例化。 List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 List 接口实现的类有：ArrayList（实现动态数组），Vector（实现动态数组），LinkedList（实现链表），Stack（实现堆栈）。 List 在 Collection 基础上增加的方法： 方法 返回值 说明 add(int index, E element) void 在列表的指定位置插入指定元素（可选操作） addAll(int index, Collection&lt;? extends E&gt; c) boolean 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作） get(int index) E 返回列表中指定位置的元素 indexOf(Object o) int 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1 lastIndexOf(Object o) int 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1 listIterator() ListIterator 返回此列表元素的列表迭代器（按适当顺序） listIterator(int index) ListIterator 返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始 remove(int index) E 移除列表中指定位置的元素（可选操作） set(int index, E element) E 用指定元素替换列表中指定位置的元素（可选操作） subList(int fromIndex, int toIndex) List 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图 ArrayListArrayList 类实现一个可增长的动态数组，位于 java.util.ArrayList。实现了 List 接口，它可以存储不同类型的对象（包括 null 在内），而数组则只能存放特定数据类型的值。 ArrayList 编程实例学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作。 创建一个学生类 Student.java： 12345678910111213141516171819/** * 学生类 */public class Student &#123; public String id; public String name; public Student(String id, String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 创建一个 ListTest.java，其中包含了一个学生列表，通过操作学生列表来管理学生 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import java.util.*;public class ListTest &#123; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 /** * 用于存放学生的List */ public List&lt;Student&gt; students; public ListTest() &#123; this.students = new ArrayList&lt;Student&gt;(); &#125; /** * 用于往students中添加学生 */ public void testAdd() &#123; // 创建一个学生对象，并通过调用add方法，添加到学生管理List中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); // 取出 List中的Student对象 索引为0 也就是第一个 Student temp = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name); Student st2 = new Student(&quot;2&quot;, &quot;李四&quot;); //添加到list中，插入到索引为0的位置，也就是第一个 students.add(0, st2); Student temp2 = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name); // 对象数组的形式添加 Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表 students.addAll(Arrays.asList(student)); Student temp3 = students.get(2); Student temp4 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name); System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(2, Arrays.asList(student2)); Student temp5 = students.get(2); Student temp6 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name); System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name); &#125; /** * 取得List中的元素的方法 */ public void testGet() &#123; int size = students.size(); for (int i = 0; i &lt; size; i++) &#123; Student st = students.get(i); System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过迭代器来遍历 * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动 */ public void testIterator() &#123; // 通过集合的iterator方法，取得迭代器实例 Iterator&lt;Student&gt; it = students.iterator(); System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;); while (it.hasNext()) &#123; Student st = it.next(); System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过for each 方法访问集合元素 * */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过for each）：&quot;); for (Student obj : students) &#123; Student st = obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; //使用java8 Steam将学生排序后输出 students.stream()//创建Stream //通过学生id排序 .sorted(Comparator.comparing(x -&gt; x.id)) //输出 .forEach(System.out::println); &#125; /** * 修改List中的元素 * */ public void testModify() &#123; students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;)); &#125; /** * 删除List中的元素 * */ public void testRemove() &#123; Student st = students.get(4); System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;); students.remove(st); System.out.println(&quot;成功删除学生！&quot;); testForEach(); &#125; public static void main(String[] args) &#123; ListTest lt = new ListTest(); lt.testAdd(); lt.testGet(); lt.testIterator(); lt.testModify(); lt.testForEach(); lt.testRemove(); &#125;&#125; 编译运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ javac Student.java ListTest.java$ java ListTest添加了学生：1:张三添加了学生：2:李四添加了学生：3:王五添加了学生：4:马六添加了学生：5:周七添加了学生：6:赵八学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:王五学生：4:马六有如下学生（通过迭代器访问）：学生2:李四学生1:张三学生5:周七学生6:赵八学生3:王五学生4:马六有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:吴酒学生：4:马六Student&#123;id=&#x27;1&#x27;, name=&#x27;张三&#x27;&#125;Student&#123;id=&#x27;2&#x27;, name=&#x27;李四&#x27;&#125;Student&#123;id=&#x27;3&#x27;, name=&#x27;吴酒&#x27;&#125;Student&#123;id=&#x27;4&#x27;, name=&#x27;马六&#x27;&#125;Student&#123;id=&#x27;5&#x27;, name=&#x27;周七&#x27;&#125;Student&#123;id=&#x27;6&#x27;, name=&#x27;赵八&#x27;&#125;我是学生：3:吴酒，我即将被删除成功删除学生！有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：4:马六Student&#123;id=&#x27;1&#x27;, name=&#x27;张三&#x27;&#125;Student&#123;id=&#x27;2&#x27;, name=&#x27;李四&#x27;&#125;Student&#123;id=&#x27;4&#x27;, name=&#x27;马六&#x27;&#125;Student&#123;id=&#x27;5&#x27;, name=&#x27;周七&#x27;&#125;Student&#123;id=&#x27;6&#x27;, name=&#x27;赵八&#x27;&#125; 在上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。 MapMap 接口也是一个非常重要的集合接口，用于存储键 / 值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。 value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键 / 值对以 Entry 类型的对象实例形式存在。 看一看 Map 中的方法吧： 方法 返回值 说明 clear() void 从此映射中移除所用映射关系（可选操作） containsKey(Object key) boolean 如果此映射包含指定键的映射关系，则返回 true containsValue(Object value) boolean 如果此映射将一个或多个键映射到指定值，则返回 true entrySet() Set&lt;Map.Entry&lt;K,V&gt;&gt; 返回此映射中包含的映射关系的 Set 视图 equals(Object o) boolean 比较指定的对象与此映射是否相等 get(Object key) V 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null hashCode() int 返回此映射的哈希码值 isEmpty() boolean 如果此映射未包含键 - 值映射关系，则返回 true keySet() Set 返回此映射中包含的键的 Set 视图 put(K key, V value) V 将指定的值与此映射中的指定键关联（可选操作） putAll(Map&lt;? extends K, ? extends V&gt; m) void 从指定映射中将所有映射关系复制到此映射中（可选操作） remove(Object key) V 如果存在一个键的映射关系，则将其从此映射中移除（可选操作） size int 返回此映射中的键 - 值映射关系数 values() Collection 返回此映射中包含的值的 Collection 视图 HashMapHashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是 无序 排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。 下面我们通过代码来学习 Map 中的方法吧。同学们都有过选课经历吧，我们就用 Map 来管理课程吧。 创建一个 Course 类： 123456789// Course.javapublic class Course &#123; public String id; public String name; public Course(String id, String name)&#123; this.id = id; this.name = name; &#125;&#125; 创建一个 MapTest 类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// MapTest.javaimport java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest &#123; /** * 用来承装课程类型对象 */ public Map&lt;String, Course&gt; courses; /** * 在构造器中初始化 courses 属性 * @param args */ public MapTest() &#123; this.courses = new HashMap&lt;String, Course&gt;(); &#125; /** * 测试添加：输入课程 ID，判断是否被占用 * 若未被占用，输入课程名称，创建新课程对象 * 并且添加到 courses 中 * @param args */ public void testPut() &#123; //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称 Scanner console = new Scanner(System.in); for(int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;请输入课程 ID：&quot;); String ID = console.next(); //判断该 ID 是否被占用 Course cr = courses.get(ID); if(cr == null)&#123; //提示输入课程名称 System.out.println(&quot;请输入课程名称：&quot;); String name = console.next(); //创建新的课程对象 Course newCourse = new Course(ID,name); //通过调用 courses 的 put 方法，添加 ID-课程映射 courses.put(ID, newCourse); System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name); &#125; else &#123; System.out.println(&quot;该课程 ID 已被占用&quot;); continue; &#125; &#125; &#125; /** * 测试 Map 的 keySet 方法 * @param args */ public void testKeySet() &#123; //通过 keySet 方法，返回 Map 中的所有键的 Set 集合 Set&lt;String&gt; keySet = courses.keySet(); //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value for(String crID: keySet) &#123; Course cr = courses.get(crID); if(cr != null)&#123; System.out.println(&quot;课程：&quot; + cr.name); &#125; &#125; &#125; /** * 测试删除 Map 中的映射 * @param args */ public void testRemove() &#123; //获取从键盘输入的待删除课程 ID 字符串 Scanner console = new Scanner(System.in); while(true)&#123; //提示输出待删除的课程 ID System.out.println(&quot;请输入要删除的课程 ID！&quot;); String ID = console.next(); //判断该 ID 是否对应的课程对象 Course cr = courses.get(ID); if(cr == null) &#123; //提示输入的 ID 并不存在 System.out.println(&quot;该 ID 不存在！&quot;); continue; &#125; courses.remove(ID); System.out.println(&quot;成功删除课程&quot; + cr.name); break; &#125; &#125; /** * 通过 entrySet 方法来遍历 Map * @param args */ public void testEntrySet() &#123; //通过 entrySet 方法，返回 Map 中的所有键值对 Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet(); for(Entry&lt;String,Course&gt; entry: entrySet) &#123; System.out.println(&quot;取得键：&quot; + entry.getKey()); System.out.println(&quot;对应的值为：&quot; + entry.getValue().name); &#125; &#125; /** * 利用 put 方法修改Map 中的已有映射 * @param args */ public void testModify()&#123; //提示输入要修改的课程 ID System.out.println(&quot;请输入要修改的课程 ID：&quot;); //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串 Scanner console = new Scanner(System.in); while(true) &#123; //取得从键盘输入的课程 ID String crID = console.next(); //从 courses 中查找该课程 ID 对应的对象 Course course = courses.get(crID); if(course == null) &#123; System.out.println(&quot;该 ID 不存在！请重新输入！&quot;); continue; &#125; //提示当前对应的课程对象的名称 System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name); //提示输入新的课程名称，来修改已有的映射 System.out.println(&quot;请输入新的课程名称：&quot;); String name = console.next(); Course newCourse = new Course(crID,name); courses.put(crID, newCourse); System.out.println(&quot;修改成功！&quot;); break; &#125; &#125; public static void main(String[] args) &#123; MapTest mt = new MapTest(); mt.testPut(); mt.testKeySet(); mt.testRemove(); mt.testModify(); mt.testEntrySet(); &#125;&#125; Set &amp;&amp; HashSetSet 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。 HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。 接下来我们通过代码的形式来详细看一看吧！ 假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧。 因为项目组的组长由一个老师担任 创建一个 PD 类 12345678910111213141516171819// PD.javaimport java.util.HashSet;import java.util.Set;/* * 项目组长类 */public class PD &#123; public String id; public String name; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 public Set&lt;Student&gt; students; public PD(String id, String name)&#123; this.id = id; this.name = name; this.students = new HashSet&lt;Student&gt;(); &#125;&#125; 创建一个学生类 Student.java： 1234567891011121314151617181920/** * 学生类 */ // Student.javapublic class Student &#123; public String id; public String name; public Student(String id, String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 接下来我们便创建一个 SetTest 类，用来管理项目成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// SetTest.javaimport java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;public class SetTest &#123; public List&lt;Student&gt; students; public SetTest() &#123; students = new ArrayList&lt;Student&gt;(); &#125; /* * 用于往students中添加学生 */ public void testAdd() &#123; //创建一个学生对象，并通过调用add方法，添加到学生管理List中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); //添加到List中的类型均为Object，所以取出时还需要强转 Student st2 = new Student(&quot;2&quot;,&quot;李四&quot;); students.add(st2); Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; students.addAll(Arrays.asList(student)); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(Arrays.asList(student2)); &#125; /** * 通过for each 方法访问集合元素 * @param args */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过for each）：&quot;); for(Object obj:students)&#123; Student st = (Student)obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; public static void main(String[] args)&#123; SetTest st = new SetTest(); st.testAdd(); st.testForEach(); PD pd = new PD(&quot;1&quot;,&quot;张老师&quot;); System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;); //创建一个 Scanner 对象，用来接收从键盘输入的学生 ID Scanner console = new Scanner(System.in); for(int i = 0;i &lt; 3; i++)&#123; System.out.println(&quot;请输入学生 ID&quot;); String studentID = console.next(); for(Student s:st.students)&#123; if(s.id.equals(studentID))&#123; pd.students.add(s); &#125; &#125; &#125; st.testForEachForSer(pd); // 关闭 Scanner 对象 console.close(); &#125; //打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator //不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素 public void testForEachForSer(PD pd)&#123; for(Student s: pd.students) &#123; System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 泛型和集合","slug":"java-泛型和集合","permalink":"https://bawcat.wiki/tags/java-%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/"}]},{"title":"Java Throwable 抛出异常","slug":"java/基础教学/Throwable","date":"2020-03-16T15:37:50.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/03/16/java/基础教学/Throwable/","link":"","permalink":"https://bawcat.wiki/2020/03/16/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/Throwable/","excerpt":"","text":"Java 关于抛出异常 异常指不期而至的各种状况，它在程序运行的过程中发生。作为开发者，我们都希望自己写的代码永远都不会出现 bug，然而现实告诉我们并没有这样的情景。如果用户在程序的使用过程中因为一些原因造成他的数据丢失，这个用户就可能不会再使用该程序了。所以，对于程序的错误以及外部环境能够对用户造成的影响，我们应当及时报告并且以适当的方式来处理这个错误。 之所以要处理异常，也是为了增强程序的鲁棒性。 异常都是从 Throwable 类派生出来的，而 Throwable 类是直接从 Object 类继承而来。你可以在 Java SE 官方 API 文档中获取更多关于它们的知识。 异常分类异常通常有四类： Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理。 Exception：可以处理的异常。 RuntimeException：可以捕获，也可以不捕获的异常。 继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常。 平时主要关注的异常是 Exception 下的异常，而 Exception 异常下又主要分为两大类异常，一个是派生于 RuntimeExcption 的异常，一个是除了 RuntimeExcption 体系之外的其他异常。 RuntimeExcption 异常（运行时异常）通常有以下几种： 错误的类型转换 数组访问越界 访问 null 指针 算术异常 一般来说，RuntimeException 都是代码逻辑出现问题。 非 RuntimeException（受检异常，Checked Exception）一般有： 打开一个不存在的文件 没有找到具有指定名称的类 操作文件异常 受检异常是编译器要求必须处理的异常，必须使用 try catch 处理，或者使用 throw 抛出，交给上层调用者处理。 声明及抛出throw 抛出异常当程序运行时数据出现错误或者我们不希望发生的情况出现的话，可以通过抛出异常来处理。 异常抛出语法： 1throw new 异常类(); 下面新建 ThrowsTest.java 12345678910111213public class ThrowsTest &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = null; //当a或者b为null时，抛出异常 if (a == null || b == null) &#123; throw new NullPointerException(); &#125; else &#123; System.out.println(a + b); &#125; &#125;&#125; 运行程序: 1234$ javac ThrowsTest.java$ java ThrowsTestException in thread &quot;main&quot; java.lang.NullPointerException at ThrowTest.main(ThrowTest.java:8) throws 声明异常throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受检异常），那么调用者必须捕获处理该异常或者使用 throws 继续向上抛出。throws 位于方法体前，多个异常之间使用 , 分割。 修改 ThrowsTest.java： 123456789101112131415import java.io.FileInputStream;import java.io.FileNotFoundException;public class ThrowsTest &#123; public static void main(String[] args) throws FileNotFoundException &#123; //由方法的调用者捕获异常或者继续向上抛出 throwsTest(); &#125; public static void throwsTest() throws FileNotFoundException &#123; new FileInputStream(&quot;/home/project/xxx.file&quot;); &#125;&#125; 运行程序： 123456789$ javac ThrowsTest.java$ java ThrowsTestException in thread &quot;main&quot; java.io.FileNotFoundException: /home/project/xxx.file (系统找不到指定的路径。) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93) at ThrowsTest.throwsTest(ThrowsTest.java:13) at ThrowsTest.main(ThrowsTest.java:8) 捕获异常通常抛出异常后，还需要将异常捕获。使用 try 和 catch 语句块来捕获异常，有时候还会用到 finally。 对于上述三个关键词所构成的语句块，try 语句块是必不可少的，catch 和 finally 语句块可以根据情况选择其一或者全选。你可以把可能发生错误或出现问题的语句放到 try 语句块中，将异常发生后要执行的语句放到 catch 语句块中，而 finally 语句块里面放置的语句，不管异常是否发生，它们都会被执行。 你可能想说，那我把所有有关的代码都放到 try 语句块中不就妥当了吗？可是你需要知道，捕获异常对于系统而言，其开销非常大，所以应尽量减少该语句块中放置的语句。 新建 CatchException.java： 1234567891011121314151617181920212223242526public class CatchException &#123; public static void main(String[] args) &#123; try &#123; // 下面定义了一个try语句块 System.out.println(&quot;I am try block.&quot;); Class&lt;?&gt; tempClass = Class.forName(&quot;&quot;); // 声明一个空的Class对象用于引发“类未发现异常” System.out.println(&quot;Bye! Try block.&quot;); &#125; catch (ClassNotFoundException e) &#123; // 下面定义了一个catch语句块 System.out.println(&quot;I am catch block.&quot;); e.printStackTrace(); //printStackTrace()的意义在于在命令行打印异常信息在程序中出错的位置及原因 System.out.println(&quot;Goodbye! Catch block.&quot;); &#125; finally &#123; // 下面定义了一个finally语句块 System.out.println(&quot;I am finally block.&quot;); &#125; &#125;&#125; 运行程序: 12345678910$ javac CatchException.java$ java CatchExceptionI am try block.I am catch block.java.lang.ClassNotFoundException: at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Unknown Source) at CatchException.main(CatchException.java:8)Goodbye! Catch block.I am finally block. 请你结合这些输出语句在源代码中的位置，再来体会一下三个语句块的作用。 捕获多个异常在一段代码中，可能会由于各种原因抛出多种不同的异常，而对于不同的异常，我们希望用不同的方式来处理它们，而不是笼统的使用同一个方式处理，在这种情况下，可以使用异常匹配，当匹配到对应的异常后，后面的异常将不再进行匹配。 编程实例新建源代码文件 MultipleCapturesDemo.java： 1234567891011121314import java.io.FileInputStream;import java.io.FileNotFoundException;public class MultipleCapturesDemo &#123; public static void main(String[] args) &#123; try &#123; new FileInputStream(&quot;&quot;); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;IO 异常&quot;); &#125; catch (Exception e) &#123; System.out.println(&quot;发生异常&quot;); &#125; &#125;&#125; 运行程序： 123$ javac MultipleCapturesDemo.java$ java MultipleCapturesDemoIO 异常 在处理异常时，并不要求抛出的异常同 catch 所声明的异常完全匹配，子类的对象也可以匹配父类的处理程序。比如异常 A 继承于异常 B，那么在处理多个异常时，一定要将异常 A 放在异常 B 之前捕获，如果将异常 B 放在异常 A 之前，那么将永远匹配到异常 B，异常 A 将永远不可能执行，并且编译器将会报错。 自定义异常尽管 Java SE 的 API 已经为我们提供了数十种异常类，然而在实际的开发过程中，你仍然可能遇到未知的异常情况。此时，你就需要对异常类进行自定义。 自定义一个异常类非常简单，只需要让它继承 Exception 或其子类就行。在自定义异常类的时候，建议同时提供无参构造方法和带字符串参数的构造方法，后者可以为你在调试时提供更加详细的信息。 百闻不如一见，下面我们尝试自定义一个算术异常类。 创建一个 MyAriException 类: 1234567891011121314// MyAriException.javapublic class MyAriException extends ArithmeticException &#123; //自定义异常类，该类继承自ArithmeticException public MyAriException() &#123; &#125; //实现默认的无参构造方法 public MyAriException(String msg) &#123; super(msg); &#125; //实现可以自定义输出信息的构造方法，将待输出信息作为参数传入即可&#125; 添加一个 ExceptionTest 类作为测试用，在该类的 main() 方法中，可以尝试使用 throw 抛出自定义的异常。 12345678910111213141516171819202122232425// ExceptionTest.javaimport java.util.Arrays;public class ExceptionTest &#123; public static void main(String[] args) &#123; int[] array = new int[5]; //声明一个长度为5的数组 Arrays.fill(array, 5); //将数组中的所有元素赋值为5 for (int i = 4; i &gt; -1; i--) &#123; //使用for循环逆序遍历整个数组，i每次递减 if (i == 0) &#123; // 如果i除以了0，就使用带异常信息的构造方法抛出异常 throw new MyAriException(&quot;There is an exception occured.&quot;); &#125; System.out.println(&quot;array[&quot; + i + &quot;] / &quot; + i + &quot; = &quot; + array[i] / i); // 如果i没有除以0，就输出此结果 &#125; &#125;&#125; 检查一下代码，编译并运行，期待中的自定义错误信息就展现在控制台中了： 12345678$ javac ExceptionTest.java MyAriException.java$ java ExceptionTestarray[4] / 4 = 1array[3] / 3 = 1array[2] / 2 = 2array[1] / 1 = 5Exception in thread &quot;main&quot; MyAriException: There is an exception occured. at ExceptionTest.main(ExceptionTest.java:17) 异常堆栈当异常抛出后，我们可以通过异常堆栈追踪程序的运行轨迹，以便我们更好的 DEBUG。 新建一个 ExceptionStackTrace.java： 1234567891011121314151617public class ExceptionStackTrace &#123; private static void method1() &#123; method2(); &#125; private static void method2() &#123; throw new NullPointerException(); &#125; public static void main(String[] args) &#123; try &#123; method1(); &#125; catch (Exception e) &#123; //打印堆栈轨迹 e.printStackTrace(); &#125; &#125;&#125; 运行程序: 123456$ javac ExceptionStackTrace.java$ java ExceptionStackTracejava.lang.NullPointerException at ExceptionStackTrace.method2(ExceptionStackTrace.java:7) at ExceptionStackTrace.method1(ExceptionStackTrace.java:3) at ExceptionStackTrace.main(ExceptionStackTrace.java:11) 通过上面的异常堆栈轨迹，在对比我们方法的调用过程，可以得出异常信息中首先打印的是距离抛出异常最近的语句，接着是调用该方法的方法，一直到最开始被调用的方法。从下往上看，就可以得出程序运行的轨迹。","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 函数式编程","slug":"java/java-函数式编程","permalink":"https://bawcat.wiki/categories/java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Throwable","slug":"java-Throwable","permalink":"https://bawcat.wiki/tags/java-Throwable/"}]},{"title":"Hadoop 伪分布式配置部署","slug":"大数据/hadoop/伪分布式配置部署","date":"2020-01-13T03:45:08.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/13/大数据/hadoop/伪分布式配置部署/","link":"","permalink":"https://bawcat.wiki/2020/01/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hadoop 伪分布式配置部署 在阅读本章节之前，请确定你已经阅读过，Hadoop 单机版部署 并存在环境 Hadoop 伪分布式模式配置 再次提醒 当前环境 必须是 您在阅读 Hadoop 单机版部署 后部署的环境 修改 core-site.xml这里我们需要修改 core-site.xml, 使用下面的命令调用 Vim 编辑器来编辑文件。 123$ cd /home/hadoop/hdfs/etc/hadoop$vim ./core-site.xml 先说一下常用配置项： fs.defaultFS fs.defaultFS 是默认的HDFS 路径。 当有多个 HDFS 集群同时工作时，用户在这里指定默认HDFS 集群， 该值来自于 hdfs-site.xml 中的配置。 fs.default.name fs.default.name 是一个描述集群中 NameNode 节点的 URI(包括协议、主机名称、端口号)， 集群里面的每一台机器都需要知道 NameNode 的地址。 DataNode 节点会现在 NameNode 上注册， 这样他们的数据才可以被使用。 独立的客户端程序通过这个 URI 跟 DataNode 交互， 以取得文件的块列表。 hadoop.tmp.dir hadoop.tmp.dir 是hadoop 文件系统依赖的基础配置，很多路径都依赖它。如果 hdfs-site.xml 中不配置namenode 和 datanode 的存放位置，默认就放在 /tmp/hadoop-${user.name} 这个路径中。 更多说明请参考 core-default.xml, 包含配置文件所有配置项的说明和默认值。 配置好以后的文件内容如下： 123456789101112131415&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 hdfs-site.xml这里我们要修改的是 hdfs-site.xml, 使用下面的命令调用 Vim 编辑器来编辑文件 123$ cd /home/hadoop/hdfs/etc/hadoop/$ vim ./hdfs-site.xml 常用配置项说明： dfs.replication dfs.replication 决定着系统里面的文件块的数据备份个数。对于一个实际的应用，它应该被设为 3 (这个数字并没有上限,但更多的备份可能并没有作用,而且会占用更多的空间)。 少于三个备份，可能会影响到数据的可靠性（系统故障时，也许会造成数据丢失） dfs.data.dir dfs.data.dir 这是 DataNode 节点被指定要存储数据的本地文件系统路径。 DataNode 节点上的这个路径没有必要完全相同，因为每台机器的环境很可能是不一样的。但如果每台机器上的这个路径都是统一配置的话，会使工作变得简单一些。 默认的情况下，它的值为 file://${hadoop.tmp.dir}/dfs/data 这个路径只能用于测试的目的， 因为它很可能会丢失掉一些数据。所以这个值最好还是被覆盖。 dfs.name.dir dfs.name.dir 是NameNode节点存储 hadoop 文件系统信息的本地系统路径。 这个值只对 NameNode 有效， DataNode 并不需要使用 到它。上面对于 /temp 类型的警告， 同样也适用于这里。 在实际应用中，它最好被覆盖掉。 更多说明请参考 hdfs-default.xml, 包含配置文件所有配置项的说明和默认值 配置好以后的文件内容如下： 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 mapred-site.xml使用下面的命令先将默认文件复制一份过来，然后调用 Vim 编辑器进行编辑。 12345$ cd /home/hadoop/hdfs/etc/hadoop/$ cp ./mapred-site.xml.template ./mapred-site.xml$ vim ./mapred-site.xml 常用配置项说明： mapred.job.tracker：JobTracker 的主机（或者 IP）和端口。更多说明请参考mapred-default.xml，包含配置文件所有配置项的说明和默认值 配置好以后的文件内容如下： 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 yarn-site.xml编辑 yarn-site.xml 文件 123$ cd /home/hadoop/hdfs/etc/hadoop$ vim ./yarn-site.xml 常用配置项说明： yarn.nodemanager.aux-services 通过该配置，用户可以自定义一些服务 更多说明请参考yarn-default.xml，包含配置文件所有配置项的说明和默认值 配置好以后的文件内容如下： 1234567&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 hadoop-env.sh123$ cd /home/hadoop/hdfs/etc/hadoop/$ sudo vim ./hadoop-env.sh 修改 JAVA_HOME 如下： 12export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_CONF_DIR=/home/hadoop/hdfs/etc/hadoop 这样简单的伪分布式就配置好了。 格式化 HDFS 文件系统在使用 hadoop 前，必须格式化一个全新的 HDFS 安装，通过创建存储目录和 NameNode 持久化数据结构的初始版本，格式化过程创建了一个空的文件系统。 由于 NameNode 管理文件系统的元数据，而 DataNode 可以动态的加入或离开集群，因此这个格式化过程并不涉及 DataNode。同理，用户也无需关注文件系统的规模。 集群中 DataNode 的数量决定着文件系统的规模。DataNode 可以在文件系统格式化之后的很长一段时间内按需增加。 使用下面的命令进行给格式化。 123$ cd ~$ hadoop namenode -format Hadoop 集群启动启动 hdfs 守护进程启动 HDFS 守护进程： 分别启动 NameNode 和 DataNode 1$ start-dfs.sh 输出如下（可以看出分别启动了 namenode,datanode,secondarynamenode,因为我们没有配置 secondarynamenode,所以地址为 0.0.0.0）： 启动 yarn使用如下命令启动 ResourceManager 和 NodeManager： 1$ start-yarn.sh 检查是否运行成功打开浏览器 输入： http://localhost:8088 进入 ResourceManager 管理页面 输入： http://localhost:50070 进入 HDFS 页面 可能出现的问题及调试方法启动伪分布式之后， 如果活跃节点显示为零，说明伪分布没有真正的启动。 原因时有的时候数据结构出现问题会造成无法启动 datanode。 如果使用 hadoop namenode -format 重新格式化仍然无法正常启动，原因时 /tmp 中的文件没有清楚，则需要先清除 /tmp/hadoop/* 再执行格式化，即可解决 hadoop datanode 无法启动的问题。 具体步骤如下所示： 1234567891011121314# 删除 hadoop:/tmp$ hadoop fs -rmr /tmp# 停止 hadoop$ stop-all.sh# 删除 /tmp/hadoop*$ rm -rf /tmp/hadoop*# 格式化$ hadoop namenode -format# 启动 hadoop$ start-all.sh 测试验证测试验证还是使用 之前的 WordCount。 不同的是 ，这次使用了伪分布式模式。 使用了 hdfs ， 因此我们需要把文件拷贝到 hdfs 上去。 首先创建相关文件夹 1$ hdfs dfs -mkdir -p /user/hadoop/input 创建输入的数据这里我们采用 /etc/protocols 文件作为输入的数据进行测试、现将文件拷贝到 hdfs 上： 12345# 上传$ hdfs dfs -put /etc/protocols /user/hadoop/input# 查看是否上传成功$ hdfs dfs -ls /user/hadoop/input 执行 Hadoop WordCount 应用（词频统计）如果存在上一次测试生成的output，由于hadoop 的安全机制，直接运行可能会报错，所以请手动删除上一次生成的 output 文件夹 1$ rm -rf /home/hadoop/hdfs/output/ 然后运行词频统计程序 1234$ hadoop jar \\ /home/hadoop/hdfs/share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar \\ org.apache.hadoop.examples.WordCount \\ /user/hadoop/input output 查看生成的单词统计数据耐心等待前面的词频统计命令结束后，输入下面的命令查看结果： 1$ hdfs dfs -cat /user/hadoop/output/* 关闭服务 关闭 HDFS 守护进程 1$ stop-dfs.sh 关闭 yarn 1$ stop-yarn.sh 参考文档http://www.cnblogs.com/kinglau/p/3796164.html","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://bawcat.wiki/categories/Hadoop/"},{"name":"部署和管理","slug":"Hadoop/部署和管理","permalink":"https://bawcat.wiki/categories/Hadoop/%E9%83%A8%E7%BD%B2%E5%92%8C%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://bawcat.wiki/tags/hadoop/"},{"name":"伪分布式","slug":"伪分布式","permalink":"https://bawcat.wiki/tags/%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Hadoop 单机安装","slug":"大数据/hadoop/单机模式部署","date":"2020-01-13T02:45:08.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/13/大数据/hadoop/单机模式部署/","link":"","permalink":"https://bawcat.wiki/2020/01/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hadoop 单机安装Hadoop 启动模式Hadoop 集群有三种启动模式： 单机模式：默认情况下运行为一个单独机器上的独立 Java 进程，主要用于调试环境 伪分布模式：在单个机器上模拟成分布式多节点环境，每一个 Hadoop 守护进程都作为一个独立的 Java 进程运行 完全分布式模式：真实的生产环境，搭建在完全分布式的集群环境 用户及用户组需要添加用来运行Hadoop 进程的用户组 Hadoop 及用户 Hadoop 注意：没有linux 环境可以使用docker 可以使用下面的命令来查看已经创建好的 hadoop 用户和 uid 与 gid 1$ id hadoop 另外在 /etc/passwd 文件中也记录了用户的信息，使用下面的命令查看： 1$ tail -5 /etc/passwd 添加用户及用户组的步骤如下： 创建用户 Hadoop 1$ sudo adduser hadoop 请按照提示输入 hadoop 用户的密码，例如密码设定为 hadoop 。 将 hadoop 用户添加进 sudo 用户组 1$ sudo usermod -G sudo hadoop 安装及配置以来的软件包Hadoop 的 运行需要JDK， 同时还应配置 SSH 免密码登录 关于配置Java的环境变量，请自行搜索教程 配置SSH免密码登录切换到 hadoop 用户， hadoop 用户时密码为 hadoop。 后续步骤都将在 hadoop 用户的环境中执行。 12// 切换 hadoop 用户su hadoop 配置 ssh 环境免密码登录。 在 /home/hadoop 目录下执行下面的命令 1234567// 切换到根目录$ cd ~ // 生成秘钥对$ ssh-keygen -t rsa// 一路回车保持默认配置即可 对于秘钥对的设置，保持迷人，等到执行完成后，秘钥对就生成好了（一般存放于 ~/.ssh/ 目录中） 12345// 将公钥写入验证文件中$ cat .ssh/id/rsa.pub &gt;&gt; .ssh/authorized_keys// 修改文件的权限为 600 $ chmod 600 .ssh/authorized_keys 验证登录本机是否还需要密码，第一次需要密码以后不需要密码就可以登录 12// 仅需输入一次 hadoop 密码， 以后不需要输入 $ ssh localhost 下载并安装 Hadoop注意，本部分的操作都是在 hadoop 用户登录的环境中进行的。 切换用户使用下面的命令。 1234// 切换为 hadoop 用户 $ su hadoop // 密码为 hadoop 下载 Hadoop 2.6.0 本次演示为 hadoop 2.6.0 学习者可以安装其他版本 具体安装步骤请参考官网 Hadoop 的下载比较缓慢，为了方便大家下载，推荐大家搜索如何 使用 阿里云的镜像 1234// 进入家目录 /home/hadoop$ cd ~$ wget 阿里云镜像地址 解压并安装1$ tar zxvf hadoop-2.6.0.tar.gz 请耐心等待解压完成 安装之前还需要删除之前的遗留文件，如果出现无此文件夹的提示， 说明没有遗留文件。 12// 删除原本遗留的 hdfs 文件夹$ rm -r /home/hadoop/hdfs 然后再进行安装工作。 12345// 复制所需文件 $ mv hadoop-2.6.0 /home/hadoop/hdfs// 将文件夹权限设置为 777$ chmod 777 /home/hadoop/hdfs 配置 Hadoop1$ vim /home/hadoop/.bashrc 在 /home/hadoop/.bashrc 文件末尾添加下列内容： 下面配置中 以 # 开头的是注释，无需输入 1234#HADOOP STARTexport HADOOP_HOME=/home/hadoop/hdfsexport JAVA_HOME=/usr/lib/jvm/java-8-oracle#HADOOP END 在 /home/hadoop/.bashrc 文件中 PATH 路径更改 HADOOP 相关内容： 1export PATH=/usr/local/sbin:/usr/local/bin/:/usr/bin:/usr/sbin:/sbin:/bin:/home/hadoop/hdfs/bin:/home/hadoop/hdfs/sbin 保存退出后，激活新加的环境变量 1$ source ~/.bashrc 至此，Hadoop 单机模式安装完成，可以通过下述步骤的测试来验证安装是否成功。 验证测试创建输入的数据，暂时采用 /etc/protocols 文件作为测试 12345678# 进入到 Hadoop 的目录$ cd /home/hadoop/hdfs# 新建一个 input 文件夹$ mkdir input# 复制文件到 input 中$ cp /etc/protocols ./input/ 执行 Hadoop WordCount 应用（词频统计） 123$ hadoop jar \\ /home/hadoop/hdfs/share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar \\ org.apache.hadoop.examples.WordCount input output 参考文档 http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/SingleCluster.html http://www.cnblogs.com/kinglau/p/3794433.html","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://bawcat.wiki/categories/Hadoop/"},{"name":"部署和管理","slug":"Hadoop/部署和管理","permalink":"https://bawcat.wiki/categories/Hadoop/%E9%83%A8%E7%BD%B2%E5%92%8C%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://bawcat.wiki/tags/hadoop/"},{"name":"单机模式","slug":"单机模式","permalink":"https://bawcat.wiki/tags/%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F/"}]},{"title":"hadoop-了解什么是hadoop","slug":"大数据/hadoop/了解什么是hadoop","date":"2020-01-13T01:13:20.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/13/大数据/hadoop/了解什么是hadoop/","link":"","permalink":"https://bawcat.wiki/2020/01/13/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFhadoop/","excerpt":"","text":"了解Hadoop Hadoop 简介 开源 Apache Hadoop 是一款支持数据密集型分布式应用并以 Apache 2.0 许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。 源于 MapReduceHadoop 是根据 Google 公司发表的 MapReduce 和 Google 档案系统的论文自行实作而成。 提供可靠性和数据移动Hadoop 框架透明地为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。 分布式文件系统此外，Hadoop 还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。 Hadoop 平台现在普遍认为整个 Apache Hadoop “平台” 包括 Hadoop 内核、MapReduce、Hadoop 分布式文件系统（HDFS）以及一些相关项目，有 Apache Hive 和 Apache HBase 等等。 Hadoop 的框架最核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，则 MapReduce 为海量的数据提供了计算。 Hadoop 历史Hadoop 由 Apache Software Foundation 公司于 2005 年秋天作为 Lucene 的子项目 Nutch 的一部分正式引入。它受到最先由 Google Lab 开发的 Map/Reduce 和 Google File System(GFS) 的启发。 2006 年 3 月份，Map/Reduce 和 Nutch Distributed File System (NDFS) 分别被纳入称为 Hadoop 的项目中。 Hadoop 是最受欢迎的在 Internet 上对搜索关键字进行内容分类的工具，但它也可以解决许多要求极大伸缩性的问题。例如，如果您要 grep 一个 10TB 的巨型文件，会出现什么情况？在传统的系统上，这将需要很长的时间。但是 Hadoop 在设计时就考虑到这些问题，采用并行执行机制，因此能大大提高效率。 目前有很多公司开始提供基于 Hadoop 的商业软件、支持、服务以及培训。 Cloudera 是一家美国的企业软件公司，该公司在 2008 年开始提供基于 Hadoop 的软件和服务。 GoGrid 是一家云计算基础设施公司，在 2012 年，该公司与 Cloudera 合作加速了企业采纳基于 Hadoop 应用的步伐。 Dataguise 公司是一家数据安全公司，同样在 2012 年该公司推出了一款针对 Hadoop 的数据保护和风险评估。 Hadoop 相关项目 Hadoop Common在 0.20 及以前的版本中，包含 HDFS、MapReduce 和其他项目公共内容，从 0.21 开始 HDFS 和 MapReduce 被分离为独立的子项目，其余内容为 Hadoop Common。 HDFSHDFS 是指 Hadoop 分布式文件系统（Distributed File System）－HDFS（Hadoop Distributed File System） MapReduceMapReduce 是一个并行计算框架，0.20 前使用 org.apache.hadoop.mapred 旧接口，0.20 版本开始引入 org.apache.hadoop.mapreduce 的新 API。 Apache HBaseHBase 是一个分布式 NoSQL 列数据库，类似谷歌公司的 BigTable。 Apache HiveHive 是构建于 Hadoop 之上的数据仓库，通过一种类 SQL 语言 HiveQL 为用户提供数据的归纳、查询和分析等功能。 Apache Mahout机器学习算法软件包。 Apache Sqoop结构化数据（如关系数据库）与 Apache Hadoop 之间的数据转换工具。 Apache ZooKeeper分布式锁设施，提供类似 Google Chubby 的功能。 Apache Avro新的数据序列化格式与传输工具，将逐步取代 Hadoop 原有的 IPC 机制。 Hadoop 优点 高可靠性Hadoop 按位存储和处理数据的能力值得人们信赖。 高扩展性Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。 高效性Hadoop 能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。 高容错性Hadoop 能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。 低成本与一体机、商用数据仓库以及 QlikView、Yonghong Z-Suite 等数据集市相比，hadoop 是开源的，项目的软件成本因此会大大降低。 支持 Java、C/C++Hadoop 带有用 Java 语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。 Hadoop 应用场景美国著名科技博客 GigaOM 的专栏作家 Derrick Harris 在一篇文章中总结了 10 个 Hadoop 的应用场景： 在线旅游全球 80% 的在线旅游网站都是在使用 Cloudera 公司提供的 Hadoop 发行版，其中 SearchBI 网站曾经报道过的 Expedia 也在其中。 移动数据Cloudera 运营总监称，美国有 70% 的智能手机数据服务背后都是由 Hadoop 来支撑的，也就是说，包括数据的存储以及无线运营商的数据处理等，都是在利用 Hadoop 技术。 电子商务这一场景应该是非常确定的，eBay 就是最大的实践者之一。国内的电商在 Hadoop 技术上也是储备颇为雄厚的。 能源开采美国 Chevron 公司是全美第二大石油公司，他们的 IT 部门主管介绍了 Chevron 使用 Hadoop 的经验，他们利用 Hadoop 进行数据的收集和处理，其中这些数据是海洋的地震数据，以便于他们找到油矿的位置。 节能另外一家能源服务商 Opower 也在使用 Hadoop,为消费者提供节约电费的服务，其中对用户电费单进行了预测分析。 基础架构管理这是一个非常基础的应用场景，用户可以用 Hadoop 从服务器、交换机以及其他的设备中收集并分析数据。 图像处理创业公司 Skybox Imaging 使用 Hadoop 来存储并处理图片数据，从卫星中拍摄的高清图像中探测地理变化。 诈骗检测：这个场景用户接触的比较少，一般金融服务或者政府机构会用到。利用 Hadoop 来存储所有的客户交易数据，包括一些非结构化的数据，能够帮助机构发现客户的异常活动，预防欺诈行为。 IT 安全 除企业 IT 基础机构的管理之外，Hadoop 还可以用来处理机器生成数据以便甄别来自恶意软件或者网络中的攻击。 医疗保健 医疗行业也会用到 Hadoop，像 IBM 的 Watson 就会使用 Hadoop 集群作为其服务的基础，包括语义分析等高级分析技术等。医疗机构可以利用语义分析为患者提供医护人员，并协助医生更好地为患者进行诊断。","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://bawcat.wiki/categories/Hadoop/"},{"name":"部署和管理","slug":"Hadoop/部署和管理","permalink":"https://bawcat.wiki/categories/Hadoop/%E9%83%A8%E7%BD%B2%E5%92%8C%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://bawcat.wiki/tags/hadoop/"},{"name":"初始hadoop","slug":"初始hadoop","permalink":"https://bawcat.wiki/tags/%E5%88%9D%E5%A7%8Bhadoop/"}]},{"title":"国外VPS搭建SSR多用户教程[中文一键安装管理]","slug":"程序人生/国外VPS搭建SSR多用户教程[中文一键安装管理]","date":"2020-01-10T08:24:49.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/10/程序人生/国外VPS搭建SSR多用户教程[中文一键安装管理]/","link":"","permalink":"https://bawcat.wiki/2020/01/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%9B%BD%E5%A4%96VPS%E6%90%AD%E5%BB%BASSR%E5%A4%9A%E7%94%A8%E6%88%B7%E6%95%99%E7%A8%8B[%E4%B8%AD%E6%96%87%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86]/","excerpt":"","text":"国外VPS搭建SSR多用户教程[中文一键安装管理] 首先一切的基础都建立在你有一台 [非大陆]的 VPS ，拥有基础服务器知识（例如连接服务器） 如果你想多用户使用，可以使用不同的端口来控制。所以，本文的SSR多用户搭建就是在一个VPS下面分别设置多个SSR账号，相同的IP地址，不同的端口和SSR密码。 本文也适用任何可用的国外VPS搭建SS/SSR,可以搭建SS多用户也可以搭建SSR多用户。 第一步 连接服务器登录服务器，远程连接你的服务器（或者VPS） 第二步 安装管理在命令行内输入下列命令 ：（该脚本适用于Centos。其他系统没有测试，如果你的系统非Centos，可以使用Docker 具体使用方法，本文不作任何阐述） 12yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/CecilWu/SSR-Chinese/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 此时服务器会自动安装脚本，**如果脚本执行过程中没有反映，你直接回车确认即可** 这个脚本是中文版的，非常简单，直接根据数字选择即可 第三步 配置管理输入数字1 之后回车开始安装 ShadowsocksR ,安装完毕之后会要求你自定义端口和密码。然后回车确认，他会要求你选择加密方式，此时一般选择 10:aes-256-cfb 具体请参考不同的加密方法 不以本文推荐为主 然后设置协议插件、混淆插件（这些都是为了防止封锁） 具体直接根据你的选择进行适当搭配 第四步 用户管理这一步没什么好讲的，基本上都是中文介绍 最后 完成上述步骤都使用完毕之后，我们输入 “Y” 确认上述部署 补充过段时间之后，系统会提示安装完成，同时显示SS账号的配置信息，自己保存好即可 关于多账号使用管理如果你想返回主界面继续安装第二个账号，可以输入下面命令调出，然后选择 “9” 切换到多端口模式即可 12// 该操作 处于 你下载 当前脚本文件夹位置bash ssr.sh 食用说明一切都准备好了之后，下载Shadowsocks的客户端： windows mac 请点击上述两个版本进行下载，下载完成之后按照账号信息进行连接配置。配置完毕之后即可愉快的玩耍了！！ 后记上述操作已经可以满足大部分需求了，但是因为是 vpn 所以网速方面还是很感人的，我们可以对应开启谷歌的 BBR 加速 （ps:现在很多厂商都会自己在服务器内部安装 BBR加速，但是有的也没有，请根据自己的情况选择安装） 请直接复制下列命令 一路回车即可 1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 如果安装 BBR 之后 发生故障，推荐 万能重装大法","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"分享","slug":"程序人生/分享","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"vpn","slug":"vpn","permalink":"https://bawcat.wiki/tags/vpn/"},{"name":"SSR","slug":"SSR","permalink":"https://bawcat.wiki/tags/SSR/"},{"name":"vps","slug":"vps","permalink":"https://bawcat.wiki/tags/vps/"},{"name":"中文VPN脚本","slug":"中文VPN脚本","permalink":"https://bawcat.wiki/tags/%E4%B8%AD%E6%96%87VPN%E8%84%9A%E6%9C%AC/"}]},{"title":"Scala 类和对象（二）","slug":"大数据/scala/类和对象（二）","date":"2020-01-10T06:30:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/10/大数据/scala/类和对象（二）/","link":"","permalink":"https://bawcat.wiki/2020/01/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Scala 类和对象（二）本章知识点概括 类的定义规范 定义类 前提条件检查 添加成员变量 自身引用 辅助构造函数 私有成员变量和方法 定义运算符 标识符 方法重载 隐式类型转换 Rational 类的定义规范首先，我们回忆下有理数的定义：一个有理数(rational)可以表示成分数形式： n/d , 其中 n 和 d 都是整数（ d 不可以为 0 ），*n*** 称为分子(numerator)，*d*** 为分母(denominator)。和浮点数相比，有理数可以精确表达一个分数，而不会有误差。 因此我们定义的 Rational 类支持上面的有理数的定义。支持有理数的加减乘除，并支持有理数的规范表示，比如 2/10 ，其规范表示为 1/5 。分子和分母的最小公倍数为 1 。 有了有理数定义的实现规范，我们可以开始设计类 Rational 。一个好的起点是考虑用户如何使用这个类，我们已经决定使用 “Immutable” 方式来使用 Rational 对象，我们需要用户在定义 Rational 对象时提供分子和分母。因此我们可以开始定义 Rational 类如下： 1class Rational( n:Int, d:Int) 可以看到，和Java不同的是，Scala的类定义可以有参数，称为 类参数 , 如上面的 n、**d**。Scala使用类参数，并把类定义和主构造函数合并在一起，在定义类的同事也定义了累的主构造函数。因此Scala的类定义相对要简洁一些 Scala 编译器会编译Scala类定义包含的任何不属于类成员和类定义的其他代码，这些代码将作为类的主构造函数。比如，我们定义一条打印消息作为类定义的代码： 12345678scala&gt; class Rational (n:Int, d:Int) &#123; | println(&quot;Created &quot; + n + &quot;/&quot; +d) | &#125;defined class Rationalscala&gt; new Rational(1,2)Created 1/2res0: Rational = Rational@22f34036 可以看到创建 Ratiaonal 对象时，自动执行类定义的代码（主构造函数） 重新定义类的 toString 方法上面的代码创建 Rational(1,2)，Scala 编译器打印出 Rational@22f34036，这是因为使用了缺省的类的 toString() 定义 ( Object 对象的)， 缺省实现是打印出对象的类名称+ @ + 16进制数（对象的地址），显示结果不是很直观，因此我们可以重新定义类的 toString() 方法以显示更有意义的字符。 在Scala中，你也可以使用 override 来重载基类定义的方法，而且必须使用 override 关键字表示重新定义基类中的成员。比如： 12345678910scala&gt; class Rational (n:Int, d:Int) &#123; | override def toString = n + &quot;/&quot; +d | &#125;defined class Rationalscala&gt; val x= new Rational(1,3)x: Rational = 1/3scala&gt; val y=new Rational(5,7)y: Rational = 5/7 前提条件检查前面说过有理数可以表示为 n/d (其中 d 、*n*** 、为整数，而 *d*** 不能为 0)。对于前面的 Rational 定义，我们如果使用 0 也是可以的。 12scala&gt; new Rational(5,0)res0: Rational = 5/0 怎么解决分母不能为0的问题？面向对象编程的一个优点是实现了数据的封装，你可以确保再起声明周期过程中是有效的。对于有理数的一个前提条件是分母不可以为0，Scala中定义为传入构造函数和方法的参数的限制范围，也就是调用这些函数或方法的调用者需要满足的条件。Scala中解决这个问题的一个方法时使用 require 方法 （ require 方法为 Predef 对象定义的一个方法，Scala环境自动载入这个类的定义，因此无需使用 import 引入这个对象），因此修改 Rational 定义如下： 12345678910scala&gt; class Rational (n:Int, d:Int) &#123; | require(d!=0) | override def toString = n + &quot;/&quot; +d | &#125;defined class Rationalscala&gt; new Rational(5,0)java.lang.IllegalArgumentException: requirement failed at scala.Predef$.require(Predef.scala:211) ... 33 elided 可以看到，如果再使用 0 作为分母，系统将抛出 IllegalArgumentException 异常 添加成员变量前面我们定义了 Rational 的主构造函数，并检查了输入不允许分母为 0 。 下面我们就可以开始实现两个 Rational 对象相加的操作。我们需要实现的是 函数化对象，因此 Rational 的加法操作应该是返回一个新的 Rational 对象，而不是返回被相加的对象本身。我们很可能写出如下的实现： 123456class Rational (n:Int, d:Int) &#123; require(d!=0) override def toString = n + &quot;/&quot; +d def add(that:Rational) : Rational = new Rational(n*that.d + that.n*d,d*that.d)&#125; 实际上编译器会给出如下编译错误: 12345&lt;console&gt;:11: error: value d is not a member of Rational new Rational(n*that.d + that.n*d,d*that.d) ^&lt;console&gt;:11: error: value d is not a member of Rational new Rational(n*that.d + that.n*d,d*that.d) 这是为什么呢？尽管类参数在新定义的函数的访问范围之内，但仅限于定义类的方法本身(比如之前定义的 toString 方法，可以直接访问类参数），但对于 that 来说，无法使用 that.d 来访问 d 。因为 that 不在定义的类可以访问的范围之内。此时需要定义为类的成员变量。（注：后面定义的 case class 类型编译器自动把类参数定义为类的属性，这时可以使用 that.d 等来访问类参数）。 修改 Rational 定义，使用成员变量定义如下： 1234567891011class Rational (n:Int, d:Int) &#123; require(d!=0) val number =n val denom =d override def toString = number + &quot;/&quot; +denom def add(that:Rational) = new Rational( number * that.denom + that.number* denom, denom * that.denom )&#125; 要注意的是，我们这里定义成员变量都使用了 val , 因为我们实现的是“immutable”类型的类定义。 number 和 denom 以及 add 都可以不定义类型，Scala 编译器能够根据上下文推算出它们的类型。 1234567891011scala&gt; val oneHalf=new Rational(1,2)oneHalf: Rational = 1/2scala&gt; val twoThirds=new Rational(2,3)twoThirds: Rational = 2/3scala&gt; oneHalf add twoThirdsres0: Rational = 7/6scala&gt; oneHalf.numberres1: Int = 1 可以看到，这时就可以使用 .number 等来访问类的成员变量。 自身引用Scala 也适用 this 来引用当前对象本身，一般来说访问类成员时无需使用 this，比如实现一个 lessThan 方法，下面两种实现是等效的。 第一种： 12def lessThan(that:Rational) = this.number * that.denom &lt; that.number * this.denom 第二种： 12def lessThan(that:Rational) = number * that.denom &lt; that.number * denom 但如果需要引入对象自身，*this*** 就无法省略，比如下面实现一个返回两个 *Rational*** 中比较大的一个值： 12def max(that:Rational) = if(lessThan(that)) that else this 其中的 this 就无法省略 辅助构造函数在定义类时，很多时候需要定义多个构造函数，在Scala中，除主构造函数之外的构造函数都成为辅助构造函数（或是从构造函数），比如对于 Rational 类来说，如果定义一个整数，就没有必要指明分母，此时只要整数本身就可以定义这个有理数。 我们可以为 Rational 定义一个辅助构造函数， Scala 定义辅助构造函数使用 this(……) 的语法，所有辅助构造函数名称为 this 1def this(n:Int) = this(n,1) 所有Scala的辅助构造函数的第一个语句都为调用其他构造函数，也就是 this(……)。被调用的构造函数可以是主构造函数或是其他构造函数（最终会调用柱构造函数）。 这样使得每个构造函数最终都会调用主构造函数，从而使得柱构造函数称为创建类单一入口点。在Scala中也只有柱构造函数才能调用基类的构造函数，这种限制有它的有点，使得Scala构造函数更加简洁以及提高一致性 私有成员变量和方法Scala类定义私有成员的方法也是使用 private 修饰符，为了实现 Rational 的规范化显示，我们需要使用一个求分子和分母的最大公约数的私有方法 gcd. 同时我们使用一个私有变量 g 来保存最大公约数，修改 Rational 的定义： 123456789101112131415class Rational (n:Int, d:Int) &#123; require(d!=0) private val g =gcd (n.abs,d.abs) val number =n/g val denom =d/g override def toString = number + &quot;/&quot; +denom def add(that:Rational) = new Rational( number * that.denom + that.number* denom, denom * that.denom ) def this(n:Int) = this(n,1) private def gcd(a:Int,b:Int):Int = if(b==0) a else gcd(b, a % b)&#125; 12scala&gt; new Rational ( 66,42)res0: Rational = 11/7 注意gcd的定义，因为他是个 回溯 函数，必须定义返回值类型。Scala 会根据成员变量出现的顺序依次初始化他们，因此 g 必须出现在 number 和 denom 之前 定义运算符我们使用 add 定义两个 Rational 对象的加法。两个 Rational 加法可以写成 x.add(y) 或者 x add y。 即使使用 x add y 还是没有 x + y 来得简洁 我们在前面说过，在Scala中，运算符（操作符）和普通的方法没有什么区别，任何方法都可以写成操作符的语法。比如上面的 x add y 而在 Scala 中对方法的名称也没有什么特别的限制，你可以使用符号作为类方法的名称，比如使用 +、*-*** 和 ***等符号。因此我们可以重新定义 *Rational*** 如下： 1234567891011121314151617class Rational (n:Int, d:Int) &#123; require(d!=0) private val g =gcd (n.abs,d.abs) val numer =n/g val denom =d/g override def toString = numer + &quot;/&quot; +denom def +(that:Rational) = new Rational( numer * that.denom + that.numer* denom, denom * that.denom ) def * (that:Rational) = new Rational( numer * that.numer, denom * that.denom) def this(n:Int) = this(n,1) private def gcd(a:Int,b:Int):Int = if(b==0) a else gcd(b, a % b)&#125; 这样就可以使用 + 、 * 号来实现Rational的加法和乘法。 +、***的优先级是 Scala 预设的，和整数的 +、*-**、** 和 */*** 的优先级一样。 下面为使用 Rational 的例子： 1234567891011scala&gt; val x= new Rational(1,2)x: Rational = 1/2scala&gt; val y=new Rational(2,3)y: Rational = 2/3scala&gt; x+yres0: Rational = 7/6scala&gt; x+ x*yres1: Rational = 5/6 从这个例子也可以看出 Scala 语言的扩展性， 你使用 Rational 对象就像 Scala 内置的数据类型一样。 Scala 中的标识符从前面的例子我们可以看到Scala可以使用两种形式的标志符， 字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号 $ 在Scala 中也看做字母。然而以 $ 开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用 $ 开始的标识符，以免造成冲突 Scala 的命名规则采用和 Java 类似的 camel 命名规则（驼峰命名法），首字符小写，比如 toString 。类名的首字符还是使用大写。此外也应该避免使用以下划线结尾的标志符以避免冲突 符号标志符包含一个或多个符号，如 + 、*:*** 和 *?*。对于 *+、++、:::、:-&gt;*之类的符号，Scala内部实现时会使用转义的标志符。例如对 *:-&gt;* 使用 *$colon$minus$greater*** 来表示这个符号。因此，如果你需要在Java代码中访问 :-&gt; 方法，你需要使用 Scala 的内部名称 $colon$minus$greater。 混合标志符由字符数字标志符后面跟着一个或多个符号组成，比如 unary_+ 为Scala 对 + 方法的内部实现时的名称。 字面量标志符为 使用 “ 定义的字符串，比如 “x” 、 “yield”。 你可以在 “ 之间使用任何有效的Scala标志符，Scala将他们解释为一个Scala标志符，一个典型的使用是 Thread 的 yield 方法，在Scala中你不能使用 Thread.yield() 是因为 yield 为 Scala 中的关键字，你必须使用 Thread.”yield”() 来使用这个方法 方法重载和 Java 一样， Scala也支持方法重载，重载的方法参数类型不同却使用同样的方法名称， 比如对于 Ratioinal 对象， + 的对象可以为另一个 Rational 对象，也可以为一个 Int 对象，此时你可以重载 + 方法以支持和 Int 相加 12def + (i:Int) = new Rational (numer + i * denom, denom) 隐式类型转换上面我们定义 Rational 的加法，并重载 + 以支持整数， r+2, 但如果我们需要 2+r 如何呢？下面例子 12345678910111213141516171819202122232425262728scala&gt; val x =new Rational(2,3)x: Rational = 2/3scala&gt; val y = new Rational(3,7)y: Rational = 3/7scala&gt; val z = 4z: Int = 4scala&gt; x + zres0: Rational = 14/3scala&gt; x + 3res1: Rational = 11/3scala&gt; 3 + x&lt;console&gt;:10: error: overloaded method value + with alternatives: (x: Double)Double &lt;and&gt; (x: Float)Float &lt;and&gt; (x: Long)Long &lt;and&gt; (x: Int)Int &lt;and&gt; (x: Char)Int &lt;and&gt; (x: Short)Int &lt;and&gt; (x: Byte)Int &lt;and&gt; (x: String)String cannot be applied to (Rational) 3 + x ^ 可以看到 x+3 没有问题， 3+x就报错了，这是因为整数类型不支持和 Rational 相加。 我们不可能去修改 Int 的定义（除非你重写Scala的 Int 定义） 以支持 Int 和 Rational 相加。 如果你写过 .net 代码，这可以通过静态扩展方法来实现， Scala 提供了类似的机制来解决这种问题。 如果 Int 类型能够根据需要自动转换为 Rational 类型， 那么 3 + x 就可以相加。 Scala 通过 implicit def 定义一个隐含类型转换，比如定义由整数到 Rational 类型的转换如下 1implicit def intToRational(x:Int) = new Rational(x) 再次重新计算 r + 2 和 2 + r 的例子： 12345678scala&gt; val r = new Rational(2,3)r: Rational = 2/3scala&gt; r + 2res0: Rational = 8/3scala&gt; 2 + rres1: Rational = 8/3 其实此时 Rational 的一个 + 重载方法时多余的，当Scala计算 2 + r，发现 2(Int) 类型没有可以和 Rational 对象相加的方法， 类型转换后的类型支持 +r , 一检查发现定义了由 Int 到 Rational 的隐含转换方法，就自动调用该方法，把整数转换为 Rational 数据类型， 然后调用 Rational 对象的 + 方法。 从而实现了 Rational 类或是 Int 类的扩展。 关于 implicit def 的详细介绍将由后面的文章来说明，隐含类型转换在设计Scala库时非常有用。","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"},{"name":"类和对象","slug":"类和对象","permalink":"https://bawcat.wiki/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"}]},{"title":"Scala 类和对象 （一）","slug":"大数据/scala/类和对象（一）","date":"2020-01-10T03:30:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/10/大数据/scala/类和对象（一）/","link":"","permalink":"https://bawcat.wiki/2020/01/10/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Scala 类和对象 （一）类和对象的定义首先介绍Scala的类定义，我们以一个简单的例子开始，创建一个计算整数累计校验和类 ChecksumAccumulator 12345class ChecksumAccumulator &#123; private var sum=0; def add(b:Byte) :Unit = sum+=b def Checksum() : Int = ~ (sum &amp; 0xFF) + 1&#125; 可以看到Scala类定义和Java非常类似，也是以 class 开始，和Java 不同的，Scala的缺省修饰符为 public， 也就是如果不带有访问范围的修饰符 public、protected、private等，Scala将默认定义为 public。 类的方法以 def定义开始，要注意的是Scala的方法的参数都是 val 类型，而不是 var 类型， 因此在函数体内不可以修改参数的值，比如：如果你修改 add 方法如下： 1234def add(b:Byte) :Unit = &#123; b=1; sum+=b;&#125; 此时编译器会报错： 类的方法分两种，一种是有返回值的，一种是不包含返回值的，没有返回值的主要是利用代码的”副作用”,比如修改类的成员变量的值或者读写文件等。Scala内部其实将这种函数的返回值定位 Unit（类同Java的void类型），对于这种类型的方法，可以省略掉 = 号，因此如果你希望函数返回某个值，淡忘了方法定义中的 = ，Scala会忽略方法的返回值，而返回 Unit 再强调一下，Scala 代码无需使用 ； 结尾，也不需要使用 return 返回值，函数的最后一行的值就作为函数的返回值 但如果你需要在一行中书写多个语句，此时需要使用 ； 隔开，不过不建议这么做。你也可以把一条语句分成几行书写，Scala 编译器大部分情况下会推算出语句的结尾，不过这样也不是一个好的编码习惯。 对象Scala 比 Java 更加面向对象，这是因为Scala不允许类保护静态元素（静态变量或者静态方法）。在Scala中提供类似功能的是称为“*Singleton***（单例对象）”的对象。在Scala中定义 *Singleton*** 对象的方法，除了使用 object 而非 class 关键字外，其他方式和类定义非常类似。下面例子创建一个 ChecksumAccumulator 对象： 1234567891011121314object ChecksumAccumulator &#123; private val cache = Map [String, Int] () def calculate(s:String) : Int = if(cache.contains(s)) cache(s) else &#123; val acc=new ChecksumAccumulator for( c &lt;- s) acc.add(c.toByte) val cs=acc.checksum() cache += ( s -&gt; cs) cs &#125;&#125; 这个对象和上一个创建的类 ChecksumAccumulator 同名， 这在Scala中把这个对象称为其同名的类的“伴侣”对象（Companion object)。如果你需要定义类的 companion 对象，Scala 要求你把这两个定义放在同一个文件中。类和其 companion 对象可以互相访问对方的私有成员。 如果你是 Java 程序员，可以把 Singleton 对象看成以前 Java 定义静态成员的地方。你可以使用类似 Java 静态方法的方式调用 Singleton 对象的方法，比如下面为这个例子完整的代码 123456789101112131415161718192021222324import scala.collection.mutable.Mapclass ChecksumAccumulator&#123; private var sum=0 def add(b:Byte) :Unit = sum +=b def checksum() : Int = ~ (sum &amp; 0xFF) +1&#125;object ChecksumAccumulator &#123; private val cache = Map [String, Int] () def calculate(s:String) : Int = if(cache.contains(s)) cache(s) else &#123; val acc=new ChecksumAccumulator for( c &lt;- s) acc.add(c.toByte) val cs=acc.checksum() cache += ( s -&gt; cs) cs &#125;&#125;println ( ChecksumAccumulator.calculate(&quot;Welcome to Scala Chinese community&quot;)) Scala 的 singleton 对象不仅仅局限于作为静态对象的容器，它在 Scala 中也是头等公民，但仅仅定义 Singleton 对象本身不会创建一个新的类型，你不可以使用 new 再创建一个新的 Singleton 对象（这也是 Singleton 名字的由来），此外和类定义不同的是，singleton 对象不可以带参数（类定义参数将在后面的内容中介绍）。 回过头来看看我们的第一个例子“Hello World”。 12345object HelloWorld &#123; def main(args: Array[String])&#123; println(&quot;Hello, world!&quot;) &#125;&#125; 这是一个最简单的 Scala 程序，*HelloWorld*** 是一个 *Singleton*** 对象，它包含一个 main 方法（ 可以支持命令行参数）。和Java类似，Scala中任何 Singleton 对象，如果包含 main 方法 ， 都可以作为应用的入口点。 在这里要说明一点的是，在 Scala 中不要求 public 类定义和其文件名同名，不过使用 public 类和文件同名还是有它的有点的，你可以根据个人喜好决定是否遵循Java文件命名风格。 最后提一下Scala的 Trait 功能， Scala的 Trait 和 Java 的 Interface 相比，可以有方法的实现（这点有点像抽象类，但如果是抽象类，就不会允许继承多个抽象类）。 Scala的 Trait 支持类和 Singleton 对象以及多个 Trait 混合 （使用来自这些 Trait 中的方法，而不是不违反单一继承的原则）。","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"},{"name":"类和对象","slug":"类和对象","permalink":"https://bawcat.wiki/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"}]},{"title":"Scala 基本数据类型","slug":"大数据/scala/基础数据类型","date":"2020-01-09T07:28:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/09/大数据/scala/基础数据类型/","link":"","permalink":"https://bawcat.wiki/2020/01/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Scala 基本数据类型基本数据类型简介如果你是个Java 程序员，你会发现 Java 支持的基本数据类型，Scala都有对应的支持，不过Scala的数据类型都是对象（比如整数），这些基本类型都可以通过隐式自动转换的形式支持比 Java 基本数据类型更多的方法。 隐式自动转换的概念将在后面介绍，简单的说就是可以为基本类型提供扩展，比如如果调用 (-1).abs() , Scala 发现基本类型Int没有提供 abs() 方法，但可以发现系统提供了从 Int 类型转换为 RichInt 的隐式自动转换，而 RichInt 具有 abs() 方法, 那么Scala就自动将 1 转换为 RichInt 类型， 然后调用 RichInt 的 abs 方法。 Scala 的基本数据类型有： Byte、Short、Int、Long 和 char （这些称为整数类型）。 整数类型加上 Float 和 Double 称为数值类型。 此外还有 String 类型，除 String 类型在 java.lang 包中定义，其他的类型都定义在包 scala 中。 比如 Int 的全名为 scala.Int 。实际上 Scala 运行环境自动会载入包 scala 和 java.lang 中定义的数据类型，你可以直接使用 Int、Short、String 而无需再引入包或是使用全称。 下面的例子给出了这些基本数据类型的字面量用法，由于Scala支持数据类型推断，你在定义变量时多数可以不指明数据类型，而是由 Scala 运行环境自动给出变量的数据类型： 1234567891011121314151617181920212223242526272829303132333435Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).Type in expressions for evaluation. Or try :help.scala&gt; var hex=0x5hex: Int = 5scala&gt; var hex2=0x00ffhex2: Int = 255scala&gt; val prog=0xcafebabelprog: Long = 3405691582scala&gt; val littler:Byte= 38littler: Byte = 38scala&gt; val big=1.23232big: Double = 1.23232scala&gt; val a=&#x27;A&#x27;a: Char = Ascala&gt; val f =&#x27;\\u0041&#x27;f: Char = Ascala&gt; val hello=&quot;hello&quot;hello: String = helloscala&gt; val longString=&quot;&quot;&quot; Welcome to Ultamix 3000. Type &quot;Help&quot; for help.&quot;&quot;&quot;longString: String = &quot; Welcome to Ultamix 3000. Type &quot;Help&quot; for help.&quot;scala&gt; val bool=truebool: Boolean = truescala&gt; Scala 的基本数据类型的字面量也支持方法（这点和Java不同，Scala中所有的数值字面量也是对象）,比如： 123456789101112scala&gt; (-2.7).absres3: Double = 2.7scala&gt; -2.7 abswarning: there were 1 feature warning(s); re-run with -feature for detailsres4: Double = 2.7scala&gt; 0 max 5res5: Int = 5scala&gt; 4 to 6res6: scala.collection.immutable.Range.Inclusive = Range(4, 5, 6) 这些方法其实是对于数据类型的 Rich 类型的方法，**Rich** 类型将在后面再做详细介绍 操作基本数据类型Scala 提供了 丰富的运算符用来操作前面介绍的基本数据类型。前面说过，这些运算符（操作符）实际为普通类方法的简化（或者称为美化）表示。比如 1+2 ，实际为 (1).+(2) , 也就是调用 Int 类型的 + 方法 例如 ： 12scala&gt; val sumMore = (1).+(2)sumMore: Int = 3 实际上类 Int 定义了多个 + 方法的重载方法(以支持不同的数据类型)，比如： 和 Long 类型相加。 + 符号是一个运算符，并且是一个中缀运算符。在 Scala中你可以定义任何方法为一操作符。比如 String 的 IndexOf 方法也可以使用操作符的语法来书写。 例如： 12345scala&gt; val s =&quot;Hello, World&quot;s: String = Hello, Worldscala&gt; s indexOf &#x27;o&#x27;res0: Int = 4 由此可以看出，运算符在Scala 中并不是什么特殊的语法，任何Scala方法都可以作为操作符来使用。是否是操作符取决于你使用这个方法， 当你使用 s.indexOf(‘o’) 时， indexOf 不是一个运算符。而你写成 s indexOf ‘o’ , indexOf 就是一个操作符，因为你使用了操作符的语法。 除了类似 + 的中缀运算符（操作符在两个操作符之间），还可以有前缀运算符和后缀运算符。顾名思义，前缀运算符的操作符在操作数前面，比如 -7 前面的 - 。后缀运算符的运算符在操作数的后面，比如 7 toLong 中的 toLong 。 前缀和后缀操作符都使用一个操作数，而中缀运算符使用前后两个操作数。Scala 在实现前缀和后缀操作符的方法，其方法名都以 unary_- 开头。 比如，表达式 -2.0 实际上调用 (2.0).unary_- 方法。 12345scala&gt; -2.0res1: Double = -2.0scala&gt; (2.0).unary_-res2: Double = -2.0 如果你需要定义前缀方法，你只能使用 +、*-**、!* 和 *~***四个符号作为前缀操作符。 后缀操作符在不使用 . 和括号调用时不带任何参数。在 Scala 中，你可以省略掉没有参数的方法调用的空括号。 按照惯例，如果你调用方法是为了利用方法的“副作用”， 此时写上空括号，如果方法没有任何副作用（没有修改其他程序状态），你可以省略掉括号。 比如： 123456scala&gt; val s = &quot;Hello, World&quot;s: String = Hello,Worldscala&gt; s toLowerCasewarning: there was one feature warning; re-run with -feature for detailsres0: String = hello,world 具体 Scala 的基本数据类型支持的操作符，可以参考Scala API 文档。 下面以示例介绍一些常用的操作符 算数运算符（包括+、-、x 和 /）1234567891011121314scala&gt; 1.2 + 2.3res0: Double = 3.5scala&gt; &#x27;b&#x27; -&#x27;a&#x27;res1: Int = 1scala&gt; 11 % 4 #取余res2: Int = 3scala&gt; 11.0f / 4.0fres3: Float = 2.75scala&gt; 2L * 3Lres4: Long = 6 关系和逻辑运算符（包括 &gt; 、&lt; 、&gt;= 和 ! 等）1234567891011121314151617scala&gt; 1 &gt;2res5: Boolean = falsescala&gt; 1.0 &lt;= 1.0res6: Boolean = truescala&gt; val thisIsBoring = !truethisIsBoring: Boolean = falsescala&gt; !thisIsBoringres7: Boolean = truescala&gt; val toBe=truetoBe: Boolean = truescala&gt; val question = toBe || ! toBe #表示逻辑或question: Boolean = true 要注意的是，逻辑运算支持“短路运算”,比如 op1 || op2 ,当 op1=true， op2 无需再计算，就可以知道结果为 true。 这时 op2 表达式不会执行。例如 1234567891011121314scala&gt; def salt()= &#123; println(&quot;salt&quot;);false&#125;salt: ()Booleanscala&gt; def pepper() =&#123;println(&quot;pepper&quot;);true&#125;pepper: ()Booleanscala&gt; pepper() &amp;&amp; salt() #表示逻辑与peppersaltres0: Boolean = falsescala&gt; salt() &amp;&amp; pepper()saltres1: Boolean = false 位操作符（包括&amp;、|、^、~）1234567891011scala&gt; 1 &amp; 2res2: Int = 0scala&gt; 1 | 2res3: Int = 3scala&gt; 1 ^ 2res4: Int = 3scala&gt; ~1res5: Int = -2 对象恒等比较如果需要比较两个对象是否相等，可以使用 == 和 != 操作符 1234567891011scala&gt; 1 == 2res6: Boolean = falsescala&gt; 1 !=2res7: Boolean = truescala&gt; List(1,2,3) == List (1,2,3)res8: Boolean = truescala&gt; (&quot;he&quot;+&quot;llo&quot;) == &quot;hello&quot;res9: Boolean = true Scala 的 == 和 Java不同，Scala的 == 只用于比较两个对象的值是否相同。而对于引用类型的比较使用另外的操作符 eq 和 ne 操作符的优先级和左右结合性Scala 的 操作符的优先级和 Java基本相同，如果有困惑时，可以使用 () 改变操作符的优先级。操作符一般为左结合，Scala规定了操作符的结合性由操作符的最后一个字符定义。对于以 : 结尾的操作符都是右结合，其他的操作符多是左结合。 例如： a\\b* 为 a.\\(b)*,而 a:::b 为 b.:::(a)， 而 a:::b:::c 等价于 a:::(b:::c) , a\\b*c* 等价于 (a\\b)*c* 基本数据类型的实现方法 当前内容可能需要部分后面章节的知识作为基础。若理解有困难，可以尝试学习后续课程后在返回查看 Scala 的基本数据类型是如何实现的呢？实际上，Scala 以和 Java 同样的方式存储整数：把它当作 32 位的字类型。这对于有效使用 JVM 平台和与 Java 库的互操作性方面来说都很重要。 标准的操作，如加法或乘法，都被实现为数据类型基本运算操作。然而，当整数需要被当作（Java）对象看待的时候， Scala 使用了“备份”类 java.lang.Integer 。如在整数上调用 toString 方法或者把整数赋值给 Any 类型的变量时，就会这么做。当需要的时候， Int 类型的整数能自动转换为 java.lang.Integer 类型的“装箱整数( boxed integer )”。 这些听上去和 Java 的 box 操作很像，实际上它们也很像，但这里有一个重要的差异，Scala 使用 box 操作比在 Java 中要少的多： 12345// Java 代码boolean isEqual(int x, int y) &#123; return x == y;&#125;System.out.println(isEqual(421,421)); 你当然会得到 true 。 现在， 把isEqual 的参数类型变为 java.lang.Integer （或 Object , 结果都一样）: 12345// Java代码 boolean isEqual(Integer x, Integer y) &#123; return x == y; &#125; System.out.println(isEqual(421,421)); 你会发现你得到了 false 的原因是，数 421 使用 box 操作了两次，因此参数 x 和 y 是两个不同的对象。因为在引用类型上，== 表示引用相等，而 Integer 是引用类型，所以结果是 false 。这是展示了 Java 不是纯面向对象语言的一个方面。我们能清楚观察到基本数据值类型和引用类型之间的差别。 现在在 Scala 里尝试同样的实验： 1234567891011scala&gt; def isEqual(x:Int,y:Int) = x == yisEqual: (x: Int, y: Int)Booleanscala&gt; isEqual(421,421)res0: Boolean = truescala&gt; def isEqual(x:Any,y:Any) = x == yisEqual: (x: Any, y: Any)Booleanscala&gt; isEqual(421,421)res1: Boolean = true Scala 的 == 设计出自动适应变量类型的操作，对值类型来说，就是自然的（数学或布尔）相等。对于引用类型，== 被视为继承自 Object 的 equals 方法的别名。比如对于字符串比较： 12345678scala&gt; val x = &quot;abcd&quot;.substring(2)x: String = cdscala&gt; val y = &quot;abcd&quot;.substring(2)y: String = cdscala&gt; x==yres0: Boolean = true 而在 Java 里，x 与 y 的比较结果将是 false。程序员在这种情况应该用 equals，不过它容易被忘记。 然而，有些情况下，你可能需要使用引用相等代替用户定义的相等。例如，某些时候效率是首要因素，你想要把某些类进行哈希合并（ hash cons ），然后通过引用相等比较它们的实例。为了满足这种情况，类 AnyRef 定义了附加的 eq 方法，它不能被重载并且实现为引用相等（也就是说，它表现得就像Java里对于引用类型的 == 那样）。同样也有一个 eq 的反义词，被称为 ne 。例如： 1234567891011121314scala&gt; val x =new String(&quot;abc&quot;)x: String = abcscala&gt; val y = new String(&quot;abc&quot;)y: String = abcscala&gt; x == yres0: Boolean = truescala&gt; x eq yres1: Boolean = falsescala&gt; x ne yres2: Boolean = true","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"},{"name":"基础数据类型","slug":"基础数据类型","permalink":"https://bawcat.wiki/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"开始学习Scala","slug":"大数据/scala/开始学习Scala","date":"2020-01-09T07:28:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/09/大数据/scala/开始学习Scala/","link":"","permalink":"https://bawcat.wiki/2020/01/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Scala/","excerpt":"","text":"开始学习Scala 老规矩，请您先自行安装 Scala 开始使用 Scala 的最简单的方式是使用交互式 Scala 解释器，只要输入 Scala 表达式， Scala 解释器会立即解释执行该语句并输出结果。当然你也可以使用如 Scala IDE 或 IntelliJ IDEA 集成开发环境。不过本教程开始还是以这种交互式 Scala 解释器为主。 开始使用 Scala 的最简单的方式是使用交互式 Scala 解释器，只要输入 Scala 表达式， Scala 解释器会立即解释执行该语句并输出结果。当然你也可以使用如 Scala IDE 或 IntelliJ IDEA 集成开发环境。不过本教程开始还是以这种交互式 Scala 解释器为主。 你可以使用 :help 命令列出一些常用的 Scala 解释器命令 退出Scala解释器，输入: 1:quit 使用表达式在 scala &gt; 提示符下，你可以输入任意的Scala表达式，比如输入 1+2 ,解释器显示： 11+2 输入上面的表达式 结果显示包括： 一个由Scala解释器自动生成的变量名或者由你指定的变量名用来指向计算出来的结果（比如 res0 代表 result0 变量） 一个冒号，后来紧跟个变量类型比如 Int 一个等于号 = 计算结果，本例为 1+2的结果 3 resX 变量名会用在之后得到表达式中, 比如: 此时 res0=3, 如果输入 *res0 3**, 则显示 *res1: Int =9*** 。 定义一些变量Scala 定义了两种类型的变量 val 和 var, val 类似于Java中的 final 变量，一旦初始化之后，不可以重新复制（我们可以称它为 常变量）.而 var 类似于一般的非 final 变量。 可以任意重新赋值。 比如定义一个字符串常变量： 12scala&gt; val msg = &quot;Hello,World&quot;msg：String = Hello,World 这个表达式定义了一个msg变量，为字符串常量。它的类型为 string(java.lang.string). 可以看到我们在定义这个变量是并不需要像Java一样定义其类型，Scala可以根据赋值的内容推算出变量的类型。这在Scala语言中称为”type inference”(类型推断)。 当然如果你愿意，你也可以采用和Java一样的方法，明确指定变量的类型，如： 12scala&gt; val msg2:String =&quot;Hello again,world&quot;msg2: String = Hello again,world 不过这样写就显得不像 Scala 风格了。此外 Scala 语句也不需要以分号结尾。 如果在命令行中需要分多行输入， Scala 解释器在新行前面显示 |，表示该行接着上一行。比如： 123scala&gt; val msg3= | &quot;Hello world 3rd time&quot;msg3: String = Hello world 3rd time 定义一些函数Scala 既是面向对象的编程语言，也是面向函数的编程语言，因此函数在 Scala 语言中的地位和类是同等的。下面的代码定义了一个简单的函数求两个值的最大值： 123456scala&gt; def max(x:Int,y:Int) : Int =&#123; | if (x &gt;y) x | else | y | &#125;max: (x: Int, y: Int)Int Scala 函数以 def 定义，之后是函数的名称（如 max )，然后是以逗号分隔的参数。Scala 中变量类型是放在参数和变量的后面，以 ： 隔开。这样做的一个好处是便于“ type inference ”。刚开始有些不习惯（如果你是 Pascal 程序员可能会觉得很亲切）。同样如果函数需要返回值，它的类型也是定义在参数的后面（实际上每个Scala函数都有返回值，只是有些返回值类型为 Unit ，类似于 void 类型）。 此外每个 Scala 表达式都有返回结果（这一点和 Java，C# 等语言不同），比如 Scala 的 if else 语句也是有返回值的，因此函数返回结果无需使用 return 语句。实际上在Scala代码中应当尽量避免使用 return 语句。函数的最后一个表达式的值就可以作为函数的结果进行返回。 同样由于 Scala 的“ type inference ”特点，本例其实无需指定返回值的类型。对于大多数函数 Scala 都可以推测出函数返回值的类型，但目前来说回溯函数（函数调用自身）还是需要指明返回结果类型的。 下面再定义个“没有”返回结果的函数（其它语言可能称这种无返回值的函数为程式）。 12scala&gt; def greet() = println(&quot;hello,world&quot;)greet: ()Unit greet 函数的返回值类型为 Unit ，表示该函数不返回任何有意义的值，Unit 类似于 Java 中的 void 类型。这种类型的函数主要用来获得函数的“副作用”，比如本函数的副作用是打印招呼语。 使用while 实现循环下面的代码使用 while 实现一个循环： 123456val args = Array(&quot;I&quot;,&quot;like&quot;,&quot;scala&quot;)var i=0while (i &lt; args.length) &#123; println (args(i)) i+=1&#125; 这里要注意的是Scala不支持++i和i++的运算符，因此需要使用 i += 1 来加一。这段代码看起来和Java代码差不多，实际上 while 也是一个函数，你自然可以利用Scala语言的扩展性，实现while语句，使它看起来和Scala语言自带的关键字一样调用。 Scala 访问数组的语法是使用 () 来实现循环，但这种实现循环的方法并不是最好的 Scala 风格，在下一步介绍使用一种更好的方法来避免通过索引来枚举数组元素。 使用 foreach 和 for 来实现迭代在实验3.4中使用 while 来实现循环， 和使用Java实现无太大差异，而 Scala 是面向函数的语言，更好的方法时采用”函数式” 风格来编写代码。比如上面的循环，使用foreach方法如下： 1args.foreach(arg =&gt; println(arg)) 该表达式，调用 args 的 foreach 方法，传入一个参数，这个参数类型也是一个函数( lambad 表达式，和C#中的概念类似)。这段代码可以再写的精简些，你可以利用Scala支持的缩写形式，如果一个函数只有一个参数并且只包含一个表达式，那么你无需明确指明参数。因此上面的代码可以写成： 1args.foreach(println) Scala 中也提供了一个称为” for comprehension” 的功能，它比Java中的 for 功能更强大。 “for comprehension” (可称之为 for 表达式) 将在后面介绍，这里先试用 for 来实现前面的例子： 12for(arg &lt;-args) println(arg) 使用类型参数化数组在Scala 中，你可以使用new 来实例化一个类。当你创建一个对象的实例时，你可以使用数值或类型参数。如果使用类型参数，它的作用类似Java或 .net 的 Generic 类型。所不同的是，Scala使用方括号来指明数据类型参数，而非尖括号。比如： 123456val greetStrings = new Array[String](3);greetStrings(0) = &quot;hello&quot;greetStrings(1) = &quot;,&quot;greetStrings(2) = &quot;world!\\n&quot;for(i &lt;- 0 to 2) print(greetStrings(i)) 可以看到 Scala 使用 [] 来为数组指明类型化参数，本例使用 String 类型，数组使用 () 而非 [] 来指明数组的索引。其中的 for 表达式中使用到 0 to 2 ，这个表达式演示了 Scala 的一个基本规则，如果一个方法只有一个参数，你可以不用括号和 . 来调用这个方法。 因此这里的 0 to 2， 其实为 (0).to(2) 调用的为整数类型的 to 方法，to 方法使用一个参数。Scala 中所有的基本数据类型也是对象（和 Java 不同），因此 0 可以有方法（实际上调用的是 RichInt 的方法），这种只有一个参数的方法可以使用操作符的写法（不用 . 和括号），实际上 Scala 中表达式 1+2 ，最终解释为 (1).+(2)+，这也是 Int 的一个方法，和 Java 不同的是，Scala 对方法的名称没有太多的限制，你可以使用符号作为方法的名称。 这里也说明为什么 Scala 中使用 () 来访问数组元素，在 Scala 中，数组和其它普遍的类定义一样，没有什么特别之处，当你在某个值后面使用 () 时，Scala 将其翻译成对应对象的 apply 方法。因此本例中 greetStrings(1) 其实是调用 greetString.apply(1) 方法。这种表达方法不仅仅只限于数组，对于任何对象，如果在其后面使用 () ，都将调用该对象的 apply 方法。同样的如果对某个使用 () 的对象赋值，比如： 1greetStrings(0) = &quot;Hello&quot; Scala 将这种赋值转换为该对象的 update 方法， 也就是 greetStrings.update(0,”hello”) 。因此上面的例子，使用传统的方法调用可以写成： 123456val greetStrings =new Array[String](3)greetStrings.update(0,&quot;Hello&quot;)greetStrings.update(1,&quot;,&quot;)greetStrings.update(2,&quot;world!\\n&quot;)for(i &lt;- 0 to 2) print(greetStrings.apply(i)) 从这点来说，数组在 Scala 中并不是某种特殊的数据类型，和普通的类没有什么不同。 不过 Scala 还是提供了初始化数组的简单方法，比如上面的例子数组可以使用如下代码： 1val greetStrings =Array(&quot;Hello&quot;,&quot;,&quot;,&quot;World\\n&quot;) 这里使用 () 其实还是调用 Array 类的关联对象 Array 的 apply 方法，也就是： 1val greetStrings =Array.apply(&quot;Hello&quot;,&quot;,&quot;,&quot;World\\n&quot;) 使用ListsScala 也是一个面向函数的编程语言，面向函数的编程语言的一个特点是，调用某个方法不应该有任何副作用，参数一定，调用该方法后，返回一定的结果，而不会去修改程序的其他状态（副作用）。这样做的一个好处是方法和方法之间关联性较小，从而方法变得更加可靠和重用性高。使用这个原则也就意味着需要把变量设为不可修改的，这也就避免访问的互锁问题。 前面介绍的数组，它的元素是可以被修改的。如果需要使用不可以修改的序列，Scala中提供了 Lists 类。和Java的 List 不同，Scala的 Lists 对象是不可修改的。它被设计用来满足函数编程风格的代码。它有点像Java 的 String，*String*** 也是不可以修改的，如果需要可以修改的 *String*** 对象，可以使用 StringBUlider 类 比如下面的代码： 12345val oneTwo = List(1,2)val threeFour = List(3,4)val oneTwoThreeFour = oneTwo ::: threeFourprintln (oneTwo + &quot; and &quot; + threeFour + &quot; were not mutated. &quot;)println (&quot;Thus,&quot; + oneTwoThreeFour + &quot; is a new list&quot;) 定义了两个 List 对象 oneTwo 和 threeFour，然后通过 ::: 操作符 （其实为 ::: 方法） 将两个列表连接起来。实际上由于 List 的不可修改特性，Scala创建了一个新的 List 对象 oneTwoThreeFour 来保存两个列表连接后的值。 List 也提供了一个 :: 方法用来像 list 中添加一个元素， :: 方法（操作符）是右操作符，也就是使用 :: 右边的对象来调用它的 :: 方法，Scala 中的规定所有以 : 开头的操作符都是右操作符，因此如果你自己定义以 : 开头的方法（操作符）也是右操作符。 如下面使用常量创建一个列表： 12val oneTwoThree = 1 :: 2 :: 3 :: Nilprintln(oneTwoThree) 调用空列表兑现 Nil 的 :: 方法也就是： 1val oneTwoThree = Nil.::(3).::(2).::(1) Scala 的 List 类还定义了其他很多很有用的方法，比如 head、*last**、length*、**reverse、*tail***等。这里就不一一说明了，具体可以参考 *List*** 文档。 使用元组(Tuples)Scala 中另外一个很有用的容器类为 Tuples ，和 List 不同的是， Tuples 可以包含不同类型的数据，而 List 只能包含同类型的数据， Tuples 在方法需要返回多个结果时非常有用。（ Tuple 对应到数字的 矢量 的概念）。 一旦定义了一个元组，可以使用 ._ 和 索引 来访问元组的元素（矢量的分量，主义和数组不听的是，元组的索引从1开始）。 123val pair = (99,&quot;Luftballons&quot;)println(pair._1)println(pair._2) 元组的实际类型取决于它的分量的类型，比如上面的 pair 的类型实际为 Tuple2[Int,String] , 而 (‘u’,’r’,’the’,1,4,’me’) 的类型为 Tuple6[Char,Char,String,Int,Int,String] 目前Scala支持的元组的最大长度为22。如果有需要，你可以自己扩展更长的元组 使用Sets 和 MapsScala Set(集合)是没有重复对象的集合，所有的元素都是唯一的。 Scala 语言的一个设计目标是让程序员可以同时利用面向对象和面向函数的方法编写代码，因此它提供的集合类分成了可以修改的集合类和不可以修改的集合类两大类型。比如 Array 总是可以修改内容的，而 List 总是不可以修改内容的。类似的情况，*Scala*** 也提供了两种 *Sets*** 和 Maps 集合类。 比如 Scala API 定义了 set 的 基Trait 类型 Set ( Trait 的概念类似于Java中的 Interface ), 所不同的是Scala中的 Trait 可以有方法的实现，分两个包定义 Mutable (可变) 和 Immutable (不可变)， 使用同样名称的子 Trait。 使用 Set 的基本方法如下： 123var jetSet = Set(&quot;Boeing&quot;,&quot;Airbus&quot;)jetSet += &quot;Lear&quot;println(jetSet.contains(&quot;Cessna&quot;)) 缺省情况 Set 为 Immutable Set, 如果你需要使用可修改的集合类（*Set*** 类型）,你可以使用全路径来指明 *Set*** 比如 scala.collection.mutable.Set。 Scala 提供的另一个类型为 Map 类型，Map(映射)是一种可迭代的key/value结构，所有的值都可以通过键来获取。Scala也提供了 Mutable 和 Immutable 两种Map类型。 Map的基本用法如下（Map类似其他语言中的关联数组，如PHP） 12val romanNumeral = Map( 1 -&gt; &quot;I&quot;, 2 -&gt; &quot;II&quot;, 3 -&gt; &quot;III&quot;, 4 -&gt; &quot;IV&quot;, 5 -&gt; &quot;V&quot;)println(romanNumeral(4)) 学习识别函数编程风格Scala语言的一个特点是支持面向函数编程，因此学习Scala的一个重要方面是改变之前的指令时编程思想（尤其是来自Java或C#背景的程序员），观念要向函数式编程转变。首先在看代码上要认识哪种是指令编程，哪种是函数式编程，实现这种思想上的转变，不仅仅会使你成为一个更好的Scala程序员，同时也会扩展你的视野，使你成为一个更好的程序员。 一个简单的原则，如果代码中含有 var 类型的变量，这段代码就是传统的指令式编程，如果代码只有 val 变量，这段代码就很有可能是函数式代码，因此学会函数式编程关键是不适用 vars 来编写代码。 来看一看简单的例子： 1234567def printArgs ( args: Array[String]) : Unit = &#123; var i=0; while(i &lt; args.length)&#123; println (args(i)); i+=1; &#125;&#125; 来自Java 背景的程序员开始写Scala代码很有可能写成上面的实现。我们试着去除vars变量，可以写成更符合函数式编程的代码： 1234def printArgs(args: Array[String]) : Unit = &#123; for(arg &lt;- args) println(arg)&#125; 或者更简化为： 123def printArgs (args:Array[String]) : Unit = &#123; args.foreach(println)&#125; 这个例子也说明了尽量少用 vars 的好处，代码更简洁明了，从而也可以减少错误的发生。因此Scala编程的一个基本原则是，能不用 vars ，尽量不用 vars， 能不用 mutable变量，尽量不用 mutable 变量，能避免函数的副作用，就尽量不产生副作用。 读取文件使用脚本实现某个人物，通常需要读取文件，本节介绍Scala读写文件的基本方法。比如下面的例子读取文件的每行，把该行字符长度添加到行首： 123456import scala.io.Sourcevar args=Source.fromFile(&quot;/home/hadoop/test.text&quot;) # 记得在对应位置创建文件，并写入内容for( line &lt;- args.getLines) println(line.length + &quot;&quot; + line) 可以看到Scala引入包的方式和Java类似，也是通过 import 语句。文件相关的类定义在 scala.io 包中。如果需要引入多个类，Scala 使用 _而非 *","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"}]},{"title":"Scala 控制语句","slug":"大数据/scala/控制语句","date":"2020-01-09T07:28:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/09/大数据/scala/控制语句/","link":"","permalink":"https://bawcat.wiki/2020/01/09/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"Scala 控制语句Scala 的所有控制结构都有返回结果，如果你使用过 Java 或 C#， 就可能了解 Java 提供的三元运算符 ?: ,它的基本功能和 if 一样，都可以返回结果。 Scala在此基础上所有控制结构（ while、*try**、if***等） 都可以返回结果。这样做的一个好处是，可以简化代码，如果没有这种特点，程序员常常需要创建一个临时变量用来保存结果 总的来说，Scala提供的基本程序控制结构，”麻雀虽小，五脏俱全”,虽然少，但足够满足其他指令式语言（如 Java，C++）所支持的程序控制功能。而且，由于这些指令都有返回结果，可以使得代码更为精简。 if 表达式Scala 语言的 if 的基本功能和其他语言没有什么不同，它根据条件执行两个不同的分支。比如，使用Java风格编写下面Scala的if语句的一个例子 123456789var age = 25var result = &quot;&quot;if (age &gt; 20)&#123; result = &quot;worker&quot;&#125;else&#123; result = &quot;Student&quot;&#125;println(result) 上面代码和使用 Java实现没有太多区别，看起来不怎么像 Scala 风格，我们重新改写一下，利用 if 可以返回结果这个特点。 123var age=25val result = if (age &gt; 20) &quot;Worker&quot; else &quot;Student&quot;println(result) 首先这种代码比前段代码短，更重要的是这段代码使用 val 而无需使用 var 类型的变量。 使用 val 为函数式编程风格 while 循环Scala 的 while 循环和 其他语言（如 Java）功能一样，它含有一个条件和循环体。只要条件满足，就一直执行循环体的代码。 比如，下面的计算最大公约数的一个实现 12345678910def gcdLoop (x: Long, y:Long) : Long =&#123; var a=x var b=y while( a!=0) &#123; var temp=a a=b % a b = temp &#125; b&#125; Scala 也有 do-while 循环，它和 while 循环类似，只是检查条件是否满足实在循环体执行之后检查。 例如 ： 12345var line=&quot;&quot;do &#123; line = readLine() println(&quot;Read: &quot; + line)&#125; while (line !=&quot;&quot;) Scala 的 while 和 do-while 称为“循环”而不是表达式，是因为它不产生有用的返回值（或是返回值为 Unit），可以写成 () 。*()*** 的存在使得Scala的 *Unit*** 和 Java 的 void 类型有所不同。 比如，下面的语句在 Scala 的解释器中执行： 123456789scala&gt; def greet() &#123; println(&quot;hi&quot;)&#125;greet: ()Unitscala&gt; greet() == ()&lt;console&gt;:9: warning: comparing values of types Unit and Unit using `==&#x27; will always yield true greet() == () ^hires0: Boolean = true 可以看到（或者看到警告） greet() 的返回值 和 () 比较结果为 true 注意另外一种可以返回 Unit 结果的语句为 var 类型赋值语句。如果你使用如下 Java 风格的语句将碰到麻烦： 12while((line=readLine())!=&quot;&quot;) println(&quot;Read: &quot; + line) 上述代码当你运行的时候，会出现 错误 错误的代码意思是 Unit （赋值语句返回值）和 String 做不等比较永远为 true 上面的代码会是一个死循环。 正因为 while 循环没有值，因此在纯函数化编程中应该避免使用 while 循环。 Scala 保留 while ，是因为在某些时候使用循环代码比较容易理解。 而如果使用纯函数化编程，需要执行一些重复运行的代码时，通常就需要使用回溯函数来实现，回溯函数通常看起来不是很直观。 比如前面计算最大公约数的函数使用纯函数化编程借助回溯函数实现如下： 12def gcd (x :Long, y:Long) :Long = if (y ==0) x else gcd (y, x % y) 总的来说，推荐尽量避免在代码中使用 while 循环， 正如函数化编程要避免使用 var 变量一样。而使用 while 循环时通常也会使用到 var 变量，因此在你打算使用 while 循环时需要特别小心，看是否可以避免使用它们 for 表达式Scala 中的 for 表达式有如一把完成迭代任务的瑞士军刀，它允许你使用一些简单的不见以不同的方法组合完成许多复杂的迭代任务。简单的应用，比如枚举一个整数列表，较复杂的应用可以同时枚举多个不同类型的列表，根据条件过滤元素，并可以生成新的集合。 枚举集合元素这是使用 for 表示式的一个基本用法，和 Java 的 for 非常类似， 比如下面的代码可以枚举当前目录下所有文件： 1234val filesHere = (new java.io.File(&quot;.&quot;)).listFilesfor(file &lt;-filesHere) println(file) 其中如 file &lt;– filesHere 的语法结构，在 Scala 中称为“生成器 (generator)”。 本例中，filesHere 的类型为 Array[File]。每次迭代中，变量 file 会初始化为该数组中一个元素， file 的 toString() 为文件的文件名，因此 println(file) 打印出文件名。 Scala 的 for 表达式支持所有类型的集合，而不仅仅是数组，比如下面使用 for 表达式来枚举一个 Range 类型。 12345 scala&gt; for(i &lt;- 1 to 4) println(&quot;Interation&quot; +i)Interation 1Interation 2Interation 3Interation 4 过滤某些时候，你可能不想枚举集合中的每一个元素，而是只想迭代某些符合条件的元素。在 Scala 中，你可以为 for 表达式添加一个过滤器——在 for 的括号内添加一个 if 语句，例如： 修改前面枚举文件的例子，改成只列出 .scala 文件，示例如下： 12345val filesHere = (new java.io.File(&quot;.&quot;)).listFilesfor( file &lt;-filesHere if file.getName.endsWith(&quot;.scala&quot;)) println(file) 如果有必要的话，你可以使用多个过滤器，只要添加多个 if 语句即可。比如，为保证前面列出的文件不是目录，可以添加一个 if，如下面代码： 123456val filesHere = (new java.io.File(&quot;.&quot;)).listFilesfor( file &lt;-filesHere if file.isFile if file.getName.endsWith(&quot;.scala&quot;)) println(file) 嵌套迭代for 表达式支持多重迭代。下面的例子使用两重迭代，外面的循环枚举 filesHere ，而内部循环枚举该文件的每一行文字。实现了类似 Unix 中的 grep 命令： 12345678910111213val filesHere = (new java.io.File(&quot;.&quot;)).listFilesdef fileLines (file : java.io.File) = scala.io.Source.fromFile(file).getLines().toListdef grep (pattern: String) = for ( file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;); line &lt;- fileLines(file) if line.trim.matches(pattern) ) println(file + &quot;:&quot; + line.trim)grep (&quot;.*gcd.*&quot;) 注意上面代码中，两个迭代之间使用了 ; ，如果你使用 {} 替代 for 的 () 括号，你可以不使用 ； 分隔这两个“生成器”。这是因为，Scala 编译器不推算包含在花括号内的省掉的 ; 。使用 {} 改写的代码如下 12345678910111213val filesHere = (new java.io.File(&quot;.&quot;)).listFilesdef fileLines (file : java.io.File) = scala.io.Source.fromFile(file).getLines().toListdef grep (pattern: String) = for &#123; file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;) line &lt;- fileLines(file) if line.trim.matches(pattern) &#125; println(file + &quot;:&quot; + line.trim)grep (&quot;.*gcd.*&quot;) 这两段代码是等效的。 绑定中间变量你可能注意到，前面代码使用了多次 line.trim 如果 trim 是个耗时的操作，你可能希望 trim 只计算一次。Scala 允许你使用 = 号来绑定计算结果到一个新变量。绑定的作用和 val 类似，只是不需要使用 val 关键字。例如，修改前面的例子，只计算一次 trim，把结果保存在 trimmed 变量中。 1234567891011121314val filesHere = (new java.io.File(&quot;.&quot;)).listFilesdef fileLines (file : java.io.File) = scala.io.Source.fromFile(file).getLines().toListdef grep (pattern: String) = for &#123; file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;) line &lt;- fileLines(file) trimmed=line.trim if trimmed.matches(pattern) &#125; println(file + &quot;:&quot; + trimmed)grep (&quot;.*gcd.*&quot;) 生成新集合for 表达式也可以用来生产新的集合，这是 Scala 的 for表达式比 Java 的 for 语句功能强大的地方。它的基本语法如下： 1for clauses yield body 关键字 yield 放在 body 的前面，for 每迭代一次，就产生一个 body 。yield 收集所有的 body 结果，返回一个 body 类型的集合。 用 try 表达式处理异常Scala 的异常处理和其它语言比如Java类似，一个方法可以通过抛出异常而不返回值的方式来终止相关代码的运行。调用函数，可以捕获这个异常作出相应的处理，或者直接退出。在这种情况下，异常会传递给调用函数的调用者，依次向上传递，直到有方法处理这个异常。 抛出异常Scala 抛出异常的方法和 Java 一样，使用 throw 方法。例如，抛出一个新的参数异常： 1throw new IllegalArgumentException 尽管看起来似乎有些自相矛盾，Scala 中，throw 也是一个表达式，也是有返回值的。比如下面的例子： 12345val half = if (n % 2 == 0) n/2 else throw new RuntimeException(&quot;n must be even&quot;) 当 n 为偶数时，n 初始化为 n 的一半；而如果 n 为奇数，将在初始化 half 之前就抛出异常。正因为如此，可以把 throw 的返回值视作任意类型。技术上来说，抛出异常的类型为 Nothing 。对于上面的例子，整个 if 表达式的类型为可以计算出值的那个分支的类型。如果 n 为 Int ，那么 if 表示式的类型也是 Int 类型，而不需要考虑 throw 表达式的类型。 捕获异常Scala 捕获异常的方法和后面介绍的“模式匹配”的使用方法是一致的。比如： 注意，这个地方的文件需要自己创建，并将文件目录写到FileReader中 1vi input.txt 12345678910import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOExceptiontry &#123; val f = new FileReader(&quot;/home/hadoop/input.txt&quot;)&#125; catch &#123; case ex: FileNotFoundException =&gt; //handle missing file case ex: IOException =&gt; //handle other I/O error&#125; 模式匹配将在后面介绍，try-catch 表达式的基本用法和 Java 一样。如果 try 块中代码在执行过程中出现异常，将逐个检测每个 catch 块。在上面的例子，如果打开文件出现异常，将先检查是否是 FileNotFoundException 异常。如果不是，再检查是否是 IOException 。如果还不是，再终止 try-catch 块的运行，而向上传递这个异常。 注意： 和Java异常处理不同的一点是，Scala 不需要你捕获 checked 的异常。这点和 C# 一样，也不需要使用 throw 来声明某个异常。当然，如果有需要，还是可以通过 @throw 来声明一个异常，但这不是必须的。 finally语句Scala 也支持 finally 语句，你可以在 finally 块中添加一些代码。这些代码不管 try 块是否抛出异常，都会执行。比如，你可以在 finally 块中添加代码保证关闭已经打开的文件，而不管前面代码中是否出现异常。 123456789import java.io.FileReaderval file = new FileReader(&quot;/home/hadoop/input.txt&quot;)try &#123; //use the file&#125; finally &#123; file.close()&#125; 生成返回值和大部分 Scala 控制结构一样，Scala 的 try-catch-finally 也生成某个值。比如下面的例子尝试分析一个 URL ，如果输入的 URL 无效，则使用缺省的 URL 链接地址： 12345678910import java.net.URLimport java.net.MalformedURLExceptiondef urlFor(path:String) = try &#123; new URL(path) &#125; catch &#123; case e: MalformedURLException =&gt; new URL(&quot;http://www.scala-lang.org&quot;) &#125; 通常情况下，finally 块用来做些清理工作，而不应该产生结果，但如果在 finally 块中使用 return 来返回某个值，这个值将覆盖 try-catch 产生的结果，比如： 12345scala&gt; def f(): Int = try &#123; return 1 &#125; finally &#123; return 2&#125;f: ()Intscala&gt; fres0: Int = 2 而下面的代码： 123456789scala&gt; def g() :Int = try 1 finally 2&lt;console&gt;:21: warning: a pure expression does nothing in statement position; you may be omitting necessary parentheses def g() : Int = try 1 finally 2 ^g: ()Intscala&gt; gres0: Int = 1 结果却是 1 ，上面两种情况常常使得程序员产生困惑，因此关键的一点是避免在 finally 生成返回值，而只用来做些清理工作，比如关闭文件。 Match 表达式Scala 的 Match 表达式支持从多个选择中选取其一，类似其它语言中的 switch 语句。通常来说，Scala 的 match 表达式支持任意的匹配模式，这种基本模式将在后面介绍。 接下来，为你介绍类似 switch 用法的 match 表达式，它也是在多个选项中选择其一。 例如，下面的例子从参数中读取食品的名称，然后根据食品的名称，打印出和该食品搭配的食品。比如，输入 salt，与之对应的食品为 pepper 。如果是 chips ，那么搭配的就是 salsa等等。 12345678val args = Array(&quot;chips&quot;)val firstArg = if (args.length &gt;0 ) args(0) else &quot;&quot;firstArg match &#123; case &quot;salt&quot; =&gt; println(&quot;pepper&quot;) case &quot;chips&quot; =&gt; println(&quot;salsa&quot;) case &quot;eggs&quot; =&gt; println(&quot;bacon&quot;) case _ =&gt; println(&quot;huh?&quot;)&#125; 这段代码和 Java 的 switch 相比有几点不同： 一是任何类型的常量都可以用在 case 语句中，而不仅仅是 int 或是枚举类型。 二是每个 case 语句无需使用 break ，Scala不支持“fall through”。 三是Scala的缺省匹配为 _ ，其作用类似 java 中的 default。 而最关键的一点，是 scala 的 match 表达式有返回值。上面的代码使用的是 println 打印，而实际上你可以使用表达式，比如修改上面的代码如下： 123456789val firstArg = if (args.length &gt;0 ) args(0) else &quot;&quot;val friend = firstArg match &#123; case &quot;salt&quot; =&gt; &quot;pepper&quot; case &quot;chips&quot; =&gt; &quot;salsa&quot; case &quot;eggs&quot; =&gt; &quot;bacon&quot; case _ =&gt; &quot;huh?&quot; &#125;println(friend) 这段代码和前面的代码是等效的，不同的是后面这段代码 match 表达式返回结果。 没有 break 和 continue 的日子你也许注意到：到目前为止，我们介绍 Scala 的内置控制结构时，没有提到使用 break 和 continue 。 Scala 特地没有在内置控制结构中包含 break 和 continue ，这是因为这两个控制结构和函数字面量有点格格不入，函数字面量我们将在后面介绍。函数字面量和其它类型字面量，比如数值字面量 4、5.6 相比，他们在 Scala 的地位相同。 我们很清楚 break 和 continue 在循环控制结构中的作用。Scala内置控制结构特地去掉了 break 和 continue ，这是为了更好的适应函数化编程。不过，你不用担心，Scala 提供了多种方法来替代 break 和 continue 的作用。 一个简单的方法，是使用一个 if 语句来代替一个 continue，使用一个布尔控制量来去除一个 break 。比如下面的 Java 代码在循环结构中使用 continue 和 break： 12345678910111213int i=0;boolean foundIt=false;while(i &lt;args.length) &#123; if (args[i].startWith(&quot;-&quot;)) &#123; i=i+1; continue; &#125; if(args[i].endsWith(&quot;.scala&quot;))&#123; foundIt=true; break; &#125; i=i+1;&#125; 这段 Java 代码实现的功能，是从一组字符串中寻找以 .scala 结尾的字符串，但跳过以 - 开头的字符串。 下面我们使用 if 和 boolean 变量，逐句将这段使用Scala来实现（不使用break和continue)如下： 123456789var i=0var foundIt=falsewhile (i &lt; args.length &amp;&amp; !foundIt) &#123; if (!args(i).startsWith(&quot;-&quot;)) &#123; if(args(i).endsWith(&quot;.scala&quot;)) foundIt=true &#125; i=i+1&#125; 可以看到，我们使用 if（与前面的 continue 条件相反）去掉了 continue，而重用了 foundIt 布尔变量，去掉了 break 。 这段代码和前面 Java 实现非常类似，并且使用了两个 var 变量。使用纯函数化编程的一个方法是去掉 var 变量的使用，而递归函数（回溯函数）是用于去除循环结构中使用 var 变量时，通常使用的一个方法。 使用递归函数重新实现上面代码的查询功能： 1234567def searchFrom(i:Int) : Int =&#123; if( i &gt;= args.length) -1 else if (args(i).startsWith(&quot;-&quot;)) searchFrom (i+1) else if (args(i).endsWith(&quot;.scala&quot;)) i else searchFrom(i+1)&#125; val i = searchFrom(0) 在函数化编程中，使用递归函数来实现循环是非常常见的一种方法，我们应该熟悉递归函数的用法。 总结我们学习了 Scala 中的主要控制语句的用法。如果你之前学习了 Java ，那么在此处有一点需要特别注意：Scala 是一门“函数式”编程语言。结合这一点，多与之前学过的编程语言作比较，相信你能获得更多。","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"}]},{"title":"开启Scala编程","slug":"大数据/scala/开始编程","date":"2020-01-08T07:28:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/08/大数据/scala/开始编程/","link":"","permalink":"https://bawcat.wiki/2020/01/08/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/%E5%BC%80%E5%A7%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"开启Scala编程 首先 需要安装 Scala 软件 进入scale 终端 Hello World每次使用开发的时候 必定输出 Hello World 代码： 12345object HelloWorld &#123; def main(args: Array[String]) &#123; println(&quot;Hello, world!&quot;) &#125;&#125; 如果一行中的代码太长，可以在该行最后以 Shift键+Enter键 进行换行即可。输入上述代码后，显示如下图所示： 如果一行中的代码太长，可以在该行最后以 Shift键+Enter键 进行换行即可。输入上述代码后，显示如下图所示： 这段代码，你可以使用命令行交互式执行： 1HelloWorld.main(null) 参考链接 百度百科 - Scala","categories":[{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"}]},{"title":"Redis 持久化机制","slug":"数据库/redis/持久化机制","date":"2020-01-06T04:12:54.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/06/数据库/redis/持久化机制/","link":"","permalink":"https://bawcat.wiki/2020/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Redis 持久化机制内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。 Redis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。 Redis 支持两种持久化方式： snapshotting（快照）：将数据存放到文件里，默认方式。 是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如： save 900 1：900 秒内如果超过 1 个 key 被修改，则发起快照保存。 save 300 10：300 秒内如果超过 10 个 key 被修改，则快照保存。 Append-only file（缩写为 aof）：将读写操作存放到文件中。 由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。 aof 比快照方式有更好的持久化性，是由于使用 aof 时，redis 会将每一个收到的写命令都通过 write 函数写入到文件中，当 redis 启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。 由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。 配置文件中的可配置参数： 1234567appendonly yes //启用 aof 持久化方式# appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中# appendfsync no //完全依赖 os，性能最好，持久化没有保证 在 redis-cli 的命令中，save 命令是将数据写入磁盘中。 12&gt; help save&gt; save","categories":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"持久化机制","slug":"持久化机制","permalink":"https://bawcat.wiki/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"}]},{"title":"Redis 主从复制","slug":"数据库/redis/主从复制","date":"2020-01-05T04:12:54.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/05/数据库/redis/主从复制/","link":"","permalink":"https://bawcat.wiki/2020/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"Redis 主从复制为了分担服务器压力，会在特定情况下部署多台服务器分别用于缓存的读和写操作，用于写操作的服务器称为主服务器，用于读操作的服务器称为从服务器。 从服务器通过 psync 操作同步主服务器的写操作，并按照一定的时间间隔更新主服务器上新写入的内容。 Redis 主从复制的过程： Slave 与 Master 建立连接，发送 psync 同步命令。 Master 会启动一个后台进程，将数据库快照保存到文件中，同时 Master 主进程会开始收集新的写命令并缓存。 后台完成保存后，就将此文件发送给 Slave。 Slave 将此文件保存到磁盘上。 Redis 主从复制特点 可以拥有多个 Slave。 多个 Slave 可以连接同一个 Master 外，还可以连接到其它的 Slave。（当 Master 宕机后，相连的 Slave 转变为 Master）。 主从复制不会阻塞 Master，在同步数据时， Master 可以继续处理 Client 请求。 提高了系统的可伸缩性。 从服务器的主要作用是响应客户端的数据请求，比如返回一篇博客信息。 上面说到了主从复制是不会阻塞 Master 的，就是说 Slave 在从 Master 复制数据时，Master 的删改插入等操作继续进行不受影响。 如果在同步过程中，主服务器修改了一篇博客，而同步到从服务器上的博客是修改前的。这时候就会出现时间差，即修改了博客过后，在访问网站的时候还是原来的数据，这是因为从服务器还未同步最新的更改，这也就意味着非阻塞式的同步只能应用于对读数据延迟接受度较高的场景。 要建立这样一个主从关系的缓存服务器，只需要在 Slave 端执行命令: 12# SLAVEOF IPADDRESS:PORT&gt; SLAVEOF 127.0.0.1:6379 如果主服务器设置了连接密码，就需要在从服务器中事先设置好： 1config set masterauth &lt;password&gt; 这样，当前服务器就作为 127.0.0.1:6379 下的一个从服务器，它将定期从该服务器复制数据到自身。在以前的版本中（2.8 以前），你应该慎用 redis 的主从复制功能，因为它的同步机制效率低下，可以想象每一次短线重连都要复制主服务器上的全部数据，算上网络通讯所耗费的时间，反而可能达不到通过 redis 缓存来提升应用响应速度的效果。但是幸运的是，官方在 2.8 以后推出了解决方案，通过部分同步来解决大量的重复操作。 这需要主服务器和从服务器都至少达到 2.8 的版本要求。","categories":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"主从复制","slug":"主从复制","permalink":"https://bawcat.wiki/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"}]},{"title":"Redis 事务处理","slug":"数据库/redis/事务处理","date":"2020-01-05T04:12:54.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/05/数据库/redis/事务处理/","link":"","permalink":"https://bawcat.wiki/2020/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","excerpt":"","text":"Redis 事务处理Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 multi 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 exec 命令时，redis 会顺序的执行队列中的所有命令。 12345&gt; multi&gt; set name a&gt; set name b&gt; exec&gt; get name 需要注意的是，redis 对于事务的处理方式比较特殊，它不会在事务过程中出错时恢复到之前的状态，这在实际应用中导致我们不能依赖 redis 的事务来保证数据一致性。","categories":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"事务处理","slug":"事务处理","permalink":"https://bawcat.wiki/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"}]},{"title":"Redis 简介与安装","slug":"数据库/redis/简介和安装","date":"2020-01-05T04:12:54.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/05/数据库/redis/简介和安装/","link":"","permalink":"https://bawcat.wiki/2020/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/","excerpt":"","text":"Redis 简介与安装Redis 是什么REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。Redis 提供了一些丰富的数据结构，包括 lists、sets、ordered sets 以及 hashes ，当然还有和 Memcached 一样的 strings 结构。Redis 当然还包括了对这些数据结构的丰富操作。 Redis 常被称作是一款数据结构服务器（data structure server）。Redis 的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。 Redis 的优点 性能极高：Redis 能支持超过 100K+ 每秒的读写频率。 丰富的数据类型：Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。 原子：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。 丰富的特性：Redis 还支持 publish/subscribe，通知，key 过期等等特性。 Redis 的安装步骤下面的安装步骤仅为示例大家不需要在环境中进行操作。 redis 手动安装的话非常简单，以 redis-4.0.9 版本为例。 首先进入 root 目录并下载 Redis 的程序包： 123sudo suwget http://labfile.oss.aliyuncs.com/courses/106/redis-4.0.9.tar.gz 在目录下，解压安装包，生成新的目录 redis-4.0.9： 1tar -xzvf redis-4.0.9.tar.gz 进入解压之后的目录，进行编译 12cd redis-4.0.9make 说明：如果没有明显的错误，则表示编译成功。 查看重要文件在Readis 安装完成之后，注意一些重要的文件，可用ls命令查看。 服务端：src/readis-server 客户端： src/redis-cli 默认配置文件：redis.conf 设置环境变量为了今后能更方便地打开 Redis 服务器和客户端，可以将 src 目录下的 redis-server 和 redis-cli 添加进环境变量所属目录里面。 12cp redis-server /usr/local/bin/cp redis-cli /usr/local/bin/ 添加完成后在任何目录下输入 redis-server 可启动服务器，输入 redis-cli 可启动客户端 运行测试在前面的步骤设置完成后可以运行测试（非必须），确认 Redis 的功能是否正常 12cd /root/redis-4.0.9make test 如果提示 You need tcl 8.5 or newer in order to run the Redis test 可以安装tcl，然后再进行测试 1sudo apt-get install tcl -y Redis 是一个服务端和客户端配合的程序，和 Mysql 类似，因此要使用 Redis 需要先启动服务端，客户端有多种形式，比如在 Java 中连接 Redis 服务器也是扮演了一个客户端的角色，本节实验中采用终端的形式来对 Redis 的各项操作进行练习。 启动 Readis-server添加完 环境变量之后 1redis-server 开启之后 会出现redis 的 界面 此时要使用 Redis-Client 需要保持此终端的运行，重开一个终端标签。 查看 Redis在命令行终端执行如下命令查看Redis： 1ps -ef | grep redis 通过端口号检查Redis服务器状态： 1netstat -nlt| grep 6379 启动 Redis-client在命令行终端执行如下命令启动 Redis-client: 1redis-cli 至此，redis 启动完成。 在有的环境下，redis 交互环境可能出现中文乱码的情况，解决办法是用下列命令启动 redis 客户端： 1redis-cli --raw","categories":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"简介与安装","slug":"简介与安装","permalink":"https://bawcat.wiki/tags/%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"}]},{"title":"Redis 虚拟内存的使用","slug":"数据库/redis/虚拟内存的使用","date":"2020-01-05T04:12:54.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2020/01/05/数据库/redis/虚拟内存的使用/","link":"","permalink":"https://bawcat.wiki/2020/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Redis 虚拟内存的使用虚拟内存管理在 2.6 及之上版本取消了，取消了是指这部分内容在后面的版本会由 redis 软件自身管理，在本实验中，选择的是 4.0.9 版本的 redis，所以实验中的配置文件没有虚拟内存管理功能的配置选项，此处仅为讲解。 Redis 的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据，尤其对于 redis 这样的内存数据库，内存总是不够用的。除了分隔到多个 redis server 外，提高数据库容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。 通过配置 vm 相关的 redis.config 配置： 1234567891011121314151617# 开启 vm 功能vm-enable yes# 交换出来的 value 保存的文件路径vm-swap-file /tmp/redis.swap# redis 使用的最大内存上限vm-max-memory 10000000# 每个页面的大小 32 字节vm-page-size 32# 最多使用多少个页面vm-pages 123217729# 用于执行 value 对象换入的工作线程数量vm-max-threads 4","categories":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"虚拟内存的使用","slug":"虚拟内存的使用","permalink":"https://bawcat.wiki/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"Java 基础学习记录","slug":"java/基础教学/index","date":"2020-01-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2020/01/03/java/基础教学/index/","link":"","permalink":"https://bawcat.wiki/2020/01/03/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/index/","excerpt":"","text":"Java 基础学习记录 所有相关 java 文章的记录均为网上教程学习记录 参考网站 以下网站不分排名 待补充","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java lang","slug":"java-lang","permalink":"https://bawcat.wiki/tags/java-lang/"}]},{"title":"Java.lang 包装类","slug":"java/基础教学/包装类","date":"2020-01-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/03/java/基础教学/包装类/","link":"","permalink":"https://bawcat.wiki/2020/01/03/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"Java.lang 包装类 原始数据类型 包装类 byte(字节) Byte char(字符) character int(整型) Integer long(长整型) Long float(浮点型) Float double(双精度) Double boolean(布尔型) Boolean short(短整型) Short 在这八个类名中，除了Integer和Character类以后，其他六个类的类名和基本数据类型一致，只是类名的第一个字母大写 Integerjava.lang 包中的 Integer 类、Long类和Short类都是Number类的子类，他们的区别在于不同子类里面封装着不同的数据类型，比如Integer类包装了一个基本类型int。其包含的方法基本相同。 我们以 Integer 类为例。 Integer 构造方法有两种： Integer(int value) ，以 int 型变量作为参数创建 Integer 对象。例如 Integer a = new Integer(10); Integer(String s) ，以 String 型变量作为参数创建 Integer 对象，例如Integer a = new Integer(“10”) 下面是Integer的常用方法 方法 返回值 功能描述 byteValue() byte 以byte类型返回该Integer的值 compareTo(Integer anotherInteger) int 在数字上比较Integer对象。如果这两个值相等，则返回0 如果调用对象的值小于anotherInteger的数值，则返回负值 如果调用对象的数值大于anotherInteger的数值，则返回正值 equals(Object IntegerObj) boolean 比较此对象与指定对象是否相等 intValue() int 以int型返回此Integer对象 shortValue() short 以short型返回此Integer对象 longValue() long 以long 型返回此Integer对象 floatValue() float 以float型返回此Integer对象 doubleValue() double 以double型返回此Integer对象 toString() String 返回一个表示该Integer值的String对象 valueOf(String str) Integer 返回保存指定的String值的Integer对象 parseInt(String str) int 将字符串参数作为有符号的十进制整数进行解析 代码示例： 123456789101112131415161718192021public class IntegerTest &#123; public static void main(String[] args)&#123; //初始化一个 Integer 类实例 Integer a = new Integer(&quot;10&quot;); //初始化一个 Integer 类实例 Integer b = new Integer(11); //判断两个数的大小 System.out.println(a.compareTo(b)); // 判断两个实例是否相等 System.out.println(a.equals(b)); //将 a 转换成 float 型数 float c = a.floatValue(); System.out.println(c); String d = &quot;10101110&quot;; //将字符串转换为数值 //parseInt(String str) 和 parseInt(String str,int radix) 都是类方法，由类来调用。后一个方法则实现将字符串按照参数 radix 指定的进制转换为 int， int e = Integer.parseInt(d, 2); System.out.println(e); &#125;&#125; CharacterCharacter 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 Character 常用方法 方法 返回值 说明 isDigit(char ch) boolean 确定字符是否为数字 isLetter(char ch) boolean 确定字符是否为字母 isLowerCase(char ch) boolean 确定字符是否为小写字母 isUpperCase(char ch) boolean 确定字符是否为大写字母 isWhitespace(char ch) boolean 确定字符是否为空白字符 isUnicodeIdentifierStart(char ch) boolean 确定是否运行将指定字符作为Unicode标识符中的首字符 示例方法12345678910111213141516171819202122232425262728public class CharacterTest &#123; public static void main(String[] args)&#123; int count; //定义了一个字符数组 char[] values = &#123;&#x27;*&#x27;, &#x27;_&#x27;, &#x27;%&#x27;, &#x27;8&#x27;, &#x27;L&#x27;, &#x27;l&#x27;&#125;; //遍历字符数组 for (count = 0; count &lt; values.length; count++)&#123; if(Character.isDigit(values[count]))&#123; System.out.println(values[count]+&quot;是一个数字&quot;); &#125; if(Character.isLetter(values[count]))&#123; System.out.println(values[count]+ &quot;是一个字母&quot;); &#125; if(Character.isUpperCase(values[count]))&#123; System.out.println(values[count]+&quot;是大写形式&quot;); &#125; if(Character.isLowerCase(values[count]))&#123; System.out.println(values[count]+&quot;是小写形式&quot;); &#125; if(Character.isUnicodeIdentifierStart(values[count]))&#123; System.out.println(values[count]+&quot;是 Unicode 标志符的第一个有效字符&quot;); &#125; &#125; //判断字符 c 是否是空白字符 char c = &#x27; &#x27;; System.out.println(&quot;字符 c 是空白字符吗？&quot;+Character.isWhitespace(c)); &#125;&#125; BooleanBoolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。 Boolean 类的构造方法也有两个： Boolean(boolean value)，创建一个表示 value 参数的 Boolean 对象，如Boolean b = new Boolean(true) Boolean(String s)，如果 String 参数不为 null 且在忽略大小写时等于 “true”, 创建一个表示 true 值的 Boolean 对象，如Boolean b = new Boolean(“ok”)，为 false。 Boolean 常用方法 方法 返回值 说明 booleanValue() boolean 将Boolean 对象的值以对应的boolean值返回 equals(Object obj) boolean 判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，而且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true parseBoolean(String s) boolean 将字符串参数解析为 boolean 值 toString() String 返回表示该 boolean 值的 String 对象 valueOf(String s) Boolean 返回一个用指定得字符串表示值的 boolean 值 示例代码1234567891011121314public class BooleanTest &#123; public static void main(String[] args) &#123; // Boolean(boolean value) 构造方法 Boolean a = new Boolean(true); System.out.println(&quot;a 为&quot;+a); // Boolean(String s) 构造方法 Boolean b = new Boolean(&quot;true&quot;); Boolean c = new Boolean(&quot;OK&quot;); System.out.println(&quot;b 为&quot;+b); System.out.println(&quot;c 为&quot;+c); System.out.println(&quot;a 的 booleanValue() 为&quot;+a.booleanValue()); System.out.println(&quot;a 和 b 相等吗？&quot;+a.equals(b)); &#125;&#125; String我们经常使用 String 类来定义一个字符串。字符串是常量，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。String 对象的初始化格式有如下两种： 123String s0 = &quot;abc&quot;;String s1 = new String(&quot;abd&quot;); String 类具有丰富的方法，比如计算字符串的长度、连接字符串、比较字符串、提取字符串等等。 length()计算字符串长度 调用方法： 字符串标识符。length(); 返回一个 int 类型的整数（字符串中字符数，中文字符也是一个字符）。例如： 1234String s1 = &quot;abc&quot;;String s2 = &quot;Java 语言&quot;;int len1 = s1.length();int len2 = s2.length(); 则变量 len1 的值是 3，变量 len2 的值是 6。 equals()该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。 equals() 方法比较是从第一字符开始，一个字符一个字符依次比较。 那如果我想忽略掉大小写关系，比如：java 和 Java 是一样的，我们怎么办呢？我们可以调用equalsIgnoreCase()方法，其用法与 equals 一致，不过它会忽视大小写。 比如： 12345678public class StringTest &#123; public static void main(String[] args)&#123; String s = new String(&quot;Java&quot;); String m = &quot;java&quot;; System.out.println(&quot;用 equals() 比较，java 和 Java 结果为&quot;+s.equals(m)); System.out.println(&quot;用 equalsIgnoreCase() 比较，java 和 Java 结果为&quot;+s.equalsIgnoreCase(m)); &#125;&#125; 而使用”==”比较的是两个对象在内存中存储的地址是否一样。例如： String s1 = “abc”; String s2 = new String(“abc”); boolean b = (s1 == s2); 则变量 b 的值是 false，因为 s1 对象对应的地址是”abc”的地址，而 s2 使用 new 关键字申请新的内存，所以内存地址和 s1 的”abc”的地址不一样，所以获得的值是 false。 字符串连接字符串连接有两种方法： 使用 + 比如 String s = “Hello “ + “World!”; 使用String类的 concat()方法 示例： 1234String s0 = new String(&quot;Hello &quot;);String s1 = &quot;World&quot; + &quot;!&quot;; //+号连接String s2 = s0.concat(s1); //concat() 方法连接System.out.println(s2); 而且使用+进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。 charAt()charAt()方法的作用是按照索引值（规定字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推），获得字符串中的指定字符。 例如： 12String s = &quot;abc&quot;;char c = s.charAt(1); 字符串常用提取方法 方法 返回值 功能描述 indexOf(int ch) int 搜索字符 ch 第一次出现的索引 indexOf(String value) int 搜索字符串 value 第一次出现的索引 lastIndexOf(int ch) int 搜索字符 ch 最后一次出现的索引 lastIndexOf(String value) int 搜索字符串 value 最后一次出现的索引 substring(int index) String 提取从位置索引开始到结束的字符串 substring(int beginindex, int endindex) String 提取 beginindex 和 endindex 之间的字符串部分 trim() String 返回一个前后不含任何空格的调用字符串的副本 说明：在字符串中，第一个字符的索引为 0，子字符串包含 beginindex 的字符，但不包含 endindex 的字符。 示例代码： 12345678910public class StringTest &#123; public static void main(String[] args) &#123; String s = &quot;abcdefabc&quot;; System.out.println(&quot;字符 a 第一次出现的位置为&quot;+s.indexOf(&#x27;a&#x27;)); System.out.println(&quot;字符串 bc 第一次出现的位置为&quot;+s.indexOf(&quot;bc&quot;)); System.out.println(&quot;字符 a 最后一次出现的位置为&quot;+s.lastIndexOf(&#x27;a&#x27;)); System.out.println(&quot;从位置 3 开始到结束的字符串&quot;+s.substring(3)); System.out.println(&quot;从位置 3 开始到 6 之间的字符串&quot;+s.substring(3,6)); &#125;&#125; StringBufferString 类的字符串创建后是不能够改变的。 示例： 12345678910String s = &quot;Hello &quot;;s.concat(&quot;World!&quot;); //字符串连接System.out.println(s); //输出 s，还是&quot;Hello &quot;s = s.concat(&quot;World!&quot;); //把字符串对象连接的结果赋给了 s 引用System.out.println(s); //输出 s，变成了&quot;Hello World!&quot;/*上述三条语句其实产生了 3 个 String 对象，&quot;Hello &quot;，&quot;World!&quot;，&quot;Hello World!&quot;。第 2 条语句确实产生了&quot;Hello World&quot;字符串，但是没有指定把该字符串的引用赋给谁，因此没有改变 s 引用。第 3 条语句根据不变性，并没有改变&quot;Hello &quot;，JVM 创建了一个新的对象，把&quot;Hello &quot;，&quot;World!&quot;的连接赋给了 s 引用，因此引用变了，但是原对象没变。*/ String 的不变性的机制显然会在 String 常量内有大量的冗余。比如我创建一个循环，使字符’1’依次连接到’n’，那么系统就得创建 n+(n-1) 个 String 对象。那有没有可变的 String 类呢？ StringBuffer 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的，这里建议大家去看一看 String 类与 StringBuffer 类的区别，理解一下他们在内存中的存储情况） 构造方法： 构造方法 说明 StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符 StringBuffer(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符 StringBuffer(int capacity) 构造一个不带字符，但具有指定初始容量的字符串缓冲区 StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容 常用方法： 方法 返回值 功能描述 insert(int offsetm,Object s) StringBuffer 在 offsetm 的位置插入字符串 s append(Object s) StringBuffer 在字符串末尾追加字符串 s length() int 确定 StringBuffer 对象的长度 setCharAt(int pos,char ch) void 使用 ch 指定的新值设置 pos 指定的位置上的字符 toString() String 转换为字符串形式 reverse() StringBuffer 反转字符串 delete(int start, int end) StringBuffer 删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列 replace(int start, int end, String s) StringBuffer 使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束 示例代码： 12345678910111213public class StringTest &#123; public static void main(String[] args)&#123; //定义和初始化一个 StringBuffer 类的字串 s StringBuffer s = new StringBuffer(&quot;I&quot;); //在 s 后面添加字串&quot; java&quot; s.append(&quot; java&quot;); //在 s[1] 的位置插入字串 s.insert(1, &quot; love&quot;); String t = s.toString(); //转为字符串 System.out.println(t); &#125;&#125; Math我们在编程的过程中，经常对一些数字进行数学操作，比如我们想要求绝对值或余弦什么的。那这些方法是否需要我们自己实现吗？其实在 java.lang 里的 Math 类 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。我们就来学习一下吧！ 方法 返回值 功能描述 sin(double numvalue) double 计算角 numvalue 的正弦值 cos(double numvalue) double 计算角 numvalue 的余弦值 acos(double numvalue) double 计算 numvalue 的反余弦 asin(double numvalue) double 计算 numvalue 的反正弦 atan(double numvalue) double 计算 numvalue 的反正切 pow(double a, double b) double 计算 a 的 b 次方 sqrt(double numvalue) double 计算给定值的正平方根 abs(int numvalue) int 计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数 ceil(double numvalue) double 返回大于等于 numvalue 的最小整数值 floor(double numvalue) double 返回小于等于 numvalue 的最大整数值 max(int a, int b) int 返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数 min(int a, int b) int 返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数 rint(double numvalue) double 返回最接近 numvalue 的整数值 round(T arg) arg 为 double 时返回 long，为 float 时返回 int 返回最接近 arg 的整数值 random() double 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0 更多方法 请参照 官方api 代码示例： 1234567891011121314public class MathTest &#123; public static void main(String[] args) &#123; System.out.println(Math.abs(-12.7)); System.out.println(Math.ceil(12.7)); System.out.println(Math.rint(12.4)); System.out.println(Math.random()); System.out.println(&quot;sin30 = &quot; + Math.sin(Math.PI / 6)); // 计算 30°的正弦值，参数是用弧度表示的角，即π的六分之一 System.out.println(&quot;cos30 = &quot; + Math.cos(Math.PI / 6)); // 计算 30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为 double System.out.println(&quot;tan30 = &quot; + Math.tan(Math.PI / 6)); // 计算 30°的正切值 &#125;&#125; 也许你会觉得简单的计算很枯燥，但在合适的地方用到它们可以让你的程序（比如游戏中飞行轨迹的计算）更加精彩。 实战小项目-生成彩票号码有了之前的基础，我们来做个更好玩的项目——彩票生成器。目前市面上彩票的种类很多，我们就以大乐透为例吧。大乐透的规则是：从 135 中随机选取 5 个不重复的数字，从 112 中随机选取 2 个不重复的数字，这些数字组成了一个七位数。如果你买的号码与摇出来的号码相同，那么你一夜之间可能就不会当程序员了。 因为彩票号码是随机生成的，所以这个项目中我们也会带大家认识随机数的使用方法。首先请在先创建一个Lottery类。 我们需要用到 1234import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Random; 由于彩票号码的前半段和后半段的规则和个数略有不同，所以我们分别创建生成它们的方法。 首先来创建生成前段号码的方法getHeadNumber()，该方法需要从 1 到 36 中随机选取一个数作为号码（即摇号的过程）。对于个位数，为了显示上更整齐，所以我们在其十位再放一个“0”。再者，为了结果更加易读，我们还需要调用Collections.sort()方法对结果进行排序。 示例代码： 1234567891011121314151617181920212223242526272829303132333435public List&lt;String&gt; getHeadNumber() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 创建彩票的前半段号码集合 String lotteryNumber = &quot;&quot;; for (int i = 1; i &lt; 36; i++) &#123; // 这个循环是为了初始化彩票的前半段号码集合 if (i &lt; 10) &#123; list.add(&quot;0&quot; + i + &quot; &quot;); // 在集合中添加 0~9 的号码，因为是个位数，为了显示上更加人性化，所以需要在十位的地方添加“0” &#125; else &#123; list.add(&quot;&quot; + i + &quot; &quot;); // 向集合添加大于 9 的号码，即添加双位数 &#125; &#125; int roundIndex = 0; // 创建并初始化随机数 List&lt;String&gt; lotteryList = new ArrayList&lt;String&gt;(); // 保存前段号码的 List 集合 for (int j = 0; j &lt; 5; j++) &#123; int amount = list.size(); // 获取前半段号码的个数 Random r = new Random(); // 创建并实例化 Random 的对象 roundIndex = r.nextInt(amount); // 获取一个 0 到 amount-1 的随机数 lotteryNumber = list.get(roundIndex); // 获取彩票数字，即摇号的号码 lotteryList.add(lotteryNumber); // 将彩票号码添加 lotteryList 中 list.remove(roundIndex); // 移除刚刚产生的号码 &#125; Collections.sort(lotteryList); // 对前半段号码进行排序，排序的目的是为了让结果更具可读性 return lotteryList; //返回前半段号码 &#125; 此处用到了Random()方法，在创建一个 Random 对象r后，你可以调用该对象的nextInt()方法得到一个随机数。r.nextInt(amount);中的 amount 是随机数的上限，产生的随机数为 0 到 100（不含 100）的整数。 你可以 了解更多 Random 的用法。 和前半段号码类似，我们接着来写生成后半段号码的方法getRearNum()，代码片段如下： 示例代码： 1234567891011121314151617181920212223242526272829303132333435public List&lt;String&gt; getRearNumber() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 创建后半段号码集合，也就是最后两个球的数字 String lotteryNumber = &quot;&quot;; for (int i = 1; i &lt; 13; i++) &#123; // 初始化后半段号码集合 if (i &lt; 10) &#123; list.add(&quot;0&quot; + i + &quot; &quot;); // 添加 0~9 的号码，原理同前半段 &#125; else &#123; list.add(&quot;&quot; + i + &quot; &quot;); // 添加大于 9 的号码 &#125; &#125; int roundIndex = 0; //创建并初始化随机数 List&lt;String&gt; lotteryList = new ArrayList&lt;String&gt;(); // 保存后半段号码的 List 集合 for (int j = 0; j &lt; 2; j++) &#123; int amount = list.size(); // 获取后半段号码的个数 Random r = new Random(); // 创建并实例化 Random 的对象 roundIndex = r.nextInt(amount); // 获取一个 0 到 amount-1 的随机数 lotteryNumber = list.get(roundIndex); // 摇号 lotteryList.add(lotteryNumber); // 将彩票号码添加 lotteryList 中 list.remove(roundIndex); // 移除刚刚产生的号码 &#125; Collections.sort(lotteryList); // 对后半段号码进行排序 return lotteryList; &#125; 现在，根据规则我们已经能够产生对应的数字了。再接再厉，我们再做一个生成最终结果的方法，把这两个号段组装成整体的号码，并且按照用户的要求产生多少组号码，在控制台输出它们。 下面给出了这个方法的代码片段： 12345678910111213141516171819202122232425262728293031public void generateLottery(String groupNum) &#123; int groupNumber = 0; //为了避免不必要的错误，一般在创建变量时都要为其赋初始值 groupNumber = Integer.parseInt(groupNum); StringBuilder sbuiler = new StringBuilder(); // 创建字符串生成器对象，使用字符串生成器能够较为方便地在字符串中追加内容 for (int i = 0; i &lt; groupNumber; i++) &#123; List&lt;String&gt; startList = getHeadNumber(); // 获得彩票前半段号码的集合 List&lt;String&gt; endList = getRearNumber(); // 获得彩票后半段号码的集合 for (int m = 0; m &lt; startList.size(); m++) &#123; sbuiler.append(startList.get(m)); // append() 即为追加方法，用于添加彩票的前半段号码到字符串生成器中 &#125; sbuiler.append(&quot; &quot;); for (int n = 0; n &lt; endList.size(); n++) &#123; sbuiler.append(endList.get(n)); // 添加彩票的后半段号码到字符串生成器中 &#125; sbuiler.append(&quot;\\n&quot;); &#125; System.out.println(sbuiler.toString()); //将每组生成好的彩票号码即时输出 &#125; 为了验证我们的实现无误，在同一个目录中创建一个名为LotteryTest的测试类，编写其main()方法。在其中创建一个彩票对象并调用其产生号码的方法。 1234567891011121314151617import java.util.Scanner;public class LotteryTest &#123; public static void main(String[] args) &#123; Lottery l = new Lottery(); Scanner scan = new Scanner(System.in);// 创建扫描器 System.out.println(&quot;Please input the number of lottery group(s) that you want to generate : &quot;); // 获得用户输入的需要生成的中奖号码个数 String groupNum = scan.nextLine(); l.generateLottery(groupNum); &#125;&#125; 检查一下代码，编译并运行 ClassClass 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即每一个类，在生成的.class文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。我们获取 Class 实例有三种方法： 利用对象调用 getClass()方法获取该对象的 Class 实例 使用 Class 类的静态方法 forName(String className)，用类的名字获取一个 Class 实例 运用.class的方式来获取 Class 实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例 关于Class 示例代码: 12345678910111213141516171819public class ClassDemo&#123; /** * */ public static void main(String[] args) throws ClassNotFoundException &#123; String objString = new String(); @SuppressWarnings(&quot;rawtypes&quot;) Class objClass; objClass = objString.getClass(); System.out.println(&quot;String 对象的类型是:&quot;+objClass.getName()); objClass = Integer.class; System.out.println(&quot;Integer 对象的类型是:&quot; + objClass.getName()); objClass = Class.forName(&quot;java.lang.String&quot;); System.out.println(&quot;Character 对象的类型是:&quot;+ objClass.getName()); objClass = objClass.getSuperclass(); System.out.println(&quot;Character 对象的父类是:&quot;+ objClass.getName()); &#125;&#125; Class 类没有共有的构造方法,它由JVM自动调用.Class类的方法在这里就不细讲了，有兴趣的可以自己查询一下. 官方详解 ObjectObject 类是所有类的父类,所有对象（包括数组）都实现这个类的方法。所以在默认的情况下，我们定义的类扩展自Object类，那我们当然可以调用和重写Object类里面的所有方法. Object 定义方法 : 方法 返回值 功能描述 equals(Objectobj) boolean 将当前对象实例与给定的对象进行比较，检查它们是否相等 finalize() throws Throwable void 当垃圾回收期确定不存在对象的更多引用时，由对象的垃圾回收期调用此方法. 通常被子类重写 getClass() Class 返回当前对象的Class对象 toString() String 返回此对象的字符创标识 wait() throws InterruptedException void 在其他线程调用此对象的notify() 方法或 notifyAll() 方法前，使当前线程进入等待状态","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java lang","slug":"java-lang","permalink":"https://bawcat.wiki/tags/java-lang/"}]},{"title":"Java 日期和随机数","slug":"java/基础教学/日期和随机数","date":"2020-01-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/03/java/基础教学/日期和随机数/","link":"","permalink":"https://bawcat.wiki/2020/01/03/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%97%A5%E6%9C%9F%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"","text":"Java 日期和随机数 这一章节 我们主要学习 java.util 中的 Date 类、Calendar 类，Random 类以及 java.time 包中的 LocalTime 类。 java.util 和 java.time 包ava.util 包提供了一些实用的方法和数据结构。比如日期类 Date，日历类 Calendar 以及随机数类 Random，同时包里还提供了 collection 框架，像堆栈 Stack、向量 Vector、位集合 Bitset 以及哈希表 Hashtable 等表示数据结构的类。而 java.time 包是 java8 新提供的包，里面对时间和日期提供了新的 api，弥补了 java.util 包对日期和时间操作的不足。 DateDate 类表示时间和日期,里面封装了操作日期和时间的方法. Date类经常用来获取系统当前时间。 Date中当前未过时的构造方法: 构造方法 说明 Date() 构造一个Date对象并对其进行初始化以反映当前时间 Date(long date) 构造一个Date对象，并根据相对于GMT1970年1月1日 00:00:00 的毫秒数对其进行初始化 代码示例: 12345678910111213141516import java.util.*;public class DateDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; String strDate, strTime = &quot;&quot;; Date objDate = new Date(); System.out.println(&quot;今天的日期是：&quot; + objDate); long time = objDate.getTime(); System.out.println(&quot;自 1970 年 1 月 1 日起以毫秒为单位的时间（GMT）：&quot; + time); strDate = objDate.toString(); //提取 GMT 时间 strTime = strDate.substring(11,(strDate.length() - 4)); //按小时、分钟和秒提取时间 strTime = &quot;时间：&quot; + strTime.substring(0,8); System.out.println(strTime); &#125;&#125; 温馨提示 Date 很多方法在JDK1.1开始就已经过时了.想要了解可以去官网查询 Calendar在早期的JDK版本中，Date类附有两大功能： 允许用年、月、日、时、分、秒来解释日期 允许对表示日期的字符串进行格式化和句法分析 在JDK1.1中提供了类Calendar来完成第一种功能，类DateFormat来完成第二项功能。DateFormat是java.text包中的一个类。与Date类有所不同的是，DateFormat类可以接受用各种语言和不同习惯表示的日期字符串。 但是Calendar类是一个抽象类，它完成Date类与普通日期表示法之间的转换，而我们更多的是使用Calendar类的子类GregorianCalendar类。它实现了世界上普遍的公历系统。当然我们也可以继承Calendar类，然后自己定义实现日历的方法. GregorianCalendar 构造方法： 构造方法 说明 GregorianCalendar 创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间 GregorianCalendar(TimeZone zone) 创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间 GregorianCalendar(Locale aLocale) 创建的对象中的相关值被设置成缺省的时区，指定地点aLocale的当前时间 GregorianCalendar(TimeZone zone,Locale aLocale) year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间 TimeZone是java.util包中的一个类，其中封装了有关时区的信息。每一个时区对应一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。 例如： 1234// 太平洋时区的ID为PSTTimeZone tz0 = TimeZone.getTimeZone(&quot;PST&quot;);// getDefault() 可以获取主机所处时区对象TimeZone tz1 = TimeZone.getDefault(); Locale只是一种机制，它用来标识一个特定的地理、政治或文化区域获取一个Locale对象的构造方法： 1234567// 调用 Locale 类的构造方法 Locale 10 = new Locale(String language);Locale 11 = new Locale(String language,String country);Locale 12 = new Locale(String language, String country, String variant);// 调用 Locale 类中定义的常量 Locale 11 = Locale.CHINA; 一个简单的示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.*;import java.text.*;public class CalendarDemo&#123; public static void main(String[] args) &#123; // 得到日期格式对象 // Date date = fmt.parse(strDateMake); System.out.println(&quot;完整显示日期时间：&quot;); // 字符串转换日期格式 DateFormat fdate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String str =fdate.format(new Date()); System.out.println(str); // 创建 Calendar 对象 Calendar calendar = Calendar.getInstance(); // 初始化 Calendar 对象，但并不必要，除非需要重置时间 calendar.setTime(new Date()); // 显示年份 System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR)); // 显示月份 （从 0 开始，实际显示要加一） System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH)); // 当前分钟数 System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE)); // 今年的第 N 天 System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;); // 本月第 N 天 System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;); // 3 小时以后 calendar.add(Calendar.HOUR_OF_DAY, 3); System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime()); // 格式化显示 str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()); System.out.println(str); // 重置 Calendar 显示当前时间 calendar.setTime(new Date()); str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()); System.out.println(str); // 创建一个 Calendar 用于比较时间 Calendar calendarNew = Calendar.getInstance(); // 设定为 5 小时以前，后者大，显示 -1 calendarNew.add(Calendar.HOUR, -5); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); // 设定 7 小时以后，前者大，显示 1 calendarNew.add(Calendar.HOUR, +7); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); // 退回 2 小时，时间相同，显示 0 calendarNew.add(Calendar.HOUR, -2); // calendarNew 创建时间点 System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime())); // calendar 创建时间点 System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime())); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); &#125;&#125; 其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。 有的人可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。 java.time因为 java8 之前的日期和时间 api 饱受诟病，比如线程安全问题，比如 Date 的月份是从 0 开始的！而 java.time 包中将月份封装成为了枚举类型。接下来来看看如何使用这个新的时间报 首先了解一下 LocalTime 类，LocalTime 类是一个不可变类（也就是用 final 修饰的类），和 String 类一样，所以它是线程安全的。除了 LocalTime 还有 LocalDate（日期）、LocalDateTime（日期和时间）等，他们的使用方式都差不多。下面来实际编写一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.time.*;import java.time.temporal.ChronoUnit;public class TimeDemo &#123; public static void main(String[] args) &#123; // 获得当前的日期和时间 LocalDateTime currentTime = LocalDateTime.now(); System.out.println(&quot;current date and time: &quot; + currentTime); // 输出当前时间的本地值（本时区） LocalDate date1 = currentTime.toLocalDate(); System.out.println(&quot;local date: &quot; + date1); Month month = currentTime.getMonth(); int day = currentTime.getDayOfMonth(); int seconds = currentTime.getSecond(); // 由当前时间对象获得各个字段，输出结果 System.out.println(&quot;month: &quot; + month +&quot;day: &quot; + day +&quot;seconds: &quot; + seconds); // 由当前时间附带月份和年再输出 LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012); System.out.println(&quot;date 2: &quot; + date2); // 输出 2016 年圣诞节的日期 LocalDate date3 = LocalDate.of(2016, Month.DECEMBER, 25); System.out.println(&quot;date 3: &quot; + date3); // 输出新闻联播的开始时间 LocalTime date4 = LocalTime.of(19, 00); System.out.println(&quot;date 4: &quot; + date4); // 转化为字符串，再输出 LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;); System.out.println(&quot;date 5: &quot; + date5); // 将字符串代表的时区信息转化 ZonedDateTime date6 = ZonedDateTime.parse(&quot;2016-04-20T19:22:15+01:30[Europe/Paris]&quot;); System.out.println(&quot;date1: &quot; + date6); // 设定地区 ID 为亚洲的加尔各答（位于印度），并输出 ZoneId id = ZoneId.of(&quot;Asia/Kolkata&quot;); System.out.println(&quot;ZoneId: &quot; + id); // 获得系统默认的当前地区并输出 ZoneId currentZone = ZoneId.systemDefault(); System.out.println(&quot;CurrentZone: &quot; + currentZone); // 获得当前的日期并输出 LocalDate today = LocalDate.now(); System.out.println(&quot;Current date: &quot; + today); // 在当前日期的基础上增加两周时间再输出 LocalDate nextWeek = today.plus(2, ChronoUnit.WEEKS); System.out.println(&quot;two weeks after now: &quot; + nextWeek); // 在当前日期的基础上增加 6 个月的时间再输出 LocalDate nextMonth = today.plus(6, ChronoUnit.MONTHS); System.out.println(&quot;6 months after now: &quot; + nextMonth); // 在当前日期的基础上增加 5 年的时间再输出 LocalDate nextYear = today.plus(5, ChronoUnit.YEARS); System.out.println(&quot;5 years after now: &quot; + nextYear); // 在当前日期的基础上增加 20 年的时间再输出（一个 Decade 为 10 年） LocalDate nextDecade = today.plus(2, ChronoUnit.DECADES); System.out.println(&quot;20 years after now: &quot; + nextDecade); &#125;&#125; Randomjava实用工具类库中的类 java.util.Random 提供了昌盛各种类型随机的方法。它可以产生int、long、float、double 以及Gaussian等类型的随机数。这也是它与java.lang.Math 中的方法Random() 最大的不同之处，后者只产生double型的随机数 构造方法 说明 Random() 产生一个随机数需要基数，这里将系统时间作为seed Random(long seed) 使用单个long种子创建一个新的随机数生成器 普通方法原型 123456789101112131415161718192021//该方法是设定基值 seedpublic synchronized void setSeed(long seed)//该方法是产生一个整型随机数public int nextInt()//该方法是产生一个 long 型随机数public long nextLong()//该方法是产生一个 Float 型随机数public float nextFloat()//该方法是产生一个 Double 型随机数public double nextDouble()//该方法是产生一个 double 型的 Gaussian 随机数public synchronized double nextGaussian()/*synchronized 是 Java 语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码*/ 大家可以验证和尝试一下引入上面所讲的所有类，调用一下里面的各种方法 参考链接在线文档-jdk-zh","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 日期","slug":"java-日期","permalink":"https://bawcat.wiki/tags/java-%E6%97%A5%E6%9C%9F/"},{"name":"java 随机数","slug":"java-随机数","permalink":"https://bawcat.wiki/tags/java-%E9%9A%8F%E6%9C%BA%E6%95%B0/"}]},{"title":"java 集合框架","slug":"java/基础教学/集合框架","date":"2020-01-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/03/java/基础教学/集合框架/","link":"","permalink":"https://bawcat.wiki/2020/01/03/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"java 集合框架集合框架的介绍我们在超市买东西的时候，如果没有购物车是不是会很麻烦呢？Java 中集合类是一种工具类，就是像购物车一样的容器，存储任意数量的具有共同属性的对象。 我们为什么要用集合呢？一个类的内部有许多相同类型的属性，并且他们的作用与意义是一样的，我们最好用一个类似容器的东西去盛放他们，在类的内部就变得井然有序。所以集合便是在类的内部，对数据进行组织的作用。这样我们便可以简单而快速地搜索大量的条目。有的集合接口，提供了一系列排列有序的元素，并且可以在序列中快速地插入或者删除有关元素。还有一些集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型。 集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。 Collection 接口因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。 Collection接口是java集合框架里的一个根接口。他也是List、Set和Queue 接口的父接口。Collection接口中定义了可用于操作List、Set和Queue的方法–增删改查 方法 返回值 说明 add(E e) boolean 向collection的尾部追加指定的元素（可选操作） addAll(Collection&lt;? extend E&gt; c) boolean 将指定collection 中的所有元素都添加此collection中(可选操作) clear() void 移除此collection中的所有元素（可选操作） contains(Object o) boolean 如果此collection包含指定元素，则返回true containsAll(Collection&lt;?&gt; c) boolean 如果此collection包含指定collection的所有元素，则返回true equals(Object o) boolean 比较此collection与指定对象是否相等 hashCode() int 返回此collection的哈希码值 isEmpty() boolean 如果此collection不包含元素 则返回true iterator() Iterator 返回在此collection的元素上进行迭代的迭代器 remove(Object o) boolean 移除此collection中出现的首个指定元素（可选操作） removeAll(Collection&lt;?&gt; c) boolean 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作） retainAll(Collection&lt;?&gt; c) boolean 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作） size() int 返回此collection中的元素数 toArray() Object[] 返回包含此collection中所有元素的数组 toArray(T[] a) T[] 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同 List 接口 与 ArrayList 类List是一个接口，不能实例化，需要一个具体类来实现实例化。List集合中的对象按照一定的顺序排放，里面的内容可以重复。List接口实现的类有：ArrayList(实现动态数组)，Vector(实现动态数组), LinkedList(实现链表)，Stack(实现堆栈). List在Collection 基础上的方法 方法 返回值 说明 add(int index, E element) void 在列表的指定位置插入指定元素（可选操作） addAll(int index, Collection&lt;? extends E&gt; c) boolean 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作） get(int index) E 返回列表中指定位置的元素 indexOf(Object o) int 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1 lastIndexOf(Object o) int 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1 listIterator() ListIterator 返回此列表元素的列表迭代器（按适当顺序） listIterator(int index) ListIterator 返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始 remove(int index) E 移除列表中指定位置的元素（可选操作） set(int index, E element) E 用指定元素替换列表中指定位置的元素（可选操作） subList(int fromIndex, int toIndex) List 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图 今天我们主要来学习 java.util.ArrayList，ArrayList 类实现一个可增长的动态数组，它可以存储不同类型的对象，而数组则只能存放特定数据类型的值。 我们通过实际的例子来学习 ArrayList 吧！学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作。 先创建一个学生类： 1234567891011121314151617181920/* * 学生类 */public class Student &#123; public String id; public String name; public Student(String id, String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 管理学生类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import java.util.*;public class ListTest &#123; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 //我们以后会详细讲到 /** * 用于存放学生的 List */ public List&lt;Student&gt; students; public ListTest() &#123; this.students = new ArrayList&lt;Student&gt;(); &#125; /** * 用于往 students 中添加学生 */ public void testAdd() &#123; // 创建一个学生对象，并通过调用 add 方法，添加到学生管理 List 中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); // 取出 List 中的 Student 对象 Student temp = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name); Student st2 = new Student(&quot;2&quot;, &quot;李四&quot;); students.add(0, st2); Student temp2 = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name); // 对象数组的形式添加 Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; // Arrays 类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表 students.addAll(Arrays.asList(student)); Student temp3 = students.get(2); Student temp4 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name); System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(2, Arrays.asList(student2)); Student temp5 = students.get(2); Student temp6 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name); System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name); &#125; /** * 取得 List 中的元素的方法 */ public void testGet() &#123; int size = students.size(); for (int i = 0; i &lt; size; i++) &#123; Student st = students.get(i); System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过迭代器来遍历 */ // 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动 public void testIterator() &#123; // 通过集合的 iterator 方法，取得迭代器实例 Iterator&lt;Student&gt; it = students.iterator(); System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;); while (it.hasNext()) &#123; Student st = it.next(); System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过 for each 方法访问集合元素 * */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过 for each）：&quot;); for (Student obj : students) &#123; Student st = obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; //使用 java8 Steam 将学生排序后输出 students.stream()//创建 Stream //通过学生 id 排序 .sorted(Comparator.comparing(x -&gt; x.id)) //输出 .forEach(System.out::println); &#125; /** * 修改 List 中的元素 * */ public void testModify() &#123; students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;)); &#125; /** * 删除 List 中的元素 * */ public void testRemove() &#123; Student st = students.get(4); System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;); students.remove(st); System.out.println(&quot;成功删除学生！&quot;); testForEach(); &#125; public static void main(String[] args) &#123; ListTest lt = new ListTest(); lt.testAdd(); lt.testGet(); lt.testIterator(); lt.testModify(); lt.testForEach(); lt.testRemove(); &#125;&#125; 上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。 List 有两种基本的类型，除了ArrayList外，还有LinkedList，LinkedList类用于创建链表数据结构，两者的对比如下： ArrayList:它擅长于随机访问元素，但是插入和移除元素很慢 LinkedList： 它通过代价较低的在List中进行插入和删除操作，提供了优化的顺序访问，它在随机访问方面相对较慢，但是它的特性集较ArrayList更大。 Set接口 和 HashSet 类Set接口也是Collection接口的子接口，它有一个很重要也是很常用的实现类————HashSet,Set是元素无序并且不包含重复元素的collection(List可以重复)，被称为集。 HashSet由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。 接下来我们同样通过代码的形式来详细看一看吧！ 在上面我们实现了学生的管理，现在学生要做项目，每一个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理 因为项目组的组长由一个老师担任，首先我们来创建一个 PD 类 12345678910111213141516171819import java.util.HashSet;import java.util.Set;/* * 项目组长类 */public class PD &#123; public String id; public String name; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 //我们以后会详细讲到 public Set&lt;Student&gt; students; public PD(String id, String name)&#123; this.id = id; this.name = name; this.students = new HashSet&lt;Student&gt;(); &#125;&#125; 接下来我们便创建一个 SetTest 类，用来管理项目成员 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;public class SetTest &#123; public List&lt;Student&gt; students; public SetTest() &#123; students = new ArrayList&lt;Student&gt;(); &#125; /* * 用于往 students 中添加学生 */ public void testAdd() &#123; //创建一个学生对象，并通过调用 add 方法，添加到学生管理 List 中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); //添加到 List 中的类型均为 Object，所以取出时还需要强转 Student st2 = new Student(&quot;2&quot;,&quot;李四&quot;); students.add(st2); Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; students.addAll(Arrays.asList(student)); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(Arrays.asList(student2)); &#125; /** * 通过 for each 方法访问集合元素 * @param args */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过 for each）：&quot;); for(Object obj:students)&#123; Student st = (Student)obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; public static void main(String[] args)&#123; SetTest st = new SetTest(); st.testAdd(); st.testForEach(); PD pd = new PD(&quot;1&quot;,&quot;张老师&quot;); System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;); //创建一个 Scanner 对象，用来接收从键盘输入的学生 ID Scanner console = new Scanner(System.in); for(int i = 0;i &lt; 3; i++)&#123; System.out.println(&quot;请输入学生 ID&quot;); String studentID = console.next(); for(Student s:st.students)&#123; if(s.id.equals(studentID))&#123; pd.students.add(s); &#125; &#125; &#125; st.testForEachForSer(pd); // 关闭 Scanner 对象 console.close(); &#125; //打印输出，老师所选的学生！Set 里遍历元素只能用 foreach 和 iterator //不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素 public void testForEachForSer(PD pd)&#123; for(Student s: pd.students) &#123; System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name); &#125; &#125;&#125; HashMap类HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是无序排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。 下面我们通过代码来学习 Map 中的方法吧。都有过选课经历吧，我们就用 Map 来管理课程吧 创建一个Course类 12345678public class Course &#123; public String id; public String name; public Course(String id, String name)&#123; this.id = id; this.name = name; &#125;&#125; 创建一个MapTest类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest &#123; /** * 用来承装课程类型对象 */ public Map&lt;String, Course&gt; courses; /** * 在构造器中初始化 courses 属性 * @param args */ public MapTest() &#123; this.courses = new HashMap&lt;String, Course&gt;(); &#125; /** * 测试添加：输入课程 ID，判断是否被占用 * 若未被占用，输入课程名称，创建新课程对象 * 并且添加到 courses 中 * @param args */ public void testPut() &#123; //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称 Scanner console = new Scanner(System.in); for(int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;请输入课程 ID：&quot;); String ID = console.next(); //判断该 ID 是否被占用 Course cr = courses.get(ID); if(cr == null)&#123; //提示输入课程名称 System.out.println(&quot;请输入课程名称：&quot;); String name = console.next(); //创建新的课程对象 Course newCourse = new Course(ID,name); //通过调用 courses 的 put 方法，添加 ID-课程映射 courses.put(ID, newCourse); System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name); &#125; else &#123; System.out.println(&quot;该课程 ID 已被占用&quot;); continue; &#125; &#125; &#125; /** * 测试 Map 的 keySet 方法 * @param args */ public void testKeySet() &#123; //通过 keySet 方法，返回 Map 中的所有键的 Set 集合 Set&lt;String&gt; keySet = courses.keySet(); //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value for(String crID: keySet) &#123; Course cr = courses.get(crID); if(cr != null)&#123; System.out.println(&quot;课程：&quot; + cr.name); &#125; &#125; &#125; /** * 测试删除 Map 中的映射 * @param args */ public void testRemove() &#123; //获取从键盘输入的待删除课程 ID 字符串 Scanner console = new Scanner(System.in); while(true)&#123; //提示输出待删除的课程 ID System.out.println(&quot;请输入要删除的课程 ID！&quot;); String ID = console.next(); //判断该 ID 是否对应的课程对象 Course cr = courses.get(ID); if(cr == null) &#123; //提示输入的 ID 并不存在 System.out.println(&quot;该 ID 不存在！&quot;); continue; &#125; courses.remove(ID); System.out.println(&quot;成功删除课程&quot; + cr.name); break; &#125; &#125; /** * 通过 entrySet 方法来遍历 Map * @param args */ public void testEntrySet() &#123; //通过 entrySet 方法，返回 Map 中的所有键值对 Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet(); for(Entry&lt;String,Course&gt; entry: entrySet) &#123; System.out.println(&quot;取得键：&quot; + entry.getKey()); System.out.println(&quot;对应的值为：&quot; + entry.getValue().name); &#125; &#125; /** * 利用 put 方法修改 Map 中的已有映射 * @param args */ public void testModify()&#123; //提示输入要修改的课程 ID System.out.println(&quot;请输入要修改的课程 ID：&quot;); //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串 Scanner console = new Scanner(System.in); while(true) &#123; //取得从键盘输入的课程 ID String crID = console.next(); //从 courses 中查找该课程 ID 对应的对象 Course course = courses.get(crID); if(course == null) &#123; System.out.println(&quot;该 ID 不存在！请重新输入！&quot;); continue; &#125; //提示当前对应的课程对象的名称 System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name); //提示输入新的课程名称，来修改已有的映射 System.out.println(&quot;请输入新的课程名称：&quot;); String name = console.next(); Course newCourse = new Course(crID,name); courses.put(crID, newCourse); System.out.println(&quot;修改成功！&quot;); break; &#125; &#125; public static void main(String[] args) &#123; MapTest mt = new MapTest(); mt.testPut(); mt.testKeySet(); mt.testRemove(); mt.testModify(); mt.testEntrySet(); &#125;&#125; 参考链接在线文档-jdk-zh","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 集合框架","slug":"java-集合框架","permalink":"https://bawcat.wiki/tags/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"java.io 数据流","slug":"java/基础教学/数据流说明(IO)/数据流","date":"2020-01-03T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/03/java/基础教学/数据流说明(IO)/数据流/","link":"","permalink":"https://bawcat.wiki/2020/01/03/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/%E6%95%B0%E6%8D%AE%E6%B5%81/","excerpt":"","text":"Java 数据流接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()…; write(), writeChar(), writeBoolean()… 此外，还可以用 readLine() 方法读取一行信息。 常用方法 方法 返回值 说明 readBoolean() boolean readByte() byte readShort() short readChar() char readInt() int readLong() long readDouble() double readFloat() float readUnsignedByte() int readUnsignedShort() int readFully(byte[] b) void 从输入流中读取一些字节，并将它们存储在缓冲区数组 b 中 reaFully(byte[] b, int off,int len) void 从输入流中读取 len 个字节 skipBytes(int n) int 与 InputStream.skip 等价 readUTF() String 按照 UTF-8 形式从输入中读取字符串 readLine() String 按回车 (\\r) 换行 (\\n) 为分割符读取一行字符串，不完全支持 UNICODE writeBoolean(boolean v) void writeByte(int v) void writeShort(int v) void writeChar(int v) void writeInt(int v) void writeLong(long v) void writeFloat(float v) void writeDouble(double v) void write(byte[] b) void 与 OutputStream.write 同义 write(byte[] b, int off, int len) void 与 OutputStream.write 同义 write(int b) void 与 OutputStream.write 同义 writeBytes(String s) void 只输出每个字符的低 8 位；不完全支持 UNICODE writeChars(String s) void 每个字符在输出中都占两个字节 数据流类 DataInputStream 和 DataOutputStream 的处理对象除了是字节或字节数组外，还可以实现对文件的不同数据类型的读写： 分别实现了 DataInput 和 DataOutput 接口。 在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来。 提供了字符串读写的手段。 数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立： 1234FileInputStream fis = new FileInputStream(&quot;file1.txt&quot;);FileOutputStream fos = new FileOutputStream(&quot;file2.txt&quot;);DataInputStream dis = new DataInputStream(fis);DataOutputStream dos = new DataOutputStream(fos); 新建源代码文件 DataStream.java： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DataStream &#123; public static void main(String[] args) throws IOException&#123; //向文件 a.txt 写入 FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;); DataOutputStream dos = new DataOutputStream(fos); try &#123; dos.writeBoolean(true); dos.writeByte((byte)123); dos.writeChar(&#x27;J&#x27;); dos.writeDouble(3.1415926); dos.writeFloat(2.122f); dos.writeInt(123); &#125; finally &#123; dos.close(); &#125; //从文件 a.txt 读出 FileInputStream fis = new FileInputStream(&quot;a.txt&quot;); DataInputStream dis = new DataInputStream(fis); try &#123; System.out.println(&quot;\\t&quot; + dis.readBoolean()); System.out.println(&quot;\\t&quot; + dis.readByte()); System.out.println(&quot;\\t&quot; + dis.readChar()); System.out.println(&quot;\\t&quot; + dis.readDouble()); System.out.println(&quot;\\t&quot; + dis.readFloat()); System.out.println(&quot;\\t&quot; + dis.readInt()); &#125; finally &#123; dis.close(); &#125; &#125;&#125; 编译运行： 12345678$ javac DataStream.java$ java DataStream true 123 J 3.1415926 2.122 123 读写对象我们知道实例化的对象存在于内存中，如果我们想传输实例化的对象怎么办呢？可以通过 ObjectOutputStream 和 ObjectInputStream 将对象输入输出。 将对象的状态信息转换为可以存储或者传输的形式的过程又叫序列化。 新建一个源代码文件 ReadWriteObject.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class ReadWriteObject &#123; public static void main(String[] args) &#123; File file = new File(&quot;/home/project/user.file&quot;); try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file))) &#123; //将匿名对象 写入到file中，注意：被写入的对象必须实现了Serializable接口 objectOutputStream.writeObject(new User(&quot;admin&quot;, &quot;adminpwd&quot;)); objectOutputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //读取文件 打开输入流 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file))) &#123;// 将信息还原为user实例 User user = (User) objectInputStream.readObject(); //打印user信息 和上面创建的匿名对象的信息一致 System.out.println(user.toString()); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;//静态内部类 必须实现Serializable static class User implements Serializable &#123; private String username; private String password; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125;&#125; 编译运行： 123$ javac ReadWriteObject.java$ java ReadWriteObjectUser&#123;username=&#x27;admin&#x27;, password=&#x27;adminpwd&#x27;&#125; NIOJava NIO(New IO) 发布于 JDK1.4，用于代替 Java 标准 IO 。Java NIO 是面向缓存的、非阻塞的 IO，而标准 IO 是面向流的，阻塞的 IO。 首先理解 NIO 的重要概念：Buffer（缓冲区） NIO 读取或者写入数据都要通过 Buffer 通过 allocate() 方法分配 Buffer，Buffer 不可实例化，Buffer 是抽象类，需要使用具体的子类，比如 ByteBuffer。 Buffer 的参数 capacity ：缓冲区的容量 position ：当前指针位置，没读取一次缓冲区数据或者写入缓冲区一个数据那么指针将会后移一位 limit ：限制指针的移动，指针不能读取 limit 之后的位置 mark ：如果设置该值，那么指针将移动到 0 - position 的位置 最后可以这几个参数的关系如下：mark &lt;= position &lt;= limit &lt;= capacity 新建源代码文件 NioDemo.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.util.Scanner;public class NioDemo &#123; public static void main(String[] args) &#123; try &#123; File file = new File(&quot;/home/project/nio.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); &#125; //创建channel nio通过channel来连接文件 相当于桥梁 FileChannel writeChannel = new RandomAccessFile(file, &quot;rw&quot;).getChannel(); //创建一个ByteBuffer 容量为100 ByteBuffer byteBuffer = ByteBuffer.allocate(100); System.out.println(&quot;请输入字符串&quot;); Scanner in = new Scanner(System.in); String s = in.nextLine(); //将字符串写入到缓冲区 byteBuffer.put(s.getBytes()); System.out.println(&quot;写入数据后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity()); //为输出数据做准备 将limit移动到position位置，position置0 byteBuffer.flip(); System.out.println(&quot;flip后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity()); //将缓冲区写入channel writeChannel.write(byteBuffer); //清除缓冲区 为下次写入或者读取数据做准备 恢复到初始状态 position=0 limit=capacity=100 因为我们这里分配的容量大小为100 byteBuffer.clear(); System.out.println(&quot;clear后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity()); //关闭channel writeChannel.close(); FileChannel readChannel = new RandomAccessFile(file, &quot;r&quot;).getChannel(); //从channel中将数据读取到缓冲区 while (readChannel.read(byteBuffer) != -1) &#123; //为读取数据做准备 byteBuffer.flip(); //输出数据 设置解码器 Charset charset = Charset.forName(&quot;UTF-8&quot;); CharsetDecoder decoder = charset.newDecoder(); System.out.println(&quot;读取结果：&quot; + decoder.decode(byteBuffer)); //清除缓冲区 byteBuffer.clear(); &#125; readChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行示例: 12345678$ javac NioDemo.java$ java NioDemo请输入字符串hellojava写入数据后指针变化-position:9 limit：100 capacity :100flip后指针变化-position:0 limit：9 capacity :100clear后指针变化-position:0 limit：100 capacity :100shiyanlou","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"},{"name":"数据流","slug":"数据流","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/"}]},{"title":"java.io 字符流","slug":"java/基础教学/数据流说明(IO)/字符流","date":"2020-01-02T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/02/java/基础教学/数据流说明(IO)/字符流/","link":"","permalink":"https://bawcat.wiki/2020/01/02/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/%E5%AD%97%E7%AC%A6%E6%B5%81/","excerpt":"","text":"java.io 字符流字符串基类java.io 包中专门用于字符流处理的类，是以Reader和Writer为基础派生的一系列类 字符串以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。 同类InputStream 和 OutputStream一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。他们的方法与类InputStream 和 OutputStream类似，只不过其中的参数换成字符或字符数组 Reader 是所有的输入字符流的父类，他是一个抽象类 我们先来看一看基类 Reader 的方法，其用法与作用都与InputStream 和 OutputStream 类似，就不做过多的说明了 方法 返回值 close() void mark(int readAheadLimit) void markSupported() boolean read() int rerad(char[] cbuf,int off,int len) int ready() boolean reset() void skip(long n) long Writer 是所有的输出字符流的父类，它是一个抽象类。Writer的方法： 方法 返回值 close() void flush() void write(char[] cbuf) void write(char[] cbuf, int off,int len) void write(int c) void write(String str) void write(String str, int off, int len) void 转换流InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。 123456789InputStreamReader(InputStream in); //缺省规范说明//指定规范 encInputStreamReader(InputStream in, String enc);OutputStreamWriter(OutputStream out); //缺省规范说明//指定规范 encOutputStreamWriter(OutputStream out, String enc); 如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符。 1InputStreamReader ir = new InputStreamReader(is,&quot;8859_1&quot;); 缓冲流类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率。 在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用 32 字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍。 BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read() 方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据。 BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作写入的动作。 构造方法： 1234//[ ]里的内容代表可选参数BufferedInputStream(InputStream in [, int size])BufferedOutputStream(OutputStream out [, int size]) 举个例子，将缓冲流与文件流相接： 12345678910FileInputStream in = new FileInputStream(&quot;file.txt&quot;);FileOutputStream out = new FileOutputStream(&quot;file2.txt&quot;);//设置输入缓冲区大小为256字节BufferedInputStream bin = new BufferedInputStream(in,256)BufferedOutputStream bout = new BufferedOutputStream(out,256)int len;byte bArray[] = new byte[256];len = bin.read(bArray); //len 中得到的是实际读取的长度，bArray 中得到的是数据 对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出。 例如方法 copy(): 1234567891011public void copy(InputStream in, OutputStream out) throws IOException &#123; out = new BufferedOutputStream(out, 4096); byte[] buf = new byte[4096]; int len = in.read(buf); while (len != -1) &#123; out.write(buf, 0, len); len = in.read(buf); &#125; //最后一次读取得数据可能不到4096字节 out.flush();&#125; BufferedReader 和 BufferedWrite同样的，为了提高字符流处理的效率，java.io 中也提供了缓冲流 BufferedReader 和 BufferedWrite。其构造方法与 BufferedInputStream 和 BufferedOutPutStream 相类似。另外，除了 read() 和 write() 方法外，它还提供了整行字符处理方法： public String readLine() ： BufferedReader 的方法，从输入流中读取一行字符，行结束标志 \\n 、**\\r** 或者两者在一起（这是根据系统而定的） public void newLine() : BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符 \\n 或 \\r , 而是系统定义的行隔离标志(line separator) 看一看例子: 1234567891011121314151617181920212223import java.io.BufferedReader;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class FileToUnicode &#123; public static void main(String args[]) &#123; try &#123; FileInputStream fis = new FileInputStream(&quot;file1.txt&quot;); InputStreamReader dis = new InputStreamReader(fis); BufferedReader reader = new BufferedReader(dis); String s; //每次读取一行，当改行为空时结束 while((s = reader.readLine()) != null)&#123; System.out.println(&quot;read:&quot; + s); &#125; dis.close(); &#125; catch(IOException e) &#123; System.out.println(e); &#125; &#125;&#125; 如file1.txt 的内容如下: 123abcefghij 输出结果： 12345$ javac FileToUnicode.java$ java FileToUnicoderead:abcread:efgread:hij 其他字符流类在这里我们就列举一下有哪些类，具体的就不仔细列举了。 对字符数组进行处理： CharArrayReader、CharArrayWrite 对文本文件进行处理：FileReader、FileWriter 对字符串进行处理：StringReader、StringWriter 过滤字符流：FilterReader、FileterWriter 管道字符流：PipedReader、PipedWriter 行处理字符流：LineNumberReader 打印字符流：PrintWriter 类有千万，方法更是不计其数，所以没有必要去掌握所有的方法和类，只需要知道常见常用的就行了，而大多数的类和方法，希望大家有一个印象，当我们在实际开放的时间，能够想到，并且借助其他工具去查询我们需要的方法的应用方式就可以了。 参考链接 在线文档-jdk-zh Java IO 流学习总结","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"},{"name":"字符流","slug":"字符流","permalink":"https://bawcat.wiki/tags/%E5%AD%97%E7%AC%A6%E6%B5%81/"}]},{"title":"java.io 字节流","slug":"java/基础教学/数据流说明(IO)/字节流","date":"2020-01-02T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/02/java/基础教学/数据流说明(IO)/字节流/","link":"","permalink":"https://bawcat.wiki/2020/01/02/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/%E5%AD%97%E8%8A%82%E6%B5%81/","excerpt":"","text":"java.io 字节流基类 InputStream 和 OutputStream字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，他们是抽象类，不能直接使用。字节流能处理所有类型的数据（如图片、avi 等）。 InputStreamInputStream 是所有表示字节输入流的基类，继承它的子类要重新定义其中所有定义的抽象方法.InputStream是从装置来源地读取数据的抽象表示，例如System中的标准输入流in对象就是一个InputStream类型的实例。 我们先来看看InputStream类的方法： 方法 说明 read()throws IOException 从输入流中读取数据的下一个字节（抽象方法） skip(long n) throws IOException 跳过和丢弃此输入流中数据的n个字节 available() throws IOException 返回流中可用字节数 mark(int readlimit) throws IOException 在此输入流中标记当前的位置 reset() throws IOException 将此流重新定位到最后一次对此输入流调用mark方法时的位置 markSupport() throws IOException 测试此输入流是否支持mark 和 reset 方法 close() throws IOException 关闭流 在InputStream类中，方法read()提供了三种从流中读数据的方法； int read(): 从输入流中读一个字节，形成一个0~255之间的整数返回（是一个抽象方法） int read(byte b[]): 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。 int read(byte b[], int off,int len): 从输入流中读取长度为len的数据，写入数组b中从索引off开始的位置，并返回读取的字节数。 对于这三个方法，若返回-1，表明流结束，否则，返回实际读取的字符数。 OutputStreamOutputStream 是所有表示字节输出流类的基类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是 java.io.PrintStream，这个类是 OutputStream 的子类。 OutputStream 类方法： 方法 说明 write(int b)throws IOException 将指定的字节写入此输出流（抽象方法） write(byte b[])throws IOException 将字节数组中的数据输出到流中 write(byte b[], int off, int len)throws IOException 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流 flush()throws IOException 刷新此输出流并强制写出所有缓冲的输出字节 close()throws IOException 关闭流 看个例子 1234567891011121314151617181920212223242526272829import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class test &#123; /** * 把输入流中的所有内容赋值到输出流中 * @param in * @param out * @throws IOException */ public void copy(InputStream in, OutputStream out) throws IOException &#123; byte[] buf = new byte[4096]; int len = in.read(buf); //read 是一个字节一个字节地读，字节流的结尾标志是-1 while (len != -1)&#123; out.write(buf, 0, len); len = in.read(buf); &#125; &#125; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub test t = new test(); System.out.println(&quot;输入字符：&quot;); t.copy(System.in, System.out); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"},{"name":"字节流","slug":"字节流","permalink":"https://bawcat.wiki/tags/%E5%AD%97%E8%8A%82%E6%B5%81/"}]},{"title":"Java 文件操作（文件流）","slug":"java/基础教学/数据流说明(IO)/文件流","date":"2020-01-02T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/02/java/基础教学/数据流说明(IO)/文件流/","link":"","permalink":"https://bawcat.wiki/2020/01/02/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/%E6%96%87%E4%BB%B6%E6%B5%81/","excerpt":"","text":"java 文件 （Java io）文件操作java.io 定义的大多数类都是流式操作，但 File 类不是。它直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它描述了文件本身的属性。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list( ) 方法检测的文件名列表。 先看一看 File 的构造方法： 1234567891011//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。File(File parent, String child)//通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例File(String pathname)// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例File(String parent, String child)//通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例File(URI uri) 例如: 12345678//一个目录路径参数File f1 = new File(&quot;/Users/mumutongxue/&quot;);//对象有两个参数——路径和文件名File f2 = new File(&quot;/Users/mumutongxue/&quot;,&quot;a.bat&quot;);//指向 f1 文件的路径及文件名File f3 = new File(f1,&quot;a.bat&quot;); 再来看看File的一些方法 方法 说明 boolean canExecute() 测试应用程序是否可以执行此抽象路径名表示的文件 boolean canRead() 测试应用程序是否可以读取此抽象路径名表示的文件 boolean canWrite() 测试应用程序是否可以修改此抽象路径名表示的文件 int compareTo(File pathname) 按字母顺序比较两个抽象路径名 boolean createNewFile() 当且仅当不存在具有抽象路径名指定名称的文件时，不可分地创建一个新的空文件 static File createTempFile(String prefix, String suffix, File directory) 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称 static File createTempFile(String prefix, String suffix, File idrectory) 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称 boolean delete() 删除此抽象路径名表示的文件或目录 void deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录 boolean equals(Object obj) 测试此抽象路径名与给定对象是否相等 boolean exists() 测试此抽象路径名表示的文件或目录是否存在 File getAbsoluteFile() 返回此抽象路径名的绝对路径名形式 String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 File getCanonicalFile() 返回此抽象路径名的规范形式 String getCanonicalPath() 返回此抽象路径名的规范名字符串 long getFreeSpace() 返回此抽象路径名指定的分区中为分配的字节数 String getName() 返回由此抽象路径名表示的文件或目录的名称 String getParent() 返回此抽象路径名父目录的路径字符串；如果此路径名没有指定父目录，则返回 null File getParentFile() 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回null String getPath() 将此抽象路径名转换为一个路径名字符串 long getTotalSpace() 返回此抽象路径名指定的分区大小 long getUsableSpace() 返回此抽象路径名指定的分区上可用于此虚拟机的字节数 int hashCode() 计算此抽象路径名的哈希码 boolean isAbsolute() 测试此抽象路径名是否为绝对路径名 boolean isDirectory() 测试此抽象路径名表示的文件是否一个目录 boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件 boolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件 long lastModified() 返回此抽象路径名表示的文件最后一次被修改的时间 long length() 返回由此抽象路径名表示的文件最后一次被修改的时间 String[] list() 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录 String[] list(FilenameFilter filter) 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录 File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件 File[] listFiles(FileFiter filter) 返回抽象路径名数组，这是路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录 File[] listFiles(FilenameFilter filter) 返回抽象路径名数组， 这些路径名表示此抽象路径名表示的 目录中满足指定过滤器的文件和目录 static File[] listRoots() 列出可用的文件系统根 boolean mkdir() 创建此抽象路径名指定的目录 boolean mkdirs() 创建此抽象路径名指定的目录，包括所有必须但不存在的父目录 boolean renameTo(File dest) 重新命名此抽象路径名表示的文件 boolean setExecutable(boolean executable) 设置此抽象路径名所有者执行权限的一个便捷方法 boolean setExecutable(boolean executable, boolean ownerOnly) 设置此抽象路径名的所有者或所有用户的执行权限 boolean setLastModified(long time) 设置此抽象路径名指定的文件或目录的最后一次修改时间 boolean setReadable(boolean readable) 设置此抽象路径名所有者读权限的一个便携方法 boolean setReadable(boolean readable, boolean ownerOnly) 设置此抽象路径名的所有者或所有用户的读权限 boolean setReadOnly() 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作 boolean setWritable(boolean writable, boolean ownerOnly) 设置此抽象路径名的所有者或所有用户的写权限 String toString() 返回此抽象路径名的路径名字符串 URI toURI() 构造一个表示此抽象路径名的file:URI 示例代码1234567891011121314151617181920212223242526272829303132333435363738import java.io.File;import java.io.IOException;public class FileDemo &#123; public static void main(String[] args)&#123; //同学们可以根据自己的路径进行更改 File f1 =new File(&quot;/home/project/1.txt&quot;); //File(String parent,String child) File f2 =new File(&quot;/home/project&quot;,&quot;2.txt&quot;); //separator 跨平台分隔符 File f3 =new File(&quot;/home&quot;+File.separator+&quot;project&quot;); File f4 =new File(f3,&quot;3.txt&quot;); try &#123; System.out.println(f1); //当文件存在时返回 false；不存在时返回 true System.out.println(f2.createNewFile()); //当文件不存在时返回 false System.out.println(f3.delete()); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; //列出磁盘下的文件和文件夹 File[] files =File.listRoots(); for(File file:files)&#123; System.out.println(file); if(file.length()&gt;0)&#123; String[] filenames =file.list(); for(String filename:filenames)&#123; System.out.println(filename); &#125; &#125; &#125; &#125;&#125; 随机读写对于 FileInputStream/FileOutputStream、FileReader/FileWriter 来说，它们的实例都是顺序访问流，即只能进行顺序读/写。而类 RandomAccessFile 则允许文件内容同时完成读和写操作，它直接继承 object，并且同时实现了接口 DataInput 和 DataOutput。 随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。 RandomAccessFile 提供了支持随机文件操作的方法： readXXX() 或者 writeXXX(): 如 ReadInt(),ReadLine(),WriteChar(),WriteDouble() 等 int skipBytes(int n): 将指针向下移动若干字节 length(): 返回文件长度 long getFilePointer(): 返回指针当前位置 void seek(long pos): 将指针调用所需位置 在生成一个随机文件对象时，除了要指定文件对象和文件名之外，还需要指明访问文件的模式。 我们来看看RandomAccessFile的构造方法： 12RandomAccessFile(File file,String mode)RandomAccessFile(String name,String mode) mode 的取值： r: 只读，任何写操作都讲抛出 IOException rw: 读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容。 rws: 打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 rwd: 打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。 例子： 1234567891011121314151617181920212223import java.io.IOException;import java.io.RandomAccessFile;public class FileDemo &#123; public static void main(String[] args)&#123; int data_arr[] = &#123;12, 32, 43, 45, 1, 5&#125;; try &#123; RandomAccessFile randf=new RandomAccessFile(&quot;temp.dat&quot;,&quot;rw&quot;); for(int i = 0; i &lt; data_arr.length; i++)&#123; randf.writeInt(data_arr[i]); &#125; for(int i = data_arr.length-1 ; i &gt;= 0; i--)&#123; //int 数据占 4 个字节 randf.seek(i * 4L); System.out.println(randf.readInt()); &#125; randf.close(); &#125;catch(IOException e)&#123; System.out.println(&quot;File access error&quot; + e); &#125; &#125;&#125; 参考链接 在线文档-jdk-zh","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"}]},{"title":"函数式接口、默认方法和Optional类","slug":"java/基础教学/函数式接口的默认方法和Optional类","date":"2020-01-01T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/01/java/基础教学/函数式接口的默认方法和Optional类/","link":"","permalink":"https://bawcat.wiki/2020/01/01/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8COptional%E7%B1%BB/","excerpt":"","text":"函数式接口、默认方法和Optional类函数式接口函数式接口通过一个单一的功能来表现。例如，带有**单个compareTo**方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于lambda表达式。 Java 8 引入的一个核心概念是函数式接口（Functional Interfaces）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。引用自IBM - Java 8 新特性概述 相关的接口及描述下面是部分函数式接口的列表 接口 描述 BitConsumer&lt;T,U&gt; 改接口代表了接收两个输入参数T、U，并且没有返回的操作 BiFunction&lt;T,U,R&gt; 该接口代表提供接收两个参数T、U，并且产生一个结果R的方法 BinaryOperator 代表了基于两个相同类型的操作数, 产生任然是相同类型结果的操作 BiPredicate&lt;T,U&gt; 代表了对两个参数的断言操作（基于Boolean值的方法） BooleanSupplier 代表了一个给出Boolean值结果的方法 Consumer 代表了接受单一输入参数并且没有返回值的操作 DoubleBinaryOperator 代表了基于两个Double类型操作数的操作，并且返回一个Double类型的返回值 DoubleConsumer 代表了一个接受单个Double类型的参数并且没有返回的操作 DoubleFunction 代表了一个接受Double类型参数并且返回结果的方法 DoublePredicate 代表了对一个Double类型的参数的断言操作 DoubleSupplier 代表了一个给出Double类型值的方法 DoubleToIntFunction 代表了接受单个Double类型参数但返回Int类型结果的方法 DoubleToLongFunction 代表了接受单个Double类型参数但返回Long类型结果的方法 DoubleUnaryOperator 代表了基于单个Double类型操作数且产生Double类型结果的操作 Function&lt;T,R&gt; 代表了接受一个参数并且产生一个结果的方法 IntBinaryOperator 代表了对两个Int类型操作数的操作，并且产生一个Int类型的结果 IntConsumer 代表了接受单个Int类型参数的操作，没有返回结果 IntFunction 代表了接受Int类型参数并且给出返回值的方法 IntPredicate 代表了对单个Int类型参数的断言操作 更多的接口可以参考Java官方API手册：java.lang.Annotation Type FunctionalInterface。在实际使用过程中，加有 @FunctionalInterface 注解的方法均是此类接口，位于java.util.Funtion包中。 一个函数式编程的例子下面我们通过一个例子学习如何使用这些函数式编程的接口 新建一个类 NewFeaturesTester.java，以下是 NewFeaturesTester.java 类中应当输入的代码： 12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class NewFeaturesTester &#123; public static void main(String args[])&#123; List&lt;Integer&gt; list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9); System.out.println(&quot;All of the numbers:&quot;); eval(list, n-&gt;true); System.out.println(&quot;Even numbers:&quot;); eval(list, n-&gt; n%2 == 0 ); System.out.println(&quot;Numbers that greater than 5:&quot;); eval(list, n -&gt; n &gt; 5 ); &#125; public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for(Integer n: list) &#123; if(predicate.test(n)) &#123; System.out.println(n); &#125; &#125; &#125;&#125; 默认方法Java 8在接口方面引入了一个关于默认方法实现的新概念。它也是作为一种向后兼容能力而出现，旧的接口也能用到Lambda表达式中。例如，*List***或 *Collection*** 接口是没有forEach方法的声明的。但是，通过这些默认方法能够就能轻易地打破集合框架实现的限制。Java 8引入默认方式使得 List 和 Collection 接口能够拥有 forEach 方法的默认实现。实现了这些接口的类也不必再实现相同的功能了。 语法如下所示: 本段代码是示例代码,仅供理解使用。 12345public interface boy &#123; default void print()&#123; System.out.println(&quot;I am a boy&quot;); &#125;&#125; 多个默认值接口中有了默认方法之后，在同一个类里面实现两个带有相同默认方法的接口就可行了。 下面的代码演示了如何解决这种含糊不清的情况。 首先是同一个类里面的两个接口 本段是示例代码，仅供理解 1234567891011public interface younger &#123; default void print()&#123; System.out.println(&quot;I am a younger.&quot;); &#125;&#125;public interface learner &#123; default void print()&#123; System.out.println(&quot;I am a learner.&quot;); &#125;&#125; 第一个解决办法就是创建一个自有的办法，来重写默认的实现。就像这样： 本段代码是示例代码，仅供理解使用。 12345public class student implements younger, learner &#123; public void print()&#123; System.out.println(&quot;I am a younger and a learner, so I am a student.&quot;); &#125;&#125; 另一个解决办法就是使用超类 super 来调用特定接口的默认方法。 本段代码是示例代码，仅供理解使用 12345public class student implements younger, learner &#123; public void print()&#123; learner.super.print(); &#125;&#125; 静态默认方法你也可以为这个接口增加静态的辅助方法(helper), 就像下面这样： 本段代码是示例代码，仅供理解使用 123456789public interface Younger &#123; default void print()&#123; System.out.println(&quot;I am a younger.&quot;); &#125; static void sayHi()&#123; System.out.println(&quot;Young is the capital.&quot;); &#125;&#125; 一个默认方法的例子下面我们通过一个例子来掌握如何使用默认方法。请看下面的代码 12345678910111213141516171819202122232425262728293031public class NewFeaturesTester &#123; public static void main(String args[]) &#123; Younger younger = new Student(); younger.print(); &#125;&#125;interface Younger &#123; default void print() &#123; System.out.println(&quot;I am a younger.&quot;); &#125; static void sayHi() &#123; System.out.println(&quot;Young is the capital.&quot;); &#125;&#125;interface Learner &#123; default void print() &#123; System.out.println(&quot;I am a learner.&quot;); &#125;&#125;class Student implements Younger, Learner &#123; public void print() &#123; Younger.super.print(); Learner.super.print(); Younger.sayHi(); System.out.println(&quot;I am a student!&quot;); &#125;&#125; Optional 类Optional是一个容器对象，用于容纳非空对象。Optional对象通过缺失值值代表null。这个类有许多实用的方法来促使代码能够处理一些像可用或者不可用的值，而不是检查那些空值（null）。Java 8中引入的这个特性有点像Google Guava里的Optional（Guava 是一个 Google 的基于Java 6的类库集合的扩展项目）。 在Java官方文档的解释中，它是一个可以为null的容器对象。如果值存在则 isPresent() 方法会返回 true ，调用 get()方法会返回该对象。 类的声明及方法下面是java.util.Optional类的声明： 12public final class Optional&lt;T&gt;extends Object 这个类继承了java.lang.Object类大多数方法。主要有： 接口 描述 static Optional empty() 该方法返回一个空的Optional实例 boolean equals(Object obj) 该方法可以指示某个对象是否与当前Optional对象相等 Optional filter(Predicate&lt;? super predicate) 如果一个值存在并且这个值满足某个给定的断言，那么该方法将返回一个描述该值的Optional对象；否则，将返回一个空的Optional对象 Optional flatMap(Function&lt;? super T,Optional&gt; mapper) 如果一个值存在，该方法会把一个map方法应用于它，并且返回结果；否则，将返回空的Optional对象 T get() 如果一个值存在于当前Optional中，则返回这个值；否则将抛出一个NoSuchElementException异常 int hashCode() 返回当前值的hash编码值。若这个值不存在，则返回0 void ifPresent(Consumer&lt;? super T&gt; consumer) 如果一个值存在，该方法会通过该值调用指定的consumer。如果不存在，则不调用 boolean isPresent() 返回一个值是否存在 Optional map(Function&lt;? super T,? extends U&gt; mapper 如果一个值存在，则将某个map方法应用于它。如果这个值是非空的，则返回一个描述结果的Optional对象 static Optional of(T value) 返回某个存在的非空值的Optional对象 更多的你可以访问官方API手册查看：http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html 一个Optional类的例子1234567891011121314151617181920212223242526272829303132import java.util.Optional;public class NewFeaturesTester &#123; public static void main(String args[])&#123; NewFeaturesTester tester = new NewFeaturesTester(); Integer value1 = null; Integer value2 = new Integer(5); // ofNullable 允许传参时给出 null Optional&lt;Integer&gt; a = Optional.ofNullable(value1); // 如果传递的参数为null，那么 of 将抛出空指针异常（NullPointerException） Optional&lt;Integer&gt; b = Optional.of(value2); System.out.println(tester.sum(a,b)); &#125; public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123; // isPresent 用于检查值是否存在 System.out.println(&quot;First parameter is present: &quot; + a.isPresent()); System.out.println(&quot;Second parameter is present: &quot; + b.isPresent()); // 如果当前返回的是传入的默认值，orElse 将返回它 Integer value1 = a.orElse(new Integer(0)); // get 用于获得值，条件是这个值必须存在 Integer value2 = b.get(); return value1 + value2; &#125;&#125; 扩展阅读Java 8 Optional类深度解析 参考链接 Java SE 8: Lambda Quick Start The Java™ Tutorials - Default Methods","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 函数式编程","slug":"java/java-函数式编程","permalink":"https://bawcat.wiki/categories/java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 函数式接口","slug":"java-函数式接口","permalink":"https://bawcat.wiki/tags/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"java Optional","slug":"java-Optional","permalink":"https://bawcat.wiki/tags/java-Optional/"}]},{"title":"Lambad Streams （流）","slug":"java/基础教学/数据流说明(IO)/Lambad-Streams","date":"2020-01-01T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/01/java/基础教学/数据流说明(IO)/Lambad-Streams/","link":"","permalink":"https://bawcat.wiki/2020/01/01/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/Lambad-Streams/","excerpt":"","text":"Streams （流）Stream 是Java 8中的一个新的抽象层。通过使用Stream，你能以类似于SQL语句的声明式方式处理数据。 例如一个典型的SQL语句能够自动地返回某些信息，而不用在开发者这一端做任何的计算工作。同样，通过使用Java的集合框架，开发者能够利用循环做重复的检查。另外一个关注点是效率，就像多核处理器能够提升效率一样，开发者也可以通过并行化编程来改进工作流程，但是这样很容易出错。 因此，Stream的引入是为了解决上述痛点。开发者可以通行声明式数据处理，以及简单地利用多核处理体系而不用写特定的代码。 说了这么久，Stream究竟是什么呢？Stream代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是Stream的一些特性： 元素序列：Stream以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。 源：Stream可以将集合、数组和I/O资源作为输入源。 聚集操作：Stream支持诸如filter、map、limit、reduce等的聚集操作。 流水技术：许多Stream操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。collect()方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。 自动迭代：Stream的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。 扩展阅读：java 8 中的 Streams Api 详解 - IBM 产生流集合的接口有两个方法来产生流 stream() :该方法返回一个将集合视为源的连续流 parallelStream() :该方法返回一个将集合视为源的并行流。 相关的方法介绍 forEach :该方法用于对Steam中的每个元素进行迭代操作。下面的代码段演示了如何使用forEach方法输出10个输出数。 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); map :该方法用于将每个元素映射到对应的结果上。下面代码段演示了怎样用map方法输出唯一的某个数的平方。 123List&lt;Integer&gt; numbers = Arrays.asList(2,3,3,2,5,2,7);// get list of unique squaresList&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i ).distinct().collect(Collectiors.toList()); filter :该方法用于过滤满足条件的元素。下面的代码段演示了怎样输出使用了过滤方法的空字符串数量。 123List&lt;String&gt;strings = Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);// get count of empty stringlong count = strings.stream().filter(string -&gt; string.isEmpty()).count(); limit :该方法用于减少Stream的大小。下面的代码段演示了怎样有限制地输出10个随机数。 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); sorted :该方法用于对Stream排序。下面的代码段演示了怎样以有序的形式输出10个随机数 12Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println); 并行处理ParallelStream 是 Stream 用于并行处理的一种替代方案。下面的代码段演示了如何使用它来输出字符串的数量 12List&lt;String&gt; strings = Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);long count = strings.parallelStream().filter(String::isEmpty).count(); 当然，在连续的Stream与并行的Stream之间切换是很容易的。 CollectorCollector 用于合并Stream的元素处理结果。它可以用于返回一个字符串列表 示例代码： 12345List&lt;String&gt; strings = Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());System.out.println(&quot;Filtered List:&quot; + filtered);String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));System.out.println(&quot;Merged String: &quot; + mergedString); 统计工具Java 8引入了用于统计的Collector来计算Stream处理完成后的所有统计数据。 下面的代码段演示了如何使用它 12345678List&lt;Integer&gt; numbers = Arrays.asList(2,3,3,2,5,2,7);IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println(&quot;Highest number in List : &quot; + stats.getMax());System.out.println(&quot;Lowest number in List : &quot; + stats.getMin());System.out.println(&quot;Sum of all numbers : &quot; + stats.getSum());System.out.println(&quot;Average of all numbers : &quot; + stats.getAverage()); 一个Stream的例子下面我们通过一个例子来演示技巧 新建一个类NewFeaturesTester.java，以下是NewFeaturesTester.java 类中应当输入的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203import java.util.ArrayList;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.Map;public class NewFeaturesTester &#123; public static void main(String args[])&#123; System.out.println(&quot;Using Java 7: &quot;); // 统计空字符串的数量 List&lt;String&gt; strings = Arrays.asList(&quot;efg&quot;, &quot;&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;ghij&quot;,&quot;&quot;, &quot;lmn&quot;); System.out.println(&quot;List: &quot; +strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(&quot;Empty Strings: &quot; + count); count = getCountLength3UsingJava7(strings); System.out.println(&quot;Strings of length 3: &quot; + count); // 消除空字符串 List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(&quot;Filtered List: &quot; + filtered); // 消除空字符串，同时使用逗号来连接 String mergedString = getMergedStringUsingJava7(strings,&quot;, &quot;); System.out.println(&quot;Merged String: &quot; + mergedString); List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7); // 获得不同数字的平方的列表 List&lt;Integer&gt; squaresList = getSquares(numbers); System.out.println(&quot;Squares List: &quot; + squaresList); List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19); System.out.println(&quot;List: &quot; +integers); System.out.println(&quot;Highest number in List : &quot; + getMax(integers)); System.out.println(&quot;Lowest number in List : &quot; + getMin(integers)); System.out.println(&quot;Sum of all numbers : &quot; + getSum(integers)); System.out.println(&quot;Average of all numbers : &quot; + getAverage(integers)); // 输出10个随机数 System.out.println(&quot;Random Numbers: &quot;); Random random = new Random(); for(int i=0; i &lt; 10; i++)&#123; System.out.println(random.nextInt()); &#125; // 使用Java 8的新特性 System.out.println(&quot;Using Java 8: &quot;); System.out.println(&quot;List: &quot; +strings); count = strings.stream().filter(string-&gt;string.isEmpty()).count(); System.out.println(&quot;Empty Strings: &quot; + count); count = strings.stream().filter(string -&gt; string.length() == 3).count(); System.out.println(&quot;Strings of length 3: &quot; + count); filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;Filtered List: &quot; + filtered); mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;Merged String: &quot; + mergedString); squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList()); System.out.println(&quot;Squares List: &quot; + squaresList); System.out.println(&quot;List: &quot; +integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics(); // 输出结果 System.out.println(&quot;Highest number in List : &quot; + stats.getMax()); System.out.println(&quot;Lowest number in List : &quot; + stats.getMin()); System.out.println(&quot;Sum of all numbers : &quot; + stats.getSum()); System.out.println(&quot;Average of all numbers : &quot; + stats.getAverage()); System.out.println(&quot;Random Numbers: &quot;); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理 count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;Empty Strings: &quot; + count); &#125; // 使用Java 7版本就提供的API来计算空串数量 private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123; int count = 0; for(String string: strings)&#123; if(string.isEmpty())&#123; count++; &#125; &#125; return count; &#125; // 使用Java 7版本就提供的API来计算长度为3字符的字符串数量 private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123; int count = 0; for(String string: strings)&#123; if(string.length() == 3)&#123; count++; &#125; &#125; return count; &#125; // 使用Java 7版本就提供的API来删除空串 private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123; List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;(); for(String string: strings)&#123; if(!string.isEmpty())&#123; filteredList.add(string); &#125; &#125; return filteredList; &#125; // 使用Java 7版本就提供的API来获取合并后的字符串 private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123; StringBuilder stringBuilder = new StringBuilder(); for(String string: strings)&#123; if(!string.isEmpty())&#123; stringBuilder.append(string); stringBuilder.append(separator); &#125; &#125; String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length()-2); &#125; // 自定义的用于计算数字的平方的方法 private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123; List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;(); for(Integer number: numbers)&#123; Integer square = new Integer(number.intValue() * number.intValue()); if(!squaresList.contains(square))&#123; squaresList.add(square); &#125; &#125; return squaresList; &#125; // 自定义的用于获得List中最大值的方法 private static int getMax(List&lt;Integer&gt; numbers)&#123; int max = numbers.get(0); for(int i=1;i &lt; numbers.size();i++)&#123; Integer number = numbers.get(i); if(number.intValue() &gt; max)&#123; max = number.intValue(); &#125; &#125; return max; &#125; // 自定义的用于获得List中最小值的方法 private static int getMin(List&lt;Integer&gt; numbers)&#123; int min = numbers.get(0); for(int i=1;i &lt; numbers.size();i++)&#123; Integer number = numbers.get(i); if(number.intValue() &lt; min)&#123; min = number.intValue(); &#125; &#125; return min; &#125; // 自定义的用于获得List中各个数字的和的方法 private static int getSum(List&lt;Integer&gt; numbers)&#123; int sum = (int)(numbers.get(0)); for(int i=1;i &lt; numbers.size();i++)&#123; sum += (int)numbers.get(i); &#125; return sum; &#125; // 自定义的用于获得List中各个数字的平均值的方法 private static int getAverage(List&lt;Integer&gt; numbers)&#123; return getSum(numbers) / numbers.size(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 函数式编程","slug":"java/java-函数式编程","permalink":"https://bawcat.wiki/categories/java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Streams","slug":"java-Streams","permalink":"https://bawcat.wiki/tags/java-Streams/"}]},{"title":"Java IO 流","slug":"java/基础教学/数据流说明(IO)/基础流","date":"2020-01-01T04:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2020/01/01/java/基础教学/数据流说明(IO)/基础流/","link":"","permalink":"https://bawcat.wiki/2020/01/01/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AF%B4%E6%98%8E(IO)/%E5%9F%BA%E7%A1%80%E6%B5%81/","excerpt":"","text":"Java IO 流在大多数程序中，都需要对输入输出进行处理。例如我们中需要获取用户从键盘上的输入，需要在控制台输出结果等等。除此之外还有从文件中读取数据，向文件中写入数据等等。在 Java 中，我们把这些不同类型的输入输出源抽象地称为 流，也就是 Stream；在里面输入输出的数据则称为数据流（Data Stream），它们通常具有统一的接口。 于是我们得到了数据流的定义： 一个 Java I/O 对象叫做数据流。读取数据到内存的对象叫做输入流，内存写出数据的对象叫做输出流。 针对其面向的不同角度，我们大致可以将流分为下面几种类型： 按照数据流的方向不同分为 输入流 和 _输出流_。这种分类不是绝对的，例如在向一个文件写入数据时，它就是输出流；而在读取数据时，它就是输入流。 按照处理数据的单位不同分为 字节流 和 字符流。 按照功能的不同分为 节点流 和 _处理流_。 需要特别说明，节点流是从特定的数据节点（文件、数据库、内存等）读写数据；处理流是连接在已有的流上，通过对数据的处理为程序提供更多功能。 在 Java 环境中，java.io 包提供了大多数的类和接口来实现输入输出管理。一些标准的输入输出则来自 java.lang 包中的类，但它们都是继承自 java.io 中的类。我们可以将输入流理解为数据的提供者，而把输出流理解为数据的接收者。在最初的时候，这些派生自抽象类 InputStream 和 OutputStream 的输入输出类是面向 8 位的字节流的。但为了支持国际化，又引入了派生自抽象类 Reader 和 Writer 的类层次，用于读写一些双字节的 Unicode 字符。 因此，在学习 java 的输入输出上，我们希望你以字节流和字符流作为区分来学习。 如果需要概括一下，则可以得到下面的定义： 字节流：表示以字节为单位从 stream 中读取或往 stream 中写入信息。通常用来读取二进制数据。 字符流：以 Unicode 字符为单位从 stream 中读取或往 stream 中写入信息。 按照这样的定义，Java 中流的层级结构可以通过下图来表示： 图中蓝色的部分均为抽象类，而绿色的部分则为派生类，是可以直接使用的。 而下图简要说明了字节流和字符流的区别，你也可以进一步了解字节流与字符流的区别。 我们知道 Java 是一门面向对象的语言，所以为了能够永久地保存对象的状态，java.io包还以字节流为基础，通过实现 ObjectInput 和 ObjectOutput 接口提供了 _对象流_。在此仅作引入，你可以通过查阅 API 手册来详细了解它们。","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"}]},{"title":"关于java Calendar Date Math 类的使用","slug":"java/基础教学/Calendar-Math-Date","date":"2019-12-29T11:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2019/12/29/java/基础教学/Calendar-Math-Date/","link":"","permalink":"https://bawcat.wiki/2019/12/29/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/Calendar-Math-Date/","excerpt":"","text":"java Calendar、Date、Math 的使用 记录 Calendar 的使用方法 Calendar 这是时间类 在早期的jdk版本中，Date类附有两大功能: 允许用年、月、日、时、分、秒来解释日期 允许对表示日期的字符串进行格式化和句法分析 在JDK1.1中提供了类Calendar来完成第一种功能，类DateFormat来完成第二项功能。DateFormat是java.text包中的一个 类。与Date类中有所不同的是，DateFormat类可以接受用各种语言和不同习惯表示的日期字符串。 但是Calendar 类是一个抽象类，他完成Date类与普通日期表示法之间的转换，而我们更多地是使用Calendar类的子类 GregorianCalendar类。它实现了世界上普遍使用的公历系统。当然我们也可以继承Calendar类，然后自己定义实现日历 方法。 先来看一看GregorianCalendar类的构造函数： 构造方法 说明 GregorianCalendar() 创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行所处的时区、地点的当前时间 GregorianCalendar(TimeZone zone) 创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间 GregorianCalendar(Locale aLocale) 创建的对象中的相关值被设置成缺省时区，指定地点aLocale的当前时间 GregorianCalendar(TimeZone zone,Locale aLocale) year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间 TimeZone是java.util包中的一个类,其中封装了有关时区的信息。每一个时区对应一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。 例如： 1234// 太平洋时区的ID 为 PSTTimeZone tz0 = TimeZone.getTimeZone(&quot;PST&quot;);// getDefault() 可以获取主机所在时区的对象TimeZone tz1 = TimeZone.getDefault(); Locale只是一种机制，他用来标识一个特定的地理、政治或文化区域取一个Locale对象的构造方法: 123456// 调用Locale类的构造方法Locale 10 = new Locale(String language)Locale 11 = new Locale(String language,String country)Locale 12 = new Locale(String language,String country,String variant)// 调用Locale类中定义的常量Locale 11 - Locale.CHINA 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class CalendarDemo &#123; public static void main(String[] args) &#123; System.out.println(&quot;完整显示日期时间：&quot;); // 字符串转换日期格式 DateFormat fdate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String str = fdate.format(new Date()); System.out.println(str); // 创建 Calendar 对象 Calendar calendar = Calendar.getInstance(); // 初始化 Calendar 对象，但并不必要，除非需要重置时间 calendar.setTime(new Date()); // 显示年份 System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR)); // 显示月份 (从0开始, 实际显示要加一) System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH)); // 当前分钟数 System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE)); // 今年的第 N 天 System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;); // 本月第 N 天 System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;); // 3小时以后 calendar.add(Calendar.HOUR_OF_DAY, 3); System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime()); // 格式化显示 str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()); System.out.println(str); // 重置 Calendar 显示当前时间 calendar.setTime(new Date()); str = (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()); System.out.println(str); // 创建一个 Calendar 用于比较时间 Calendar calendarNew = Calendar.getInstance(); // 设定为 5 小时以前，后者大，显示 -1 calendarNew.add(Calendar.HOUR, -5); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); // 设定7小时以后，前者大，显示 1 calendarNew.add(Calendar.HOUR, +7); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); // 退回 2 小时，时间相同，显示0 calendarNew.add(Calendar.HOUR, -2); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); // calendarNew创建时间点 System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime())); // calendar创建时间点 System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime())); System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar)); &#125;&#125; 输出结果 12345678910111213141516完整显示日期时间：2019-12-12 06:17:57年： 2019月： 11分钟： 17今年的第 346天本月的第 12天三小时以后的时间： Thu Dec 12 09:17:57 UTC 20192019-12-12 09:17:57:1082019-12-12 06:17:57:122时间比较：-1时间比较：1时间比较：12019-12-12 06:17:57:1232019-12-12 06:17:57:122时间比较：1 大家运行上面的代码后，看见控制台上的输出结果会不会有所疑问呢？ 其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。 有的人可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时 间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一 些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。 Date Date 类表示日期和时间，里面封装了操作日期和时间的方法.Date类经常用来获取系统当前时间 Date 中定义的未过时的构造方法: 构造方法 说明 Date() 构造一个Date对象并对其进行初始化以反映当前时间 Date(long date) 构造一个Date对象，并根据相对于 GMT 1970年1月1日 00:00:00的毫秒数以对其进行初始化 示例代码： 123456789101112131415161718192021import java.text.SimpleDateFormat;import java.util.Date;public class DateDemo&#123; public static void main(String[] args)&#123; String strDate, strTime; Date objDate = new Date(); System.out.println(&quot;今天的日期是: &quot; + objDate); long time = objDate.getTime(); System.out.println(&quot;自1970年1月1日起以毫秒为单位的时间（GMT）&quot; + time); strDate = objDate.toString(); // 提取GMT时间 strTime = strDate.substring(11, (strDate.length() - 4)); // 按照小时、分钟和秒提取时间 strTime = &quot;时间：&quot; + strTime.substring(0,8); System.out.println(strTime); // 格式化时间 SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;); System.out.println(formatter.format(objDate)); &#125;&#125; 运行结果: 123456$ javac DateDemo.java$ java DateDemo 今天的日期是: Thu Dec 12 06:34:45 UTC 2019自1970年1月1日起以毫秒为单位的时间（GMT）1576132485389时间：06:34:452019-12-12 06:34:45:389 注意 Date类的很多方法自 JDK 1.1 开始就已经过时了。 Math Math 类在java.lang 包中，包含用于执行基本数学运算的方法,如初等指数、对数、平方根和三角函数 常见方法: 方法 返回值 功能描述 sin(double numvalue) double 计算角numvalue的正弦值 cos(double numvalue) double 计算角 numvalue 的余弦值 acos(double numvalue) double 计算 numvalue 的反余弦 asin(double numvalue) double 计算 numvalue 的反正弦 atan(double numvalue) double 计算 numvalue 的反正切 pow(double a, double b) double 计算 a 的 b 次方 sqrt(double numvalue) double 计算给定值的正平方根 abs(int numvalue) int 计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数 ceil(double numvalue) double 返回大于等于 numvalue 的最小整数值 floor(double numvalue) double 返回小于等于 numvalue 的最大整数值 max(int a, int b) int 返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数 min(int a, int b) int 返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数 rint(double numvalue) double 返回最接近 numvalue 的整数值 round(T arg) arg 为 double 时返回long,为float 时返回int 返回最接近arg的整数值 random() double 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0 上面都是一些常用的方法，如果同学们还会用到极坐标、对数等，就去查一查手册吧。 示例代码: 1234567891011121314public class MathDemo &#123; public static void main(String[] args) &#123; System.out.println(Math.abs(-12.7)); System.out.println(Math.ceil(12.7)); System.out.println(Math.rint(12.4)); System.out.println(Math.random()); System.out.println(&quot;sin30 = &quot; + Math.sin(Math.PI / 6)); // 计算30°的正弦值，参数是用弧度表示的角，即π的六分之一 System.out.println(&quot;cos30 = &quot; + Math.cos(Math.PI / 6)); // 计算30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为double System.out.println(&quot;tan30 = &quot; + Math.tan(Math.PI / 6)); // 计算30°的正切值 &#125;&#125; 输出结果: 123456789$ javac MathDemo.java$ java MathDemo12.713.012.00.4548881782067914sin30 = 0.49999999999999994cos30 = 0.8660254037844387tan30 = 0.5773502691896257","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Calendar","slug":"java-Calendar","permalink":"https://bawcat.wiki/tags/java-Calendar/"},{"name":"java Math","slug":"java-Math","permalink":"https://bawcat.wiki/tags/java-Math/"},{"name":"java Date","slug":"java-Date","permalink":"https://bawcat.wiki/tags/java-Date/"}]},{"title":"关于java Collections 类的使用","slug":"java/基础教学/基础数据类型/Collections","date":"2019-12-29T10:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/29/java/基础教学/基础数据类型/Collections/","link":"","permalink":"https://bawcat.wiki/2019/12/29/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Collections/","excerpt":"","text":"Java Collections java.util.Collections 是一个工具类,他包含了大量对集合进行操作的静态方法. 方法名 描述 void sort(List list) 按自然升序排序 void sort(List list,Comparator c) 自定义排序规则排序 void shuffle(List list) 随机排序,用于打乱顺序 void reverse(List list) 反转,将列表元素顺序反转 void swap(List list,int i,int j) 交换处于索引 i 和 j 位置的元素 int binarySearch(List list,Object key) 二分查找,列表必须有序,返回找到的元素索引位置 int max(Collection coll) 查找最大值 int min(Collection coll) 查找最小值 void fill(List list,Object obj) 使用obj填充list所有元素 boolean replaceAll(List list,Object oldVal,Object newVal) 使用用newVal替换所有的oldVal &lt;K,V&gt;Map&lt;K,V&gt; synchronizedList(List list) 将list包装为线程安全的List List synchronizedList(List list) 将list包装为线程安全的List 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CollectionsDemo &#123; public static void main(String[] args) &#123;// 创建一个空List List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //赋值 list.add(3); list.add(5); list.add(7); list.add(9); list.add(12); System.out.print(&quot;初始顺序：&quot;); list.forEach(v -&gt; System.out.print(v + &quot;\\t&quot;)); //打乱顺序 Collections.shuffle(list); System.out.print(&quot;\\n打乱顺序：&quot;); list.forEach(v -&gt; System.out.print(v + &quot;\\t&quot;)); //反转 Collections.reverse(list); System.out.print(&quot;\\n反转集合：&quot;); list.forEach(v -&gt; System.out.print(v + &quot;\\t&quot;)); //第一个位和最后一位交换 Collections.swap(list,0,list.size()-1); System.out.print(&quot;\\n交换第一位和最后一位：&quot;); list.forEach(v -&gt; System.out.print(v + &quot;\\t&quot;)); //按自然升序排序 Collections.sort(list); System.out.print(&quot;\\nSort排序后：&quot;); list.forEach(v -&gt; System.out.print(v + &quot;\\t&quot;)); //二分查找 必须排序后 System.out.print(&quot;\\n二分查找数值7的位置：&quot;+Collections.binarySearch(list, 7)); //返回线程安全的list List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list); &#125;&#125; 运算结果: 12345678$ javac CollectionsDemo.java$ java CollectionsDemo初始顺序：3 5 7 9 12 打乱顺序：5 7 3 12 9 反转集合：9 12 3 7 5 交换第一位和最后一位：5 12 3 7 9 Sort排序后：3 5 7 9 12 二分查找数值7的位置：2","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Collections","slug":"java-Collections","permalink":"https://bawcat.wiki/tags/java-Collections/"}]},{"title":"Lambad 表达式的含义及使用方法、引用","slug":"java/基础教学/lambad表达式","date":"2019-12-27T08:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2019/12/27/java/基础教学/lambad表达式/","link":"","permalink":"https://bawcat.wiki/2019/12/27/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Lambad 表达式的含义及使用方法、引用什么是函数式编程函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。 Lambad 表达式Lambad 表达式是在Java 8 中引入的。并且成为了Java 8最大的特点。它使得功能性编程变得非常便利，极大地简化了开发工作。 语法一个Lambad表达式具有下面这样的语法特征。它由三个部分组成；第一部分为一个括号内用都好分割的参数列表，参数即函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;; 第三部分为方法体，可以使表达式和代码块。语法如下 1parameter -&gt; expression body 下面列举了Lambad表达式的几个最重要的特征； 可选的类型声明：你不用去声明参数的类型。编译器可以从参数的值来推断它是什么类型。 可选的参数周围的括号：你可以不用在括号内声明单个参数。但是对于很多参数的情况，括号是必需的 可选的大括号：如果表达式体里面只有一个语句，那么你不必用大括号括起来。 可选的返回关键字：如果表达式体只有单个表达式用于值的返回，那么编译器会自动完成这一步。若要指示表达式来返回某个值，则需要使用大括号。 语言的设计者们思考了很多如何让现有的功能和lambda表达式友好兼容。于是就有了函数接口这个概念。函数接口是一种只有一个方法的接口，函数接口可以隐式地转换成 Lambda 表达式。 函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码。引用自IBM - Java 8 新特性概述。 一个Lambad 表达式的例子下面尝试写一些代码来理解Lambda表达式。新建一个类NewFeaturesTester.java，请在NewFeaturesTester.java中输入下面这些代码，对于它们的解释在注释中给出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class NewFeaturesTester &#123; public static void main(String args[])&#123; NewFeaturesTester tester = new NewFeaturesTester(); // 带有类型声明的表达式 MathOperation addition = (int a, int b) -&gt; a + b; // 没有类型声明的表达式 MathOperation subtraction = (a, b) -&gt; a - b; // 带有大括号、带有返回语句的表达式 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号和return语句的表达式 MathOperation division = (int a, int b) -&gt; a / b; // 输出结果 System.out.println(&quot;10 + 5 = &quot; + tester.operate(10, 5, addition)); System.out.println(&quot;10 - 5 = &quot; + tester.operate(10, 5, subtraction)); System.out.println(&quot;10 x 5 = &quot; + tester.operate(10, 5, multiplication)); System.out.println(&quot;10 / 5 = &quot; + tester.operate(10, 5, division)); // 没有括号的表达式 GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); // 有括号的表达式 GreetingService greetService2 = (message) -&gt; System.out.println(&quot;Hello &quot; + message); // 调用sayMessage方法输出结果 greetService1.sayMessage(&quot;Java&quot;); greetService2.sayMessage(&quot;Classmate&quot;); &#125; // 下面是定义的一些接口和方法 interface MathOperation &#123; int operation(int a, int b); &#125; interface GreetingService &#123; void sayMessage(String message); &#125; private int operate(int a, int b, MathOperation mathOperation)&#123; return mathOperation.operation(a, b); &#125;&#125; 需要注意的是： Lambda表达式优先用于定义功能接口在行内的实现，即单个方法只有一个接口。在上面的例子中，我们用了多个类型的Lambda表达式来定义MathOperation接口的操作方法。然后我们定义了GreetingService的sayMessage的实现 Lambda表达式让匿名类不再需要，这为Java增添了简洁但实用的函数式编程能力。 作用域我们可以通过下面这段代码来学习Lambda的作用域。请将代码修改至如下这些： 1234567891011121314151617181920public class NewFeaturesTester &#123; final static String salutation = &quot;Hello &quot;; //正确，不可再次赋值 //static String salutation = &quot;Hello &quot;; //正确，可再次赋值 //String salutation = &quot;Hello &quot;; //报错 //final String salutation = &quot;Hello &quot;; //报错 public static void main(String args[])&#123; //final String salutation = &quot;Hello &quot;; //正确，不可再次赋值 //String salutation = &quot;Hello &quot;; //正确，隐性为 final , 不可再次赋值 // salution = &quot;welcome to &quot; GreetingService greetService1 = message -&gt; System.out.println(salutation + message); greetService1.sayMessage(&quot;Java&quot;); &#125; interface GreetingService &#123; void sayMessage(String message); &#125;&#125; 可以得到以下结论： 可访问static修饰的成员变量,如果是final static 修饰，不可再次赋值，只有static修饰可再次赋值； 可访问表达式外层的final局部变量（不用声明为final，隐性具有final语义），不可再次赋值 方法引用 方法也是一种对象，可以通过名字来引用，不过方法引用的唯一用途是支持Lambad的简写，使用方法名称来表示Lambad。不能通过方法引用来获得诸如方法签名的相关信息。引用自永无止境，上下求索 的博客 方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。 方法引用可以通过方法的名字来引用其本身。方法引用是通过::符号（双冒号）来描述的。 它可以用来引用下列类型的方法： 构造器引用。语法是Class::new,或者更一般的Class::new,要求构造器方法是没有参数； 静态方法引用。语法是Class::static_method,要求接受一个Class类型的参数; 特定类的任意对象方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入； 更多对于方法引用的介绍，可以参考这一篇博文–java8 - 方法引用(method referrance) 例子： 123456789101112131415161718import java.util.List;import java.util.ArrayList;public class NewFeaturesTester &#123; public static void main(String args[])&#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;Peter&quot;); names.add(&quot;Linda&quot;); names.add(&quot;Smith&quot;); names.add(&quot;Zack&quot;); names.add(&quot;Bob&quot;); // 通过System.out::println引用了输出的方法 names.forEach(System.out::println); &#125;&#125; 参考链接 The Java™ Tutorials - Lambda Expressions The Java™ Tutorials - Method References java8 - 方法引用(method referrance) Java 8 特性 – 终极手册 JAVA8 十大新特性详解 Java9都快发布了，Java8的十大新特性你了解多少呢？","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 函数式编程","slug":"java/java-函数式编程","permalink":"https://bawcat.wiki/categories/java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Lambad","slug":"java-Lambad","permalink":"https://bawcat.wiki/tags/java-Lambad/"}]},{"title":"java 正则表达式 (regular)","slug":"java/基础教学/正则表达式","date":"2019-12-26T18:49:59.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/26/java/基础教学/正则表达式/","link":"","permalink":"https://bawcat.wiki/2019/12/26/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Java 的 正则表达式使用 正则表达式，又称规则表达式.（英语：Regular Expression ,在代码中常简写 regex 、 regexp 或 RE）, 计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本。 Java 通过 java.util.regex 包提供正则表达式的功能 示例Java 使用正则表达式匹配非常简单，我们以邮箱地址为例 12345678910111213141516import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexDemo &#123; public static void main(String[] args) &#123;// Pattern类 正则表达式的编译表示。 Pattern pattern = Pattern.compile(&quot;^[a-zA-Z0-9_!#$%&amp;&#x27;*+/=?`&#123;|&#125;~^.-]+@[a-zA-Z0-9.-]+$&quot;); String[] emails = &#123;&quot;shiyanlou@shiyanlou.com&quot;, &quot;shiyanlou&quot;&#125;; for (String email : emails) &#123;//Matcher 通过解释Pattern对字符序列执行匹配操作的引擎 Matcher matcher = pattern.matcher(email); System.out.println(email + &quot;匹配结果：&quot; + matcher.matches()); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java 正则","slug":"java-正则","permalink":"https://bawcat.wiki/tags/java-%E6%AD%A3%E5%88%99/"},{"name":"java regular","slug":"java-regular","permalink":"https://bawcat.wiki/tags/java-regular/"},{"name":"regular","slug":"regular","permalink":"https://bawcat.wiki/tags/regular/"}]},{"title":"java-反射","slug":"java/基础教学/关于反射","date":"2019-12-24T18:44:42.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/24/java/基础教学/关于反射/","link":"","permalink":"https://bawcat.wiki/2019/12/24/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Java 反射Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用，我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。 什么是反射？反射是Java 编程语言的一个腾讯，它提供了在运行时检查和动态调用类、方法、属性的能力。 反射能做什么？反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。 反射常用类常用类 Class：Class 类标识正在运行的Java程序中的类和接口 Field： 提供有关类或接口的单个域的信息和动态访问。如数据类型，访问修饰符，域的名称和值 Method ：提供有关类或接口上的单个构造函数的信息和访问权限。如访问修饰符，返回类型，名称，参数类型和方法的异常类型。 Constructor ：提供有关类的单个构造函数的信息和访问权限。例如构造函数的访问修饰符，名称和参数类型。 Modifier：提供了有关访问修饰符的信息。 ClassClass 类没有公共构造方法，可以通过其他方法获取Class类。 Object 提供的 getClass() 方法 类名.Class Class.forName(String className) 方法。className为类的全限定名 Class 类常用方法： 方法 描述 Field getField(String name) 获取指定的域对象 field[] getFields() 返回所有的公有域对象数组 Method getDeclaredMethod(String name,Class&lt;?&gt;……parameterTypes) 返回指定的方法对象 Method[] getDeclaredMethods() 返回所有方法对象数组 String getNmae() 获取全限定名 更多方法请参阅官方文档 反射方法示例123456789101112131415161718192021222324252627282930313233import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectDemo &#123; public int a; private int b; public static void main(String[] args) &#123; Class&lt;ReflectDemo&gt; reflectDemoClass = ReflectDemo.class; //输出所有的域名称 for (Field declaredField : reflectDemoClass.getDeclaredFields()) &#123; //可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值 System.out.println(&quot;域：&quot; + declaredField.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredField.getModifiers())); &#125; //输出所有的公有域名称 for (Field field : reflectDemoClass.getFields()) &#123; System.out.println(&quot;公有域：&quot; + field.getName() + &quot; 修饰符：&quot; + Modifier.toString(field.getModifiers())); &#125; //输出类的所有方法名 for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) &#123; System.out.println(&quot;方法：&quot; + declaredMethod.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredMethod.getModifiers())); &#125; &#125; public void fun1() &#123; &#125; private void fun2() &#123; &#125;&#125; 总结 反射虽然提供了强大的能力，但是也会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用劲量不用","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 反射","slug":"java-反射","permalink":"https://bawcat.wiki/tags/java-%E5%8F%8D%E5%B0%84/"}]},{"title":"java-设计模式","slug":"java/基础教学/设计模式","date":"2019-12-23T18:42:13.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/23/java/基础教学/设计模式/","link":"","permalink":"https://bawcat.wiki/2019/12/23/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Java 常见设计模式 设计模式(Design pattern) 代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简要说明 本次示例 主要介绍一下模式 中介模式 代理模式 责任链模式 中介模式简介 定义一个对象，该对象封装了一组对象的交互方式。对象之间的通信将封装在中介对象中。对象不再直接相互通信而是通过中介进行通信。这减少了通信对象之间的依赖性，从而减少了耦合。 优点 避免一组交互对象之间的紧密耦合 可以独立地改变一组对象之间的交互 类图 示例代码比如 我们要实现一个聊天室 聊天室就是中介，聊天的人就是一个同事类，发送的消息都由聊天室转发给别人 首先我们新建一个聊天室文件 123public abstract class AbstractChatRoom &#123; public abstract void notice(String message, User user);&#125; 然后我们新建一个聊天室 12345678910111213141516171819import java.util.ArrayList;import java.util.List;public class ChatRoom extends AbstractChatRoom &#123; private List&lt;User&gt; users = new ArrayList&lt;&gt;(); public void register(User user) &#123; users.add(user); &#125; @Override public void notice(String message, User user) &#123; for (User u : users) &#123; if (u != user) &#123; u.getMessage(message); &#125; &#125; &#125;&#125; 现在我们新建一个用户基类 123456789101112131415161718192021public abstract class User &#123; protected AbstractChatRoom chatRoom; public User(AbstractChatRoom chatRoom) &#123; this.chatRoom = chatRoom; &#125; /** * 发送消息 * * @param msg */ public abstract void sendMessage(String msg); /** * 接受消息 * * @param msg */ public abstract void getMessage(String msg);&#125; 模拟用户A 12345678910111213141516public class UserA extends User &#123; public UserA(AbstractChatRoom chatRoom) &#123; super(chatRoom); &#125; @Override public void sendMessage(String msg) &#123; System.out.println(&quot;用户A发送 &quot; + msg); chatRoom.notice(msg, this); &#125; @Override public void getMessage(String msg) &#123; System.out.println(&quot;用户A收到 &quot; + msg); &#125;&#125; 模拟用户B 12345678910111213141516public class UserB extends User &#123; public UserB(AbstractChatRoom chatRoom) &#123; super(chatRoom); &#125; @Override public void sendMessage(String msg) &#123; System.out.println(&quot;用户B发送 &quot; + msg); chatRoom.notice(msg, this); &#125; @Override public void getMessage(String msg) &#123; System.out.println(&quot;用户B收到 &quot; + msg); &#125;&#125; 客户端 1234567891011public class Client &#123; public static void main(String[] args) &#123; ChatRoom chatRoom = new ChatRoom(); UserA userA = new UserA(chatRoom); UserB userB = new UserB(chatRoom); chatRoom.register(userA); chatRoom.register(userB); userA.sendMessage(&quot;你好！&quot;); userB.sendMessage(&quot;再见！&quot;); &#125;&#125; 自己编译运行 查看效果 代理模式简介 代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不合适或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用 优点 隐藏原始对象并控制对象的访问 访问对象时提供其他的功能 类图 说明： Subject : 一个客户端可用的公开的功能接口 RealSubject: 实现Subject接口的类，提供了接口方法的具体实现 Proxy: 实现Subject接口的代理类，通过RealSubject类的业务逻辑方法来实现抽象方法，可以附加自己的操作 示例 假设我们需要建设一栋楼房，但是建设之前我们需要购买原材料（如水泥……)接着才能开始建设，楼房主体建设完成后，还需要封顶 首先建立一个 构建接口 123public interface LouSubject&#123; void build();&#125; 建设大楼主程序 123456public class LouRealSubject implements LouSubject&#123; @Override public void build()&#123; System.out.println(&quot;建设实验楼&quot;); &#125;&#125; 建设大楼需要购买材料方法 123456789101112public class LouProxy implements LouSubject&#123; private LouSubject target; public LouProxy()&#123; this.target = new LouRealSubject(); &#125; @Override public void build()&#123; System.out.println(&quot;购买材料&quot;); target.build(); System.out.println(&quot;封顶&quot;); &#125;&#125; 使用主客户端执行程序 123456public class LouClient&#123; public static void main(String[] args)&#123; LouSubject proxy = new LouProxy(); proxy.build(); &#125;&#125; 责任链模式 责任链模式是一种由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。还存在一种机制，用于将新处理对象添加到该链的末尾。责任链模式还在结构上与装饰器模式几乎相同不同之处在于对于装饰器。所有类都处理请求，而对于责任链，链中的一个类恰好处理请求。 优点 避免将请求的发送方与其接收方耦合 可以使用多个接收器处理请求 类图 handler : 抽象处理者ConcreteHandler：具体处理者，接受到请求后，可以选择处理请求或者传递给下一个处理者 示例代码假设我们有一个 OA 系统 不同的职位可以处理不同的审批流 组长： 可以处理两天以内的审批厂长： 可以处理七天以内的审批老板： 可以处理十五天以内的审批如果组长可以处理，那么久直接处理了，如果组长不可以处理，那么我们再继续往下传递 处理程序 123456789101112public abstract class Handler &#123; /** * 下个处理者 */ protected Handler successor; public void setSuccessor(Handler successor) &#123; this.successor = successor; &#125; public abstract void handlerRequest(int heaven);&#125; 组长处理程序 123456789101112public class GroupLeaderHandler extends Handler &#123; @Override public void handlerRequest(int heaven) &#123; if (heaven &lt;= 2) &#123; System.out.println(&quot;组长处理&quot;); &#125;else &#123; if (super.successor != null) &#123; super.successor.handlerRequest(heaven); &#125; &#125; &#125;&#125; 厂长处理程序 123456789101112public class FactoryManagerHandler extends Handler&#123; @Override public void handlerRequest(int heaven) &#123; if (heaven &lt;= 7) &#123; System.out.println(&quot;厂长处理&quot;); &#125;else &#123; if (super.successor != null) &#123; super.successor.handlerRequest(heaven); &#125; &#125; &#125;&#125; 老板处理 123456789101112public class BossHandler extends Handler &#123; @Override public void handlerRequest(int heaven) &#123; if (heaven &lt;= 15) &#123; System.out.println(&quot;老板处理&quot;); &#125;else &#123; if (super.successor != null) &#123; super.successor.handlerRequest(heaven); &#125; &#125; &#125;&#125; 模拟发起请求 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Handler groupLeaderHandler = new GroupLeaderHandler(); Handler factoryManagerHandler = new FactoryManagerHandler(); Handler bossHandler = new BossHandler(); groupLeaderHandler.setSuccessor(factoryManagerHandler); factoryManagerHandler.setSuccessor(bossHandler); //请假一天 groupLeaderHandler.handlerRequest(1); //请假6天 groupLeaderHandler.handlerRequest(6); //请假10天 groupLeaderHandler.handlerRequest(10); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://bawcat.wiki/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"关于 Java 多线程","slug":"java/基础教学/关于Java多线程","date":"2019-12-23T08:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/23/java/基础教学/关于Java多线程/","link":"","permalink":"https://bawcat.wiki/2019/12/23/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"java 多线程 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。本节主要讲解 Java 多线程的一些概念以及其实现。 多线程 线程变量 线程同步 Lock 与 Unlock 死锁 线程生命周期 ArrayBlockingQueue 生产者消费者模式 线程池 线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。 如同大自然中的万物，线程也有“生老病死”的过程，下图表示了一个线程从创建到消亡的过程，以及过程中的状态。 结合线程的生命周期来看看多线程的定义： 多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作。 在 Java 中，垃圾回收机制就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处。 从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解。 对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（**Thread**） Java 中的**Thread**类就是专门用来创建线程和操作线程的类。 创建线程创建线程的方法： 继承 Thread 类并重写它的run()方法，然后用这个子类来创建对象并调用start()方法。 定义一个类并实现 Runnable 接口，实现run()方法 总的来说就是线程通过 start()方法启动而不是 run()方法，run()方法的内容为我们要实现的业务逻辑 编程示例123456789101112131415161718192021222324252627282930313233343536373839public class CreateThread &#123; public static void main(String[] args) &#123; Thread1 thread1 = new Thread1(); //声明一个Thread1对象，这个Thread1类继承自Thread类的 Thread thread2 = new Thread(new Thread2()); //传递一个匿名对象作为参数 thread1.start(); thread2.start(); //启动线程 &#125;&#125;class Thread1 extends Thread &#123; @Override public void run() &#123; //在run()方法中放入线程要完成的工作 //这里我们把两个线程各自的工作设置为打印100次信息 for (int i = 0; i &lt; 100; ++i) &#123; System.out.println(&quot;Hello! This is &quot; + i); &#125; //在这个循环结束后，线程便会自动结束 &#125;&#125;class Thread2 implements Runnable &#123; //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造 @Override public void run() &#123; for (int i = 0; i &lt; 100; ++i) &#123; System.out.println(&quot;Thanks. There is &quot; + i); &#125; &#125;&#125; 你在控制台就可以看到两个线程近似交替地在输出信息。受到系统调度的影响，两个线程输出信息的先后顺序可能不同。 线程变量 ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。 示例代码： 123456789101112131415161718192021222324252627public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; ThreadDemo threadDemo = new ThreadDemo(); //启动2个线程 new Thread(threadDemo).start(); new Thread(threadDemo).start(); &#125;&#125;class ThreadDemo implements Runnable &#123; //使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0 private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0); @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; //get方法获取线程变量值 Integer integer = threadLocal.get(); integer += 1; //set方法设置线程变量值 threadLocal.set(integer); System.out.println(integer); &#125; &#125;&#125; 通过输出控制台的结果我们可以看到，两个线程之间的变量互不干涉 线程共享变量如果我们去掉了ThreadLocal,其他的流程都不改变,已经使用2个线程自增变量会如何呢？ 修改ThreadLoacalDemo.java 123456789101112131415161718192021public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; ThreadDemo threadDemo = new ThreadDemo(); new Thread(threadDemo).start(); new Thread(threadDemo).start(); &#125;&#125;class ThreadDemo implements Runnable &#123; private Integer integer = 0; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; integer++; System.out.println(integer); &#125; &#125;&#125; 在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象threadDemo的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错 线程同步当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问。 Synchronized关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法： 对普通方式使用,将会锁住当前实例对象 对静态方法使用,将会锁住当前类的Class对象 对代码块使用,将会锁住代码块中的对象 使用示例 在下面的代码中, 演示了三种加锁方式. 12345678910111213141516171819public class SynchronizedDemo &#123; private static Object lock = new Object(); public static void main(String[] args) &#123; //同步代码块 锁住lock synchronized (lock) &#123; //doSomething &#125; &#125; //静态同步方法 锁住当前类class对象 public synchronized static void staticMethod()&#123; &#125; //普通同步方法 锁住当前实例对象 public synchronized void memberMethod() &#123; &#125;&#125; java.util.concurrentjava.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等。 Lock 与 UnlockJUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能。 12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.ReentrantLock;public class LockDemo &#123; private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; lock.lock(); try &#123; //需要同步的代码块 System.out.println(&quot;线程1加锁&quot;); &#125;finally &#123;// 一定要在finally中解锁，否则可能造成死锁 lock.unlock(); System.out.println(&quot;线程1解锁&quot;); &#125; &#125;); thread1.start(); Thread thread2 = new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(&quot;线程2加锁&quot;); &#125;finally &#123; lock.unlock(); System.out.println(&quot;线程2解锁&quot;); &#125; &#125;); thread2.start(); &#125;&#125; 在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现。 饥饿饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况。 线程生命周期线程的声明周期共有 6 种状态，分别是：新建New、运行（可运行）Runnable、阻塞Blocked、计时等待Timed Waiting、等待Waiting和终止Terminate。 当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象调用start()方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了调用了sleep()方法、调用wait()方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态。当run()方法执行结束后，线程也就终止了。 示例 12345678910111213141516171819202122232425262728293031323334353637383940public class ThreadState implements Runnable &#123; public synchronized void waitForAMoment() throws InterruptedException &#123; wait(500); //使用wait()方法使当前线程等待500毫秒 //或者等待其他线程调用notify()或notifyAll()方法来唤醒 &#125; public synchronized void waitForever() throws InterruptedException &#123; wait(); //不填入时间就意味着使当前线程永久等待， //只能等到其他线程调用notify()或notifyAll()方法才能唤醒 &#125; public synchronized void notifyNow() throws InterruptedException &#123; notify(); //使用notify()方法来唤醒那些因为调用了wait()方法而进入等待状态的线程 &#125; @Override public void run() &#123; //这里用异常处理是为了防止可能的中断异常 //如果任何线程中断了当前线程，则抛出该异常 try &#123; waitForAMoment(); // 在新线程中运行waitMoment()方法 waitForever(); // 在新线程中运行waitForever()方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实现代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadTest &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadState state = new ThreadState(); //声明并实例化一个ThreadState对象 Thread thread = new Thread(state); //利用这个名为state的ThreadState对象来创建Thread对象 System.out.println(&quot;Create new thread: &quot; + thread.getState()); //使用getState()方法来获得线程的状态，并进行输出 thread.start(); //使用thread对象的start()方法来启动新的线程 System.out.println(&quot;Start the thread: &quot; + thread.getState()); //输出线程的状态 Thread.sleep(100); //通过调用sleep()方法使当前这个线程休眠100毫秒，从而使新的线程运行waitForAMoment()方法 System.out.println(&quot;Waiting for a moment (time): &quot; + thread.getState()); //输出线程的状态 Thread.sleep(1000); //使当前这个线程休眠1000毫秒，从而使新的线程运行waitForever()方法 System.out.println(&quot;Waiting for a moment: &quot; + thread.getState()); //输出线程的状态 state.notifyNow(); // 调用state的notifyNow()方法 System.out.println(&quot;Wake up the thread: &quot; + thread.getState()); //输出线程的状态 Thread.sleep(1000); //使当前线程休眠1000毫秒，使新线程结束 System.out.println(&quot;Terminate the thread: &quot; + thread.getState()); //输出线程的状态 &#125;&#125; ArrayBlockingQueue ArrayBlockingQueue 是由数组支持的有界阻塞队列.位于java.util.concurrent包下 首先看看其构造方法: 构造方法 描述 public ArrayBlockingQueue(int capacity) 构造大小为capacity的队列 public ArrayBlockingQueue(int capacity, boolean fair) 指定队列大小，以及内部实现是公平锁还是非公平锁 public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) 指定队列大小, 以及锁实现, 并且在初始化是加入集合c 入队常用方法: 入队方法 队列已满 队列未满 add 抛出异常 返回true offer 返回false 返回true put 阻塞直到插入 没有返回值 出队常用方法: 出队方法 队列为空 队列不为空 remove 抛出异常 移出并返回队首 poll 返回null 移出并返回队首 take 阻塞直到返回 移出并返回队首 示例源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.ArrayBlockingQueue;public class ABQDemo &#123; //构建大小为10的阻塞队列 private static ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; arrayBlockingQueue.add(i); &#125; &#125;); thread1.start(); try &#123; //等待线程1执行完毕 thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(() -&gt; &#123; //如果插入失败 if (!arrayBlockingQueue.offer(11)) &#123; System.out.println(&quot;插入元素11失败&quot;); &#125; try &#123; //一直阻塞直到插入元素11，注意这里阻塞的不是主线程，main方法还是继续运行 arrayBlockingQueue.put(11); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); Thread thread2=new Thread(() -&gt; &#123; Integer element; System.out.println(&quot;开始出队:&quot;); //打印队列中的元素 while ((element = arrayBlockingQueue.poll()) != null) &#123; System.out.print(&quot;\\t&quot;+element); &#125; &#125;); thread2.start(); &#125;&#125; 生产者消费者模式 生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度。举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Random;import java.util.concurrent.LinkedBlockingQueue;public class PCModel &#123; private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(); public static void main(String[] args)&#123; // 生产者 Thread provider = new Thread(()-&gt; &#123; // 执行代码块 Random random = new Random(); for (int j = 0; j &lt; 5; j++)&#123; try&#123; int i = random.nextInt(); // 直到插入数据 queue.put(i); System.out.println(&quot;生产数据：&quot;+ i); Thread.sleep(1000);// 睡眠程序 &#125; catch(InterruptedException e)&#123; e.printStackTrace();// 抛出异常 &#125; &#125; &#125;); // 消费者 Thread consumer = new Thread(()-&gt;&#123; Integer data; for (int i = 0; i &lt; 5; i++)&#123; try&#123; // 阻塞直到取出数据 data = queue.take(); System.out.println(&quot;消费数据:&quot;+data); Thread.sleep(1000); &#125; catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); // 启动线程 provider.start(); consumer.start(); &#125;&#125; 线程池 线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。 由于Java创建和销毁线程都会带来资源上的销毁,所以线程池可以帮助我们复用线程，减少资源消耗 Java 线程池可以通过 Executors 工具类创建，Executors 常用方法： newFixedThreeadPoo(int nThreads); 创建一个固定大小为n的线程池 newSingleThreadExecutor(); 创建只有一个线程的线程池 newCachedThreadPool(); 创建一个根据需要创建新线程的线程池 示例代码： 123456789101112131415161718import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo &#123; //使用Executors 创建一个固定大小为5的线程池 private static ExecutorService executorService = Executors.newFixedThreadPool(5); public static void main(String[] args) &#123;// 提交任务 executorService.submit(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125;); //停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭 executorService.shutdown(); &#125;&#125; 除了使用**Executors**工具类帮助我们创建之外，也可以直接创建线程池 示例代码： 1234567891011121314151617181920212223import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolDemo2 &#123; private static ExecutorService executorService = new ThreadPoolExecutor( 5, //核心线程数为5 10,//最大线程数为10 0L, TimeUnit.MILLISECONDS,//非核心线程存活时间 new LinkedBlockingQueue&lt;&gt;());//任务队列 public static void main(String[] args) &#123; //提交任务 executorService.submit(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125;); //关闭线程池 executorService.shutdown(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java 多线程","slug":"java-多线程","permalink":"https://bawcat.wiki/tags/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"关于 Java Socket 的使用","slug":"java/基础教学/Socket","date":"2019-12-23T02:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2019/12/23/java/基础教学/Socket/","link":"","permalink":"https://bawcat.wiki/2019/12/23/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/Socket/","excerpt":"","text":"Java Socket 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节 TCP UDP HttpURLConnection InetAddress Socket ServerSocket Socket 简介(摘抄网络) 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket 建立网络通信连接至少要一对端口号(socket)。socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口HTTP 是轿车，提供了封装或者显示数据的具体形式Socket 是发动机，提供了网络通信的能力Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目 客户软件将插头插到不同编号的插座，就可以得到不同的服务 TCP (摘抄网络) TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收然后接收端实体对已成功收到的包发回一个相应的确认（ACK）如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和 UDP (摘抄网络) UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17。UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议UDP 协议的主要作用是将网络数据流量压缩成数据包的形式一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据 HttpURLConnection HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。我们可以使用它来发起网络请求，获取服务器的相关资源。 HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用HttpURLConnection 类的基本流程，想要了解更多方法的同学可以查询API 文档 1234567891011121314151617181920212223242526272829303132import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpUrlTest &#123; public static void main(String[] args) &#123; try &#123; //设置url URL shiyanlou = new URL(&quot;https://www.baidu.com&quot;); //打开连接 HttpURLConnection urlConnection = (HttpURLConnection)shiyanlou.openConnection(); //设置请求方法 urlConnection.setRequestMethod(&quot;GET&quot;); //设置连接超时时间 urlConnection.setConnectTimeout(1000); //获取输入流 InputStream inputStream = urlConnection.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); //打印结果 bufferedReader.lines().forEach(System.out::println); //关闭连接 inputStream.close(); bufferedReader.close(); urlConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面对baidu发起请求抓取 获取首页源代码 InetAddress InetAddress类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类。 InetAddress没有公共构造方法，我们只能使用它提供的静态方法来构建一个InetAddress类实例 getLocalHost(): 返回本地主机地址 getAllByName（String host）：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联。 getByAddress（byte [] addr）：从原始 IP 地址的字节数组中返回一个 InetAddress 对象。 getByName（String host）：根据提供的主机名创建一个 InetAddress 对象。 getHostAddress（）：返回文本表示的 IP 地址字符串。 getHostname（）：获取主机名。 代码实例: 1234567891011121314151617181920import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressDemo &#123; public static void main(String[] args) &#123; try &#123; InetAddress shiyanlou = InetAddress.getByName(&quot;www.baidu.com&quot;); //toString 方法将输出主机名和ip地址 System.out.println(shiyanlou.toString()); //获取ip地址 String ip = shiyanlou.toString().split(&quot;/&quot;)[1]; //根据IP地址获取主机名 InetAddress byAddress = InetAddress.getByName(ip); System.out.println(&quot;get hostname by IP address:&quot; + byAddress.getHostName()); System.out.println(&quot;localhost: &quot;+InetAddress.getLocalHost()); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述代码 获取baidu的主机名和ip地址 并输出 SocketSocket类代表一个客户端套接字，可以使用该类想服务器发送和接受数据。一般需要通过下面几个步骤： 建立与服务器的连接 使用输出流将数据发送到服务器 使用输入流读取服务器返回的数据 关闭连接 Socket 常用构造方法 Socket(InetAddress address, int port)：创建一个套接字，连接到指定 IP 地址和端口的服务器 Socket(String host, int port)：创建一个套接字，连接到指定的主机名和端口的服务器 Socket(InetAddress address, int port, InetAddress localAddr, int localPort)：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口。 在创建Socket时，需要捕获异常 getOutputStream()该方法可以获取输出流，在建立连接后，可以使用该方法获取输出流，发送数据到服务器。发送数据的方式和使用 IO 流是相同的，使用 write 方法发送指定的数据即可。 getInputStream()用户获取输入流，通过该方法获取输入流之后可以读取服务器发送来的数据。使用方法和 IO 流相同，使用 read 方法即可。 close()关闭 Socket，可能抛出 IO 异常，所以我们同样需要捕获异常。 ServerSocketServerSocket类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。 创建一个**ServerSocket**一般需要以下几个步骤: 创建服务器套接字并将其绑定到特定的接口 等待客户端连接 通过客户端套接字获取输入流，从客户端读取数据 通过客户端套接字获取输出流，发送数据到客户端 关闭套接字 常用构造方法: ServerSocket():创建一个未绑定端口的服务器器套接字 ServerSocket(int port)：创建绑定到指定端口号的服务器套接字. ServerSocket(int port, int backlog)：创建一个绑定到指定端口号的服务器套接字，并且**backlog** 参数指定了最大排队连接数 ServerSocket(int port,int backlog,InetAddress bindAddr)：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址。 示例: 1ServerSocket serverSocket = new ServerSocket(8888); accept()用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个**Socket**对象。 close()用于关闭服务器套接字，服务器停止后，将断开所有连接。 其他方法可以查阅官方文档 网络编程实例 java.net 包提供了两个类Socket和ServerSocket，分别实现 Socket 连接的客户端和服务器端。 我们编译一个简单的 Socket 应用，实现客户端发送信息给服务端，服务端再将信息发送回客户端的回显的功能。 服务端： 12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer &#123; public static void main(String[] args) &#123; try &#123; //服务端需要使用ServerSocket类 ServerSocket serverSocket = new ServerSocket(1080); //阻塞 等待客户端连接 Socket client = serverSocket.accept(); PrintWriter out = new PrintWriter(client.getOutputStream(), true); BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); String userIn; while ((userIn = in.readLine()) != null) &#123; System.out.println(&quot;收到客户端消息：&quot; + userIn); //发回客户端 out.println(userIn); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient &#123; public static void main(String[] args) &#123; String hostname = &quot;127.0.0.1&quot;; //socket端口 int port = 1080; Scanner userIn = new Scanner(System.in); try &#123; //建立socket连接 Socket socket = new Socket(hostname, port); //获取socket输出流 PrintWriter out = new PrintWriter(socket.getOutputStream(), true); //获取输入流 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String userInput; System.out.println(&quot;请输入信息：&quot;); //当用户输入exit时退出 while (!&quot;exit&quot;.equals(userInput = userIn.nextLine())) &#123; out.println(userInput); System.out.println(&quot;收到服务端回应:&quot; + in.readLine()); &#125; //关闭socket socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Socket","slug":"java-Socket","permalink":"https://bawcat.wiki/tags/java-Socket/"}]},{"title":"关于 Java Set、HashSet 的使用","slug":"java/基础教学/基础数据类型/Set-HashSet","date":"2019-12-22T02:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/22/java/基础教学/基础数据类型/Set-HashSet/","link":"","permalink":"https://bawcat.wiki/2019/12/22/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Set-HashSet/","excerpt":"","text":"Set 和 HashSetSet 接口也是 Collection 接口的子接口, 它有一个很重要也是很常用的实现类—-HashSet.Set 是元素无需并且不包含重复元素的Collection(List可以重复), 被称为集 HashSet 由哈希表(实际上是一个HashMap实例)支持. 它不保证set的迭代顺序; 特别是它不保证该顺序恒久不变 示例代码: 假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧。 12345678910111213141516171819// PD.javaimport java.util.HashSet;import java.util.Set;/* * 项目组长类 */public class PD &#123; public String id; public String name; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 public Set&lt;Student&gt; students; public PD(String id, String name)&#123; this.id = id; this.name = name; this.students = new HashSet&lt;Student&gt;(); &#125;&#125; 1234567891011121314151617181920/** * 学生类 */ // Student.javapublic class Student &#123; public String id; public String name; public Student(String id, String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 管理成员类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// SetTest.javaimport java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;public class SetTest &#123; public List&lt;Student&gt; students; public SetTest() &#123; students = new ArrayList&lt;Student&gt;(); &#125; /* * 用于往students中添加学生 */ public void testAdd() &#123; //创建一个学生对象，并通过调用add方法，添加到学生管理List中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); //添加到List中的类型均为Object，所以取出时还需要强转 Student st2 = new Student(&quot;2&quot;,&quot;李四&quot;); students.add(st2); Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; students.addAll(Arrays.asList(student)); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(Arrays.asList(student2)); &#125; /** * 通过for each 方法访问集合元素 * @param args */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过for each）：&quot;); for(Object obj:students)&#123; Student st = (Student)obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; public static void main(String[] args)&#123; SetTest st = new SetTest(); st.testAdd(); st.testForEach(); PD pd = new PD(&quot;1&quot;,&quot;张老师&quot;); System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;); //创建一个 Scanner 对象，用来接收从键盘输入的学生 ID Scanner console = new Scanner(System.in); for(int i = 0;i &lt; 3; i++)&#123; System.out.println(&quot;请输入学生 ID&quot;); String studentID = console.next(); for(Student s:st.students)&#123; if(s.id.equals(studentID))&#123; pd.students.add(s); &#125; &#125; &#125; st.testForEachForSer(pd); // 关闭 Scanner 对象 console.close(); &#125; //打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator //不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素 public void testForEachForSer(PD pd)&#123; for(Student s: pd.students) &#123; System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name); &#125; &#125;&#125; 编译运行: 12345678910111213141516171819$ javac PD.java SetTest.java Student.java$ java SetTest有如下学生（通过for each）：学生：1:张三学生：2:李四学生：3:王五学生：4:马六学生：5:周七学生：6:赵八请：张老师选择小组成员！请输入学生 ID4请输入学生 ID5请输入学生 ID6选择了学生：4:马六选择了学生：5:周七选择了学生：6:赵八","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Set","slug":"java-Set","permalink":"https://bawcat.wiki/tags/java-Set/"},{"name":"java HashSet","slug":"java-HashSet","permalink":"https://bawcat.wiki/tags/java-HashSet/"}]},{"title":"关于 Java Map 的使用","slug":"java/基础教学/基础数据类型/map","date":"2019-12-21T02:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/21/java/基础教学/基础数据类型/map/","link":"","permalink":"https://bawcat.wiki/2019/12/21/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/map/","excerpt":"","text":"java MapMap 接口也是一个非常重要的集合接口, 用于存储键/值对.Map 中的元素都是成对出现的,键值对就想数组的索引与数组的内容关系一样, 将一个键映射到一个值的对象.一个映射不能包含重复的键；每个键最多只能映射到一个值.我们可以通过键去找到相应的值. 1key =&gt;(映射) value value 可以存储任意类型的对象,我们可以根据key键快速查找value.Map 中的键/值对以Entry类型的对象实例形式存在. Map 方法: 方法 返回值 说明 clear() void 从此映射中一处所用映射关系(可选操作) containsKey(Object key) boolean 如果此映射包含指定键的映射关系,则返回 true containsValue(Object value) boolean 如果此映射将一个或多个映射到指定值,则返回true entrySet() Set&lt;Map.Entry&lt;K,V&gt;&gt; 返回此映射中包含的映射关系的Set视图 equals(Object o) boolean 比较指定的对象与此映射是否相等 get(Object key) V 返回指定键所映射的值;如果此映射不包含该键的映射关系,则返回null hashCode() int 返回此映射的哈希码值 isEmpty() boolean 如果此映射为包含键-值映射关系,则返回true keySet() Set 返回此映射中包含的键的Set视图 put(K key,Vvalue) V 将指定的值与此映射中的指定键关联（可选操作） putAll(Map&lt;? extends K, ? extends V&gt;m) void 从指定映射中将所有映射关系复制到此映射中（可选操作） remove(Object key) V 如果存在一个键的映射关系,则将其从此映射中移除（可选操作） size int 返回此映射中的键-值映射关系数 values() Collection 返回此映射中包含的值的Collection 视图 HashMap 是基于哈希表的Map接口的一个重要实现类. HashMap 中的Entry对象是无需排列的,key值和value值都可以为null,但是一个HashMap 只能有一个key值为null的映射(key值不可重复) 示例代码: 123456789// Course.javapublic class Course &#123; public String id; public String name; public Course(String id, String name)&#123; this.id = id; this.name = name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// MapTest.javaimport java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest &#123; /** * 用来承装课程类型对象 */ public Map&lt;String, Course&gt; courses; /** * 在构造器中初始化 courses 属性 * @param args */ public MapTest() &#123; this.courses = new HashMap&lt;String, Course&gt;(); &#125; /** * 测试添加：输入课程 ID，判断是否被占用 * 若未被占用，输入课程名称，创建新课程对象 * 并且添加到 courses 中 * @param args */ public void testPut() &#123; //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称 Scanner console = new Scanner(System.in); for(int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;请输入课程 ID：&quot;); String ID = console.next(); //判断该 ID 是否被占用 Course cr = courses.get(ID); if(cr == null)&#123; //提示输入课程名称 System.out.println(&quot;请输入课程名称：&quot;); String name = console.next(); //创建新的课程对象 Course newCourse = new Course(ID,name); //通过调用 courses 的 put 方法，添加 ID-课程映射 courses.put(ID, newCourse); System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name); &#125; else &#123; System.out.println(&quot;该课程 ID 已被占用&quot;); continue; &#125; &#125; &#125; /** * 测试 Map 的 keySet 方法 * @param args */ public void testKeySet() &#123; //通过 keySet 方法，返回 Map 中的所有键的 Set 集合 Set&lt;String&gt; keySet = courses.keySet(); //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value for(String crID: keySet) &#123; Course cr = courses.get(crID); if(cr != null)&#123; System.out.println(&quot;课程：&quot; + cr.name); &#125; &#125; &#125; /** * 测试删除 Map 中的映射 * @param args */ public void testRemove() &#123; //获取从键盘输入的待删除课程 ID 字符串 Scanner console = new Scanner(System.in); while(true)&#123; //提示输出待删除的课程 ID System.out.println(&quot;请输入要删除的课程 ID！&quot;); String ID = console.next(); //判断该 ID 是否对应的课程对象 Course cr = courses.get(ID); if(cr == null) &#123; //提示输入的 ID 并不存在 System.out.println(&quot;该 ID 不存在！&quot;); continue; &#125; courses.remove(ID); System.out.println(&quot;成功删除课程&quot; + cr.name); break; &#125; &#125; /** * 通过 entrySet 方法来遍历 Map * @param args */ public void testEntrySet() &#123; //通过 entrySet 方法，返回 Map 中的所有键值对 Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet(); for(Entry&lt;String,Course&gt; entry: entrySet) &#123; System.out.println(&quot;取得键：&quot; + entry.getKey()); System.out.println(&quot;对应的值为：&quot; + entry.getValue().name); &#125; &#125; /** * 利用 put 方法修改Map 中的已有映射 * @param args */ public void testModify()&#123; //提示输入要修改的课程 ID System.out.println(&quot;请输入要修改的课程 ID：&quot;); //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串 Scanner console = new Scanner(System.in); while(true) &#123; //取得从键盘输入的课程 ID String crID = console.next(); //从 courses 中查找该课程 ID 对应的对象 Course course = courses.get(crID); if(course == null) &#123; System.out.println(&quot;该 ID 不存在！请重新输入！&quot;); continue; &#125; //提示当前对应的课程对象的名称 System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name); //提示输入新的课程名称，来修改已有的映射 System.out.println(&quot;请输入新的课程名称：&quot;); String name = console.next(); Course newCourse = new Course(crID,name); courses.put(crID, newCourse); System.out.println(&quot;修改成功！&quot;); break; &#125; &#125; public static void main(String[] args) &#123; MapTest mt = new MapTest(); mt.testPut(); mt.testKeySet(); mt.testRemove(); mt.testModify(); mt.testEntrySet(); &#125;&#125; 运行结果: 12345678910111213141516171819202122232425262728$ javac Course.java MapTest.java$ java MapTest请输入课程 ID：1请输入课程名称：语文成功添加课程：语文请输入课程 ID：1该课程 ID 已被占用请输入课程 ID：2请输入课程名称：数学成功添加课程：数学课程：语文课程：数学请输入要删除的课程 ID！1成功删除课程语文请输入要修改的课程 ID：2当前该课程 ID，所对应的课程为：数学请输入新的课程名称：英语修改成功！取得键：2对应的值为：英语","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Map","slug":"java-Map","permalink":"https://bawcat.wiki/tags/java-Map/"}]},{"title":"关于 Java JDBC 的使用","slug":"java/基础教学/JDBC","date":"2019-12-20T02:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2019/12/20/java/基础教学/JDBC/","link":"","permalink":"https://bawcat.wiki/2019/12/20/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/JDBC/","excerpt":"","text":"Java JDBC JDBC 是连接数据库和Java程序的桥梁，通过JDBC API 可以方便地实现对各种主流数据库的操作. 本节将重点讲解JDBC的内容 本章概括: SQL 简介 JDBC 创建数据库 数据库操作 JDBC 结果集 插入数据 小提示 在已经掌握了 关系数据库 和 非关系数据库的小伙伴 可以进行适当跳章 数据库简介数据库，简而言之可以理解成电子化的文件柜–存储点子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作 所谓”数据库”系以一定方式存储在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成. 常见的关系型数据库有以下几种: Mysql MariaDB Percona Server PostgreSQL Microsoft Access Microsoft SQL Server Google Fusion Tables FileMaker Oracle Sybase dBASE Clipper FoxPro foshub 常见的非关系型数据库 Redis BigTable Cassandra MongoDB CouchDB SQL 简介 结构化查询语言(Structured Query Language)简称 SQL(发音：/ˈes kjuː ˈel/ “S-Q-L”)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 SQL语句不是本章节主要内容 想要了解 请戳这里 JDBC JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的api，还有与数据库进行通信的驱动程序。 我们要写设计到数据库的程序，是通过C语言或者C++语言直接访问数据库的接口 对于不同的数据库，我们需要知道不同数据库对外提供的系统API，这就影响了我们程序扩展和跨平台的实现. 那么有没有一种方法来对不同的数据库接口进行统一呢？ 当然有. 我们只需要和最上层接口进行交互，剩下的部分就交给其它层去处理,我们的任务就变得轻松简单许多 . JDBC 为数据库开发人员提供了一个标准的API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯Java API 编写数据库应用程序 JDBC 连接数据库设计到建立一个JDBC连接的编程主要有四个步骤: 导入JDBC驱动：只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤. 注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求。 数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库。 创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接。 导入JDBC 驱动程序需要下载对应的数据库的JDBC驱动，将其导入到项目中,具体的导入方式根据个人的IDE确定，当前我们直接通过命令行导入 javac -cp 注册JDBC驱动程序我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序。 方法一 —- Class.forName(); 动态加载一个类最常用的方法时使用Java的Class.forName()方法,通过使用这个方法来将数据库的驱动类动态加载到内存中,然后我们就可以使用. 使用Class.forName()来注册Mysql驱动程序; 123456try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#125; catch(ClassNotFoundException ex)&#123; System.out.println(&quot;Error: unable to load driver class!&quot;); System.exit(1);&#125; 方法2 —- DriverManager.registerDriver(); 12Driver driver = new com.mysql.jdbc.Driver();DriverManager.registerDriver(driver); 指定数据库连接 URL 当加载了驱动程序,便可以使用 DriverManager.getConnection() 方法连接到数据库了这里给出 DriverManager.getConnection() 三个重载方法： 123456getConnection(String url)getConnection(String url, Properties prop)getConnection(String url, String user, String password) 数据库的URL是指定数据库地址.下表列出了下来流行的JDBC驱动程序名和数据库的URL。 RDBMS JDBC 驱动程序的名称 URL Mysql com.mysql.jdbc.Driver jdbc:mysql://hostname/databaseName Oracle oracle.jdbc.driver.OracleDriver jdbc:oracle:thin:@hostname:port Number:databaseName DB2 COM.ibm.db2.jdbc.net.DB2Driver jdbc:db2:hostname:port Number/databaseName Sybase com.sybase.jdbc.SybDriver jdbc:sybase:Tds:hostname: port Number/databaseName 创建连接对象下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection()最常用形式要求传递一个数据库 URL，用户名 username 和密码 password。 使用数据库 URL 的 用户名 和 密码 1234String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;String USER = &quot;username&quot;;String PASS = &quot;password&quot;;Connection conn = DriverManager.gegtConnection(URL, USER, PASS); 只使用一个数据库 URL 然而在这种情况下，数据库的URL，包括用户名和密码。 123String URL = &quot;jdbc:mysql://localhost/EXAMPLE?user=root&amp;password=0909&quot;;// 密码为示例// Mysql URL 的参数设置详细可以查阅相关资料Connection conn = DriverManager.getConnection(URL); 使用数据库的 URL 和 一个 Properties 对象 12345678910import java.util.*;String URL = &quot;jdbc:mysql://localhost/EXAMPLE&quot;;Properties pro = new Properties();// Properties 对象 保存一组关键词-值对pro.put(&quot;user&quot;, &quot;root&quot;);pro.put(&quot;password&quot;, &quot;&quot;);Connection conn = DriverManager.getConnection(URL, pro); 关闭JDBC连接 1conn.close(); 创建数据库 在使用数据库之前第一件事情就是创建数据库，这里我们将使用JDBC来创建数据库 示例代码： 123456789101112131415161718192021222324252627282930import java.sql.*;public class CreateDatabase &#123; public static void main(String[] args)&#123; Connection connection = null; try &#123; //加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //打开数据库连接 第一个参数为数据库地址 后面2个参数分别为数据库用户名和密码 connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/&quot;,&quot;root&quot;,&quot;&quot;); //创建Statement Statement statement = connection.createStatement(); //执行sql statement.execute(&quot;create database EXAMPLE&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; //关闭连接 if (connection != null) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 启动mysql 服务 单文件编译运行需要使用mysql的 jar 包 运行示例： 123$ wget http://labfile.oss.aliyuncs.com/courses/1230/mysql-connector-java-5.1.47.jar$ javac -cp mysql-connector-java-5.1.47.jar CreateDatabase.java$ java -cp .:mysql-connector-java-5.1.47.jar CreateDatabase 数据库操作当连接上了数据库后，就需要通过SQL语句对数据库进行操作. 随着java语言应用面的逐步扩宽，Sun公司开发了一个标准的SQL数据库访问接口—-JDBC API. 它可以使Java编程人员通过一个一致的接口，访问多种关系数据库.而今天我们简单示例一遍，如何利用JDBC的一些核心API与数据库进行交互 通过使用JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性,使可以使用SQL或者PL/SQL 命令和从数据库接收数据. 他们还定义了许多方法,帮助消除Java和数据库之间数据类型的差异 接口 应用场景 Statement 当在运行时使用静态SQL语句时（Statement接口不能接收参数) CallableStatement 当要访问数据库中的存储过程时（CallableStatement对象的接口还可以接收运行时输入参数） PreparedStatement 当计划多次使用SQL语句时（PreparedStatement接口接收在运行时输入参数） Statement我们要使用 Statement 接口，第一步肯定是创建一个 Statement 对象了。我们需要使用 Connection 对象的 createStatement() 方法进行创建. 123456789Statement stmt = null;try &#123; stmt = conn.createStatement(); ……&#125; catch(SQLException e)&#123; ……&#125; finally&#123; ……&#125; 一旦创建了一个 Statement 对象，我们就可以用它来执行SQL 语句了， 首先我们先来看看Statement 里面有哪些方法吧! 方法 说明 boolean execute(String SQL) 如果 ResultSet 对象可以被检索返回布尔值true，否则返回false。使用这个方法来执行SQL DDL 语句，或当需要使用真正的动态SQL int executeUpdate(String SQL) 用于执行 INSERT、UPDATE或DELETE语句以及SQLDDL（数据定义语言）语句。返回值是一个整数, 指示受影响的行数（即更新计数） ResultSet executeQuery(String SQL) 返回ResultSet对象。用于产生单个结果集的语句,例如SELECT 语句 正如关闭一个Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭Statement对象。 123456789Statement stmt = null;try&#123; stmt = conn.createStatement(); ……&#125; catch (SQLException e)&#123; ……&#125; finally &#123; stmt.close();&#125; 如果关闭了 Connection 对象首先它会关闭 Statement 对象，然而应该始终明确关闭Statement对象，以确保正确的清除。 PreparedStatementPreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。我们先来创建一个 PreparedStatement 对象。 Statement 为一条 SQL 语句生成执行计划。如果要执行两条 SQL 语句，会生成两个执行计划。一万个查询就生成一万个执行计划！ PreparedStatement 用于使用绑定变量重用执行计划 通过 set 不同数据，只需要生成一次执行计划，并且可以重用 1234567891011PreparedStatement pstmt = null;try &#123; /** * 在JDBC中所有的参数都被代表？符号，这是已知的参数标记。在执行SQL语句之前 必须提供值的每一个参数 */ String SQL = &quot;Update Students SET age = ? WHERE id = ?&quot;; pstmt = conn.prepareStatement(SQL); . . .&#125; catch (SQLException e)&#123; pstmt.close();&#125; CallableStatementCallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用IN参数。 CallableStatement 对象可以使用所有三个 参数 描述 IN 它的值实在创建SQL语句时未知的参数，将IN参数传给CallableStatement对象是通过 setXXX() 方法完成的 OUT 其值由它返回的SQL语句提供的参数。从OUT参数的getXXX() 方法检索值 INOUT 同时提供输入和输出值的参数，绑定的setXXX() 方法的变量，并使用getXXX() 方法检索值 在JDBC中调用存储过程的语法如下所示. 注意，方括号标识其间的内容是可选项; 方括号本身并不是语法的组成部分. 1&#123;call 存储过程名[(?,?,……)]&#125; 返回结果参数的过程的语法为： 1&#123;? = call 存储过程名[(?,?,……)]&#125; 不带参数的存储过程的语法类似： 1&#123;call 存储过程名&#125; CallableStatement 对象是用Connection方法prepareCall 创建的。 123456789101112CallableStatement cstmt = null;try &#123; String SQL = &quot;&#123;call getEXAMPLEName (?, ?)&#125;&quot;; cstmt = conn.prepareCall (SQL); . . .&#125;catch (SQLException e) &#123; . . .&#125;finally &#123; cstmt.close();&#125; 关于CallableStatement接口更多的可以查询java JDBC api JDBC 结果集 结果集通常是通过执行查询数据库的语句生成，表示数据库查询结果的数据表 ResultSet 介绍ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。 ResultSet 接口的方法可分为三类: 导航方法: 用于移动光标 获取方法：用于查看当前行的光标所指向的列中的数据 更新方法：用于更新当前行的列中的数据 JDBC 提供下列连接方法来创建所需的 ResultSet 语句： 12345createStatement(int RSType, int RSConcurrency);prepareStatement(String SQL, int RSType, int RSConcurrency);prepareCall(String sql, int RSType, int RSConcurrency); Rstype 表示 ResultSet 对象的类型，RsConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新. ResultSet 的类型，如果不指定ResultSet类型 将自动获取一个是 TYPE_FORWARD_ONLY； 类型 描述 ResultSet.TYPE_FORWARD_ONLY 游标只能向前移动的结果集 ResultSet.TYPE_SCROLL_INSENSITIVE 游标可以向前和向后滚动，但不及时更新，就是如果数据库里的数据修改过，并不在ResultSet中反应出来 ResultSet.TYPE_SCROLL_SENSITIVE 游标可以向前和向后滚动，并及时跟踪数据库的更新，以便更改ResultSet中的数据 并发性的ResultSet，如果不指定任何并发类型，将自动获得一个为CONCUR_READ_ONLY 并发 描述 ResultSet.CONCUR_READ_ONLY 创建结果集只读。这是默认的 ResultSet.CONCUR_UPDATABLE 创建一个可更新的结果集 示例创建了一个双向、可更新的ResultSet对象； 12345678910try &#123; Statement stmt = conn.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE );&#125; catch(Exception ex)&#123; ……&#125; finally &#123; ……&#125; 导航我们在上面已经知道了，导航方法时用于移动光标.我们先来看一看，在ResultSet接口中有哪些方法会涉及光标的移动. 方法 说明 public void beforeFirst() throws SQLException 将光标移动到正好位于第一行之前 public void afterLast() throws SQLException 将光标移动到刚刚结束的最后一行 public boolean first() throws SQLException 将光标移动到第一行 public void last() throws SQLException 将光标移动到最后一行 public boolean absolute(int row) throws SQLException 将光标移动到指定的行 public boolean relative(int row) throws SQLException 从它目前所指向向前或向后移动光标行的给定数量 public boolean previous() throws SQLException 将光标移动到上一行。上一行关闭的结果集此方法返回false public boolean next() throws SQLException 将光标移动到下一行。如果没有更多的行结果集中的此方法返回false public int getRow() throws SQLException 返回的行号，改光标指向的行 public void moveToInsertRow() throws SQLException 将光标移动到一个特殊的行，可以用来插入新行插入到数据库中的结果集。当前光标位置被记住 public void moveToCurrentRow() throws SQLException 移动光标返回到当前行，如果光标在当前插入行，否则，这个方法不执行任何操作 获取ResultSet 接口中 我们经常使用get方法来查看结果集 方法 说明 public int getInt(String columnName) throws SQLException 当前行中名为ColumnName列的值 public int getInt(int columnIndex) throws SQLException 当前行中指定列的索引的值。 列索引从1开始，意味着一个行的第一列是1，行的第二列是2，依次类推 当然还有 getString() 等等 更新更新的方法如下： 方法 说明 public void updateString(int columnIndex, String s) throws SQLException 指定列中的字符串更改为s的值 public void updateString(String columnName, String s) throws SQLException 类似于前面的方法，不同之处在于由它的名称。而不是它的索引指定的列 类似的还有updateDouble() 等等 我们在更新了结果集中的内容，当然需要更新一下数据库了。 我们可以调用下面的方法更新数据库| 方法 | 说明 || —- | —- || public void updateRow() | 通过更新数据库中响应的行更新当前行 || public void deleteRow() | 从数据库中删除当前行 || public void refreshRow() | 刷新在结果集的数据，以反映最新变化在数据库中 || public void cancelRowUpdates() | 取消所做的当前行的任何更新 || public void insertRow() | 插入一行到数据库中。当光标指向插入行此方法只能被调用 | 我们这里对上面的方法做一个小小的举例 123456789101112131415Statement stmt = conn.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE );String sql = &quot;SELECT id, name, age FROM Students&quot;;ResultSet rs = stmt.executeQuery(sql);//结果集中插入新行rs.moveToInsertRow();rs.updateInt(&quot;id&quot;,5);rs.updateString(&quot;name&quot;,&quot;John&quot;);rs.updateInt(&quot;age&quot;,21);//更新数据库rs.insertRow(); JDBC 事务我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务。让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败。 如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开。 例如: 1234Connection conn = null;conn = DriverManager.getConnection(URL);// 关闭自动提交conn.setAutoCommit(false); 我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用commit() 方法 1conn.commit(); 尤其不要忘记，在catch块内添加回滚事务，表示操作出现异常，撤销事务; 1conn.rollback();","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java JDBC","slug":"java-JDBC","permalink":"https://bawcat.wiki/tags/java-JDBC/"}]},{"title":"关于 Java System、Random 的使用","slug":"java/基础教学/System-Random","date":"2019-12-19T08:00:00.000Z","updated":"2023-07-24T09:52:35.541Z","comments":true,"path":"2019/12/19/java/基础教学/System-Random/","link":"","permalink":"https://bawcat.wiki/2019/12/19/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/System-Random/","excerpt":"","text":"java 关于 System、Random 的使用 记录java的System、Random 类的使用 SystemSystem 类提供一下的功能: 标准输入，标准输出和错误输出流 访问外部定义的属性和环境变量 加载文件和库的方法 以及用于快速复制数组的实用方法。 System 不可以被实例化，只能使用其静态方法 123456789101112//从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length) //返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)public static long currentTimeMillis() //终止当前正在运行的Java虚拟机，status为 0时退出public static void exit(int status) // 运行垃圾收集器public static void gc() // 取得当前系统的全部属性public static Properties getProperties()//获取指定键的系统属性public static String getProperty(String key) 示例代码： 123456789101112131415161718import java.util.Arrays;public class SystemDemo &#123; public static void main(String[] args) &#123; int[] a = &#123;7, 8, 9, 10, 11&#125;; int[] b = &#123;1, 2, 3, 4, 5, 6&#125;; //从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3 System.arraycopy(a, 1, b, 2, 3); //输出结果 System.out.println(Arrays.toString(b)); System.out.println(&quot;当前时间：&quot; + System.currentTimeMillis()); System.out.println(&quot;java版本信息：&quot; + System.getProperty(&quot;java.version&quot;)); //运行垃圾收集器 System.gc(); //退出 System.exit(0); &#125;&#125; 输出结果 123[1, 2, 8, 9, 10, 6]当前时间：1576139050573java版本信息：1.8.0_131 Random Random 类用于生产伪随机数流，在java.util包下。 示例代码: 123456789101112131415161718192021import java.util.Random;public class RandomDemo &#123; public static void main(String[] args) &#123; Random random = new Random(); //随机生成一个整数 int范围 System.out.println(random.nextInt()); //生成 [0,n] 范围的整数 设n=100 System.out.println(random.nextInt(100 + 1)); //生成 [0,n) 范围的整数 设n=100 System.out.println(random.nextInt(100)); //生成 [m,n] 范围的整数 设n=100 m=40 System.out.println((random.nextInt(100 - 40 + 1) + 40)); //随机生成一个整数 long范围 System.out.print(random.nextLong()); //生成[0,1.0)范围的float型小数 System.out.println(random.nextFloat()); //生成[0,1.0)范围的double型小数 System.out.println(random.nextDouble()); &#125;&#125; 运行结果： 12345678$ javac RandomDemo.java$ java RandomDemo272128541679366-23177167376469717070.931040350.20044632645967309 ps 多关注 (new Random).nextInt() 这个生产随机数的 规则 [m,n] 例如 m=x n&gt;m :x可以是任何数","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java System","slug":"java-System","permalink":"https://bawcat.wiki/tags/java-System/"},{"name":"java Random","slug":"java-Random","permalink":"https://bawcat.wiki/tags/java-Random/"}]},{"title":"程序员常用算法","slug":"算法/程序员常用算法","date":"2019-12-13T18:48:04.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/12/13/算法/程序员常用算法/","link":"","permalink":"https://bawcat.wiki/2019/12/13/%E7%AE%97%E6%B3%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法 算法（Algorithm）是指解题方案的准确而完整的描述,是一系列解决问题的清晰指令,算法代表着用系统的方法描述解决问题的策略机制.也就是说,能够对一定规范的输入,在有限时间内获得所要求的输出.如果一个算法有缺陷,或不适合于某个问题,执行这个算法将不会解决这个问题.不同的算法可能用不同的时间、空间或效率来完成同样的任务.一个算法的优劣可以用空间复杂度于时间复杂度来衡量—-维基百科 插入排序 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。插入排序的基本思想是：每步将一个待排序的记录按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 排序过程步骤: 从第一个元素开始, 该元素可以认为已经被排序 取出下一个元素, 在已经排序的元素序列中从后向前扫描 如果该元素(已排序)大于新元素,将该元素移到下一位置 重复步骤3, 直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 示例代码: 1234567891011121314151617181920212223import java.util.Arrays;public class InsertSort &#123; public static void sort(int[] arr) &#123; int temp; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; //对已经排序好的元素比较，找到一个比插入元素大的元素 交换位置 if (arr[i] &lt; arr[j]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] ints = &#123;5, 3, 4, 1, 2&#125;; sort(ints); System.out.println(Arrays.toString(ints)); &#125;&#125; 冒泡排序 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成-这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样故名“冒泡排序”。 冒泡排序的运行过程如下: 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 示例代码: 12345678910111213141516171819202122import java.util.Arrays;public class BubbleSort &#123; public static void sort(int[] arr) &#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; //如果当前元素比后一位元素大 交换位置 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] ints = &#123;5, 3, 4, 1, 2&#125;; sort(ints); System.out.println(Arrays.toString(ints)); &#125;&#125; 归并排序 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法该算法是采用分治法（Divide and Conquer）的一个非常典型的应用将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 排序过程: 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class MergeSort &#123; public static void mergeSort(int[] arrays, int left, int right) &#123;// 如果数组还可以拆分 if (left &lt; right) &#123; //数组的中间位置 int middle = (left + right) / 2; //拆分左边数组 mergeSort(arrays, left, middle); //拆分右边数组 mergeSort(arrays, middle + 1, right); //合并 merge(arrays, left, middle, right); &#125; &#125; /** * 合并数组 */ public static void merge(int[] arr, int left, int middle, int right) &#123; //申请合并空间 大小为两个已经排序序列之和 int[] temp = new int[right - left + 1]; //i 和 j为两个已经排好序的数组的起始位置 int i = left; int j = middle + 1; int k = 0; //排序 while (i &lt;= middle &amp;&amp; j &lt;= right) &#123; //将比较小的数组放入合并空间 if (arr[i] &lt; arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; //将左边剩余元素写入合并空间 while (i &lt;= middle) &#123; temp[k++] = arr[i++]; &#125; //将右边剩余的元素写入合并空间 while (j &lt;= right) &#123; temp[k++] = arr[j++]; &#125; //将排序后的数组写回原来的数组 for (int l = 0; l &lt; temp.length; l++) &#123; arr[l + left] = temp[l]; &#125; &#125; public static void main(String[] args) &#123; int[] ints = &#123;5, 3, 4, 1, 2&#125;; mergeSort(ints,0,ints.length-1); System.out.println(Arrays.toString(ints)); &#125;&#125; 快速排序 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 O(nlogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。 快速排序使用分治法(Divide and conquer) 策略来吧一个序列(List)分为两个子序列(sub-lists) 步骤如下 : 从数列中挑出一个元素，称为“基准”（pivot）， 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Arrays;public class QuickSort &#123; public static void sort(int[] arr, int head, int tail) &#123; if (head &gt;= tail || arr == null || arr.length &lt;= 1) &#123; return; &#125; //设置数组的起始位置 i 结束位置j 基准 pivot 为数组的中间 int i = head, j = tail, pivot = arr[(head + tail) / 2]; while (i &lt;= j) &#123; //当数组小于基准 循环结束后 相当于i所处的位置的值为大于基准的元素 while (arr[i] &lt; pivot) &#123; ++i; &#125; //当数组大于基准 循环结束后 相当于j所处的位置的值为小于于基准的元素 while (arr[j] &gt; pivot) &#123; --j; &#125; //如果i&lt;j 那么则将交互i j对应位置的值 if (i &lt; j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; //将指针继续移动 ++i; --j; &#125; else if (i == j) &#123;//如果i=j 那么说明本次排序已经结束 将i++ 如果这里不使用i++ 那么后面的sort(arr,i,tail)将改为arr(arr,i+1,tail) ++i; &#125; &#125; //继续将数组分割 sort(arr, head, j); sort(arr, i, tail); &#125; public static void main(String[] args) &#123; int[] ints = &#123;5, 3, 4, 1, 2&#125;; sort(ints, 0, ints.length - 1); System.out.println(Arrays.toString(ints)); &#125;&#125; 搜索算法 线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。 示例代码: 123456789101112131415161718public class LinearSearch &#123; public static void main(String[] args) &#123; int[] ints = &#123;5, 3, 4, 1, 2&#125;; System.out.println(search(ints, 4)); &#125; public static int search(int[] arr, int key) &#123; //循环 for (int i = 0; i &lt; arr.length; i++) &#123; //比较是否等于key if (arr[i] == key) &#123; return arr[i]; &#125; &#125; //找不到就返回-1 return -1; &#125;&#125; 二分查找 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 示例代码: 12345678910111213141516171819202122232425public class BinarySearch &#123; public static int search(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; while (low &lt;= high) &#123; int middle = (high + low) / 2; //如果相等 返回值 if (key == arr[middle]) &#123; return key; &#125; else if (key &lt; arr[middle]) &#123; //如果key小于中间值，那么改变high，值可能在左边部（比较小的部分） high = middle - 1; &#125;else &#123; //如果key大于中间值，那么改变low，值可能在右边部（比较大的部分） low = middle + 1; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] ints = &#123;1, 2, 3, 4, 5&#125;; System.out.println(search(ints, 4)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://bawcat.wiki/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://bawcat.wiki/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://bawcat.wiki/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"基础算法","permalink":"https://bawcat.wiki/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"算法实例","slug":"算法实例","permalink":"https://bawcat.wiki/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B/"}]},{"title":"关于java Arrays、StringBuilder 类的使用","slug":"java/基础教学/基础数据类型/Arrays-StringBuilder","date":"2019-12-11T10:00:13.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/11/java/基础教学/基础数据类型/Arrays-StringBuilder/","link":"","permalink":"https://bawcat.wiki/2019/12/11/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Arrays-StringBuilder/","excerpt":"","text":"关于java Arrays、StringBuilder 类的使用 记录 java Arrays、StringBuilder 两个类的使用方法 Arrays Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为list 方法 描述 List asList(T…a) 返回由指定数组构造的list void sort(Object[] a) 对数组进行排序 void fill(Object[] a, Object val) 对数组的所有元素都赋上相同的值 boolean equals(Object[] a, Object[] a2) 检查两个数组是否相等 int binarySearch(Object[] a, Object key) 对排序后的数组使用二分法查找数据 示例代码: 12345678910111213141516171819202122232425262728293031import java.util.Arrays;import java.util.Random;public class ArraysDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[10]; //将数组元素都设为9 Arrays.fill(arr, 9); System.out.println(&quot;fill:&quot; + Arrays.toString(arr)); Random random = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; //使用100以内的随机数赋值数组 arr[i] = random.nextInt(101); &#125; //重新赋值后的数组 System.out.println(&quot;重新赋值：&quot; + Arrays.toString(arr)); //将索引为5的元素设为50 arr[5] = 50; //排序 Arrays.sort(arr); //排序后的数组 System.out.println(&quot;sort排序后：&quot; + Arrays.toString(arr)); //查找50的位置 int i = Arrays.binarySearch(arr, 50); System.out.println(&quot;值为50的元素索引：&quot;+i); //复制一份新数组 int[] newArr = Arrays.copyOf(arr, arr.length); //比较 System.out.println(&quot;equals:&quot;+Arrays.equals(arr, newArr)); &#125;&#125; 编译结果: 1234567$ javac ArraysDemo.java$ java ArraysDemofill:[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]重新赋值：[69, 83, 40, 58, 94, 42, 2, 53, 43, 83]sort排序后：[2, 40, 43, 50, 53, 58, 69, 83, 83, 94]值为50的元素索引：3equals:true StringBuilder StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的） StringBuilder 的构造方法： 构造方法 说明 StringBuider() 构造一个其中不带字符的StringBuilder, 其容量为16个字符 StringBuilder(CharSequenceseq) 构造一个StringBuilder, 它包含与指定的CHarSequence相同的字符 StringBuilder(int capacity) 构造一个具有指定初始容量的StringBuilder StringBuilder(String str) 并将其内容初始化为指定的字符串内容 StringBuilder 类的常用方法: 方法 返回值 功能描述 insert(int offsetm, Object obj) StringBuilder 在offsetm的位置插入字符串obj append(Object obj) StringBuilder 在字符串末尾追加字符串 obj length() int 确定StringBuilder 对象的长度 setCharAt(int index,char ch) void 使用ch指定的新值设置index指定的位置上的字符 toString() String 转换为字符串形式 reverse() StringBuilder 反转字符串 delete(int start, int end) StringBuilder 删除调用对象中从start位置开始直到end指定的索引(end-1)位置的字符序列 replace(int start, int end, String str) StringBuilder 使用一组字符替换另一组字符。将用替换字符串从start指定的位置开始替换，直到end直到的位置结束","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java Arrays","slug":"java-Arrays","permalink":"https://bawcat.wiki/tags/java-Arrays/"},{"name":"java StringBuilder","slug":"java-StringBuilder","permalink":"https://bawcat.wiki/tags/java-StringBuilder/"}]},{"title":"关于 java ArrayList","slug":"java/基础教学/基础数据类型/ArrayList","date":"2019-12-09T18:45:55.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/12/09/java/基础教学/基础数据类型/ArrayList/","link":"","permalink":"https://bawcat.wiki/2019/12/09/java/%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ArrayList/","excerpt":"","text":"ArrayList 类的使用示例List是一个借口,不能实例化,需要一个具体类来实现实例化.List集合中的对象按照一定的顺序排放,里面的内容可以重复.List借口实现的类有：ArrayList(实现动态数组),Vector(实现动态数组),LinkedList(实现链表),Stack(实现堆栈). List在Collection基础上增加的方法： 方法 返回值 说明 add(int index, E element) void 在列表的指定位置插入指定元素(可选操作) addAll(int index, Collection&lt;? extends E&gt; c) boolean 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作） get(int index) E 返回列表中指定位置的元素 indexOf(Object o) int 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1 lastIndexOf(Object o) int 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1 listIterator() ListIterator 返回此列表元素的列表迭代器（按适当顺序) listIterator(int index) ListIterator 返回此列表元素的列表迭代器（按适当顺序）,从列表的指定位置开始 remove(int index) E 移除列表中指定位置的元素（可选操作） set(int index,E element) E 用指定元素替换列表中指定位置的元素（可选操作) subList(int fromIndex, int toIndex) List 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图 ArrayList 类实现了一个可增长的动态数组, 位于java.util.ArrayList.实现了List接口, 它可以存储不同的类型的对象（包括null在内）,而数组则只能存放特点数据类型的值 ArrayList学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作 12345678910111213141516171819/** * 学生类 */public class Student &#123; public String id; public String name; public Student(String id, String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 对学生操作类，通过学生列表来管理学生 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.util.*;public class ListTest &#123; //集合后面的&lt;&gt;代表泛型的意思 //泛型是规定了集合元素的类型 /** * 用于存放学生的List */ public List&lt;Student&gt; students; public ListTest() &#123; this.students = new ArrayList&lt;Student&gt;(); &#125; /** * 用于往students中添加学生 */ public void testAdd() &#123; // 创建一个学生对象，并通过调用add方法，添加到学生管理List中 Student st1 = new Student(&quot;1&quot;, &quot;张三&quot;); students.add(st1); // 取出 List中的Student对象 索引为0 也就是第一个 Student temp = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name); Student st2 = new Student(&quot;2&quot;, &quot;李四&quot;); //添加到list中，插入到索引为0的位置，也就是第一个 students.add(0, st2); Student temp2 = students.get(0); System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name); // 对象数组的形式添加 Student[] student = &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;; // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表 students.addAll(Arrays.asList(student)); Student temp3 = students.get(2); Student temp4 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name); System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name); Student[] student2 = &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;; students.addAll(2, Arrays.asList(student2)); Student temp5 = students.get(2); Student temp6 = students.get(3); System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name); System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name); &#125; /** * 取得List中的元素的方法 */ public void testGet() &#123; int size = students.size(); for (int i = 0; i &lt; size; i++) &#123; Student st = students.get(i); System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过迭代器来遍历 * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动 */ public void testIterator() &#123; // 通过集合的iterator方法，取得迭代器实例 Iterator&lt;Student&gt; it = students.iterator(); System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;); while (it.hasNext()) &#123; Student st = it.next(); System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name); &#125; &#125; /** * 通过for each 方法访问集合元素 * */ public void testForEach() &#123; System.out.println(&quot;有如下学生（通过for each）：&quot;); for (Student obj : students) &#123; Student st = obj; System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name); &#125; //使用java8 Steam将学生排序后输出 students.stream()//创建Stream //通过学生id排序 .sorted(Comparator.comparing(x -&gt; x.id)) //输出 .forEach(System.out::println); &#125; /** * 修改List中的元素 * */ public void testModify() &#123; students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;)); &#125; /** * 删除List中的元素 * */ public void testRemove() &#123; Student st = students.get(4); System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;); students.remove(st); System.out.println(&quot;成功删除学生！&quot;); testForEach(); &#125; public static void main(String[] args) &#123; ListTest lt = new ListTest(); lt.testAdd(); lt.testGet(); lt.testIterator(); lt.testModify(); lt.testForEach(); lt.testRemove(); &#125;&#125; 编译运行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ javac Student.java ListTest.java$ java ListTest添加了学生：1:张三添加了学生：2:李四添加了学生：3:王五添加了学生：4:马六添加了学生：5:周七添加了学生：6:赵八学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:王五学生：4:马六有如下学生（通过迭代器访问）：学生2:李四学生1:张三学生5:周七学生6:赵八学生3:王五学生4:马六有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：3:吴酒学生：4:马六Student&#123;id=&#x27;1&#x27;, name=&#x27;张三&#x27;&#125;Student&#123;id=&#x27;2&#x27;, name=&#x27;李四&#x27;&#125;Student&#123;id=&#x27;3&#x27;, name=&#x27;吴酒&#x27;&#125;Student&#123;id=&#x27;4&#x27;, name=&#x27;马六&#x27;&#125;Student&#123;id=&#x27;5&#x27;, name=&#x27;周七&#x27;&#125;Student&#123;id=&#x27;6&#x27;, name=&#x27;赵八&#x27;&#125;我是学生：3:吴酒，我即将被删除成功删除学生！有如下学生（通过for each）：学生：2:李四学生：1:张三学生：5:周七学生：6:赵八学生：4:马六Student&#123;id=&#x27;1&#x27;, name=&#x27;张三&#x27;&#125;Student&#123;id=&#x27;2&#x27;, name=&#x27;李四&#x27;&#125;Student&#123;id=&#x27;4&#x27;, name=&#x27;马六&#x27;&#125;Student&#123;id=&#x27;5&#x27;, name=&#x27;周七&#x27;&#125;Student&#123;id=&#x27;6&#x27;, name=&#x27;赵八&#x27;&#125; 在上面的代码中, 用到了Arrays类,Arrays 包含用来操作数组(比如排序和搜索)的各种方法asList()方法用来返回一个受指定数组支持的固定大小的列表","categories":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"java ArrayList","slug":"java-ArrayList","permalink":"https://bawcat.wiki/tags/java-ArrayList/"}]},{"title":"Nginx配置文件详细说明","slug":"linux/linux-centos-2018-09-10-1","date":"2019-10-19T13:55:56.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/10/19/linux/linux-centos-2018-09-10-1/","link":"","permalink":"https://bawcat.wiki/2019/10/19/linux/linux-centos-2018-09-10-1/","excerpt":"","text":"关于nginx相关配置 在此记录下Nginx服务器nginx.conf的配置文件说明, 部分注释收集与网络. #运行用户 user www-data; #启动进程,通常设置成和cpu的数量相等 worker_processes 1; #全局错误日志及PID文件 error_log /var/log/nginx/error.log; pid /var/run/nginx.pid; #工作模式及连接数上限 events &#123; use epoll; #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能 worker_connections 1024;#单个后台worker process进程的最大并发链接数 # multi_accept on; &#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持 http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6]\\.(?!.*SV1)&quot;; #设定请求缓冲 client_header_buffer_size 1k; large_client_header_buffers 4 4k; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; #设定负载均衡的服务器列表 upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 #本机上的Squid开启3128端口 server 192.168.8.1:3128 weight=5; server 192.168.8.2:80 weight=1; server 192.168.8.3:80 weight=6; &#125; server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.xx.com; #设定本虚拟主机的访问日志 access_log logs/www.xx.com.access.log main; #默认请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 fastcgi_pass www.xx.com; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /root; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/htdocs; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ \\.php$ &#123; root /root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name; include fastcgi_params; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /\\.ht &#123; deny all; &#125; &#125; &#125; 以上是一些基本的配置,使用Nginx最大的好处就是负载均衡 如果要使用负载均衡的话,可以修改配置http节点如下： #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #省略上文有的一些配置节点 #。。。。。。。。。。 #设定负载均衡的服务器列表 upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口 server 192.168.8.2x:80 weight=1; server 192.168.8.3x:80 weight=6; &#125; upstream mysvr2 &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.x:80 weight=1; server 192.168.8.x:80 weight=6; &#125; #第一个虚拟服务器 server &#123; #侦听192.168.8.x的80端口 listen 80; server_name 192.168.8.x; #对aspx后缀的进行负载均衡请求 location ~ .*\\.aspx$ &#123; root /root; #定义服务器的默认网站根目录位置 index index.php index.html index.htm; #定义首页索引文件的名称 proxy_pass http://mysvr ;#请求转向mysvr 定义的服务器列表 #以下是一些反向代理的配置可删除. proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; &#125; &#125;","categories":[{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/categories/centos/"},{"name":"nginx","slug":"centos/nginx","permalink":"https://bawcat.wiki/categories/centos/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://bawcat.wiki/tags/nginx/"},{"name":"config","slug":"config","permalink":"https://bawcat.wiki/tags/config/"},{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://bawcat.wiki/tags/linux/"},{"name":"lnmp","slug":"lnmp","permalink":"https://bawcat.wiki/tags/lnmp/"}]},{"title":"关于推荐大家建立个人博客","slug":"程序人生/关于推荐大家建立个人博客","date":"2019-10-19T13:23:13.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/10/19/程序人生/关于推荐大家建立个人博客/","link":"","permalink":"https://bawcat.wiki/2019/10/19/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%85%B3%E4%BA%8E%E6%8E%A8%E8%8D%90%E5%A4%A7%E5%AE%B6%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"关于博客 关于博客 说实在的 很多朋友都在问我 为什么要做一个博客 其实对于每一个程序员来说 个人博客就好像是一个人的身份标识一样 当然 更多的是一个人的编程思想 也是一种隔着屏幕的文化交流 同时也是一场知识竞赛 对于我们来说 其实也有很多人 会用印象笔记那样的东西 这些都是一种记录方式 而我们制作博客 将文章放在博文上面 同时也是为了帮助别人 博客的好处 没有什么是没有意义的 今天你学习的一小部分 积少成多 终会成为你未来前进道路上的助力 其实对于博客来说的话 有很多种方式可以证明博文是好的 例如记录自己的学习过程 记录自己踩过的坑 当然 你可以说 （我自己用印象笔记**）都可以记录呀 为什么还要花钱租借服务器去搭建博客这种东西 其实在这里 我就要说一句了 其实吧 将文章放在网络上不仅仅可以和各位大佬交流 同时呢也可以帮助到其他人 甚至你的个人博客站点流量高了之后 大家可以申请百度谷歌的广告联盟 这些还能帮助我们盈利 不仅在学习的过程中我们还可以利用知识赚钱（我真是太贼了୧(๑•̀⌄•́๑)૭）） 当然这些都不是最主要的问题 还能提高我们的文笔 更多的是一台服务器在我们租借回来之后 我们的实际运用 我就看到身边的很多人 要么只会敲代码 要么只会用工具 若是两者结合一下 那么又是一位大佬啊 可惜 没如果 为什么要使用服务器 相信大家都用 github 其实在使用github的过程中 我们会发现 一个小问题（对于刚刚开始学习的小白来说）我们通过zip去下载的方式总是很麻烦 这个时候 我们会发现 github 还给我们提供了git克隆模式 甚至 我们还可以通过 composer 去帮助我们管理整个项目 而本地环境总归还是不能与线上环境相对比的 比如有的坑 就是因为 windows 环境和 linux 的环境问题 PHP就有很多代码运行需要修改 所以 养成一个使用服务器 利用 git 管理项目 代码等好的行为是一个优秀程序员必备的技能之一 相对比与公司 我们需要考虑到更多的环境 考虑更多的配置问题 这些对于从未接触过服务器的你来说 难道就是几篇教程就能解决问题么 实践出真理 这句话永远都不会过时 就算你是天才 也需要不少的经验值才能将你堆积起来 理论操作时永远成长不起来的 价格太贵 腰包无法接受 其实说价格这个问题的人 我相信都是不怎么关注服务器的人 2018年 简直就是云计算大爆发的一个时代 在这个时代 很多人因为云计算一夜崛起 也有人因为云计算 突然XX 随着时间的推移 现在2019的到来 区块链 云计算 物联网 网络已经充斥着我们的生活 我们生活中也已经被网络所包围 这是一场机遇 同时也是一场危机 其实只要大家多多关注网络咨询 就能够在百度上面找到很多现在的服务器运营商 他们的价格相对于阿里云 腾讯云来说要低很多 不过同时 也会有各种毛病等 不过阿里 腾讯 偶尔也是会有一些活动的 例如： 阿里云新老回馈https://promotion.aliyun.com/ntms/act/qwbk.html?accounttraceid=a755f1fa-ac36-4af1-979a-442b1013f494&amp;userCode=4jm8fecv 阿里全民云计算https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=4jm8fecv 类似的活动也有很多 包括阿里云 和 腾讯云的 学生机 校园计划等 都可以帮助我们去学习这些方向","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"随笔","slug":"程序人生/随笔","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://bawcat.wiki/tags/%E9%9A%8F%E7%AC%94/"},{"name":"小记","slug":"小记","permalink":"https://bawcat.wiki/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"https://bawcat.wiki/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"简单工厂模式（Simple Factory Pattern)","slug":"设计模式/简单工厂模式","date":"2019-09-26T12:26:39.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/09/26/设计模式/简单工厂模式/","link":"","permalink":"https://bawcat.wiki/2019/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简单工厂模式（Simple Factory Pattern)1.1 模式动机考虑到一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如 圆形按钮、棱角按钮、矩形按钮），这些按钮都来源同一个基类，不过在基础基类之后不同的子类修改了部分属性从而使得他们能够呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道哪些具体的按钮的名字，只需要知道表示这个按钮的一个参数，并提供一个调用方便的方法，把该参数传入方法并返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 1.2 模式定义简单工厂模式（Simple Factory Pattern）: 又称之为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 1.3 模式结构简单工厂模式包含如下角色： Factory:工厂角色 工厂角色负责实现创建所有实例的内部逻辑 Product:抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreateProduct:具体产品角色 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例 1.4 时序图 1.5 代码分析12345678910111213 # include &quot;Factory.h&quot; # include &quot;ConcreteProductA.h&quot; # include &quot;ConcreteProductB.h&quot; Product* Factory::createProduct(string proname)&#123; if(&quot;A&quot; == proname) &#123; return new ContreteProductA(); &#125;else if(&quot;B&quot; == proname)&#123; return new ConcreteProductB(); &#125; return NULL;&#125; 1.6 模式分析 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 在调用工厂类的工厂方法时，由于工厂方法时静态方法，使用起来很方便，可以通过类名直接调，而且只需要传入一个简单的参数即可，在实际开发过程中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无需修改任何源代码。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而不需要知道其创建细节 1.7 实例 略 1.8 简单工厂模式的优点 工作累含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 1.9 简单工厂模式的缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都会受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多的时候，有可能会造成工厂逻辑过于复杂，不利于系统的扩展和维护 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构 1.10 适用环境在一下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 1.11 模式应用 JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat, 它用于格式化一个本地日期或者时间。123public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Locale locale); Java 加密技术获取不同的加密算法的密钥生成器1KetGenerator ketGen=KetGenerator.getInstance(&quot;DESede&quot;); 创建密码器：1Cipher cp=Cipher.getInstance(&quot;DESede&quot;); 1.12 总结 创建型模式对类的实例化过程进行了抽象，能够将对象的创建于对象的使用过程分离。 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，而且产品较多时，工厂方法代码将会非常复杂。 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数。对于如何创建对象不关心。’","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://bawcat.wiki/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"lumen + dingo 搭建api服务器","slug":"python/dingo","date":"2019-06-27T12:26:39.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2019/06/27/python/dingo/","link":"","permalink":"https://bawcat.wiki/2019/06/27/python/dingo/","excerpt":"","text":"lumen + dingo 搭建api服务器网上现在关于lumen的教程还是蛮少的，不过很少有初级PHP人员直接接触lumen，估计这也是一个问题吧！作为一个菜鸟，因为公司项目重构，所以我走上了lumen的流行 lumen lumen git地址 全部关于lumen的介绍以及说明都有 至于 dingo/api 是一个基于larveral和lumen的api工具 可以帮助我们快速构建api服务 dingo/api dingo/api git地址 全部关于dingo组件 安装首先 ，通过使用composer安装laravel安装器： 1composer global require &quot;laravel/lumen-installer&quot; 然后我们通过安装器进行安装 1lumen new blog 其次我们也可以通过composer创建项目 1composer create-project --prefer-dist laravel/lumen blog 本地开发环境如果你本地安装了PHP，并且你想使用PHP内置的服务器来为你提供应用服务，php -S localhost:8000 -t public命令。该命令会在 http://localhost:8000上启动开发服务器 lumen 和 laravel 虽然是同一个框架系列但是不属于同样的结构 lumen更像是一个laravel的儿子，一个专属于api开发的框架 所以在文件结构上的处理和方式也有很多不同 Lumen 框架所有的配置信息都是存在 .env 文件中。一旦 Lumen 成功安装，你同时也要 配置本地环境。 dingo install首先去dingo的git上面查看当前版本 我这里安装的是2.2以上的版本 至于dingo的版本安装失败 请参考https://learnku.com/courses/laravel-package/api-development-kit-dingoapi/ 安装dingo 有两种方法 这两种方法基本上百度都能找到 一种是在composer.json文件中进行修改 然后composer update： 123&quot;require&quot;: &#123; &quot;dingo/api&quot;: &quot;^2.2&quot; &#125; 另一种就是直接使用 composer 直接将包引入 1composer require dingo/api 当我们安装 dingo 之后我们需要对dingo进行注册 我们使用 laravel 需要将配置文件引入进来，当然我们当前使用的是lumen 1$app-&gt;register(Dingo\\Api\\Provider\\LumenServiceProvider::class); 关于FacadesAPI 自带了两个 Facade ，你可以自己选择使用 Dingo\\Api\\Facade\\API 这个调度器的 Facade ，并提供了一些好用的辅助方法 Dingo\\Api\\Facade\\Route 你可以使用这个 Facade 来获取API的当前路由、请求、检查当前的路由名称等 Dingo 配置 大部分的配置信息都是预先配置好了的，为的是让你能快速上手你的 API 项目。你可以通过 ·env 文件来自定义大部分配置。但是，有一些配置微调需要你发布配置文件（Laravel）或者在 bootstrap/app.php 文件中配置 （Lumen）。你也可以使用 AppServiceProvider 中的 boot 方法来做设置。 Standards Tree 标准树 这有三个不同的树x,prs,和,vnd.你使用的标准树需要取决于你开发的项目 关于版本描述，请自行参考官网配置 配置.env 1API_STANDARDS_TREE=vnd 子类型通常是应用程序或项目的短名称，都是小写的。 1API_SUBTYPE=myapp 前缀和子域 12API_PREFIX=apiAPI_DOMAIN=api.myapp.com 当然域名和前缀只能用一个 版本号 1API_VERSION=v1 最后配置格式123456# dingo API_STANDARDS_TREE=prs API_SUBTYPE=package API_PREFIX=api API_VERSION=v1 API_DEBUG=true 这几个配置非常的重要， API 版本的切换会利用到这些配置，不配置是会报错的。 接下来就可以进行接口测试了。具体测试 基本上官网文档都讲解的非常明白。具体请自行参考官网配置","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"lumen","slug":"PHP/lumen","permalink":"https://bawcat.wiki/categories/PHP/lumen/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://bawcat.wiki/tags/laravel/"},{"name":"dingo","slug":"dingo","permalink":"https://bawcat.wiki/tags/dingo/"},{"name":"lumen","slug":"lumen","permalink":"https://bawcat.wiki/tags/lumen/"},{"name":"api server","slug":"api-server","permalink":"https://bawcat.wiki/tags/api-server/"}]},{"title":"mysql FIND_IN_SET使用方法","slug":"数据库/mysql/FIND_IN_SET使用方法","date":"2019-06-16T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/06/16/数据库/mysql/FIND_IN_SET使用方法/","link":"","permalink":"https://bawcat.wiki/2019/06/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/FIND_IN_SET%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"mysql FIND_IN_SET使用方法使用场景在最近的一次项目中，遇到一个场景，在一个审批中可能存在两个人同时进行审批，按照原先项目的思路，我决定对该项目的字段进行修改 首先在原有字段上进行修改 原有字段存在单个人的id 我们在单个id时对该id进行存储 然后 用户登录时，我们获取用户的id 然后对该id 进行验证 对此进行修改 我直接将原有的bigint类型修改成为varchar字段 如 原字段 存储用户1 = id = 1现在字段 存储 用户1 = id = 1 多用户 用户1、用户2 = id = 1,2 问题概述问题出现在id如果是按照in去查询 那么我们永远只能查询到id在前的无法查询到第一个id 后面的id 百度了一下 在mysql的手册中找到了FIND_IN_SET() 方法 使用方法语法1FIND_IN_SET(str,strlist) 定义 假如字符串str在由N子链组成的字符串列表strlist中，则返回值的范围在1到N之间。 一个字符串列表就是一个由一些被‘,’符号分开的自链组成的字符串。 如果第一个参数是一个常数字符串，而第二个是typeSET列，则FIND_IN_SET()函数被优化，使用比特计算。 如果str不在strlist或strlist为空字符串，则返回值为0。 如任意一个参数为NULL，则返回值为NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。 strlist：一个由英文逗号“,”链接的字符串，例如：”a,b,c,d”，该字符串形式上类似于SET类型的值被逗号给链接起来。 1示例：SELECT FIND_IN_SET(&#x27;b&#x27;,&#x27;a,b,c,d&#x27;) // 返回2，即为第二个值 关于mysql中的 IN和FIND_IN_SET的查询问题原来以为mysql可以进行这样的查询select id, list, name from table where ‘daodao’ IN (list); 注：table含有三个字段id:int, list:varchar(255), name:varchar(255) 实际上这样是不行的，这样只有当’daodao’是list中的第一个元素(我测试的时候貌似是第一个也是不行的，只有当list字段的值等于daodao时才是对的)时，查询才有效，否则都的不到结果，即使’daodao’真的在list中 结尾大家可以测试一下 我在网上也找到相同的文章 比较详细的那种http://blog.sina.com.cn/s/blog_5b5460eb0100e5r9.html 总结：所以如果list是常量，则可以直接用IN， 否则要用FIND_IN_SET()函数","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://bawcat.wiki/tags/SQL/"},{"name":"SELECT","slug":"SELECT","permalink":"https://bawcat.wiki/tags/SELECT/"}]},{"title":"mysql 关联查询 查询字段存在null赋值0","slug":"数据库/mysql/联查询 查询字段存在null赋值","date":"2019-06-13T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/06/13/数据库/mysql/联查询 查询字段存在null赋值/","link":"","permalink":"https://bawcat.wiki/2019/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E8%81%94%E6%9F%A5%E8%AF%A2%20%E6%9F%A5%E8%AF%A2%E5%AD%97%E6%AE%B5%E5%AD%98%E5%9C%A8null%E8%B5%8B%E5%80%BC/","excerpt":"","text":"mysql 5.6 以上问题描述 在读取数据库中 我们会发现 有的字段我们虽然默认为0 但是在关联查询时 主表查询从表如果查询不到数据 那么数据就会为空 而在前端展示不好看 所以我们能不能直接赋值 环境~ mysql 版本 5.6以上 查询条件1select 字段1,字段2,ifNull(字段3,0) as 字段3(别名) from 表名 环境~ sqlserver 查询条件1select 字段1,字段2,isNull(字段3,0) as 字段3(别名) from 表名 环境~ oracle 查询条件1select 字段1,字段2,nvl(字段3,0) from 表名","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://bawcat.wiki/tags/SQL/"},{"name":"SELECT","slug":"SELECT","permalink":"https://bawcat.wiki/tags/SELECT/"}]},{"title":"互联网架构，如何进行容量设计？","slug":"架构设计/互联网架构，如何进行容量设计？","date":"2019-01-07T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/01/07/架构设计/互联网架构，如何进行容量设计？/","link":"","permalink":"https://bawcat.wiki/2019/01/07/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%B9%E9%87%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F/","excerpt":"","text":"互联网架构，如何进行容量设计？原创： 58沈剑 架构师之路 2016-08-23 一，需求缘起 互联网公司，这样的场景是否似曾相识： 场景一：pm要做一个很大的运营活动，技术老大杀过来，问了两个问题： （1）机器能抗住么？ （2）如果扛不住，需要加多少台机器？ 场景二：系统设计阶段，技术老大杀过来，又问了两个问题： （1）数据库需要分库么？ （2）如果需要分库，需要分几个库？ 技术上来说，这些都是系统容量预估的问题，容量设计是架构师必备的技能之一。常见的容量评估包括数据量、并发量、带宽、CPU/MEM/DISK等，今天分享的内容，就以【并发量】为例，看看如何回答好这两个问题。 二，容量评估的步骤与方法 【步骤一：评估总访问量】如何知道总访问量？对于一个运营活动的访问量评估，或者一个系统上线后PV的评估，有什么好的方法？ 答案是：询问业务方，询问运营同学，询问产品同学，看对运营活动或者产品上线后的预期是什么。 举例：58要做一个APP-push的运营活动，计划在30分钟内完成5000w用户的push推送，预计push消息点击率10%，求push落地页系统的总访问量？ 回答：5000w*10% = 500w 【步骤二：评估平均访问量QPS】如何知道平均访问量QPS？ 答案是：有了总量，除以总时间即可，如果按照天评估，一天按照4w秒计算。 举例1：push落地页系统30分钟的总访问量是500w，求平均访问量QPS 回答：500w/(30*60) = 2778，大概3000QPS 举例2：主站首页估计日均pv 8000w，求平均访问QPS 回答：一天按照4w秒算，8000w/4w=2000，大概2000QPS 提问：为什么一天按照4w秒计算？ 回答：一天共24小时60分钟60秒=8w秒，一般假设所有请求都发生在白天，所以一般来说一天只按照4w秒评估 【步骤三：评估高峰QPS】系统容量规划时，不能只考虑平均QPS，而是要抗住高峰的QPS，如何知道高峰QPS呢？ 答案是：根据业务特性，通过业务访问曲线评估 举例：日均QPS为2000，业务访问趋势图如下图，求峰值QPS预估？ 回答：从图中可以看出，峰值QPS大概是均值QPS的2.5倍，日均QPS为2000，于是评估出峰值QPS为5000。 说明：有一些业务例如“秒杀业务”比较难画出业务访问趋势图，这类业务的容量评估不在此列。 【步骤四：评估系统、单机极限QPS】如何评估一个业务，一个服务单机能的极限QPS呢？ 答案是：压力测试 在一个服务上线前，一般来说是需要进行压力测试的（很多创业型公司，业务迭代很快的系统可能没有这一步，那就悲剧了），以APP-push运营活动落地页为例（日均QPS2000，峰值QPS5000），这个系统的架构可能是这样的： 1）访问端是APP 2）运营活动H5落地页是一个web站点 3）H5落地页由缓存cache、数据库db中的数据拼装而成 通过压力测试发现，web层是瓶颈，tomcat压测单机只能抗住1200的QPS（一般来说，1%的流量到数据库，数据库500QPS还是能轻松抗住的，cache的话QPS能抗住，需要评估cache的带宽，假设不是瓶颈），我们就得到了web单机极限的QPS是1200。一般来说，线上系统是不会跑满到极限的，打个8折，单机线上允许跑到QPS1000。 【步骤五：根据线上冗余度回答两个问题】好了，上述步骤1-4已经得到了峰值QPS是5000，单机QPS是1000，假设线上部署了2台服务，就能自信自如的回答技术老大提出的问题了： （1）机器能抗住么？ -&gt; 峰值5000，单机1000，线上2台，扛不住 （2）如果扛不住，需要加多少台机器？ -&gt; 需要额外3台，提前预留1台更好，给4台更稳 除了并发量的容量预估，数据量、带宽、CPU/MEM/DISK等评估亦可遵循类似的步骤。 三，总结 互联网架构设计如何进行容量评估： 【步骤一：评估总访问量】 -&gt; 询问业务、产品、运营【步骤二：评估平均访问量QPS】 -&gt; 除以时间，一天算4w秒【步骤三：评估高峰QPS】 -&gt; 根据业务曲线图来【步骤四：评估系统、单机极限QPS】 -&gt; 压测很重要【步骤五：根据线上冗余度回答两个问题】 -&gt; 估计冗余度与线上冗余度差值","categories":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/categories/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/tags/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"架构师","slug":"架构师","permalink":"https://bawcat.wiki/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"容量设计","slug":"容量设计","permalink":"https://bawcat.wiki/tags/%E5%AE%B9%E9%87%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"巧用CAS解决数据一致性问题","slug":"架构设计/巧用CAS解决数据一致性问题","date":"2019-01-07T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/01/07/架构设计/巧用CAS解决数据一致性问题/","link":"","permalink":"https://bawcat.wiki/2019/01/07/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%B7%A7%E7%94%A8CAS%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"巧用CAS解决数据一致性问题58沈剑 架构师之路 2015-11-05 缘起：在高并发的分布式环境下，对于数据的查询与修改容易引发一致性问题，本文将分享一种非常简单但有效的优化方法。 一、业务场景业务场景为，购买商品的过程要对余额进行查询与修改，大致的业务流程如下： （1）从数据库查询用户现有余额 SELECT money FROM t_yue WHERE uid=$uid，不妨设查询出来的$old_money=100元 （2）业务层实施业务逻辑，比如购买一个80元的商品，并且打九折 if($old\\_money&gt; 80\\*0.9) $new\\_money=$old_money-80\\*0.9=28 （3）将数据库中的余额进行修改 UPDAtE t\\_yue SET money=$new\\_money WHERE uid=$uid 在并发量低的情况下，这个流程没有任何问题，原有金额100元，购买了80元的九折商品（72元），剩余28元。 二、潜在的问题在分布式环境中，如果并发量很大，这种“查询**+**修改”的业务很容易出现数据不一致。极限情况下，可能出现这样的异常流程： （1）业务1和业务2同时查询余额，是100元 （2）业务1和业务2进行逻辑计算，算出各自业务的余额，假设业务1算出的余额是28元，业务2算出的余额是38元 （3）业务1对数据库中的余额先进行修改，设置成28元。 业务2对数据库中的余额后进行修改，设置成38元。 此时异常出现了，原有金额100元，业务1扣除了72元，业务2扣除了62元，最后剩余38元。 三、问题原因 高并发环境下，对同一个数据的并发读（两边都读出余额是100）与并发写（一个写回28，一个写回38）导致的数据一致性问题。 四、原因分析业务1的写回：原有金额100，这是一个初始状态，写回金额28，理论上只有在原有金额为100的时候才允许写回成功，这一步没问题。 业务2的写回：的原有金额100，这是一个初始状态，写回金额38，理论上只有在原有金额为100的时候才允许写回成功，可实际上，这个时候数据库中的金额已经变为28了，这一步的写操作不应该成功。 五、简易解决方案在set写回的时候，加上初始状态的条件compare，只有初始状态不变时，才允许set写回成功，这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。 六、业务的升级业务线使用CAS解决高并发时数据一致性问题，只需要在进行set操作时，compare一下初始值，如果初始值变换，不允许set成功。 对于上文中的业务场景，只需要将“UPDAtEt\\_yue SET money=$new\\_money WHERE uid=$uid”升级为 “UPDAtE t\\_yue SETmoney=$new\\_money WHERE uid=$uid **AND money=$old_money**”即可。 并发操作发生时： 业务1执行 =&gt; UPDAtE t_yue **SET money=28** WHERE uid=$uid **AND money=100** 业务2执行 =&gt; UPDAtE t_yue **SET money=38** WHERE uid=$uid **AND money=100** 【这两个操作同时进行时，只能有一个执行成功】。 七、怎么判断哪个执行成功，哪个执行失败set操作，其实无所谓成功或者失败，业务能通过affect rows得知哪个修改没有成功： 执行成功的业务，affect rows为1 执行失败的业务，affect rows为0 八、总结 高并发“查询并修改”的场景，可以用CAS（Compare and Set）的方式解决数据一致性问题。对应到业务，即在set的时候，加上初始条件的比对。","categories":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/categories/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/tags/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"架构师","slug":"架构师","permalink":"https://bawcat.wiki/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"CAS","slug":"CAS","permalink":"https://bawcat.wiki/tags/CAS/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/tags/MYSQL/"},{"name":"CAS 算法","slug":"CAS-算法","permalink":"https://bawcat.wiki/tags/CAS-%E7%AE%97%E6%B3%95/"},{"name":"MYSQL 锁","slug":"MYSQL-锁","permalink":"https://bawcat.wiki/tags/MYSQL-%E9%94%81/"}]},{"title":"究竟啥才是互联网架构“高可用”","slug":"架构设计/究竟啥才是互联网架构“高可用”","date":"2019-01-07T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2019/01/07/架构设计/究竟啥才是互联网架构“高可用”/","link":"","permalink":"https://bawcat.wiki/2019/01/07/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E7%A9%B6%E7%AB%9F%E5%95%A5%E6%89%8D%E6%98%AF%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%E2%80%9C%E9%AB%98%E5%8F%AF%E7%94%A8%E2%80%9D/","excerpt":"","text":"究竟啥才是互联网架构“高可用”原创： 58沈剑 架构师之路 2016-12-05 一、什么是高可用高可用HA**（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。 假设系统一直能够提供服务，我们说系统的可用性是100%。 如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。 很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。 百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度HA最高的褒奖。 二、如何保障系统的高可用我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。 保证系统高可用，架构设计的核心准则是：冗余。 有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。 接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。 三、常见的互联网分层架构常见互联网分布式架构如上，分为： （1）客户端层：典型调用方是浏览器browser或者手机应用APP （2）反向代理层：系统入口，反向代理 （3）站点应用层：实现核心应用逻辑，返回html或者json （4）服务层：如果实现了服务化，就有这一层 （5）数据**-**缓存层：缓存加速访问存储 （6）数据**-**数据库层：数据库固化数据存储 整个系统的高可用，又是通过每一层的冗余**+**自动故障转移来综合实现的。 四、分层高可用架构实践【客户端层-&gt;**反向代理层】的高可用** 【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。 自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。 【反向代理层-&gt;**站点层】的高可用** 【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。 自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。 【站点层-&gt;**服务层】的高可用** 【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。 自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。 【服务层&gt;**缓存层】的高可用** 【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。 缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。 缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。 以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。 自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。 说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。 这类允许“cache miss”的业务场景，缓存架构的建议是： 将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。 缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。 【服务层&gt;**数据库层】的高可用** 大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。 【服务层&gt;**数据库层“读”】的高可用** 【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。 既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。 自动故障转移：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。 【服务层&gt;**数据库层“写”】的高可用** 【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。 以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。 自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。 五、总结高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。 方法论上，高可用是通过冗余**+**自动故障转移来实现的。 整个互联网分层系统架构的高可用，又是通过每一层的冗余**+**自动故障转移来综合实现的，具体的： （1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移 （2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移 （3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移 （4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性 （5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移 （6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移 末了，希望文章的思路是清晰的，希望大家对高可用的概念和实践有个系统的认识，感谢大家。 ==【完】==","categories":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/categories/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/tags/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"架构师","slug":"架构师","permalink":"https://bawcat.wiki/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"高可用服务","slug":"高可用服务","permalink":"https://bawcat.wiki/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1/"},{"name":"分布式","slug":"分布式","permalink":"https://bawcat.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"如何在 CentOS7 中安装 Nodejs","slug":"linux/linux-centos-2018-12-28-1","date":"2018-12-27T16:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2018/12/27/linux/linux-centos-2018-12-28-1/","link":"","permalink":"https://bawcat.wiki/2018/12/27/linux/linux-centos-2018-12-28-1/","excerpt":"","text":"安装版本：10.13.0 一、安装必要的编译软件包sudo yum install gcc gcc-c++ 二、从源码下载Nodejscd /usr/local/src wget https://npm.taobao.org/mirrors/node/v10.13.0/node-v10.13.0.tar.gz 三、解压 nodejs 安装包tar xvf node-v10.13.0.tar.gz 四、进入解压的 node 文件夹，开始编译cd node-v10.13.0/ ./configure make 注：make过程较为耗时，可能需要30分钟以上 如果编译过程中报 C++ Compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)，那需要先升级一下 gcc，编译正常的话请忽略直接跳至第五步开始安装 检查 gcc 的版本 gcc -v 如果版本号低于4.9.4，请先升级gcc 五、安装Nodejssudo make install 六、到此就已经安装完毕了","categories":[{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/categories/centos/"},{"name":"Nodejs","slug":"centos/Nodejs","permalink":"https://bawcat.wiki/categories/centos/Nodejs/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://bawcat.wiki/tags/linux/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bawcat.wiki/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://bawcat.wiki/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"如何在 Centos7 中安装 gcc","slug":"linux/linux-centos-2018-12-27-1","date":"2018-12-26T16:00:00.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2018/12/26/linux/linux-centos-2018-12-27-1/","link":"","permalink":"https://bawcat.wiki/2018/12/26/linux/linux-centos-2018-12-27-1/","excerpt":"","text":"如何在 Centos7 中安装 gcc系统环境：Centos7.4今天在安装 Nodejs8.7 的时候，报了一个警告：WARNING: C++ Compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++) 然后，查了一下自己系统上安装的版本：4.8.5好吧，不能用 yum 升级了，那就手动安装了吧 一、选择需要升级的版本gcc ftp 下载地址列表(我选择了5.4.0) 二、获取安装包并解压cd /usr/local/src wget https://ftp.gnu.org/gnu/gcc/gcc-5.4.0/gcc-5.4.0.tar.bz2 tar -jxvf gcc-5.4.0.tar.bz2 注：bz2是一种压缩文件格式，若无法解压，安装 bzip2 即可：yum -y install bzip2 三、进入解压后的gcc文件夹，下载供编译需求的依赖项cd gcc-build-5.4.0 ./contrib/download_prerequisites 四、建立一个文件夹存放编译文件mkdir gcc-build-5.4.0 cd gcc-build-5.4.0 五、生成 Makefile 文件make 注：这个过程非常耗时，我的1核1G内存大约花了一个来小时 六、安装sudo make install 七、重启服务器，验证版本gcc -v 等了那么久，总算是成功了，很激动对不对？但是！我执行到上边以后，屁颠屁颠的跑去编译 nodejs 了，耍出了一个错误： /usr/local/src/node-v8.7.0/out/Release/mksnapshot: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#39; not found (required by /usr/local/src/node-v8.7.0/out/Release/mksnapshot) 编译失败~ 劳资等了30分钟 好吧，出了问题终究是要解决的问题原因：升级gcc时，生成的动态库没有替换老版本 gcc 动态库导致的解决方案：将gcc最新版本的动态库替换系统中老版本的动态库。(1). 查找编译gcc时生成的最新动态库 find / -name &quot;libstdc++.so*&quot; (2) 将找到的动态库libstdc++.so.6.0.21复制到/usr/lib64 cp /usr/local/src/gcc-5.4.0/gcc-build-5.4.0/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6.0.21 /usr/lib64 (3). 切换工作目录至/usr/lib64，删除原来的软连接， 将默认库的软连接指向最新动态库。 cd /usr/lib64 rm -rf libstdc++.so.6 ln -s libstdc++.so.6.0.21 libstdc++.so.6 到这里才算是收工了。","categories":[{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/categories/centos/"},{"name":"gcc","slug":"centos/gcc","permalink":"https://bawcat.wiki/categories/centos/gcc/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://bawcat.wiki/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"https://bawcat.wiki/tags/gcc/"}]},{"title":"一文让你彻底搞清楚javascript中的require、import与export","slug":"web/一文让你彻底搞清楚javascript中的require、import与export","date":"2018-12-06T01:33:32.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2018/12/06/web/一文让你彻底搞清楚javascript中的require、import与export/","link":"","permalink":"https://bawcat.wiki/2018/12/06/web/%E4%B8%80%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9Ajavascript%E4%B8%AD%E7%9A%84require%E3%80%81import%E4%B8%8Eexport/","excerpt":"","text":"前言 本文主要给大家介绍了关于javascript中require、import与export的相关内容，分享出来供大家参考学习，下面话不多说了，来一起看看详细的介绍吧。 为什么有模块概念理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，Javascript不是一种模块化编程语言，在es6以前，它是不支持”类”（class），所以也就没有”模块”（module）了。 require时代Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。 * 原始写法 * 模块就是实现特定功能的一组方法。只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 123456function m1()&#123; //...&#125;function m2()&#123; //... &#125; 上面的函数 * m1() * 和 * m2() * ，组成一个模块。使用的时候，直接调用就行了。 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 对象写法为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面 123456789var module1 = new Object(&#123;_count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 上面的函数 * m1() * 和 * m2() * ，都封装在module1对象里。使用的时候，就是调用这个对象的属性 1module1.m1(); 这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。 1module._count = 1; 立即执行函数写法使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的 1234567891011121314var module = (function() &#123;var _count = 0;var m1 = function() &#123;alert(_count)&#125;var m2 = function() &#123;alert(_count + 1)&#125; return &#123;m1: m1,m2: m2&#125;&#125;)() 使用上面的写法，外部代码无法读取内部的_count变量。 1 console.info(module._count); //undefined * module * 就是Javascript模块的基本写法。 主流模块规范在es6以前，还没有提出一套官方的规范,从社区和框架推广程度而言,目前通行的javascript模块规范有两种：CommonJS 和 AMD CommonJS规范[photos des=”node.js”][/photos] 2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。 这标志”Javascript模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。 node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。 在CommonJS中,暴露模块使用 * module.exports * 和 * exports * ，很多人不明白暴露对象为什么会有两个,后面会介绍区别 在CommonJS中，有一个全局性方法 * require() * ，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。 1var math = require(&#x27;math&#x27;); 然后，就可以调用模块提供的方法： 12 var math = require(&#x27;math&#x27;); math.add(2,3); // 5 正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格 AMD规范[photos des=”requrie.js”][/photos] 有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。 但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题 12var math = require(&#x27;math&#x27;);math.add(2, 3); 第二行math.add(2, 3) ，在第一行**require(‘math’)**之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。 这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 模块必须采用特定的define()函数来 1define(id?, dependencies?, factory) id:字符串，模块名称(可选) dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式 factory: 工厂方法，返回一个模块函数 如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 123456789// math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 12345678define([&#x27;Lib&#x27;], function(Lib)&#123; function foo()&#123; Lib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); 当require()函数加载上面这个模块的时候，就会先加载Lib.js文件。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样： 123require([&#x27;math&#x27;], function (math) &#123; math.add(2, 3);&#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。 目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。 CMD规范[photos des=”CMD”][/photos] CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的： 1234define(function(require, exports, module) &#123;var clock = require(&#x27;clock&#x27;);clock.start();&#125;); CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块 1define(id?, dependencies?, factory) id:字符串，模块名称(可选) dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式 factory: 工厂方法，返回一个模块函数12345define(&#x27;hello&#x27;, [&#x27;jquery&#x27;], function(require, exports, module) &#123; // 模块代码 &#125;); 如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。123define(function(require, exports, module) &#123;// 模块代码&#125;); 注意：带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。 CMD与AMD区别AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载； 而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 现阶段的标准 [photos des=”ES6”][/photos] ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。 export导出模块export语法声明用于导出函数、对象、指定文件（或模块）的原始值。 注意：在node中使用的是exports,不要混淆了 export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。 12345678910111213export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, const export default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;; export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用 default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入 －继承模块并导出继承模块所有的方法和属性 as－重命名导出“标识符” from－从已经存在的模块、脚本文件…导出 命名式导出模块可以通过export前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。 12export &#123; myFunction &#125;; // 导出一个已定义的函数export const foo = Math.sqrt(2); // 导出一个常量 我们可以使用*和from关键字来实现的模块的继承： 1export * from &#x27;article&#x27;; 模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象： 12345var name = &#x27;IT笔录&#x27;;var domain = &#x27;http://itbilu.com&#x27;; export &#123;name, domain&#125;; // 相当于导出&#123;name:name,domain:domain&#125; 模块导出时，我们可以使用as关键字对导出成员进行重命名： 1234var name = &#x27;IT笔录&#x27;;var domain = &#x27;http://itbilu.com&#x27;; export &#123;name as siteName, domain&#125;; 注意：下面的语法有严重错误的情况： 12345// 错误演示export 1; // 绝对不可以 var a = 100;export a; export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应 export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如： 1export &#123;fun as default,a,b,c&#125;; 默认导出默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。 12export default function() &#123;&#125;; // 可以导出一个函数export default class()&#123;&#125;; // 也可以出一个类 命名式导出与默认导出默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了default名称的命名导出。 下面两种导出方式是等价的： 1234const D = 123; export default D;export &#123; D as default &#125;; export使用示例使用名称导出一个模块时： 123456// &quot;my-module.js&quot; 模块export function cube(x) &#123;return x * x * x;&#125;const foo = Math.PI + Math.SQRT2;export &#123; foo &#125;; 在另一个模块（脚本文件）中，我们可以像下面这样引用： 123import &#123; cube, foo &#125; from &#x27;my-module&#x27;;console.log(cube(3)); // 27console.log(foo); // 4.555806215962888 使用默认导出一个模块时： 1234// &quot;my-module.js&quot;模块export default function (x) &#123;return x * x * x;&#125; 在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单： 123// 引用 &quot;my-module.js&quot;模块import cube from &#x27;my-module&#x27;;console.log(cube(3)); // 27 import引入模块import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。 import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。 import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。 123456789import defaultMember from &quot;module-name&quot;;import * as name from &quot;module-name&quot;;import &#123; member &#125; from &quot;module-name&quot;;import &#123; member as alias &#125; from &quot;module-name&quot;;import &#123; member1 , member2 &#125; from &quot;module-name&quot;;import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;import defaultMember, * as name from &quot;module-name&quot;;import &quot;module-name&quot;; name－从将要导入模块中收到的导出值的名称 member, memberN－从导出模块，导入指定名称的多个成员 defaultMember－从导出模块，导入默认导出成员 alias, aliasN－别名，对指定导入成员进行的重命名 module-name－要导入的模块。是一个文件名 as－重命名导入成员名称（“标识符”） from－从已经存在的模块、脚本文件等导入 命名式导入我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员： 注意：花括号里面的变量与export后面的变量一一对应 12import &#123;myMember&#125; from &quot;my-module&quot;;import &#123;foo, bar&#125; from &quot;my-module&quot;; 通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中： 1import * as myModule from &quot;my-module&quot;; 导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用： 1import &#123;reallyReallyLongModuleMemberName as shortName&#125; from &quot;my-module&quot;; 导入多个成员时，同样可以使用别名： 1import &#123;reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from &quot;my-module&quot;; 导入一个模块，但不进行任何绑定： 1import &quot;my-module&quot;; 默认导入在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。 直接导入默认值： 1import myDefault from &quot;my-module&quot;; 也可以在命名空间导入和名称导入中，同时使用默认导入： 1import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用 或 1import myDefault, &#123;foo, bar&#125; from &quot;my-module&quot;; // 指定成员导入 import使用示例12345678910111213141516171819// --file.js--function getJSON(url, callback) &#123;let xhr = new XMLHttpRequest();xhr.onload = function () &#123;callback(this.responseText)&#125;;xhr.open(&quot;GET&quot;, url, true);xhr.send();&#125; export function getUsefulContents(url, callback) &#123;getJSON(url, data =&gt; callback(JSON.parse(data)));&#125; // --main.js--import &#123; getUsefulContents &#125; from &quot;file&quot;;getUsefulContents(&quot;http://itbilu.com&quot;, data =&gt; &#123;doSomethingUseful(data);&#125;); default关键字123456// d.jsexport default function() &#123;&#125; // 等效于：function a() &#123;&#125;;export &#123;a as default&#125;; 在import的时候，可以这样用：1234import a from &#x27;./d&#x27;; // 等效于，或者说就是下面这种写法的简写，是同一个意思import &#123;default as a&#125; from &#x27;./d&#x27;; 这个语法糖的好处就是import的时候，可以省去花括号{}。 简单的说，如果import的时候，你发现某个变量没有花括号括起来（没有*号），那么你在脑海中应该把它还原成有花括号的as语法。 所以，下面这种写法你也应该理解了吧： 1import $,&#123;each,map&#125; from &#x27;jquery&#x27;; import后面第一个$是{defalut as $}的替代写法。 as关键字as简单的说就是取一个别名,export中可以用，import中其实可以用： 1234567// a.jsvar a = function() &#123;&#125;;export &#123;a as fun&#125;; // b.jsimport &#123;fun as a&#125; from &#x27;./a&#x27;;a(); 上面这段代码，export的时候，对外提供的接口是fun，它是a.js内部a这个函数的别名，但是在模块外面，认不到a，只能认到fun。 import中的as就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个c.js也通过了fun这个接口： 12// c.jsexport function fun() &#123;&#125;; 如果在b.js中同时使用a和c这两个模块，就必须想办法解决接口重名的问题，as就解决了。 CommonJS中module.exports 与 exports的区别Module.exportsThe module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do. 译文：module.exports对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给module.exports。 注意，将期望的对象赋值给exports会简单地重新绑定到本地exports变量上，这可能不是你想要的。 Module.exportsThe exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports: 译文：exports变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。它有一个快捷方式，以便 module.exports.f = … 可以被更简洁地写成exports.f = … 。 注意，就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到module.exports(其实是exports.属性会自动挂载到没有命名冲突的module.exports.属性) 从Api文档上面的可以看出，从require导入方式去理解，关键有两个变量(全局变量module.exports，局部变量exports)、一个返回值(module.exports) 12345678910111213141516function require(...) &#123;var module = &#123; exports: &#123;&#125; &#125;;((module, exports) =&gt; &#123;// 你的被引入代码 Start// var exports = module.exports = &#123;&#125;; (默认都有的)function some_func() &#123;&#125;;exports = some_func;// 此时，exports不再挂载到module.exports，// export将导出&#123;&#125;默认对象module.exports = some_func;// 此时，这个模块将导出some_func对象，覆盖exports上的some_func// 你的被引入代码 End&#125;)(module, module.exports);// 不管是exports还是module.exports，最后返回的还是module.exportsreturn module.exports;&#125; demo.js:12345678910111213141516171819console.log(exports); // &#123;&#125;console.log(module.exports); // &#123;&#125;console.log(exports === module.exports); // trueconsole.log(exports == module.exports); // trueconsole.log(module);/**Module &#123;id: &#x27;.&#x27;,exports: &#123;&#125;,parent: null,filename: &#x27;/Users/larben/Desktop/demo.js&#x27;,loaded: false,children: [],paths:[ &#x27;/Users/larben/Desktop/node_modules&#x27;,&#x27;/Users/larben/node_modules&#x27;,&#x27;/Users/node_modules&#x27;,&#x27;/node_modules&#x27; ] &#125;*/ 注意 每个js文件一创建，都有一个var exports = module.exports = {} , 使exports和module.exports都指向一个空对象。 module.exports和exports所指向的内存地址相同 本文转载自：https://www.jb51.net/article/124442.htm","categories":[{"name":"javascript","slug":"javascript","permalink":"https://bawcat.wiki/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://bawcat.wiki/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://bawcat.wiki/tags/web/"},{"name":"require","slug":"require","permalink":"https://bawcat.wiki/tags/require/"},{"name":"import","slug":"import","permalink":"https://bawcat.wiki/tags/import/"},{"name":"export","slug":"export","permalink":"https://bawcat.wiki/tags/export/"}]},{"title":"电商商品数据库设计","slug":"程序人生/电商商品数据库设计","date":"2018-10-22T16:00:00.000Z","updated":"2023-07-24T09:52:35.549Z","comments":true,"path":"2018/10/22/程序人生/电商商品数据库设计/","link":"","permalink":"https://bawcat.wiki/2018/10/22/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%94%B5%E5%95%86%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"sku 在电商系统中，商品模型至关重要，是整个电商的核心，下面通过一个简单的分析，设计一个基础的商品模型。 商品模型的演化在以前，那时 CMS 很流行，最常见的模型是栏目 - 文章模型。 于是做电商的时候，自然就继承了这种一对多的关系。 只是栏目变成了分类，文章变成了商品。商品也具备了独特的业务属性。 现在很多电商网站上左侧的菜单，也就是这个分类。 后来我们慢慢发现一个问题，只有分类并不能适应所有的需求，比如 nike 鞋和 nikeT 恤，用户可能希望先看 nike 的所有商品，这个模型就不能满足。 我们想在这个关系中，加入“品牌”概念。于是： 这样基本用户可以在首页上通过分类或者品牌找到自己想要的商品，也可以直接查看热门的商品和新上架的商品。 但是问题也来了，用户在进入分类后，展示在用户面前的是很多很多商品，用户希望再通过筛选查询出更接近他目标的商品。 于是优秀的产品设计师，设计出了类似这样的 UI： 用户可以通过这些筛选条件进一步缩小自己的目标范围，那么问题又来了，这样的产品需求排在程序员面前，怎么去实现它？ 经过分析，我们找出了一个方法，我们知道商品之间的属性可能存在着较大的差别，比如牛仔裤它有版型、腰型、裤长等属性； 而电脑它有 CPU、显卡等属性，各类商品的属性是不同的。 再进一步想，休闲裤也版型、腰型、裤长等属性；台式电脑或者笔记本电脑都有 CPU、显卡等属性。 所以我们得出：一个分类对应若干属性，而一个属性，对应若干属性选项，而一个具体商品又对应若干属性选项（例如具体一条牛仔裤，他的裤长：7 分，裤型：直筒）。 有点绕，仔细品味一下。 从图上可以看出，分类和属性的关系（例如：“牛仔裤”分类下有裤型、裤长、版型等属性）、属性和属性选项的关系（例如：裤长属性有长款、九分裤、七分裤的选项）、商品和属性选项的关系（例如某条牛仔裤的裤长是 7 分裤）。 至此，我们知道一个商品的分类、品牌以及它有什么属性和对应的属性值。那么通过筛选条件，自然就可以查询出指定的商品。 这里特别说一句，价格也是属性，不要设想用商品表中的价格字段去做计算。 这不利于查询也增加了复杂度，让商家编辑人员用属性来设置并保证他的正确性。 有了这个模型，我们大概就可以看到以下界面（请不要太关注左边，重点在右边和下面）： 这个页面展示商品的所有信息，按照之前的设计好像都可以满足。 但是我们似乎感觉错过了什么，在图上右边我们发现该商品当前的颜色和尺寸，并且允许用户可以选择其他的颜色和尺寸。 这给我们带来了疑惑，这里的“颜色”和“尺寸”是什么，一件商品的不同颜色不同尺寸是算一个商品还是多个商品。 经过思考后，我们发现我们混淆了两个概念——“商品”和“货品”。不同规格的货品作为独立的商品。 比如一条裤子的有 L 尺寸、M 尺寸、一个 U 盘有 16G 还是 32G 的，都是同样的货品，不同规格的商品。 可以认为货品和商品是一对多的关系。 弄清了这个概念，处理这个需求就容易多了，这里的“颜色”、“尺寸”我们就作为“规格”来处理，而红色、黑色；L 号、M 号我们视为规格的选项或者说规格值。 一件货品对应若干规格，而具有某一规格值的货品就是商品。 好了，现在好像差不多了。 基于这个模型可以满足基本的商品搜索、展示的需求。 搜索引擎也可以根据这个模型数据生成对应的商品索引，达到准确搜索的目的。 商品模块还会和其他模块一起协作，比如用户系统、订单系统、支付系统等。 一般情况下我们会把商品业务独立出来做成“商品中心”的服务，集中处理商品查询、更新、发布等业务，支撑其他业务。 从 SPU、SKU 开始 首先我们需要澄清上篇中的这两个概念，在上篇文章中“货品”是指一种概念物品，这种物品并不是一个具体的实物，当它具备具体的属性、价格时，才是一种实物，也就是商品。 “商品”就是库存中一个具体的实物。 例如：iphone6，就是一种货品，但用户购买的并不是货品而是商品，也就是用户最终购买的可能是：金色 -16G- 移动版 iphone6。 换句话来说，货品是一种产品的称谓（如 iphone6），商品是用户购买的具体实物，具备特定的属性（如：金色 -16G- 移动版）。 如果觉得这样理解还是比较混，那么忘记这两个概念，下面讲标准化的名称。 我们刚才说的 iphone6，书面称谓叫“SPU” Standard Product Unit （标准化产品单元），它是最接近用户认知的产品单元，比如用户说，我想买个 iphone4、iphone6、小米 4，这些都是 SPU，也就是用户普遍认知范围内的一种产品。 然而在电商系统中只有 SPU 并没有什么卵用，用户购买时肯定要确定，需要什么颜色、多少 G 的，支持什么网络。 所以，例如金色 -16G- 移动版 iphone6，就需要一个名称去规范它，这个名称叫“SKU” Stock Keeping Unit(库存单元)，换句话理解就是库存里面存的东西，库存里存在东西肯定是具体的某种规格的 iphone6。基于这个理解，我们先画下图： SPU,SKU 两个表，有各自的编码，这方便库存统计以及后台系统的管理，另外价格字段是在 SKU 中，这应该好理解，不同规格的 iphone6 肯定价格不一样，另外 SPU 与分类和品牌关联. 如 iphone6 属于“手机”分类，“苹果”品牌。当然一个 SPU 也可能属于多个分类，可以做成多对多的关系。有了这个基础，我们再来看电商商品详情页是怎么设计的： 我们看到这个页面其实是一个 SKU 的详情页，因为它指定了价格、颜色、版本、容量等信息，不同的颜色、版本、容量其实是不同的价格，不同的 SKU。 我们如果要实现这个设计，我们需要加两个概念，就是“属性”和“属性选项”。 “属性”正如这里的颜色、版本、容量。而“属性选项”则是金色、银色、移动 4G 版、16gb、64gb 等。可以看出“属性”和“属性选项”是一对多的关系， 而“属性选项”和 SKU 则是多对多关系，一个金色 -16G- 移动版 iphone6，具备“金色”、“16G”，“移动版”多个选项，而一个“金色”选项除了对应 iphone6 还可以对于 iphone4。我们继续画图： 需要注意的是，属性是对于一个分类的，这样设计的目的主要是为了属性能归类管理，也方便在添加产品时，通过分类对属性进行筛选。 例如，“手机”分类有颜色、版本、容量等属性，而“衬衫”分类有“颜色”、“尺寸”。这里有博友可能有疑问，如果属性和分类是一对多的关系，那么属性表将会出现一些冗余，比如“手机”、“衬衫”都有颜色属性，但是在属性表中就会两条颜色的记录甚至更多。这里其实可以设计为多对多的关系。 一对多的关系，可以在商品规模小、数据量不太大的电商上适应，这样的好处是，可以让产品发布者更好的管理属性选项和发布产品，因为即便是两个颜色的属性，但他们的属性选项确可以不同，对于“手机”来说，可能只有黑、白、金、银等颜色，但对于“衬衫”分类来说选项就可以有“红橙黄绿青蓝紫”甚至有“花格”。 所以可以考虑牺牲冗余来提高商家发布者的体验。接下来我们来看另外一个特性——“规格”： “规格”代表这一个 SKU 具体的各项参数，是一个详细的产品规格说明，用户可以通过这些参数与其他同类手机做对比。 这些参数中，部分参数将参与列表页的筛选条件中 我们可以注意到两幅图，有些规格并不能对应上。 这是因为我们在规格表中可以设置哪些规格显示在详细页中，哪些规格显示在列表筛选条件中。 最终的商品模型就是这样： 好了，这个电商商品模型的雏形就有了，但一个成熟的大型电商系统模型要比这个复杂的多，光是一个价格都会有一个单独的模块进行管理，比如市场价、进货价、成本价等，要进行成本核算，要与营销活动结合，双 11 折扣，或者与其他商品打包购买价格更便宜等。 总之，需要根据业务的需要进行一步一步的扩展和设计。以后有机会介绍下电商中订单模型。","categories":[{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://bawcat.wiki/tags/mysql/"},{"name":"sku","slug":"sku","permalink":"https://bawcat.wiki/tags/sku/"},{"name":"spu","slug":"spu","permalink":"https://bawcat.wiki/tags/spu/"},{"name":"数据库设计","slug":"数据库设计","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"}]},{"title":"基于 PHP 的数据爬取（QueryList）","slug":"php/php-querylist-2018-09-14","date":"2018-09-14T14:06:08.000Z","updated":"2023-07-24T09:52:35.545Z","comments":true,"path":"2018/09/14/php/php-querylist-2018-09-14/","link":"","permalink":"https://bawcat.wiki/2018/09/14/php/php-querylist-2018-09-14/","excerpt":"基于PHP的数据爬取官方网站站点 简单、 灵活、强大的PHP采集工具，让采集更简单一点。 简介： QueryList使用jQuery选择器来做采集，让你告别复杂的正则表达式；QueryList具有jQuery一样的DOM操作能力、Http网络操作能力、乱码解决能力、内容过滤能力以及可扩展能力；可以轻松实现诸如：模拟登陆、伪造浏览器、HTTP代理等意复杂的网络请求；拥有丰富的插件，支持多线程采集以及使用PhantomJS采集JavaScript动态渲染的页面。 安装 通过Composer安装: composer require jaeger/querylist 使用教程： 直接上代码： &lt;?php include &#39;./vendor/autoload.php&#39;; // 使用composer安装后引入目录 use QL\\QueryList; // 使用插件 $html = file_get_contents(&#39;https://www.biqudu.com/14_14778/&#39;); // 手动获取页面 $data = QueryList::html($html); // 得到页面内容 $data = QueryList::setHtml(&#39;https://www.biqudu.com/14_14778/&#39;); // 等同于上面的html() $data-&gt;rules([ // 采集所有a标签的href属性 &#39;link&#39; =&gt; [&#39;a&#39;,&#39;href&#39;], // 采集所有a标签的文本内容 &#39;text&#39; =&gt; [&#39;a&#39;,&#39;text&#39;] ]); // 此处$data = 上面已经获取到网页内容之后的对象 // 设置采集规则 替代了传统正则 $data-&gt;query(); // 此处$data = 上面已经获取到网页内容之后的对象 // query 执行操作 $data-&gt;getData(); // 此处$data = 上面已经获取到网页内容之后的对象 // 得到数据结果 $data-&gt;all(); // 此处$data = 上面已经获取到网页内容之后的对象 // 将数据转换成二维数组 print_r($data-&gt;all()); // 打印结果","text":"基于PHP的数据爬取官方网站站点 简单、 灵活、强大的PHP采集工具，让采集更简单一点。 简介： QueryList使用jQuery选择器来做采集，让你告别复杂的正则表达式；QueryList具有jQuery一样的DOM操作能力、Http网络操作能力、乱码解决能力、内容过滤能力以及可扩展能力；可以轻松实现诸如：模拟登陆、伪造浏览器、HTTP代理等意复杂的网络请求；拥有丰富的插件，支持多线程采集以及使用PhantomJS采集JavaScript动态渲染的页面。 安装 通过Composer安装: composer require jaeger/querylist 使用教程： 直接上代码： &lt;?php include &#39;./vendor/autoload.php&#39;; // 使用composer安装后引入目录 use QL\\QueryList; // 使用插件 $html = file_get_contents(&#39;https://www.biqudu.com/14_14778/&#39;); // 手动获取页面 $data = QueryList::html($html); // 得到页面内容 $data = QueryList::setHtml(&#39;https://www.biqudu.com/14_14778/&#39;); // 等同于上面的html() $data-&gt;rules([ // 采集所有a标签的href属性 &#39;link&#39; =&gt; [&#39;a&#39;,&#39;href&#39;], // 采集所有a标签的文本内容 &#39;text&#39; =&gt; [&#39;a&#39;,&#39;text&#39;] ]); // 此处$data = 上面已经获取到网页内容之后的对象 // 设置采集规则 替代了传统正则 $data-&gt;query(); // 此处$data = 上面已经获取到网页内容之后的对象 // query 执行操作 $data-&gt;getData(); // 此处$data = 上面已经获取到网页内容之后的对象 // 得到数据结果 $data-&gt;all(); // 此处$data = 上面已经获取到网页内容之后的对象 // 将数据转换成二维数组 print_r($data-&gt;all()); // 打印结果 上面的基本使用方法就是这样了 这样我们已经可以抓取到一定的数据了 如果你对爬取数据感兴趣 欢迎前往官网查看文档 超级传送门（点我）","categories":[{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"QueryList","slug":"PHP/QueryList","permalink":"https://bawcat.wiki/categories/PHP/QueryList/"}],"tags":[{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"querylist","slug":"querylist","permalink":"https://bawcat.wiki/tags/querylist/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bawcat.wiki/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据抓取","slug":"数据抓取","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}]}],"categories":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/categories/golang/"},{"name":"程序人生","slug":"程序人生","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"PHP","slug":"PHP","permalink":"https://bawcat.wiki/categories/PHP/"},{"name":"java","slug":"java","permalink":"https://bawcat.wiki/categories/java/"},{"name":"Swing","slug":"java/Swing","permalink":"https://bawcat.wiki/categories/java/Swing/"},{"name":"Spring","slug":"java/Spring","permalink":"https://bawcat.wiki/categories/java/Spring/"},{"name":"Pcntl","slug":"PHP/Pcntl","permalink":"https://bawcat.wiki/categories/PHP/Pcntl/"},{"name":"优秀文章","slug":"PHP/优秀文章","permalink":"https://bawcat.wiki/categories/PHP/%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0/"},{"name":"java 基础","slug":"java/java-基础","permalink":"https://bawcat.wiki/categories/java/java-%E5%9F%BA%E7%A1%80/"},{"name":"java 函数式编程","slug":"java/java-函数式编程","permalink":"https://bawcat.wiki/categories/java/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://bawcat.wiki/categories/Hadoop/"},{"name":"部署和管理","slug":"Hadoop/部署和管理","permalink":"https://bawcat.wiki/categories/Hadoop/%E9%83%A8%E7%BD%B2%E5%92%8C%E7%AE%A1%E7%90%86/"},{"name":"分享","slug":"程序人生/分享","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%88%86%E4%BA%AB/"},{"name":"Scala","slug":"Scala","permalink":"https://bawcat.wiki/categories/Scala/"},{"name":"基础开发","slug":"Scala/基础开发","permalink":"https://bawcat.wiki/categories/Scala/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"},{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/categories/redis/"},{"name":"java API","slug":"java/java-API","permalink":"https://bawcat.wiki/categories/java/java-API/"},{"name":"算法","slug":"算法","permalink":"https://bawcat.wiki/categories/%E7%AE%97%E6%B3%95/"},{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/categories/centos/"},{"name":"nginx","slug":"centos/nginx","permalink":"https://bawcat.wiki/categories/centos/nginx/"},{"name":"随笔","slug":"程序人生/随笔","permalink":"https://bawcat.wiki/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E9%9A%8F%E7%AC%94/"},{"name":"lumen","slug":"PHP/lumen","permalink":"https://bawcat.wiki/categories/PHP/lumen/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/categories/MYSQL/"},{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/categories/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"Nodejs","slug":"centos/Nodejs","permalink":"https://bawcat.wiki/categories/centos/Nodejs/"},{"name":"gcc","slug":"centos/gcc","permalink":"https://bawcat.wiki/categories/centos/gcc/"},{"name":"javascript","slug":"javascript","permalink":"https://bawcat.wiki/categories/javascript/"},{"name":"QueryList","slug":"PHP/QueryList","permalink":"https://bawcat.wiki/categories/PHP/QueryList/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://bawcat.wiki/tags/golang/"},{"name":"go","slug":"go","permalink":"https://bawcat.wiki/tags/go/"},{"name":"协程","slug":"协程","permalink":"https://bawcat.wiki/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"进程锁","slug":"进程锁","permalink":"https://bawcat.wiki/tags/%E8%BF%9B%E7%A8%8B%E9%94%81/"},{"name":"debug 方法","slug":"debug-方法","permalink":"https://bawcat.wiki/tags/debug-%E6%96%B9%E6%B3%95/"},{"name":"竞争调试","slug":"竞争调试","permalink":"https://bawcat.wiki/tags/%E7%AB%9E%E4%BA%89%E8%B0%83%E8%AF%95/"},{"name":"指针","slug":"指针","permalink":"https://bawcat.wiki/tags/%E6%8C%87%E9%92%88/"},{"name":"变量","slug":"变量","permalink":"https://bawcat.wiki/tags/%E5%8F%98%E9%87%8F/"},{"name":"gc","slug":"gc","permalink":"https://bawcat.wiki/tags/gc/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://bawcat.wiki/tags/ffmpeg/"},{"name":"php","slug":"php","permalink":"https://bawcat.wiki/tags/php/"},{"name":"php 安装","slug":"php-安装","permalink":"https://bawcat.wiki/tags/php-%E5%AE%89%E8%A3%85/"},{"name":"编译安装","slug":"编译安装","permalink":"https://bawcat.wiki/tags/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"},{"name":"错误排坑","slug":"错误排坑","permalink":"https://bawcat.wiki/tags/%E9%94%99%E8%AF%AF%E6%8E%92%E5%9D%91/"},{"name":"php 编译错误解决","slug":"php-编译错误解决","permalink":"https://bawcat.wiki/tags/php-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"},{"name":"java","slug":"java","permalink":"https://bawcat.wiki/tags/java/"},{"name":"Swing","slug":"Swing","permalink":"https://bawcat.wiki/tags/Swing/"},{"name":"Spring","slug":"Spring","permalink":"https://bawcat.wiki/tags/Spring/"},{"name":"事务管理","slug":"事务管理","permalink":"https://bawcat.wiki/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"JDBC","slug":"JDBC","permalink":"https://bawcat.wiki/tags/JDBC/"},{"name":"Templeate","slug":"Templeate","permalink":"https://bawcat.wiki/tags/Templeate/"},{"name":"IOC","slug":"IOC","permalink":"https://bawcat.wiki/tags/IOC/"},{"name":"AOP","slug":"AOP","permalink":"https://bawcat.wiki/tags/AOP/"},{"name":"pcntl","slug":"pcntl","permalink":"https://bawcat.wiki/tags/pcntl/"},{"name":"进程管理","slug":"进程管理","permalink":"https://bawcat.wiki/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"文件上传","slug":"文件上传","permalink":"https://bawcat.wiki/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"上传原理","slug":"上传原理","permalink":"https://bawcat.wiki/tags/%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"},{"name":"$_FILES","slug":"FILES","permalink":"https://bawcat.wiki/tags/FILES/"},{"name":"java File","slug":"java-File","permalink":"https://bawcat.wiki/tags/java-File/"},{"name":"java nio","slug":"java-nio","permalink":"https://bawcat.wiki/tags/java-nio/"},{"name":"java Files","slug":"java-Files","permalink":"https://bawcat.wiki/tags/java-Files/"},{"name":"java StandardCopyOption","slug":"java-StandardCopyOption","permalink":"https://bawcat.wiki/tags/java-StandardCopyOption/"},{"name":"java Paths","slug":"java-Paths","permalink":"https://bawcat.wiki/tags/java-Paths/"},{"name":"java 泛型和集合","slug":"java-泛型和集合","permalink":"https://bawcat.wiki/tags/java-%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/"},{"name":"java Throwable","slug":"java-Throwable","permalink":"https://bawcat.wiki/tags/java-Throwable/"},{"name":"hadoop","slug":"hadoop","permalink":"https://bawcat.wiki/tags/hadoop/"},{"name":"伪分布式","slug":"伪分布式","permalink":"https://bawcat.wiki/tags/%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"单机模式","slug":"单机模式","permalink":"https://bawcat.wiki/tags/%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F/"},{"name":"初始hadoop","slug":"初始hadoop","permalink":"https://bawcat.wiki/tags/%E5%88%9D%E5%A7%8Bhadoop/"},{"name":"vpn","slug":"vpn","permalink":"https://bawcat.wiki/tags/vpn/"},{"name":"SSR","slug":"SSR","permalink":"https://bawcat.wiki/tags/SSR/"},{"name":"vps","slug":"vps","permalink":"https://bawcat.wiki/tags/vps/"},{"name":"中文VPN脚本","slug":"中文VPN脚本","permalink":"https://bawcat.wiki/tags/%E4%B8%AD%E6%96%87VPN%E8%84%9A%E6%9C%AC/"},{"name":"scala","slug":"scala","permalink":"https://bawcat.wiki/tags/scala/"},{"name":"类和对象","slug":"类和对象","permalink":"https://bawcat.wiki/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"name":"基础数据类型","slug":"基础数据类型","permalink":"https://bawcat.wiki/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"redis","slug":"redis","permalink":"https://bawcat.wiki/tags/redis/"},{"name":"持久化机制","slug":"持久化机制","permalink":"https://bawcat.wiki/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"},{"name":"主从复制","slug":"主从复制","permalink":"https://bawcat.wiki/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"},{"name":"事务处理","slug":"事务处理","permalink":"https://bawcat.wiki/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"},{"name":"简介与安装","slug":"简介与安装","permalink":"https://bawcat.wiki/tags/%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"name":"虚拟内存的使用","slug":"虚拟内存的使用","permalink":"https://bawcat.wiki/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"java lang","slug":"java-lang","permalink":"https://bawcat.wiki/tags/java-lang/"},{"name":"java 日期","slug":"java-日期","permalink":"https://bawcat.wiki/tags/java-%E6%97%A5%E6%9C%9F/"},{"name":"java 随机数","slug":"java-随机数","permalink":"https://bawcat.wiki/tags/java-%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"java 集合框架","slug":"java-集合框架","permalink":"https://bawcat.wiki/tags/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"java IO","slug":"java-IO","permalink":"https://bawcat.wiki/tags/java-IO/"},{"name":"数据流","slug":"数据流","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E6%B5%81/"},{"name":"字符流","slug":"字符流","permalink":"https://bawcat.wiki/tags/%E5%AD%97%E7%AC%A6%E6%B5%81/"},{"name":"字节流","slug":"字节流","permalink":"https://bawcat.wiki/tags/%E5%AD%97%E8%8A%82%E6%B5%81/"},{"name":"java 函数式接口","slug":"java-函数式接口","permalink":"https://bawcat.wiki/tags/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"java Optional","slug":"java-Optional","permalink":"https://bawcat.wiki/tags/java-Optional/"},{"name":"java Streams","slug":"java-Streams","permalink":"https://bawcat.wiki/tags/java-Streams/"},{"name":"java Calendar","slug":"java-Calendar","permalink":"https://bawcat.wiki/tags/java-Calendar/"},{"name":"java Math","slug":"java-Math","permalink":"https://bawcat.wiki/tags/java-Math/"},{"name":"java Date","slug":"java-Date","permalink":"https://bawcat.wiki/tags/java-Date/"},{"name":"java Collections","slug":"java-Collections","permalink":"https://bawcat.wiki/tags/java-Collections/"},{"name":"java Lambad","slug":"java-Lambad","permalink":"https://bawcat.wiki/tags/java-Lambad/"},{"name":"java 正则","slug":"java-正则","permalink":"https://bawcat.wiki/tags/java-%E6%AD%A3%E5%88%99/"},{"name":"java regular","slug":"java-regular","permalink":"https://bawcat.wiki/tags/java-regular/"},{"name":"regular","slug":"regular","permalink":"https://bawcat.wiki/tags/regular/"},{"name":"java 反射","slug":"java-反射","permalink":"https://bawcat.wiki/tags/java-%E5%8F%8D%E5%B0%84/"},{"name":"java 设计模式","slug":"java-设计模式","permalink":"https://bawcat.wiki/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java 多线程","slug":"java-多线程","permalink":"https://bawcat.wiki/tags/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"java Socket","slug":"java-Socket","permalink":"https://bawcat.wiki/tags/java-Socket/"},{"name":"java Set","slug":"java-Set","permalink":"https://bawcat.wiki/tags/java-Set/"},{"name":"java HashSet","slug":"java-HashSet","permalink":"https://bawcat.wiki/tags/java-HashSet/"},{"name":"java Map","slug":"java-Map","permalink":"https://bawcat.wiki/tags/java-Map/"},{"name":"java JDBC","slug":"java-JDBC","permalink":"https://bawcat.wiki/tags/java-JDBC/"},{"name":"java System","slug":"java-System","permalink":"https://bawcat.wiki/tags/java-System/"},{"name":"java Random","slug":"java-Random","permalink":"https://bawcat.wiki/tags/java-Random/"},{"name":"算法","slug":"算法","permalink":"https://bawcat.wiki/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://bawcat.wiki/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"基础算法","slug":"基础算法","permalink":"https://bawcat.wiki/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"算法实例","slug":"算法实例","permalink":"https://bawcat.wiki/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B/"},{"name":"java Arrays","slug":"java-Arrays","permalink":"https://bawcat.wiki/tags/java-Arrays/"},{"name":"java StringBuilder","slug":"java-StringBuilder","permalink":"https://bawcat.wiki/tags/java-StringBuilder/"},{"name":"java ArrayList","slug":"java-ArrayList","permalink":"https://bawcat.wiki/tags/java-ArrayList/"},{"name":"nginx","slug":"nginx","permalink":"https://bawcat.wiki/tags/nginx/"},{"name":"config","slug":"config","permalink":"https://bawcat.wiki/tags/config/"},{"name":"centos","slug":"centos","permalink":"https://bawcat.wiki/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://bawcat.wiki/tags/linux/"},{"name":"lnmp","slug":"lnmp","permalink":"https://bawcat.wiki/tags/lnmp/"},{"name":"随笔","slug":"随笔","permalink":"https://bawcat.wiki/tags/%E9%9A%8F%E7%AC%94/"},{"name":"小记","slug":"小记","permalink":"https://bawcat.wiki/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"https://bawcat.wiki/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"设计模式","slug":"设计模式","permalink":"https://bawcat.wiki/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"laravel","slug":"laravel","permalink":"https://bawcat.wiki/tags/laravel/"},{"name":"dingo","slug":"dingo","permalink":"https://bawcat.wiki/tags/dingo/"},{"name":"lumen","slug":"lumen","permalink":"https://bawcat.wiki/tags/lumen/"},{"name":"api server","slug":"api-server","permalink":"https://bawcat.wiki/tags/api-server/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://bawcat.wiki/tags/MYSQL/"},{"name":"SQL","slug":"SQL","permalink":"https://bawcat.wiki/tags/SQL/"},{"name":"SELECT","slug":"SELECT","permalink":"https://bawcat.wiki/tags/SELECT/"},{"name":"服务架构","slug":"服务架构","permalink":"https://bawcat.wiki/tags/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"name":"架构师","slug":"架构师","permalink":"https://bawcat.wiki/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"},{"name":"容量设计","slug":"容量设计","permalink":"https://bawcat.wiki/tags/%E5%AE%B9%E9%87%8F%E8%AE%BE%E8%AE%A1/"},{"name":"CAS","slug":"CAS","permalink":"https://bawcat.wiki/tags/CAS/"},{"name":"CAS 算法","slug":"CAS-算法","permalink":"https://bawcat.wiki/tags/CAS-%E7%AE%97%E6%B3%95/"},{"name":"MYSQL 锁","slug":"MYSQL-锁","permalink":"https://bawcat.wiki/tags/MYSQL-%E9%94%81/"},{"name":"高可用服务","slug":"高可用服务","permalink":"https://bawcat.wiki/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%8D%E5%8A%A1/"},{"name":"分布式","slug":"分布式","permalink":"https://bawcat.wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nodejs","slug":"nodejs","permalink":"https://bawcat.wiki/tags/nodejs/"},{"name":"前端","slug":"前端","permalink":"https://bawcat.wiki/tags/%E5%89%8D%E7%AB%AF/"},{"name":"gcc","slug":"gcc","permalink":"https://bawcat.wiki/tags/gcc/"},{"name":"javascript","slug":"javascript","permalink":"https://bawcat.wiki/tags/javascript/"},{"name":"web","slug":"web","permalink":"https://bawcat.wiki/tags/web/"},{"name":"require","slug":"require","permalink":"https://bawcat.wiki/tags/require/"},{"name":"import","slug":"import","permalink":"https://bawcat.wiki/tags/import/"},{"name":"export","slug":"export","permalink":"https://bawcat.wiki/tags/export/"},{"name":"mysql","slug":"mysql","permalink":"https://bawcat.wiki/tags/mysql/"},{"name":"sku","slug":"sku","permalink":"https://bawcat.wiki/tags/sku/"},{"name":"spu","slug":"spu","permalink":"https://bawcat.wiki/tags/spu/"},{"name":"数据库设计","slug":"数据库设计","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"name":"querylist","slug":"querylist","permalink":"https://bawcat.wiki/tags/querylist/"},{"name":"爬虫","slug":"爬虫","permalink":"https://bawcat.wiki/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据抓取","slug":"数据抓取","permalink":"https://bawcat.wiki/tags/%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96/"}]}