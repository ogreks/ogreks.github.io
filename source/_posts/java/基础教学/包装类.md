---
title: Java.lang 包装类
date: 2020-01-03 12:00:00
categories:
 - java
 - java API
tags:
 - java
 - java lang
cover: https://s2.ax1x.com/2019/12/11/QsYkmn.png
---


## Java.lang 包装类

| 原始数据类型 | 包装类 |  
| ------ | ------- |  
| byte(字节) | Byte |  
| char(字符) | character |  
| int(整型) | Integer |  
| long(长整型) | Long |  
| float(浮点型) | Float |  
| double(双精度) | Double |  
| boolean(布尔型) | Boolean |  
| short(短整型) | Short |  

在这八个类名中，除了Integer和Character类以后，其他六个类的类名和基本数据类型一致，只是类名的第一个字母大写  

### Integer

java.lang 包中的 Integer 类、Long类和Short类都是Number类的子类，他们的区别在于不同子类里面封装着不同的数据类型，比如Integer类包装了一个基本类型int。其包含的方法基本相同。  

我们以 Integer 类为例。 Integer 构造方法有两种：  

1. Integer(int value) ，以 int 型变量作为参数创建 Integer 对象。例如 ***Integer a = new Integer(10);***
2. Integer(String s) ，以 String 型变量作为参数创建   ***Integer 对象，例如Integer a = new Integer("10")***

下面是Integer的常用方法  

| 方法 | 返回值 | 功能描述 |  
| ---- | ---- | ---- |  
| byteValue() | byte | 以byte类型返回该Integer的值 |  
| compareTo(Integer anotherInteger) | int | 在数字上比较Integer对象。如果这两个值相等，则返回0 如果调用对象的值小于anotherInteger的数值，则返回负值 如果调用对象的数值大于anotherInteger的数值，则返回正值 |  
| equals(Object IntegerObj) | boolean | 比较此对象与指定对象是否相等 |  
| intValue() | int | 以int型返回此Integer对象 |  
| shortValue() | short | 以short型返回此Integer对象 |  
| longValue() | long | 以long 型返回此Integer对象 |  
| floatValue() | float | 以float型返回此Integer对象 |  
| doubleValue() | double | 以double型返回此Integer对象 |  
| toString() | String | 返回一个表示该Integer值的String对象 |  
| valueOf(String str) | Integer | 返回保存指定的String值的Integer对象 |  
| parseInt(String str) | int | 将字符串参数作为有符号的十进制整数进行解析 |  

代码示例：  

```
public class IntegerTest {
    public static void main(String[] args){
        //初始化一个 Integer 类实例
        Integer a = new Integer("10");
        //初始化一个 Integer 类实例
        Integer b = new Integer(11);
        //判断两个数的大小
        System.out.println(a.compareTo(b));
        // 判断两个实例是否相等
        System.out.println(a.equals(b));
        //将 a 转换成 float 型数
        float c = a.floatValue();
        System.out.println(c);

        String d = "10101110";
        //将字符串转换为数值
        //parseInt(String str) 和 parseInt(String str,int radix) 都是类方法，由类来调用。后一个方法则实现将字符串按照参数 radix 指定的进制转换为 int，
        int e = Integer.parseInt(d, 2);
        System.out.println(e);
    }
}
```

### Character

Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。  

Character 常用方法  

| 方法 | 返回值 | 说明 |  
| ---- | ---- | ---- |  
| isDigit(char ch) | boolean | 确定字符是否为数字 |  
| isLetter(char ch) | boolean | 确定字符是否为字母 |  
| isLowerCase(char ch) | boolean | 确定字符是否为小写字母 |  
| isUpperCase(char ch) | boolean | 确定字符是否为大写字母 |  
| isWhitespace(char ch) | boolean | 确定字符是否为空白字符 |  
| isUnicodeIdentifierStart(char ch) | boolean | 确定是否运行将指定字符作为Unicode标识符中的首字符 |  

#### 示例方法

```
public class CharacterTest {
    public static void main(String[] args){
        int count;
        //定义了一个字符数组
        char[] values = {'*', '_', '%', '8', 'L', 'l'};
        //遍历字符数组
        for (count = 0; count < values.length; count++){
            if(Character.isDigit(values[count])){
                System.out.println(values[count]+"是一个数字");
            }
            if(Character.isLetter(values[count])){
                System.out.println(values[count]+ "是一个字母");
            }
            if(Character.isUpperCase(values[count])){
                System.out.println(values[count]+"是大写形式");
            }
            if(Character.isLowerCase(values[count])){
                System.out.println(values[count]+"是小写形式");
            }
            if(Character.isUnicodeIdentifierStart(values[count])){
                System.out.println(values[count]+"是 Unicode 标志符的第一个有效字符");
            }
        }
        //判断字符 c 是否是空白字符
        char c = ' ';
        System.out.println("字符 c 是空白字符吗？"+Character.isWhitespace(c));
    }
}
```

### Boolean

Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。  

Boolean 类的构造方法也有两个：  

1. Boolean(boolean value)，创建一个表示 value 参数的 Boolean 对象，如Boolean b = new Boolean(true)  

2. Boolean(String s)，如果 String 参数不为 null 且在忽略大小写时等于 "true", 创建一个表示 true 值的 Boolean 对象，如Boolean b = new Boolean("ok")，为 false。  

Boolean 常用方法  

| 方法 | 返回值 | 说明 |  
| --- | --- | --- |  
| booleanValue() | boolean | 将Boolean 对象的值以对应的boolean值返回 |  
| equals(Object obj) | boolean | 判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，而且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true |  
| parseBoolean(String s) | boolean | 将字符串参数解析为 boolean 值 |  
| toString() | String | 返回表示该 boolean 值的 String 对象 |  
| valueOf(String s) | Boolean | 返回一个用指定得字符串表示值的 boolean 值 |  

#### 示例代码

```
public class BooleanTest {
    public static void main(String[] args) {
        // Boolean(boolean value) 构造方法
        Boolean a = new Boolean(true);
        System.out.println("a 为"+a);
        // Boolean(String s) 构造方法
        Boolean b = new Boolean("true");
        Boolean c = new Boolean("OK");
        System.out.println("b 为"+b);
        System.out.println("c 为"+c);
        System.out.println("a 的 booleanValue() 为"+a.booleanValue());
        System.out.println("a 和 b 相等吗？"+a.equals(b));
    }
}
```

### String

我们经常使用 String 类来定义一个字符串。字符串是常量，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。  
String 对象的初始化格式有如下两种：  

```
String s0 = "abc";

String s1 = new String("abd");
```

String 类具有丰富的方法，比如计算字符串的长度、连接字符串、比较字符串、提取字符串等等。  

#### length()

计算字符串长度  

调用方法： ***字符串标识符。length();***  返回一个 int 类型的整数（字符串中字符数，中文字符也是一个字符）。例如：  

```
String s1 = "abc";
String s2 = "Java 语言";
int len1 = s1.length();
int len2 = s2.length();
```

则变量 len1 的值是 3，变量 len2 的值是 6。   

#### equals()

该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。  

equals() 方法比较是从第一字符开始，一个字符一个字符依次比较。  

那如果我想忽略掉大小写关系，比如：java 和 Java 是一样的，我们怎么办呢？我们可以调用equalsIgnoreCase()方法，其用法与 equals 一致，不过它会忽视大小写。  

比如：  

```
public class StringTest {
    public static void main(String[] args){
        String s = new String("Java");
        String m = "java";
        System.out.println("用 equals() 比较，java 和 Java 结果为"+s.equals(m));
        System.out.println("用 equalsIgnoreCase() 比较，java 和 Java 结果为"+s.equalsIgnoreCase(m));
    }
}
```

而使用"=="比较的是两个对象在内存中存储的地址是否一样。例如： String s1 = "abc"; String s2 = new String("abc"); boolean b = (s1 == s2); 则变量 b 的值是 false，因为 s1 对象对应的地址是"abc"的地址，而 s2 使用 new 关键字申请新的内存，所以内存地址和 s1 的"abc"的地址不一样，所以获得的值是 false。  

#### 字符串连接

字符串连接有两种方法：  

1. 使用 ***+*** 比如 String s = "Hello " + "World!";
2. 使用String类的 ***concat()***方法  

示例：  

```
String s0 = new String("Hello ");
String s1 = "World" + "!";   //+号连接
String s2 = s0.concat(s1); //concat() 方法连接
System.out.println(s2);
```

而且使用+进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。  

#### charAt()

charAt()方法的作用是按照索引值（规定字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推），获得字符串中的指定字符。  

例如：  

```
String s = "abc";
char c = s.charAt(1);
```

#### 字符串常用提取方法  

| 方法 | 返回值 | 功能描述 |  
| ---- | ---- | ---- |  
| indexOf(int ch) | int | 搜索字符 ch 第一次出现的索引 |  
| indexOf(String value) | int | 搜索字符串 value 第一次出现的索引 |  
| lastIndexOf(int ch) | int | 搜索字符 ch 最后一次出现的索引 |  
| lastIndexOf(String value) | int | 搜索字符串 value 最后一次出现的索引 |  
| substring(int index) | String | 提取从位置索引开始到结束的字符串 |  
| substring(int beginindex, int endindex) | String | 提取 beginindex 和 endindex 之间的字符串部分 |  
| trim() | String | 返回一个前后不含任何空格的调用字符串的副本 |  

说明：在字符串中，第一个字符的索引为 0，子字符串包含 beginindex 的字符，但不包含 endindex 的字符。  

示例代码：  

```
public class StringTest {
    public static void main(String[] args) {
         String s = "abcdefabc";
         System.out.println("字符 a 第一次出现的位置为"+s.indexOf('a'));
         System.out.println("字符串 bc 第一次出现的位置为"+s.indexOf("bc"));
         System.out.println("字符 a 最后一次出现的位置为"+s.lastIndexOf('a'));
         System.out.println("从位置 3 开始到结束的字符串"+s.substring(3));
         System.out.println("从位置 3 开始到 6 之间的字符串"+s.substring(3,6));
    }
}
```

#### StringBuffer

String 类的字符串创建后是不能够改变的。  

示例：  

```

String s = "Hello ";
s.concat("World!");   //字符串连接
System.out.println(s); //输出 s，还是"Hello "
s = s.concat("World!");  //把字符串对象连接的结果赋给了 s 引用
System.out.println(s);  //输出 s，变成了"Hello World!"

/*
上述三条语句其实产生了 3 个 String 对象，"Hello "，"World!"，"Hello World!"。第 2 条语句确实产生了"Hello World"字符串，但是没有指定把该字符串的引用赋给谁，因此没有改变 s 引用。第 3 条语句根据不变性，并没有改变"Hello "，JVM 创建了一个新的对象，把"Hello "，"World!"的连接赋给了 s 引用，因此引用变了，但是原对象没变。
*/
```

String 的不变性的机制显然会在 String 常量内有大量的冗余。比如我创建一个循环，使字符'1'依次连接到'n'，那么系统就得创建 n+(n-1) 个 String 对象。那有没有可变的 String 类呢？  

StringBuffer 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的，这里建议大家去看一看 String 类与 StringBuffer 类的区别，理解一下他们在内存中的存储情况）  

构造方法：  

| 构造方法 | 说明 |  
| ---- | ---- |  
| StringBuffer() | 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符 |  
| StringBuffer(CharSequence seq) | 构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符 |  
| StringBuffer(int capacity) | 构造一个不带字符，但具有指定初始容量的字符串缓冲区 |  
| StringBuffer(String str) | 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容 |

常用方法：  

| 方法 | 返回值 | 功能描述 |  
| ---- | ---- | ---- |  
| insert(int offsetm,Object s) | StringBuffer | 在 offsetm 的位置插入字符串 s |  
| append(Object s) | StringBuffer | 在字符串末尾追加字符串 s |  
| length() | int | 确定 StringBuffer 对象的长度 |  
| setCharAt(int pos,char ch) | void | 使用 ch 指定的新值设置 pos 指定的位置上的字符 |  
| toString() | String | 转换为字符串形式 |  
| reverse() | StringBuffer | 反转字符串 |  
| delete(int start, int end) | StringBuffer | 删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列 |  
| replace(int start, int end, String s) | StringBuffer | 使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束 |  

示例代码：  

```
public class StringTest {

    public static void main(String[] args){
        //定义和初始化一个 StringBuffer 类的字串 s
        StringBuffer s = new StringBuffer("I");
        //在 s 后面添加字串" java"
        s.append(" java");
        //在 s[1] 的位置插入字串
        s.insert(1, " love");
        String t = s.toString(); //转为字符串
        System.out.println(t);
    }
}
```

### Math  

我们在编程的过程中，经常对一些数字进行数学操作，比如我们想要求绝对值或余弦什么的。那这些方法是否需要我们自己实现吗？其实在 java.lang 里的 Math 类 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。我们就来学习一下吧！  

| 方法 | 返回值 | 功能描述 |  
| ---- | ---- | ---- |  
| sin(double numvalue) | double | 计算角 numvalue 的正弦值 |  
| cos(double numvalue) | double | 计算角 numvalue 的余弦值 |  
| acos(double numvalue) | double | 计算 numvalue 的反余弦 |  
| asin(double numvalue) | double | 计算 numvalue 的反正弦 |  
| atan(double numvalue) | double | 计算 numvalue 的反正切 |  
| pow(double a, double b) | double | 计算 a 的 b 次方 |  
| sqrt(double numvalue) | double | 计算给定值的正平方根 |  
| abs(int numvalue) | int | 计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数 |  
| ceil(double numvalue) | double | 返回大于等于 numvalue 的最小整数值 |  
| floor(double numvalue) | double | 返回小于等于 numvalue 的最大整数值 |  
| max(int a, int b) | int | 返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数 |  
| min(int a, int b) | int | 返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数 |  
| rint(double numvalue) | double | 返回最接近 numvalue 的整数值 |  
| round(T arg) | arg 为 double 时返回 long，为 float 时返回 int | 返回最接近 arg 的整数值 |  
| random() | double | 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0 |  

> 更多方法 请参照 官方api  

代码示例：  

```
public class MathTest {
    public static void main(String[] args) {
        System.out.println(Math.abs(-12.7));
        System.out.println(Math.ceil(12.7));
        System.out.println(Math.rint(12.4));
        System.out.println(Math.random());
        System.out.println("sin30 = " + Math.sin(Math.PI / 6));
        // 计算 30°的正弦值，参数是用弧度表示的角，即π的六分之一
        System.out.println("cos30 = " + Math.cos(Math.PI / 6));
        // 计算 30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为 double
        System.out.println("tan30 = " + Math.tan(Math.PI / 6));
        // 计算 30°的正切值
    }
}
```

也许你会觉得简单的计算很枯燥，但在合适的地方用到它们可以让你的程序（比如游戏中飞行轨迹的计算）更加精彩。  


#### 实战小项目-生成彩票号码

有了之前的基础，我们来做个更好玩的项目——彩票生成器。目前市面上彩票的种类很多，我们就以大乐透为例吧。大乐透的规则是：从 135 中随机选取 5 个不重复的数字，从 112 中随机选取 2 个不重复的数字，这些数字组成了一个七位数。如果你买的号码与摇出来的号码相同，那么你一夜之间可能就不会当程序员了。  

因为彩票号码是随机生成的，所以这个项目中我们也会带大家认识随机数的使用方法。首先请在先创建一个Lottery类。  

我们需要用到  

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
```

由于彩票号码的前半段和后半段的规则和个数略有不同，所以我们分别创建生成它们的方法。  

首先来创建生成前段号码的方法getHeadNumber()，该方法需要从 1 到 36 中随机选取一个数作为号码（即摇号的过程）。对于个位数，为了显示上更整齐，所以我们在其十位再放一个“0”。再者，为了结果更加易读，我们还需要调用Collections.sort()方法对结果进行排序。  

示例代码：  

```
public List<String> getHeadNumber() {
        List<String> list = new ArrayList<String>(); 
        // 创建彩票的前半段号码集合
        String lotteryNumber = "";
        for (int i = 1; i < 36; i++) { 
            // 这个循环是为了初始化彩票的前半段号码集合

            if (i < 10) {
                list.add("0" + i + "  ");
                // 在集合中添加 0~9 的号码，因为是个位数，为了显示上更加人性化，所以需要在十位的地方添加“0”
            } else {
                list.add("" + i + "  ");
                // 向集合添加大于 9 的号码，即添加双位数
            }
        }

        int roundIndex = 0;
        // 创建并初始化随机数

        List<String> lotteryList = new ArrayList<String>(); 
        // 保存前段号码的 List 集合

        for (int j = 0; j < 5; j++) {
            int amount = list.size(); // 获取前半段号码的个数
            Random r = new Random(); // 创建并实例化 Random 的对象
            roundIndex = r.nextInt(amount); // 获取一个 0 到 amount-1 的随机数
            lotteryNumber = list.get(roundIndex); // 获取彩票数字，即摇号的号码
            lotteryList.add(lotteryNumber); // 将彩票号码添加 lotteryList 中
            list.remove(roundIndex); // 移除刚刚产生的号码
        }
        Collections.sort(lotteryList); 
        // 对前半段号码进行排序，排序的目的是为了让结果更具可读性
        return lotteryList;
        //返回前半段号码
    }
```

此处用到了Random()方法，在创建一个 Random 对象r后，你可以调用该对象的nextInt()方法得到一个随机数。r.nextInt(amount);中的 amount 是随机数的上限，产生的随机数为 0 到 100（不含 100）的整数。 你可以 [了解更多 Random 的用法](http://www.cnblogs.com/ningvsban/p/3590722.html)。  

和前半段号码类似，我们接着来写生成后半段号码的方法getRearNum()，代码片段如下：  

示例代码：  
```
public List<String> getRearNumber() {
        List<String> list = new ArrayList<String>(); 
        // 创建后半段号码集合，也就是最后两个球的数字

        String lotteryNumber = "";
        for (int i = 1; i < 13; i++) { 
            // 初始化后半段号码集合

            if (i < 10) {
                list.add("0" + i + "  ");
                // 添加 0~9 的号码，原理同前半段
            } else {
                list.add("" + i + "  ");
                // 添加大于 9 的号码
            }
        }
        int roundIndex = 0;
        //创建并初始化随机数

        List<String> lotteryList = new ArrayList<String>(); 
        // 保存后半段号码的 List 集合

        for (int j = 0; j < 2; j++) {
            int amount = list.size(); // 获取后半段号码的个数
            Random r = new Random(); // 创建并实例化 Random 的对象
            roundIndex = r.nextInt(amount); // 获取一个 0 到 amount-1 的随机数
            lotteryNumber = list.get(roundIndex); // 摇号
            lotteryList.add(lotteryNumber); // 将彩票号码添加 lotteryList 中
            list.remove(roundIndex); // 移除刚刚产生的号码
        }

        Collections.sort(lotteryList); 
        // 对后半段号码进行排序
        return lotteryList;
    }
```

现在，根据规则我们已经能够产生对应的数字了。再接再厉，我们再做一个生成最终结果的方法，把这两个号段组装成整体的号码，并且按照用户的要求产生多少组号码，在控制台输出它们。  

下面给出了这个方法的代码片段：  

```
public void generateLottery(String groupNum) {

        int groupNumber = 0;
        //为了避免不必要的错误，一般在创建变量时都要为其赋初始值

        groupNumber = Integer.parseInt(groupNum);
        StringBuilder sbuiler = new StringBuilder();
        // 创建字符串生成器对象，使用字符串生成器能够较为方便地在字符串中追加内容

        for (int i = 0; i < groupNumber; i++) {
            List<String> startList = getHeadNumber();
            // 获得彩票前半段号码的集合

            List<String> endList = getRearNumber();
            // 获得彩票后半段号码的集合

            for (int m = 0; m < startList.size(); m++) {
                sbuiler.append(startList.get(m));
                // append() 即为追加方法，用于添加彩票的前半段号码到字符串生成器中
            }
            sbuiler.append("    ");
            for (int n = 0; n < endList.size(); n++) {
                sbuiler.append(endList.get(n));
                // 添加彩票的后半段号码到字符串生成器中
            }
            sbuiler.append("\n");
        }

        System.out.println(sbuiler.toString());
        //将每组生成好的彩票号码即时输出
    }
```

为了验证我们的实现无误，在同一个目录中创建一个名为LotteryTest的测试类，编写其main()方法。在其中创建一个彩票对象并调用其产生号码的方法。  

```
import java.util.Scanner;

public class LotteryTest {

    public static void main(String[] args) {

        Lottery l = new Lottery();
        Scanner scan = new Scanner(System.in);// 创建扫描器
        System.out.println("Please input the number of lottery group(s) that you want to generate : ");
        // 获得用户输入的需要生成的中奖号码个数

        String groupNum = scan.nextLine();
        l.generateLottery(groupNum);

    }

}
```

检查一下代码，编译并运行  

### Class

Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即每一个类，在生成的.class文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。我们获取 Class 实例有三种方法：  

1. 利用对象调用 getClass()方法获取该对象的 Class 实例

2. 使用 Class 类的静态方法 forName(String className)，用类的名字获取一个 Class 实例  

3. 运用.class的方式来获取 Class 实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例  

关于Class 示例代码:  
```
public class ClassDemo{
    /**
     *
     */
    public static void main(String[] args) throws ClassNotFoundException {
        String objString = new String();
        @SuppressWarnings("rawtypes")
        Class objClass;
        objClass = objString.getClass();
        System.out.println("String 对象的类型是:"+objClass.getName());
        objClass = Integer.class;
        System.out.println("Integer 对象的类型是:" + objClass.getName());
        objClass = Class.forName("java.lang.String");
        System.out.println("Character 对象的类型是:"+ objClass.getName());
        objClass = objClass.getSuperclass();
        System.out.println("Character 对象的父类是:"+ objClass.getName());

    }
}
```

Class 类没有共有的构造方法,它由JVM自动调用.Class类的方法在这里就不细讲了，有兴趣的可以自己查询一下.  

> [官方详解](http://blog.csdn.net/u010858605/article/details/53454830)

### Object

Object 类是所有类的父类,所有对象（包括数组）都实现这个类的方法。所以在默认的情况下，我们定义的类扩展自Object类，那我们当然可以调用和重写Object类里面的所有方法.  

Object 定义方法 :  

| 方法 | 返回值 | 功能描述 |  
| --- | --- | --- |  
| equals(Objectobj) | boolean | 将当前对象实例与给定的对象进行比较，检查它们是否相等 |  
| finalize() throws Throwable | void | 当垃圾回收期确定不存在对象的更多引用时，由对象的垃圾回收期调用此方法. 通常被子类重写 |  
| getClass() | Class | 返回当前对象的Class对象 |  
| toString() | String | 返回此对象的字符创标识 |  
| wait() throws InterruptedException | void | 在其他线程调用此对象的notify() 方法或 notifyAll() 方法前，使当前线程进入等待状态 |  

