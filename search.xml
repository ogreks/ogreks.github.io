<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FFmpeg Tutorial</title>
      <link href="2020/11/29/ffmpeg-2020-11-29-FFmpeg-Tutorial/"/>
      <url>2020/11/29/ffmpeg-2020-11-29-FFmpeg-Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg-Tutorial"><a href="#FFmpeg-Tutorial" class="headerlink" title="FFmpeg_Tutorial"></a>FFmpeg_Tutorial</h1><p><strong>FFmpeg工具和sdk库的使用demo</strong><br>github link (<a href="https://github.com/MagicConch17/FFmpeg_Tutorial)[https://github.com/MagicConch17/FFmpeg_Tutorial]">https://github.com/MagicConch17/FFmpeg_Tutorial)[https://github.com/MagicConch17/FFmpeg_Tutorial]</a></p><hr><h2 id="一、使用FFmpeg命令行工具和批处理脚本进行简单的音视频文件编辑"><a href="#一、使用FFmpeg命令行工具和批处理脚本进行简单的音视频文件编辑" class="headerlink" title="一、使用FFmpeg命令行工具和批处理脚本进行简单的音视频文件编辑"></a>一、使用FFmpeg命令行工具和批处理脚本进行简单的音视频文件编辑</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p>对于每一个从事音视频技术开发的工程师，想必没有一个人对FFmpeg这个名称感到陌生。FFmpeg是一套非常知名的音视频处理的开源工具，它包含了开发完成的工具软件、封装好的函数库以及源代码供我们按需使用。FFmpeg提供了非常强大的功能，可以完成音视频的编码、解码、转码、视频采集、后处理（抓图、水印、封装/解封装、格式转换等），还有流媒体服务等诸多功能，可以说涵盖了音视频开发中绝大多数的领域。原生的FFmpeg是在Linux环境下开发的，但是通过各种方法（比如交叉编译等）可以使它运行在多种平台环境上，具有比较好的可移植性。</p><p>FFmpeg项目的官方网址为：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a>。在它的官网上我们可以找到许多非常有用的内容，如项目的简介、版本更新日志、库和源代码的地址、使用文档等信息。官方的使用文档是我们在开发时必不可少的信息来源，其重要性不言而喻。除了官方网站以外，我们下载的FFmpeg的程序包中也有使用参考文档的离线版本。</p><h3 id="2、FFmpeg组成"><a href="#2、FFmpeg组成" class="headerlink" title="2、FFmpeg组成"></a>2、FFmpeg组成</h3><p>构成FFmpeg主要有三个部分，第一部分是四个作用不同的工具软件，分别是：ffmpeg.exe，ffplay.exe，ffserver.exe和ffprobe.exe。</p><ul><li>ffmpeg.exe：音视频转码、转换器</li><li>ffplay.exe：简单的音视频播放器</li><li>ffserver.exe：流媒体服务器</li><li>ffprobe.exe：简单的多媒体码流分析器</li></ul><p>第二部分是可以供开发者使用的SDK，为各个不同平台编译完成的库。如果说上面的四个工具软件都是完整成品形式的玩具，那么这些库就相当于乐高积木一样，我们可以根据自己的需求使用这些库开发自己的应用程序。这些库有：</p><ul><li>libavcodec：包含音视频编码器和解码器</li><li>libavutil：包含多媒体应用常用的简化编程的工具，如随机数生成器、数据结构、数学函数等功能</li><li>libavformat：包含多种多媒体容器格式的封装、解封装工具</li><li>libavfilter：包含多媒体处理常用的滤镜功能</li><li>libavdevice：用于音视频数据采集和渲染等功能的设备相关</li><li>libswscale：用于图像缩放和色彩空间和像素格式转换功能</li><li>libswresample：用于音频重采样和格式转换等功能</li></ul><p>第三部分是整个工程的源代码，无论是编译出来的可执行程序还是SDK，都是由这些源代码编译出来的。FFmpeg的源代码由C语言实现，主要在Linux平台上进行开发。FFmpeg不是一个孤立的工程，它还存在多个依赖的第三方工程来增强它自身的功能。在当前这一系列的博文/视频中，我们暂时不会涉及太多源代码相关的内容，主要以FFmpeg的工具和SDK的调用为主。到下一系列我们将专门研究如何编译源代码并根据源代码来进行二次开发。</p><h3 id="3、FFMpeg工具的下载和使用"><a href="#3、FFMpeg工具的下载和使用" class="headerlink" title="3、FFMpeg工具的下载和使用"></a>3、FFMpeg工具的下载和使用</h3><h4 id="1-FFmpeg工具的下载："><a href="#1-FFmpeg工具的下载：" class="headerlink" title="(1)FFmpeg工具的下载："></a>(1)FFmpeg工具的下载：</h4><p>在官网上我们可以找到”Download”页面，该页上可以下载FFmpeg的工具、库和源代码等。在选择”Windows Packages”下的Windows Builds后，会跳转到Windows版本的下载页面：</p><p>在下载页面上，我们可以看到，对于32位和64位版本，分别提供了三种不同的模式：static、shared和dev</p><ul><li><strong>static</strong>: 该版本提供了静态版本的FFmpeg工具，将依赖的库生成在了最终的可执行文件中；作为工具而言此版本就可以满足我们的需求；</li><li><strong>share</strong>: 该版本的工具包括可执行文件和dll，程序运行过程必须依赖于提供的dll文件； </li><li><strong>dev</strong>: 提供了库的头文件和dll的引导库；</li></ul><h4 id="2-ffplay-exe的使用"><a href="#2-ffplay-exe的使用" class="headerlink" title="(2)ffplay.exe的使用"></a>(2)ffplay.exe的使用</h4><p>ffplay是一个极为简单的音视频媒体播放器。ffplay.exe使用了ffmpeg库和SDL库开发成的，可以用作FFmpeg API的测试工具。<br>ffplay的使用方法，最简单的是直接按照默认格式播放某一个音视频文件或流：</p><pre><code>ffplay.exe  -i ../video/IMG_0886.MOV</code></pre><p>除此之外，ffplay还支持传入各种参数来控制播放行为。比较常用的参数有：</p><ul><li>-i input_file：输入文件名</li><li>-x width -y height：控制播放窗口的宽高</li><li>-t duration：控制播放的时长</li><li>-window_title title：播放窗口的标题，默认为输入文件名</li><li>-showmode mode：设置显示模式，0:显示视频;1:显示音频波形；2：显示音频频谱</li><li>-autoexit：设置视频播放完成后自动退出</li></ul><p>其他参数可以参考官网的文档：<a href="https://www.ffmpeg.org/ffplay.html">https://www.ffmpeg.org/ffplay.html</a>或下载包里的文档</p><h4 id="3-ffprobe的使用"><a href="#3-ffprobe的使用" class="headerlink" title="(3)ffprobe的使用"></a>(3)ffprobe的使用</h4><p>ffprobe可以提供简单的音视频文件分析功能。最简单的方法同ffplay类似：</p><pre><code>ffprobe.exe  -i ../video/IMG_0886.MOV</code></pre><p>分析完成后，ffprobe会显示音视频文件中包含的每个码流的信息，包括编码格式、像素分辨率、码率、帧率等信息：</p><p><img src= "/img/loading.gif" data-lazy-src="http://cl.ly/2h2l1g1U1m1F/QQ%E6%88%AA%E5%9B%BE20160331231357.png" alt="ffprobe"></p><h4 id="4-ffmpeg的使用"><a href="#4-ffmpeg的使用" class="headerlink" title="(4)ffmpeg的使用"></a>(4)ffmpeg的使用</h4><p>ffmpeg.exe可谓是整个工程的核心所在，它的主要功能是完成音视频各种各样的转换操作。<br>视频转码：ffmpeg.exe可以将视频文件由原格式转换为其他格式，如从avi转为mp4等：</p><pre><code>ffmpeg -i ../video/IMG_0886.MOV ../video/output_mpeg4_mp3.avi </code></pre><p>这里，ffmpeg默认将视频编码格式选择为mpeg4，音频转码格式为mp3。如果我们希望保留原始编码，需要增加参数-c copy，表明不做任何转码操作：</p><pre><code>ffmpeg -i ../video/IMG_0886.MOV -c copy ../video/output_copy.avi</code></pre><p>如果我们希望将视频转换为其他编码格式，则需要在参数中指定目标格式-c:v libx265或-vcodec libx265。ffmpeg支持的所有编码器格式可以通过以下命令查看：</p><pre><code>ffmpeg.exe -encoders</code></pre><p>实际操作：</p><pre><code>ffmpeg -i ../video/IMG_0886.MOV -c:v mjpeg  ../video/output_mjpeg.avi</code></pre><p>视频解封装：ffmpeg可以将视频中的音频和视频流分别提取出来。需要在命令行中添加参数-an和-vn，分别表示屏蔽音频和视频流：</p><pre><code>@REM 提取视频流ffmpeg -i ../video/IMG_0886.MOV -c:v copy -an ../video/IMG_0886_v.MOV@REM 提取音频流ffmpeg -i ../video/IMG_0886.MOV -c:a copy -vn ../video/IMG_0886_a.aac</code></pre><p>视频截取：使用ffmpeg命令并指定参数-ss和-t，分别表示截取开始时刻和截取时长</p><pre><code>@REM 视频截取ffmpeg -ss 5 -t 5 -i ../video/IMG_0886.MOV -c copy ../video/IMG_0886_cut.MOV</code></pre><hr><h2 id="二、调用FFmpeg-SDK对YUV视频序列进行编码"><a href="#二、调用FFmpeg-SDK对YUV视频序列进行编码" class="headerlink" title="二、调用FFmpeg SDK对YUV视频序列进行编码"></a>二、调用FFmpeg SDK对YUV视频序列进行编码</h2><p>视频由像素格式编码为码流格式是FFMpeg的一项基本功能。通常，视频编码器的输入视频通常为原始的图像像素值，输出格式为符合某种格式规定的二进制码流。</p><h3 id="1、FFMpeg进行视频编码所需要的结构："><a href="#1、FFMpeg进行视频编码所需要的结构：" class="headerlink" title="1、FFMpeg进行视频编码所需要的结构："></a>1、FFMpeg进行视频编码所需要的结构：</h3><ul><li><strong>AVCodec</strong>：AVCodec结构保存了一个编解码器的实例，实现实际的编码功能。通常我们在程序中定义一个指向AVCodec结构的指针指向该实例。</li><li><strong>AVCodecContext</strong>：AVCodecContext表示AVCodec所代表的上下文信息，保存了AVCodec所需要的一些参数。对于实现编码功能，我们可以在这个结构中设置我们指定的编码参数。通常也是定义一个指针指向AVCodecContext。</li><li><strong>AVFrame</strong>：AVFrame结构保存编码之前的像素数据，并作为编码器的输入数据。其在程序中也是一个指针的形式。</li><li><strong>AVPacket</strong>：AVPacket表示码流包结构，包含编码之后的码流数据。该结构可以不定义指针，以一个对象的形式定义。</li></ul><p>在我们的程序中，我们将这些结构整合在了一个结构体中：</p><pre><code>/*************************************************Struct:            CodecCtxDescription:    FFMpeg编解码器上下文*************************************************/typedef struct&#123;    AVCodec            *codec;        //指向编解码器实例    AVFrame            *frame;        //保存解码之后/编码之前的像素数据    AVCodecContext    *c;            //编解码器上下文，保存编解码器的一些参数设置    AVPacket        pkt;        //码流包结构，包含编码码流数据&#125; CodecCtx;</code></pre><h3 id="2、FFMpeg编码的主要步骤："><a href="#2、FFMpeg编码的主要步骤：" class="headerlink" title="2、FFMpeg编码的主要步骤："></a>2、FFMpeg编码的主要步骤：</h3><h4 id="1-、输入编码参数"><a href="#1-、输入编码参数" class="headerlink" title="(1)、输入编码参数"></a>(1)、输入编码参数</h4><p>这一步我们可以设置一个专门的配置文件，并将参数按照某个事写入这个配置文件中，再在程序中解析这个配置文件获得编码的参数。如果参数不多的话，我们可以直接使用命令行将编码参数传入即可。</p><h4 id="2-、按照要求初始化需要的FFMpeg结构"><a href="#2-、按照要求初始化需要的FFMpeg结构" class="headerlink" title="(2)、按照要求初始化需要的FFMpeg结构"></a>(2)、按照要求初始化需要的FFMpeg结构</h4><p>首先，所有涉及到编解码的的功能，都必须要注册音视频编解码器之后才能使用。注册编解码调用下面的函数：</p><pre><code>avcodec_register_all();</code></pre><p>编解码器注册完成之后，根据指定的CODEC_ID查找指定的codec实例。CODEC_ID通常指定了编解码器的格式，在这里我们使用当前应用最为广泛的H.264格式为例。查找codec调用的函数为avcodec_find_encoder，其声明格式为：</p><pre><code>AVCodec *avcodec_find_encoder(enum AVCodecID id);</code></pre><p>该函数的输入参数为一个AVCodecID的枚举类型，返回值为一个指向AVCodec结构的指针，用于接收找到的编解码器实例。如果没有找到，那么该函数会返回一个空指针。调用方法如下：</p><pre><code>/* find the mpeg1 video encoder */ctx.codec = avcodec_find_encoder(AV_CODEC_ID_H264);    //根据CODEC_ID查找编解码器对象实例的指针if (!ctx.codec) &#123;    fprintf(stderr, &quot;Codec not found\n&quot;);    return false;&#125;</code></pre><p>AVCodec查找成功后，下一步是分配AVCodecContext实例。分配AVCodecContext实例需要我们前面查找到的AVCodec作为参数，调用的是avcodec_alloc_context3函数。其声明方式为：</p><pre><code>AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);</code></pre><p>其特点同avcodec_find_encoder类似，返回一个指向AVCodecContext实例的指针。如果分配失败，会返回一个空指针。调用方式为：</p><pre><code>ctx.c = avcodec_alloc_context3(ctx.codec);            //分配AVCodecContext实例if (!ctx.c)&#123;    fprintf(stderr, &quot;Could not allocate video codec context\n&quot;);    return false;&#125;</code></pre><p>需注意，在分配成功之后，应将编码的参数设置赋值给AVCodecContext的成员。</p><p>现在，AVCodec、AVCodecContext的指针都已经分配好，然后以这两个对象的指针作为参数打开编码器对象。调用的函数为avcodec_open2，声明方式为：</p><pre><code>int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);</code></pre><p>该函数的前两个参数是我们刚刚建立的两个对象，第三个参数为一个字典类型对象，用于保存函数执行过程总未能识别的AVCodecContext和另外一些私有设置选项。函数的返回值表示编码器是否打开成功，若成功返回0，失败返回一个负数。调用方式为：</p><pre><code>if (avcodec_open2(ctx.c, ctx.codec, NULL) &lt; 0)        //根据编码器上下文打开编码器&#123;    fprintf(stderr, &quot;Could not open codec\n&quot;);    exit(1);&#125;</code></pre><p>然后，我们需要处理AVFrame对象。AVFrame表示视频原始像素数据的一个容器，处理该类型数据需要两个步骤，其一是分配AVFrame对象，其二是分配实际的像素数据的存储空间。分配对象空间类似于new操作符一样，只是需要调用函数av_frame_alloc。如果失败，那么函数返回一个空指针。AVFrame对象分配成功后，需要设置图像的分辨率和像素格式等。实际调用过程如下：</p><pre><code>ctx.frame = av_frame_alloc();                        //分配AVFrame对象if (!ctx.frame) &#123;    fprintf(stderr, &quot;Could not allocate video frame\n&quot;);    return false;&#125;ctx.frame-&gt;format = ctx.c-&gt;pix_fmt;ctx.frame-&gt;width = ctx.c-&gt;width;ctx.frame-&gt;height = ctx.c-&gt;height;</code></pre><p>分配像素的存储空间需要调用av_image_alloc函数，其声明方式为：</p><pre><code>int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align);</code></pre><p>该函数的四个参数分别表示AVFrame结构中的缓存指针、各个颜色分量的宽度、图像分辨率（宽、高）、像素格式和内存对其的大小。该函数会返回分配的内存的大小，如果失败则返回一个负值。具体调用方式如：</p><pre><code>ret = av_image_alloc(ctx.frame-&gt;data, ctx.frame-&gt;linesize, ctx.c-&gt;width, ctx.c-&gt;height, ctx.c-&gt;pix_fmt, 32);if (ret &lt; 0) &#123;    fprintf(stderr, &quot;Could not allocate raw picture buffer\n&quot;);    return false;&#125;</code></pre><h4 id="3-、编码循环体"><a href="#3-、编码循环体" class="headerlink" title="(3)、编码循环体"></a>(3)、编码循环体</h4><p>到此为止，我们的准备工作已经大致完成，下面开始执行实际编码的循环过程。用伪代码大致表示编码的流程为：</p><pre><code>while (numCoded &lt; maxNumToCode)&#123;    read_yuv_data();    encode_video_frame();    write_out_h264();&#125;</code></pre><p>其中，read_yuv_data部分直接使用fread语句读取即可，只需要知道的是，三个颜色分量Y/U/V的地址分别为AVframe::data[0]、AVframe::data[1]和AVframe::data[2]，图像的宽度分别为AVframe::linesize[0]、AVframe::linesize[1]和AVframe::linesize[2]。需要注意的是，linesize中的值通常指的是stride而不是width，也就是说，像素保存区可能是带有一定宽度的无效边区的，在读取数据时需注意。</p><p>编码前另外需要完成的操作时初始化AVPacket对象。该对象保存了编码之后的码流数据。对其进行初始化的操作非常简单，只需要调用av_init_packet并传入AVPacket对象的指针。随后将AVPacket::data设为NULL，AVPacket::size赋值0.</p><p>成功将原始的YUV像素值保存到了AVframe结构中之后，便可以调用avcodec_encode_video2函数进行实际的编码操作。该函数可谓是整个工程的核心所在，其声明方式为：</p><pre><code>int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr);</code></pre><p>其参数和返回值的意义：</p><ul><li>avctx: AVCodecContext结构，指定了编码的一些参数；</li><li>avpkt: AVPacket对象的指针，用于保存输出码流；</li><li>frame：AVframe结构，用于传入原始的像素数据；</li><li>got_packet_ptr：输出参数，用于标识AVPacket中是否已经有了完整的一帧；</li><li>返回值：编码是否成功。成功返回0，失败则返回负的错误码</li></ul><p>通过输出参数*got_packet_ptr，我们可以判断是否应有一帧完整的码流数据包输出，如果是，那么可以将AVpacket中的码流数据输出出来，其地址为AVPacket::data，大小为AVPacket::size。具体调用方式如下：</p><pre><code>/* encode the image */ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), ctx.frame, &amp;got_output);    //将AVFrame中的像素信息编码为AVPacket中的码流if (ret &lt; 0) &#123;    fprintf(stderr, &quot;Error encoding frame\n&quot;);    exit(1);&#125;if (got_output) &#123;    //获得一个完整的编码帧    printf(&quot;Write frame %3d (size=%5d)\n&quot;, frameIdx, ctx.pkt.size);    fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout);    av_packet_unref(&amp;(ctx.pkt));&#125;</code></pre><p>因此，一个完整的编码循环提就可以使用下面的代码实现：</p><pre><code>/* encode 1 second of video */for (frameIdx = 0; frameIdx &lt; io_param.nTotalFrames; frameIdx++)&#123;    av_init_packet(&amp;(ctx.pkt));                //初始化AVPacket实例    ctx.pkt.data = NULL;                    // packet data will be allocated by the encoder    ctx.pkt.size = 0;    fflush(stdout);                Read_yuv_data(ctx, io_param, 0);        //Y分量    Read_yuv_data(ctx, io_param, 1);        //U分量    Read_yuv_data(ctx, io_param, 2);        //V分量    ctx.frame-&gt;pts = frameIdx;    /* encode the image */    ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), ctx.frame, &amp;got_output);    //将AVFrame中的像素信息编码为AVPacket中的码流    if (ret &lt; 0)     &#123;        fprintf(stderr, &quot;Error encoding frame\n&quot;);        exit(1);    &#125;    if (got_output)     &#123;        //获得一个完整的编码帧        printf(&quot;Write frame %3d (size=%5d)\n&quot;, frameIdx, ctx.pkt.size);        fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout);        av_packet_unref(&amp;(ctx.pkt));    &#125;&#125; //for (frameIdx = 0; frameIdx &lt; io_param.nTotalFrames; frameIdx++)</code></pre><h4 id="4-、收尾处理"><a href="#4-、收尾处理" class="headerlink" title="(4)、收尾处理"></a>(4)、收尾处理</h4><p>如果我们就此结束编码器的整个运行过程，我们会发现，编码完成之后的码流对比原来的数据少了一帧。这是因为我们是根据读取原始像素数据结束来判断循环结束的，这样最后一帧还保留在编码器中尚未输出。所以在关闭整个解码过程之前，我们必须继续执行编码的操作，直到将最后一帧输出为止。执行这项操作依然调用avcodec_encode_video2函数，只是表示AVFrame的参数设为NULL即可：</p><pre><code>/* get the delayed frames */for (got_output = 1; got_output; frameIdx++) &#123;    fflush(stdout);    ret = avcodec_encode_video2(ctx.c, &amp;(ctx.pkt), NULL, &amp;got_output);        //输出编码器中剩余的码流    if (ret &lt; 0)    &#123;        fprintf(stderr, &quot;Error encoding frame\n&quot;);        exit(1);    &#125;    if (got_output)     &#123;        printf(&quot;Write frame %3d (size=%5d)\n&quot;, frameIdx, ctx.pkt.size);        fwrite(ctx.pkt.data, 1, ctx.pkt.size, io_param.pFout);        av_packet_unref(&amp;(ctx.pkt));    &#125;&#125; //for (got_output = 1; got_output; frameIdx++) </code></pre><p>此后，我们就可以按计划关闭编码器的各个组件，结束整个编码的流程。编码器组件的释放流程可类比建立流程，需要关闭AVCocec、释放AVCodecContext、释放AVFrame中的图像缓存和对象本身：</p><pre><code>avcodec_close(ctx.c);av_free(ctx.c);av_freep(&amp;(ctx.frame-&gt;data[0]));av_frame_free(&amp;(ctx.frame));</code></pre><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>使用FFMpeg进行视频编码的主要流程如：</p><ol><li>首先解析、处理输入参数，如编码器的参数、图像的参数、输入输出文件；</li><li>建立整个FFMpeg编码器的各种组件工具，顺序依次为：avcodec_register_all -&gt; avcodec_find_encoder -&gt; avcodec_alloc_context3 -&gt;  avcodec_open2 -&gt; av_frame_alloc -&gt;  av_image_alloc;</li><li>编码循环：av_init_packet -&gt; avcodec_encode_video2(两次) -&gt; av_packet_unref</li><li>关闭编码器组件：avcodec_close，av_free，av_freep，av_frame_free</li></ol><hr><h2 id="三、调用FFmpeg-SDK对H-264格式的视频压缩码流进行解码"><a href="#三、调用FFmpeg-SDK对H-264格式的视频压缩码流进行解码" class="headerlink" title="三、调用FFmpeg SDK对H.264格式的视频压缩码流进行解码"></a>三、调用FFmpeg SDK对H.264格式的视频压缩码流进行解码</h2><p>经过了上篇调用FFMpeg SDK对视频进行编码的过程之后，我们可以比较容易地理解本篇的内容，即上一篇的逆过程——将H.264格式的裸码流解码为像素格式的图像信息。</p><h3 id="1、FFMpeg视频解码器所包含的结构"><a href="#1、FFMpeg视频解码器所包含的结构" class="headerlink" title="1、FFMpeg视频解码器所包含的结构"></a>1、FFMpeg视频解码器所包含的结构</h3><p>同FFMpeg编码器类似，FFMpeg解码器也需要编码时的各种结构，除此之外，解码器还需要另一个结构——编解码解析器——用于从码流中截取出一帧完整的码流数据单元。因此我们定义一个编解码上下文结构为：</p><pre><code>/*************************************************Struct:            CodecCtxDescription:    FFMpeg编解码器上下文*************************************************/typedef struct&#123;    AVCodec            *pCodec;                //编解码器实例指针    AVCodecContext    *pCodecContext;            //编解码器上下文，指定了编解码的参数    AVCodecParserContext *pCodecParserCtx;    //编解码解析器，从码流中截取完整的一个NAL Unit数据    AVFrame            *frame;                    //封装图像对象指针    AVPacket        pkt;                    //封装码流对象实例&#125; CodecCtx;</code></pre><h3 id="2、FFMpeg进行解码操作的主要步骤"><a href="#2、FFMpeg进行解码操作的主要步骤" class="headerlink" title="2、FFMpeg进行解码操作的主要步骤"></a>2、FFMpeg进行解码操作的主要步骤</h3><h4 id="1-参数传递和解析"><a href="#1-参数传递和解析" class="headerlink" title="(1). 参数传递和解析"></a>(1). 参数传递和解析</h4><p>同编码器类似，解码器也需要传递参数。不过相比编码器，解码器在运行时所需要的大部分信息都包含在输入码流中，因此输入参数一般只需要指定一个待解码的视频码流文件即可</p><h4 id="2-按照要求初始化需要的FFMpeg结构"><a href="#2-按照要求初始化需要的FFMpeg结构" class="headerlink" title="(2). 按照要求初始化需要的FFMpeg结构"></a>(2). 按照要求初始化需要的FFMpeg结构</h4><p>首先，所有涉及到编解码的的功能，都必须要注册音视频编解码器之后才能使用。注册编解码调用下面的函数：</p><pre><code>avcodec_register_all();</code></pre><p>编解码器注册完成之后，根据指定的CODEC_ID查找指定的codec实例。CODEC_ID通常指定了编解码器的格式，在这里我们使用当前应用最为广泛的H.264格式为例。查找codec调用的函数为avcodec_find_encoder，其声明格式为：</p><pre><code>AVCodec *avcodec_find_encoder(enum AVCodecID id);</code></pre><p>该函数的输入参数为一个AVCodecID的枚举类型，返回值为一个指向AVCodec结构的指针，用于接收找到的编解码器实例。如果没有找到，那么该函数会返回一个空指针。调用方法如下：</p><pre><code>/* find the mpeg1 video encoder */ctx.codec = avcodec_find_encoder(AV_CODEC_ID_H264);    //根据CODEC_ID查找编解码器对象实例的指针if (!ctx.codec) &#123;    fprintf(stderr, &quot;Codec not found\n&quot;);    return false;&#125;</code></pre><p>AVCodec查找成功后，下一步是分配AVCodecContext实例。分配AVCodecContext实例需要我们前面查找到的AVCodec作为参数，调用的是avcodec_alloc_context3函数。其声明方式为：</p><pre><code>AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);</code></pre><p>其特点同avcodec_find_encoder类似，返回一个指向AVCodecContext实例的指针。如果分配失败，会返回一个空指针。调用方式为：</p><pre><code>ctx.c = avcodec_alloc_context3(ctx.codec);            //分配AVCodecContext实例if (!ctx.c)&#123;    fprintf(stderr, &quot;Could not allocate video codec context\n&quot;);    return false;&#125;</code></pre><p>我们应该记得，在FFMpeg视频编码的实现中，AVCodecContext对象分配完成后，下一步实在该对象中设置编码的参数。而在解码器的实现中，基本不需要额外设置参数信息，因此这个对象更多地作为输出参数接收数据。因此对象分配完成后，不需要进一步的初始化操作。</p><p>解码器与编码器实现中不同的一点在于，解码器的实现中需要额外的一个AVCodecParserContext结构，用于从码流中截取一个完整的NAL单元。因此我们需要分配一个AVCodecParserContext类型的对象，使用函数av_parser_init，声明为：</p><pre><code>AVCodecParserContext *av_parser_init(int codec_id);</code></pre><p>调用方式为：</p><pre><code>ctx.pCodecParserCtx = av_parser_init(AV_CODEC_ID_H264);if (!ctx.pCodecParserCtx)&#123;    printf(&quot;Could not allocate video parser context\n&quot;);    return false;&#125;</code></pre><p>随后，打开AVCodec对象，然后分配AVFrame对象：</p><pre><code>//打开AVCodec对象if (avcodec_open2(ctx.pCodecContext, ctx.pCodec, NULL) &lt; 0)&#123;    fprintf(stderr, &quot;Could not open codec\n&quot;);    return false;&#125;//分配AVFrame对象ctx.frame = av_frame_alloc();if (!ctx.frame) &#123;    fprintf(stderr, &quot;Could not allocate video frame\n&quot;);    return false;&#125;</code></pre><h4 id="3-、解码循环体"><a href="#3-、解码循环体" class="headerlink" title="(3)、解码循环体"></a>(3)、解码循环体</h4><p>完成必须的codec组件的建立和初始化之后，开始进入正式的解码循环过程。解码循环通常按照以下几个步骤实现：</p><p>首先按照某个指定的长度读取一段码流保存到缓存区中。</p><p>由于H.264中一个包的长度是不定的，我们读取一段固定长度的码流通常不可能刚好读出一个包的长度。所以我们就需要使用AVCodecParserContext结构对我们读出的码流信息进行解析，直到取出一个完整的H.264包。对码流解析的函数为av_parser_parse2，声明方式如：</p><pre><code>int av_parser_parse2(AVCodecParserContext *s,                 AVCodecContext *avctx,                 uint8_t **poutbuf, int *poutbuf_size,                 const uint8_t *buf, int buf_size,                 int64_t pts, int64_t dts,                 int64_t pos);</code></pre><p>这个函数的各个参数的意义：</p><ul><li><strong>AVCodecParserContext *s</strong>：初始化过的AVCodecParserContext对象，决定了码流该以怎样的标准进行解析；</li><li>*<em>AVCodecContext <em>avctx</em></em>：预先定义好的AVCodecContext对象；</li><li><strong>uint8_t **poutbuf</strong>：AVPacket::data的地址，保存解析完成的包数据；</li><li><strong>int *poutbuf_size</strong>：AVPacket的实际数据长度；如果没解析出完整的一个包，这个值为0；</li><li><strong>const uint8_t *buf, int buf_size</strong>：输入参数，缓存的地址和长度；</li><li><strong>int64_t pts, int64_t dts</strong>：显示和解码的时间戳；</li><li><strong>nt64_t pos</strong> ：码流中的位置；</li><li>返回值为解析所使用的比特位的长度；</li></ul><p>具体的调用方式为：</p><pre><code>len = av_parser_parse2(ctx.pCodecParserCtx, ctx.pCodecContext,                         &amp;(ctx.pkt.data), &amp;(ctx.pkt.size),                         pDataPtr, uDataSize,                         AV_NOPTS_VALUE, AV_NOPTS_VALUE, AV_NOPTS_VALUE);</code></pre><p>如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。</p><p>在最终解析出一个完整的包之后，我们就可以调用解码API进行实际的解码过程了。解码过程调用的函数为avcodec_decode_video2，该函数的声明为：</p><pre><code>int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,                     int *got_picture_ptr,                     const AVPacket *avpkt);</code></pre><p>这个函数与前篇所遇到的编码函数avcodec_encode_video2有些类似，只是参数的顺序略有不同，解码函数的输入输出参数与编码函数相比交换了位置。该函数各个参数的意义：</p><ul><li><strong>AVCodecContext *avctx</strong>：编解码器上下文对象，在打开编解码器时生成；</li><li><strong>AVFrame *picture</strong>: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好；</li><li><strong>int *got_picture_ptr</strong>: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了</li><li><strong>const AVPacket *avpkt</strong>: 前面解析好的码流包；</li></ul><p>实际调用的方法为：</p><pre><code>int ret = avcodec_decode_video2(ctx.pCodecContext, ctx.frame, &amp;got_picture, &amp;(ctx.pkt));if (ret &lt; 0) &#123;    printf(&quot;Decode Error.\n&quot;);    return ret;&#125;if (got_picture) &#123;    //获得一帧完整的图像，写出到输出文件    write_out_yuv_frame(ctx, inputoutput);    printf(&quot;Succeed to decode 1 frame!\n&quot;);&#125;</code></pre><p>最后，同编码器一样，解码过程的最后一帧可能也存在延迟。处理最后这一帧的方法也跟解码器类似：将AVPacket::data设为NULL，AVPacket::size设为0，然后在调用avcodec_encode_video2完成最后的解码过程：</p><pre><code>ctx.pkt.data = NULL;ctx.pkt.size = 0;while(1)&#123;    //将编码器中剩余的数据继续输出完    int ret = avcodec_decode_video2(ctx.pCodecContext, ctx.frame, &amp;got_picture, &amp;(ctx.pkt));    if (ret &lt; 0)     &#123;        printf(&quot;Decode Error.\n&quot;);        return ret;    &#125;    if (got_picture)     &#123;        write_out_yuv_frame(ctx, inputoutput);        printf(&quot;Flush Decoder: Succeed to decode 1 frame!\n&quot;);    &#125;    else    &#123;        break;    &#125;&#125; //while(1)</code></pre><p>####(4). 收尾工作<br>收尾工作主要包括关闭输入输出文件、关闭FFMpeg解码器各个组件。其中关闭解码器组件需要：</p><pre><code>avcodec_close(ctx.pCodecContext);av_free(ctx.pCodecContext);av_frame_free(&amp;(ctx.frame));</code></pre><h3 id="3、总结-1"><a href="#3、总结-1" class="headerlink" title="3、总结"></a>3、总结</h3><p>解码器的流程与编码器类似，只是中间需要加入一个解析的过程。整个流程大致为：</p><p>1.读取码流数据 -&gt; 2.解析数据，是否尚未解析出一个包就已经用完？是返回1，否继续 -&gt; 3.解析出一个包？是则继续，否则返回上一步继续解析 -&gt; 4.调用avcodec_decode_video2进行解码 -&gt; 5.是否解码出一帧完整的图像？是则继续，否则返回上一步继续解码 -&gt; 6.写出图像数据 -&gt; 返回步骤2继续解析。</p><hr><h2 id="四、调用FFmpeg-SDK解析封装格式的视频为音频流和视频流"><a href="#四、调用FFmpeg-SDK解析封装格式的视频为音频流和视频流" class="headerlink" title="四、调用FFmpeg SDK解析封装格式的视频为音频流和视频流"></a>四、调用FFmpeg SDK解析封装格式的视频为音频流和视频流</h2><p>我们平常最常用的音视频文件通常不是单独的音频信号和视频信号，而是一个整体的文件。这个文件会在其中包含音频流和视频流，并通过某种方式进行同步播放。通常，文件的音频和视频通过某种标准格式进行复用，生成某种封装格式，而封装的标志就是文件的扩展名，常用的有mp4/avi/flv/mkv等。</p><p>从底层考虑，我们可以使用的只有视频解码器、音频解码器，或者再加上一些附加的字幕解码等额外信息，却不存在所谓的mp4解码器或者avi解码器。所以，为了可以正确播放视频文件，必须将封装格式的视频文件分离出视频和音频信息分别进行解码和播放。</p><p>事实上，无论是mp4还是avi等文件格式，都有不同的标准格式，对于不同的格式并没有一种通用的解析方法。因此，FFMpeg专门定义了一个库来处理设计文件封装格式的功能，即libavformat。涉及文件的封装、解封装的问题，都可以通过调用libavformat的API实现。这里我们实现一个demo来处理音视频文件的解复用与解码的功能。</p><h3 id="1-FFMpeg解复用-解码器所包含的结构"><a href="#1-FFMpeg解复用-解码器所包含的结构" class="headerlink" title="1. FFMpeg解复用-解码器所包含的结构"></a>1. FFMpeg解复用-解码器所包含的结构</h3><p>这一过程实际上包括了封装文件的解复用和音频/视频解码两个步骤，因此需要定义的结构体大致包括用于解码和解封装的部分。我们定义下面这样的一个结构体实现这个功能：</p><pre><code>/*************************************************Struct:            DemuxingVideoAudioContexDescription:    保存解复用器和解码器的上下文组件*************************************************/typedef struct&#123;    AVFormatContext *fmt_ctx;    AVCodecContext *video_dec_ctx, *audio_dec_ctx;    AVStream *video_stream, *audio_stream;    AVFrame *frame;    AVPacket pkt;    int video_stream_idx, audio_stream_idx;    int width, height;    uint8_t *video_dst_data[4];    int video_dst_linesize[4];    int video_dst_bufsize;    enum AVPixelFormat pix_fmt;&#125; DemuxingVideoAudioContex;</code></pre><p>这个结构体中的大部分数据类型我们在前面做编码/解码等功能时已经见到过，另外几个是涉及到视频文件的复用的，其中有：</p><ul><li>AVFormatContext：用于处理音视频封装格式的上下文信息。</li><li>AVStream：表示音频或者视频流的结构。</li><li>AVPixelFormat：枚举类型，表示图像像素的格式，最常用的是AV_PIX_FMT_YUV420P</li></ul><h3 id="2、FFMpeg解复用-解码的过程"><a href="#2、FFMpeg解复用-解码的过程" class="headerlink" title="2、FFMpeg解复用-解码的过程"></a>2、FFMpeg解复用-解码的过程</h3><h4 id="1-、相关结构的初始化"><a href="#1-、相关结构的初始化" class="headerlink" title="(1)、相关结构的初始化"></a>(1)、相关结构的初始化</h4><p>与使用FFMpeg进行其他操作一样，首先需注册FFMpeg组件：</p><pre><code>av_register_all();</code></pre><p>随后，我们需要打开待处理的音视频文件。然而在此我们不使用打开文件的fopen函数，而是使用avformat_open_input函数。该函数不但会打开输入文件，而且可以根据输入文件读取相应的格式信息。该函数的声明如下：</p><pre><code>int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options);</code></pre><p>该函数的各个参数的作用为：</p><ul><li><strong>ps</strong>：根据输入文件接收与格式相关的句柄信息；可以指向NULL，那么AVFormatContext类型的实例将由该函数进行分配。</li><li><strong>url</strong>：视频url或者文件路径；</li><li><strong>fmt</strong>：强制输入格式，可设置为NULL以自动检测；</li><li><strong>options</strong>：保存文件格式无法识别的信息；</li><li><strong>返回值</strong>：成功返回0，失败则返回负的错误码；</li></ul><p>该函数的调用方式为：</p><pre><code>if (avformat_open_input(&amp;(va_ctx.fmt_ctx), files.src_filename, NULL, NULL) &lt; 0)&#123;    fprintf(stderr, &quot;Could not open source file %s\n&quot;, files.src_filename);    return -1;&#125;</code></pre><p>打开文件后，调用avformat_find_stream_info函数获取文件中的流信息。该函数的声明为：</p><pre><code>int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);</code></pre><p>该函数的第一个参数即前面的文件句柄，第二个参数也是用于保存无法识别的信息的AVDictionary的结构，通常可设为NULL。调用方式如：</p><pre><code>/* retrieve stream information */if (avformat_find_stream_info(va_ctx.fmt_ctx, NULL) &lt; 0) &#123;    fprintf(stderr, &quot;Could not find stream information\n&quot;);    return -1;&#125;</code></pre><p>获取文件中的流信息后，下一步则是获取文件中的音频和视频流，并准备对音频和视频信息进行解码。获取文件中的流使用av_find_best_stream函数，其声明如：</p><pre><code>int av_find_best_stream(AVFormatContext *ic,                    enum AVMediaType type,                    int wanted_stream_nb,                    int related_stream,                    AVCodec **decoder_ret,                    int flags);</code></pre><p>其中各个参数的意义：</p><ul><li><strong>ic</strong>：视频文件句柄；</li><li><strong>type</strong>：表示数据的类型，常用的有AVMEDIA_TYPE_VIDEO表示视频，AVMEDIA_TYPE_AUDIO表示音频等；</li><li><strong>wanted_stream_nb</strong>：我们期望获取到的数据流的数量，设置为-1使用自动获取；</li><li><strong>related_stream</strong>：获取相关的音视频流，如果没有则设为-1；</li><li><strong>decoder_ret</strong>：返回这一路数据流的解码器；</li><li><strong>flags</strong>：未定义；</li><li>返回值：函数执行成功返回流的数量，失败则返回负的错误码；</li></ul><p>在函数执行成功后，便可调用avcodec_find_decoder和avcodec_open2打开解码器准备解码音视频流。该部分的代码实现如：</p><pre><code>static int open_codec_context(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx, enum AVMediaType type)&#123;    int ret, stream_index;    AVStream *st;    AVCodecContext *dec_ctx = NULL;    AVCodec *dec = NULL;    AVDictionary *opts = NULL;    ret = av_find_best_stream(va_ctx.fmt_ctx, type, -1, -1, NULL, 0);    if (ret &lt; 0)     &#123;        fprintf(stderr, &quot;Could not find %s stream in input file &#39;%s&#39;\n&quot;, av_get_media_type_string(type), files.src_filename);        return ret;    &#125;     else     &#123;        stream_index = ret;        st = va_ctx.fmt_ctx-&gt;streams[stream_index];        /* find decoder for the stream */        dec_ctx = st-&gt;codec;        dec = avcodec_find_decoder(dec_ctx-&gt;codec_id);        if (!dec)         &#123;            fprintf(stderr, &quot;Failed to find %s codec\n&quot;, av_get_media_type_string(type));            return AVERROR(EINVAL);        &#125;        /* Init the decoders, with or without reference counting */        av_dict_set(&amp;opts, &quot;refcounted_frames&quot;, files.refcount ? &quot;1&quot; : &quot;0&quot;, 0);        if ((ret = avcodec_open2(dec_ctx, dec, &amp;opts)) &lt; 0)         &#123;            fprintf(stderr, &quot;Failed to open %s codec\n&quot;, av_get_media_type_string(type));            return ret;        &#125;        switch (type)        &#123;        case AVMEDIA_TYPE_VIDEO:            va_ctx.video_stream_idx = stream_index;            va_ctx.video_stream = va_ctx.fmt_ctx-&gt;streams[stream_index];            va_ctx.video_dec_ctx = va_ctx.video_stream-&gt;codec;            break;        case AVMEDIA_TYPE_AUDIO:            va_ctx.audio_stream_idx = stream_index;            va_ctx.audio_stream = va_ctx.fmt_ctx-&gt;streams[stream_index];            va_ctx.audio_dec_ctx = va_ctx.audio_stream-&gt;codec;            break;        default:            fprintf(stderr, &quot;Error: unsupported MediaType: %s\n&quot;, av_get_media_type_string(type));            return -1;        &#125;    &#125;    return 0;&#125;</code></pre><p>整体初始化的函数代码为：</p><pre><code>int InitDemuxContext(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx)&#123;    int ret = 0, width, height;    /* register all formats and codecs */    av_register_all();    /* open input file, and allocate format context */    if (avformat_open_input(&amp;(va_ctx.fmt_ctx), files.src_filename, NULL, NULL) &lt; 0)    &#123;        fprintf(stderr, &quot;Could not open source file %s\n&quot;, files.src_filename);        return -1;    &#125;    /* retrieve stream information */    if (avformat_find_stream_info(va_ctx.fmt_ctx, NULL) &lt; 0)     &#123;        fprintf(stderr, &quot;Could not find stream information\n&quot;);        return -1;    &#125;    if (open_codec_context(files, va_ctx, AVMEDIA_TYPE_VIDEO) &gt;= 0)     &#123;        files.video_dst_file = fopen(files.video_dst_filename, &quot;wb&quot;);        if (!files.video_dst_file)         &#123;            fprintf(stderr, &quot;Could not open destination file %s\n&quot;, files.video_dst_filename);            return -1;        &#125;        /* allocate image where the decoded image will be put */        va_ctx.width = va_ctx.video_dec_ctx-&gt;width;        va_ctx.height = va_ctx.video_dec_ctx-&gt;height;        va_ctx.pix_fmt = va_ctx.video_dec_ctx-&gt;pix_fmt;        ret = av_image_alloc(va_ctx.video_dst_data, va_ctx.video_dst_linesize, va_ctx.width, va_ctx.height, va_ctx.pix_fmt, 1);        if (ret &lt; 0)         &#123;            fprintf(stderr, &quot;Could not allocate raw video buffer\n&quot;);            return -1;        &#125;        va_ctx.video_dst_bufsize = ret;    &#125;    if (open_codec_context(files, va_ctx, AVMEDIA_TYPE_AUDIO) &gt;= 0)     &#123;        files.audio_dst_file = fopen(files.audio_dst_filename, &quot;wb&quot;);        if (!files.audio_dst_file)         &#123;            fprintf(stderr, &quot;Could not open destination file %s\n&quot;, files.audio_dst_filename);            return -1;        &#125;    &#125;    if (va_ctx.video_stream)    &#123;        printf(&quot;Demuxing video from file &#39;%s&#39; into &#39;%s&#39;\n&quot;, files.src_filename, files.video_dst_filename);    &#125;    if (va_ctx.audio_stream)    &#123;        printf(&quot;Demuxing audio from file &#39;%s&#39; into &#39;%s&#39;\n&quot;, files.src_filename, files.audio_dst_filename);    &#125;    /* dump input information to stderr */    av_dump_format(va_ctx.fmt_ctx, 0, files.src_filename, 0);    if (!va_ctx.audio_stream &amp;&amp; !va_ctx.video_stream)     &#123;        fprintf(stderr, &quot;Could not find audio or video stream in the input, aborting\n&quot;);        return -1;    &#125;    return 0;&#125;</code></pre><p>随后要做的，是分配AVFrame和初始化AVPacket对象：</p><pre><code>va_ctx.frame = av_frame_alloc();            //分配AVFrame结构对象if (!va_ctx.frame)&#123;    fprintf(stderr, &quot;Could not allocate frame\n&quot;);    ret = AVERROR(ENOMEM);    goto end;&#125;/* initialize packet, set data to NULL, let the demuxer fill it */av_init_packet(&amp;va_ctx.pkt);                //初始化AVPacket对象va_ctx.pkt.data = NULL;va_ctx.pkt.size = 0;</code></pre><h4 id="2-、循环解析视频文件的包数据"><a href="#2-、循环解析视频文件的包数据" class="headerlink" title="(2)、循环解析视频文件的包数据"></a>(2)、循环解析视频文件的包数据</h4><p>解析视频文件的循环代码段为：</p><pre><code>/* read frames from the file */while (av_read_frame(va_ctx.fmt_ctx, &amp;va_ctx.pkt) &gt;= 0)        //从输入程序中读取一个包的数据&#123;    AVPacket orig_pkt = va_ctx.pkt;    do     &#123;        ret = Decode_packet(files, va_ctx, &amp;got_frame, 0);    //解码这个包        if (ret &lt; 0)            break;        va_ctx.pkt.data += ret;        va_ctx.pkt.size -= ret;    &#125; while (va_ctx.pkt.size &gt; 0);    av_packet_unref(&amp;orig_pkt);&#125;</code></pre><p>这部分代码逻辑上非常简单，首先调用av_read_frame函数，从文件中读取一个packet的数据，并实现了一个Decode_packet对这个packet进行解码。Decode_packet函数的实现如下：</p><pre><code>int Decode_packet(IOFileName &amp;files, DemuxingVideoAudioContex &amp;va_ctx, int *got_frame, int cached)&#123;    int ret = 0;    int decoded = va_ctx.pkt.size;    static int video_frame_count = 0;    static int audio_frame_count = 0;    *got_frame = 0;    if (va_ctx.pkt.stream_index == va_ctx.video_stream_idx)    &#123;        /* decode video frame */        ret = avcodec_decode_video2(va_ctx.video_dec_ctx, va_ctx.frame, got_frame, &amp;va_ctx.pkt);        if (ret &lt; 0)        &#123;            printf(&quot;Error decoding video frame (%d)\n&quot;, ret);            return ret;        &#125;        if (*got_frame)        &#123;            if (va_ctx.frame-&gt;width != va_ctx.width || va_ctx.frame-&gt;height != va_ctx.height ||                va_ctx.frame-&gt;format != va_ctx.pix_fmt)            &#123;                /* To handle this change, one could call av_image_alloc again and                * decode the following frames into another rawvideo file. */                printf(&quot;Error: Width, height and pixel format have to be &quot;                    &quot;constant in a rawvideo file, but the width, height or &quot;                    &quot;pixel format of the input video changed:\n&quot;                    &quot;old: width = %d, height = %d, format = %s\n&quot;                    &quot;new: width = %d, height = %d, format = %s\n&quot;,                    va_ctx.width, va_ctx.height, av_get_pix_fmt_name((AVPixelFormat)(va_ctx.pix_fmt)),                    va_ctx.frame-&gt;width, va_ctx.frame-&gt;height,                    av_get_pix_fmt_name((AVPixelFormat)va_ctx.frame-&gt;format));                return -1;            &#125;            printf(&quot;video_frame%s n:%d coded_n:%d pts:%s\n&quot;, cached ? &quot;(cached)&quot; : &quot;&quot;, video_frame_count++, va_ctx.frame-&gt;coded_picture_number, va_ctx.frame-&gt;pts);            /* copy decoded frame to destination buffer:            * this is required since rawvideo expects non aligned data */            av_image_copy(va_ctx.video_dst_data, va_ctx.video_dst_linesize,                (const uint8_t **)(va_ctx.frame-&gt;data), va_ctx.frame-&gt;linesize,                va_ctx.pix_fmt, va_ctx.width, va_ctx.height);            /* write to rawvideo file */            fwrite(va_ctx.video_dst_data[0], 1, va_ctx.video_dst_bufsize, files.video_dst_file);        &#125;    &#125;    else if (va_ctx.pkt.stream_index == va_ctx.audio_stream_idx)    &#123;        /* decode audio frame */        ret = avcodec_decode_audio4(va_ctx.audio_dec_ctx, va_ctx.frame, got_frame, &amp;va_ctx.pkt);        if (ret &lt; 0)        &#123;            printf(&quot;Error decoding audio frame (%s)\n&quot;, ret);            return ret;        &#125;        /* Some audio decoders decode only part of the packet, and have to be        * called again with the remainder of the packet data.        * Sample: fate-suite/lossless-audio/luckynight-partial.shn        * Also, some decoders might over-read the packet. */        decoded = FFMIN(ret, va_ctx.pkt.size);        if (*got_frame)        &#123;            size_t unpadded_linesize = va_ctx.frame-&gt;nb_samples * av_get_bytes_per_sample((AVSampleFormat)va_ctx.frame-&gt;format);            printf(&quot;audio_frame%s n:%d nb_samples:%d pts:%s\n&quot;,                cached ? &quot;(cached)&quot; : &quot;&quot;,                audio_frame_count++, va_ctx.frame-&gt;nb_samples,                va_ctx.frame-&gt;pts);            /* Write the raw audio data samples of the first plane. This works            * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,            * most audio decoders output planar audio, which uses a separate            * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).            * In other words, this code will write only the first audio channel            * in these cases.            * You should use libswresample or libavfilter to convert the frame            * to packed data. */            fwrite(va_ctx.frame-&gt;extended_data[0], 1, unpadded_linesize, files.audio_dst_file);        &#125;    &#125;        /* If we use frame reference counting, we own the data and need        * to de-reference it when we don&#39;t use it anymore */        if (*got_frame &amp;&amp; files.refcount)            av_frame_unref(va_ctx.frame);            return decoded;&#125;</code></pre><p>在该函数中，首先对读取到的packet中的stream_index分别于先前获取的音频和视频的stream_index进行对比来确定是音频还是视频流。而后分别调用相应的解码函数进行解码，以视频流为例，判断当前stream为视频流后，调用avcodec_decode_video2函数将流数据解码为像素数据，并在获取完整的一帧之后，将其写出到输出文件中。</p><h3 id="3、总结-2"><a href="#3、总结-2" class="headerlink" title="3、总结"></a>3、总结</h3><p>相对于前文讲述过的解码H.264格式裸码流，解封装+解码过程看似多了一个步骤，然而在实现起来实际上并无过多差别。这主要是由于FFMpeg中的多个API已经很好地实现了封装文件的解析和读取过程，如打开文件我们使用avformat_open_input代替fopen，读取数据包使用av_read_frame代替fread，其他方面只需要多一步判断封装文件中数据流的类型即可，剩余部分与裸码流的解码并无太多差别。</p><hr><p>##五、调用FFMpeg SDK封装音频和视频为视频文件</p><p>音频和视频的封装过程为解封装的逆过程，即将独立的音频数据和视频数据按照容器文件所规定的格式封装为一个完整的视频文件的过程。对于大多数消费者来说，视频封装的容器是大家最为熟悉的，因为它直接体现在了我们使用的音视频文件扩展名上，比较常见的有mp4、avi、mkv、flv等等。</p><p>在进行音频和视频封装时，我们将实际操作一系列音频或视频流数据的生成和写入。所谓流，指的是一系列相关联的包的集合，这些包一般同属于一组按照时间先后顺序进行解码/渲染等处理的数据。在一个比较典型的视频文件中，我们通常至少会包含一个视频流和一个音频流。</p><p>在FFMpeg中，表示音频流或视频流有一个专门的结构，即”AVStream”实现。该结构主要对音频和视频数据的处理进行管理和控制。另外，”AVFormatContext”结构也是必须的，因为它包含了控制输入和输出的信息。</p><p>音频和视频数据封装为视频文件的主要步骤为：</p><h3 id="1-相关数据结构的准备"><a href="#1-相关数据结构的准备" class="headerlink" title="1. 相关数据结构的准备"></a>1. 相关数据结构的准备</h3><p>首先，根据输出文件的格式获取AVFormatContext结构，获取AVFormatContext结构使用函数avformat_alloc_output_context2实现。该函数的声明为：</p><pre><code>int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename);</code></pre><p>其中：</p><ul><li>ctx：输出到AVFormatContext结构的指针，如果函数失败则返回给该指针为NULL；</li><li>oformat：指定输出的AVOutputFormat类型，如果设为NULL则使用format_name和filename生成；</li><li>format_name：输出格式的名称，如果设为NULL则使用filename默认格式；</li><li>filename：目标文件名，如果不使用，可以设为NULL；</li></ul><p>分配AVFormatContext成功后，我们需要添加希望封装的数据流，一般是一路视频流+一路音频流（可能还有其他音频流和字幕流等）。添加流首先需要查找流所包含的媒体的编码器，这需要传入codec_id后使用avcodec_find_encoder函数实现，将查找到的编码器保存在AVCodec指针中。</p><p>之后，调用avformat_new_stream函数向AVFormatContext结构中所代表的媒体文件中添加数据流。该函数的声明如下：</p><pre><code>AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c);</code></pre><p>其中各个参数的含义：</p><ul><li>s：AVFormatContext结构，表示要封装生成的视频文件；</li><li>c：上一步根据codec_id产生的编码器指针；</li><li>返回值：指向生成的stream对象的指针；如果失败则返回NULL指针。</li></ul><p>此时，一个新的AVStream便已经加入到输出文件中，下面就可以设置stream的id和codec等参数。AVStream::codec是一个AVCodecContext类型的指针变量成员，设置其中的值可以对编码进行配置。整个添加stream的例子如：</p><pre><code>/* Add an output stream. */static void add_stream(OutputStream *ost, AVFormatContext *oc,    AVCodec **codec, enum AVCodecID codec_id)&#123;    AVCodecContext *c;    int i;    /* find the encoder */    *codec = avcodec_find_encoder(codec_id);    if (!(*codec))    &#123;        fprintf(stderr, &quot;Could not find encoder for &#39;%s&#39;\n&quot;, avcodec_get_name(codec_id));        exit(1);    &#125;    ost-&gt;st = avformat_new_stream(oc, *codec);    if (!ost-&gt;st)    &#123;        fprintf(stderr, &quot;Could not allocate stream\n&quot;);        exit(1);    &#125;    ost-&gt;st-&gt;id = oc-&gt;nb_streams - 1;    c = ost-&gt;st-&gt;codec;    switch ((*codec)-&gt;type)    &#123;    case AVMEDIA_TYPE_AUDIO:        c-&gt;sample_fmt = (*codec)-&gt;sample_fmts ? (*codec)-&gt;sample_fmts[0] : AV_SAMPLE_FMT_FLTP;        c-&gt;bit_rate = 64000;        c-&gt;sample_rate = 44100;        if ((*codec)-&gt;supported_samplerates)        &#123;            c-&gt;sample_rate = (*codec)-&gt;supported_samplerates[0];            for (i = 0; (*codec)-&gt;supported_samplerates[i]; i++)            &#123;                if ((*codec)-&gt;supported_samplerates[i] == 44100)                    c-&gt;sample_rate = 44100;            &#125;        &#125;        c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout);        c-&gt;channel_layout = AV_CH_LAYOUT_STEREO;        if ((*codec)-&gt;channel_layouts)        &#123;            c-&gt;channel_layout = (*codec)-&gt;channel_layouts[0];            for (i = 0; (*codec)-&gt;channel_layouts[i]; i++)            &#123;                if ((*codec)-&gt;channel_layouts[i] == AV_CH_LAYOUT_STEREO)                    c-&gt;channel_layout = AV_CH_LAYOUT_STEREO;            &#125;        &#125;        c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout);        &#123;            AVRational r = &#123; 1, c-&gt;sample_rate &#125;;            ost-&gt;st-&gt;time_base = r;        &#125;        break;    case AVMEDIA_TYPE_VIDEO:        c-&gt;codec_id = codec_id;        c-&gt;bit_rate = 400000;        /* Resolution must be a multiple of two. */        c-&gt;width = 352;        c-&gt;height = 288;        /* timebase: This is the fundamental unit of time (in seconds) in terms        * of which frame timestamps are represented. For fixed-fps content,        * timebase should be 1/framerate and timestamp increments should be        * identical to 1. */        &#123;            AVRational r = &#123; 1, STREAM_FRAME_RATE &#125;;            ost-&gt;st-&gt;time_base = r;        &#125;        c-&gt;time_base = ost-&gt;st-&gt;time_base;        c-&gt;gop_size = 12; /* emit one intra frame every twelve frames at most */        c-&gt;pix_fmt = AV_PIX_FMT_YUV420P;        if (c-&gt;codec_id == AV_CODEC_ID_MPEG2VIDEO)        &#123;            /* just for testing, we also add B frames */            c-&gt;max_b_frames = 2;        &#125;        if (c-&gt;codec_id == AV_CODEC_ID_MPEG1VIDEO)        &#123;            /* Needed to avoid using macroblocks in which some coeffs overflow.            * This does not happen with normal video, it just happens here as            * the motion of the chroma plane does not match the luma plane. */            c-&gt;mb_decision = 2;        &#125;        break;    default:        break;    &#125;    /* Some formats want stream headers to be separate. */    if (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)        c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;&#125;    </code></pre><h3 id="2-打开音视频"><a href="#2-打开音视频" class="headerlink" title="2. 打开音视频"></a>2. 打开音视频</h3><p>打开音视频主要涉及到打开编码音视频数据所需要的编码器，以及分配相应的frame对象。其中打开编码器如之前一样，调用avcodec_open函数，分配frame对象调用av_frame_alloc以及av_frame_get_buffer。分配frame对象的实现如下：</p><pre><code>static AVFrame *alloc_picture(enum AVPixelFormat pix_fmt, int width, int height)&#123;    AVFrame *picture;    int ret;    picture = av_frame_alloc();    if (!picture)    &#123;        return NULL;    &#125;    picture-&gt;format = pix_fmt;    picture-&gt;width = width;    picture-&gt;height = height;    /* allocate the buffers for the frame data */    ret = av_frame_get_buffer(picture, 32);    if (ret &lt; 0)    &#123;        fprintf(stderr, &quot;Could not allocate frame data.\n&quot;);        exit(1);    &#125;    return picture;&#125;</code></pre><p>而上层打开音视频部分的实现如：</p><pre><code>void Open_video(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg, IOParam &amp;io)&#123;    int ret;    AVCodecContext *c = ost-&gt;st-&gt;codec;    AVDictionary *opt = NULL;    av_dict_copy(&amp;opt, opt_arg, 0);    /* open the codec */    ret = avcodec_open2(c, codec, &amp;opt);    av_dict_free(&amp;opt);    if (ret &lt; 0)    &#123;        fprintf(stderr, &quot;Could not open video codec: %d\n&quot;, ret);        exit(1);    &#125;    /* allocate and init a re-usable frame */    ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height);    if (!ost-&gt;frame)    &#123;        fprintf(stderr, &quot;Could not allocate video frame\n&quot;);        exit(1);    &#125;    /* If the output format is not YUV420P, then a temporary YUV420P    * picture is needed too. It is then converted to the required    * output format. */    ost-&gt;tmp_frame = NULL;    if (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P)    &#123;        ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height);        if (!ost-&gt;tmp_frame)        &#123;            fprintf(stderr, &quot;Could not allocate temporary picture\n&quot;);            exit(1);        &#125;    &#125;    //打开输入YUV文件    fopen_s(&amp;g_inputYUVFile, io.input_file_name, &quot;rb+&quot;);    if (g_inputYUVFile == NULL)    &#123;        fprintf(stderr, &quot;Open input yuv file failed.\n&quot;);        exit(1);    &#125;&#125;</code></pre><h3 id="3-打开输出文件并写入文件头"><a href="#3-打开输出文件并写入文件头" class="headerlink" title="3. 打开输出文件并写入文件头"></a>3. 打开输出文件并写入文件头</h3><p>如果判断需要写出文件的话，则需要打开输出文件。在这里，我们可以不再定义输出文件指针，并使用fopen打开，而是直接使用FFMpeg的API——avio_open来实现输出文件的打开功能。该函数的声明如下：</p><pre><code>int avio_open(AVIOContext **s, const char *url, int flags);</code></pre><p>该函数的输入参数为：</p><ul><li>s：输出参数，返回一个AVIOContext；如果打开失败则返回NULL；</li><li>url：输出的url或者文件的完整路径；</li><li>flags：控制文件打开方式，如读方式、写方式和读写方式；</li></ul><p>实际的代码实现方式如下：</p><pre><code>/* open the output file, if needed */if (!(fmt-&gt;flags &amp; AVFMT_NOFILE))&#123;    ret = avio_open(&amp;oc-&gt;pb, io.output_file_name, AVIO_FLAG_WRITE);    if (ret &lt; 0)    &#123;        fprintf(stderr, &quot;Could not open &#39;%s&#39;: %d\n&quot;, io.output_file_name, ret);        return 1;    &#125;&#125;</code></pre><p>写入文件头操作是生成视频文件中极为重要的一步，而实现过程却非常简单，只需要通过函数avformat_write_header即可，该函数的声明为：</p><pre><code>int avformat_write_header(AVFormatContext *s, AVDictionary **options);</code></pre><p>其输入参数实际上重要的只有第一个，即标记输出文件的句柄对象指针；options用于保存无法识别的设置项，可以传入一个空指针。其返回值表示写文件头成功与否，成功则返回0，失败则返回负的错误码。</p><p>实现方式如：</p><pre><code>/* Write the stream header, if any. */ret = avformat_write_header(oc, &amp;opt);if (ret &lt; 0)&#123;    fprintf(stderr, &quot;Error occurred when opening output file: %d\n&quot;,ret);    return 1;&#125;</code></pre><p>###4. 编码和封装循环</p><p>以视频流为例。编解码循环的过程实际上可以封装在一个函数Write_video_frame中。该函数从逻辑上可以分为3个部分：获取原始视频信号、视频编码、写入输出文件。</p><h4 id="1-读取原始视频数据"><a href="#1-读取原始视频数据" class="headerlink" title="(1) 读取原始视频数据"></a>(1) 读取原始视频数据</h4><p>这一部分主要实现根据时长判断是否需要继续进行处理、读取视频到AVFrame和设置pts。其中时长判断部分根据pts和AVCodecContext的time_base判断。实现如下：</p><pre><code>AVCodecContext *c = ost-&gt;st-&gt;codec;/* check if we want to generate more frames */&#123;    AVRational r = &#123; 1, 1 &#125;;    if (av_compare_ts(ost-&gt;next_pts, ost-&gt;st-&gt;codec-&gt;time_base, STREAM_DURATION, r) &gt;= 0)    &#123;        return NULL;    &#125;&#125;</code></pre><p>读取视频到AVFrame我们定义一个fill_yuv_image函数实现：</p><pre><code>static void fill_yuv_image(AVFrame *pict, int frame_index, int width, int height)&#123;    int x, y, i, ret;    /* when we pass a frame to the encoder, it may keep a reference to it    * internally;    * make sure we do not overwrite it here    */    ret = av_frame_make_writable(pict);    if (ret &lt; 0)    &#123;        exit(1);    &#125;    i = frame_index;    /* Y */    for (y = 0; y &lt; height; y++)    &#123;        ret = fread_s(&amp;pict-&gt;data[0][y * pict-&gt;linesize[0]], pict-&gt;linesize[0], 1, width, g_inputYUVFile);        if (ret != width)        &#123;            printf(&quot;Error: Read Y data error.\n&quot;);            exit(1);        &#125;    &#125;    /* U */    for (y = 0; y &lt; height / 2; y++)     &#123;        ret = fread_s(&amp;pict-&gt;data[1][y * pict-&gt;linesize[1]], pict-&gt;linesize[1], 1, width / 2, g_inputYUVFile);        if (ret != width / 2)        &#123;            printf(&quot;Error: Read U data error.\n&quot;);            exit(1);        &#125;    &#125;    /* V */    for (y = 0; y &lt; height / 2; y++)     &#123;        ret = fread_s(&amp;pict-&gt;data[2][y * pict-&gt;linesize[2]], pict-&gt;linesize[2], 1, width / 2, g_inputYUVFile);        if (ret != width / 2)        &#123;            printf(&quot;Error: Read V data error.\n&quot;);            exit(1);        &#125;    &#125;&#125;</code></pre><p>然后进行pts的设置，很简单，就是上一个frame的pts递增1：</p><pre><code>ost-&gt;frame-&gt;pts = ost-&gt;next_pts++;</code></pre><p>整个获取视频信号的实现如：</p><pre><code>static AVFrame *get_video_frame(OutputStream *ost)&#123;    AVCodecContext *c = ost-&gt;st-&gt;codec;    /* check if we want to generate more frames */    &#123;        AVRational r = &#123; 1, 1 &#125;;        if (av_compare_ts(ost-&gt;next_pts, ost-&gt;st-&gt;codec-&gt;time_base, STREAM_DURATION, r) &gt;= 0)        &#123;            return NULL;        &#125;    &#125;    fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);    ost-&gt;frame-&gt;pts = ost-&gt;next_pts++;    return ost-&gt;frame;&#125;</code></pre><h4 id="2-视频编码"><a href="#2-视频编码" class="headerlink" title="(2) 视频编码"></a>(2) 视频编码</h4><p>视频编码的方式同之前几次使用的方式相同，即调用avcodec_encode_video2，实现方法如：</p><pre><code>/* encode the image */ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet);if (ret &lt; 0) &#123;    fprintf(stderr, &quot;Error encoding video frame: %d\n&quot;, ret);    exit(1);&#125;</code></pre><h4 id="3-写出编码后的数据到输出视频文件"><a href="#3-写出编码后的数据到输出视频文件" class="headerlink" title="(3) 写出编码后的数据到输出视频文件"></a>(3) 写出编码后的数据到输出视频文件</h4><p>这部分的实现过程很简单，方式如下：</p><pre><code>/* rescale output packet timestamp values from codec to stream timebase */av_packet_rescale_ts(pkt, *time_base, st-&gt;time_base);pkt-&gt;stream_index = st-&gt;index;/* Write the compressed frame to the media file. *///    log_packet(fmt_ctx, pkt);return av_interleaved_write_frame(fmt_ctx, pkt);</code></pre><p>av_packet_rescale_ts函数的作用为不同time_base度量之间的转换，在这里起到的作用是将AVCodecContext的time_base转换为AVStream中的time_base。av_interleaved_write_frame函数的作用是写出AVPacket到输出文件。该函数的声明为：</p><pre><code>int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);</code></pre><p>该函数的声明也很简单，第一个参数是之前打开并写入文件头的文件句柄，第二个参数是写入文件的packet。返回值为错误码，成功返回0，失败则返回一个负值。</p><p>Write_video_frame函数的整体实现如：</p><pre><code>int Write_video_frame(AVFormatContext *oc, OutputStream *ost)&#123;    int ret;    AVCodecContext *c;    AVFrame *frame;    int got_packet = 0;    AVPacket pkt = &#123; 0 &#125;;    c = ost-&gt;st-&gt;codec;    frame = get_video_frame(ost);    av_init_packet(&amp;pkt);    /* encode the image */    ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet);    if (ret &lt; 0)     &#123;        fprintf(stderr, &quot;Error encoding video frame: %d\n&quot;, ret);        exit(1);    &#125;    if (got_packet)    &#123;        ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt);    &#125;    else     &#123;        ret = 0;    &#125;    if (ret &lt; 0)    &#123;        fprintf(stderr, &quot;Error while writing video frame: %d\n&quot;, ret);        exit(1);    &#125;    return (frame || got_packet) ? 0 : 1;&#125;</code></pre><p>以上是写入一帧视频数据的方法，写入音频的方法于此大同小异。整个编码封装的循环上层实现如：</p><pre><code>while (encode_video || encode_audio) &#123;    /* select the stream to encode */    if (encode_video &amp;&amp; (!encode_audio || av_compare_ts(video_st.next_pts, video_st.st-&gt;codec-&gt;time_base, audio_st.next_pts, audio_st.st-&gt;codec-&gt;time_base) &lt;= 0))    &#123;        encode_video = !Write_video_frame(oc, &amp;video_st);        if (encode_video)        &#123;            printf(&quot;Write %d video frame.\n&quot;, videoFrameIdx++);        &#125;        else        &#123;            printf(&quot;Video ended, exit.\n&quot;);        &#125;    &#125;    else     &#123;        encode_audio = !Write_audio_frame(oc, &amp;audio_st);        if (encode_audio)        &#123;            printf(&quot;Write %d audio frame.\n&quot;, audioFrameIdx++);        &#125;        else        &#123;            printf(&quot;Audio ended, exit.\n&quot;);        &#125;    &#125;&#125;</code></pre><p>###5. 写入文件尾，并进行收尾工作</p><p>写入文件尾的数据同写文件头一样简单，只需要调用函数av_write_trailer即可实现：</p><pre><code>int av_write_trailer(AVFormatContext *s);</code></pre><p>该函数只有一个参数即视频文件的句柄，当返回值为0时表示函数执行成功。</p><p>整个流程的收尾工作包括关闭文件中的数据流、关闭输出文件和释放AVCodecContext对象。其中关闭数据流的实现方式如：</p><pre><code>void Close_stream(AVFormatContext *oc, OutputStream *ost)&#123;    avcodec_close(ost-&gt;st-&gt;codec);    av_frame_free(&amp;ost-&gt;frame);    av_frame_free(&amp;ost-&gt;tmp_frame);    sws_freeContext(ost-&gt;sws_ctx);    swr_free(&amp;ost-&gt;swr_ctx);&#125;</code></pre><p>关闭输出文件和释放AVCodecContext对象：</p><pre><code>if (!(fmt-&gt;flags &amp; AVFMT_NOFILE))    /* Close the output file. */    avio_closep(&amp;oc-&gt;pb);/* free the stream */avformat_free_context(oc);</code></pre><p>至此，整个处理流程便结束了。正确设置输入的YUV文件就可以获取封装好的音视频文件。</p><hr><p>##六、调用FFMpeg SDK实现视频文件的转封装</p><p>有时候我们可能会面对这样的一种需求，即我们不需要对视频内的音频或视频信号进行什么实际的操作，只是希望能把文件的封装格式进行转换，例如从avi转换为mp4格式或者flv格式等。实际上，转封装不需要对内部的音视频进行解码，只需要根据从输入文件中获取包含的数据流添加到输出文件中，然后将输入文件中的数据包按照规定格式写入到输出文件中去。</p><h3 id="1、解析命令行参数"><a href="#1、解析命令行参数" class="headerlink" title="1、解析命令行参数"></a>1、解析命令行参数</h3><p>如同之前的工程一样，我们使用命令行参数传入输入和输出的文件名。为此，我们定义了如下的结构体和函数来实现传入输入输出文件的过程：</p><pre><code>typedef struct _IOFiles&#123;    const char *inputName;    const char *outputName;&#125; IOFiles;static bool hello(int argc, char **argv, IOFiles &amp;io_param)&#123;    printf(&quot;FFMpeg Remuxing Demo.\nCommand format: %s inputfile outputfile\n&quot;, argv[0]);    if (argc != 3)    &#123;        printf(&quot;Error: command line error, please re-check.\n&quot;);        return false;    &#125;    io_param.inputName = argv[1];    io_param.outputName = argv[2];    return true;&#125;</code></pre><p>在main函数执行时，调用hello函数解析命令行并保存到IOFiles结构中：</p><pre><code>int main(int argc, char **argv)&#123;    IOFiles io_param;    if (!hello(argc, argv, io_param))    &#123;        return -1;    &#125;    //......&#125;</code></pre><h3 id="2、所需要的结构与初始化操作"><a href="#2、所需要的结构与初始化操作" class="headerlink" title="2、所需要的结构与初始化操作"></a>2、所需要的结构与初始化操作</h3><p>为了实现视频文件的转封装操作，我们需要以下的结构：</p><pre><code>AVOutputFormat *ofmt = NULL;AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL;AVPacket pkt;</code></pre><p>然后所需要的初始化操作有打开输入视频文件、获取其中的流信息和获取输出文件的句柄：</p><pre><code>av_register_all();//按封装格式打开输入视频文件if ((ret = avformat_open_input(&amp;ifmt_ctx, io_param.inputName, NULL, NULL)) &lt; 0)&#123;    printf(&quot;Error: Open input file failed.\n&quot;);    goto end;&#125;//获取输入视频文件中的流信息if ((ret = avformat_find_stream_info(ifmt_ctx, NULL)) &lt; 0)&#123;    printf(&quot;Error: Failed to retrieve input stream information.\n&quot;);    goto end;&#125;av_dump_format(ifmt_ctx, 0, io_param.inputName, 0);//按照文件名获取输出文件的句柄avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, io_param.outputName);if (!ofmt_ctx)&#123;    printf(&quot;Error: Could not create output context.\n&quot;);    goto end;&#125;ofmt = ofmt_ctx-&gt;oformat;</code></pre><h3 id="3、-向输出文件中添加Stream并打开输出文件"><a href="#3、-向输出文件中添加Stream并打开输出文件" class="headerlink" title="3、 向输出文件中添加Stream并打开输出文件"></a>3、 向输出文件中添加Stream并打开输出文件</h3><p>在我们获取到了输入文件中的流信息后，保持输入流中的codec不变，并以其为依据添加到输出文件中：</p><pre><code>for (unsigned int i = 0; i &lt; ifmt_ctx-&gt;nb_streams ; i++)&#123;    AVStream *inStream = ifmt_ctx-&gt;streams[i];    AVStream *outStream = avformat_new_stream(ofmt_ctx, inStream-&gt;codec-&gt;codec);    if (!outStream)    &#123;        printf(&quot;Error: Could not allocate output stream.\n&quot;);        goto end;    &#125;    ret = avcodec_copy_context(outStream-&gt;codec, inStream-&gt;codec);    outStream-&gt;codec-&gt;codec_tag = 0;    if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)    &#123;        outStream-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;    &#125;&#125;av_dump_format(ofmt_ctx, 0, io_param.outputName, 1);</code></pre><p>这里调用了函数avcodec_copy_context函数，该函数的声明如下：</p><pre><code>int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src);</code></pre><p>该函数的作用是将src表示的AVCodecContext中的内容拷贝到dest中。</p><p>随后，调用avio_open函数打开输出文件：</p><pre><code>av_dump_format(ofmt_ctx, 0, io_param.outputName, 1);if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE))&#123;    ret = avio_open(&amp;ofmt_ctx-&gt;pb, io_param.outputName, AVIO_FLAG_WRITE);    if (ret &lt; 0)    &#123;        printf(&quot;Error: Could not open output file.\n&quot;);        goto end;    &#125;&#125;</code></pre><h3 id="4、写入文件的音视频数据"><a href="#4、写入文件的音视频数据" class="headerlink" title="4、写入文件的音视频数据"></a>4、写入文件的音视频数据</h3><p>首先向输出文件中写入文件头:</p><pre><code>ret = avformat_write_header(ofmt_ctx, NULL);if (ret &lt; 0) &#123;    printf(&quot;Error: Could not write output file header.\n&quot;);    goto end;&#125;</code></pre><p>写入文件的视频和音频包数据，其实就是将音频和视频Packets从输入文件中读出来，正确设置pts和dts等时间量之后，再写入到输出文件中去：</p><pre><code>while (1) &#123;    AVStream *in_stream, *out_stream;    ret = av_read_frame(ifmt_ctx, &amp;pkt);    if (ret &lt; 0)        break;    in_stream  = ifmt_ctx-&gt;streams[pkt.stream_index];    out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];        /* copy packet */    pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));    pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));    pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);    pkt.pos = -1;    ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);    if (ret &lt; 0)     &#123;        fprintf(stderr, &quot;Error muxing packet\n&quot;);        break;    &#125;    av_free_packet(&amp;pkt);&#125;</code></pre><p>最后要做的就是写入文件尾：</p><pre><code>av_write_trailer(ofmt_ctx);</code></pre><h3 id="5、-收尾工作"><a href="#5、-收尾工作" class="headerlink" title="5、 收尾工作"></a>5、 收尾工作</h3><p>写入输出文件完成后，需要对打开的结构进行关闭或释放等操作。主要有关闭输入输出文件、释放输出文件的句柄等：</p><pre><code>avformat_close_input(&amp;ifmt_ctx);/* close output */if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE))    avio_closep(&amp;ofmt_ctx-&gt;pb);avformat_free_context(ofmt_ctx);if (ret &lt; 0 &amp;&amp; ret != AVERROR_EOF) &#123;    fprintf(stderr, &quot;Error failed to write packet to output file.\n&quot;);    return 1;&#125;</code></pre><hr><p>##七、 FFMpeg实现视频水印</p><p>视频的水印通常指附加在原始视频上的可见或者不可见的，与原始视频无直接关联的标识。通常在有线电视画面上电视台的台标以及视频网站上的logo就是典型的视频水印的应用场景。通常实现视频水印可以通过FFMpeg提供的libavfilter库实现。libavfilter库实际上实现的是视频的滤镜功能，除了水印之外，还可以实现视频帧的灰度化、平滑、翻转、直方图均衡、裁剪等操作。</p><p>我们这里实现的视频水印等操作，完全在视频像素域实现，即从一个yuv文件中读取数据到AVFrame结构，对AVFrame结构进行处理后再输出到另一个yuv文件。中间不涉及封装或编码解码等操作。</p><p>###1. 解析命令行，获取输入输出文件信息</p><p>我们通过与之前类似的方式，在命令行中获取输入、输出文件名，图像宽高。首先定义如下的结构体用于保存配置信息：</p><pre><code>typedef struct _IOFiles&#123;    const char *inputFileName;        //输入文件名    const char *outputFileName;        //输出文件名    FILE *iFile;                    //输入文件指针    FILE *oFile;                    //输出文件指针    uint8_t filterIdx;                //Filter索引    unsigned int frameWidth;        //图像宽度    unsigned int frameHeight;        //图像高度&#125;IOFiles;</code></pre><p>在这个结构体中，filterIdx用于表示当前工程选择哪一种filter，即希望实现哪一种功能。</p><p>在进入main函数之后，调用hello函数来解析命令行参数：</p><pre><code>static int hello(int argc, char **argv, IOFiles &amp;files)&#123;    if (argc &lt; 4)     &#123;        printf(&quot;usage: %s output_file input_file filter_index\n&quot;            &quot;Filter index:.\n&quot;            &quot;1. Color component\n&quot;            &quot;2. Blur\n&quot;            &quot;3. Horizonal flip\n&quot;            &quot;4. HUE\n&quot;            &quot;5. Crop\n&quot;            &quot;6. Box\n&quot;            &quot;7. Text\n&quot;            &quot;\n&quot;, argv[0]);        return -1;    &#125;    files.inputFileName = argv[1];    files.outputFileName = argv[2];    files.frameWidth = atoi(argv[3]);    files.frameHeight = atoi(argv[4]);    files.filterIdx = atoi(argv[5]);    fopen_s(&amp;files.iFile, files.inputFileName, &quot;rb+&quot;);    if (!files.iFile)    &#123;        printf(&quot;Error: open input file failed.\n&quot;);        return -1;    &#125;    fopen_s(&amp;files.oFile, files.outputFileName, &quot;wb+&quot;);    if (!files.oFile)    &#123;        printf(&quot;Error: open output file failed.\n&quot;);        return -1;    &#125;    return 0;&#125;</code></pre><p>该函数实现了输入输出文件的文件名获取并打开，并读取filter索引。</p><p>###2. Video Filter初始化</p><p>在进行初始化之前，必须调用filter的init函数，之后才能针对Video Filter进行各种操作。其声明如下：</p><pre><code>void avfilter_register_all(void);</code></pre><p>为了实现视频水印的功能，所需要的相关结构主要有：</p><pre><code>AVFilterContext *buffersink_ctx;  AVFilterContext *buffersrc_ctx;  AVFilterGraph *filter_graph;</code></pre><p>其中AVFilterContext用于表示一个filter的实例上下文，AVFilterGraph表示一个video filtering的工作流。Video Filter的初始化实现如以下函数：</p><pre><code>//初始化video filter相关的结构int Init_video_filter(const char *filter_descr, int width, int height)&#123;    char args[512];      AVFilter *buffersrc  = avfilter_get_by_name(&quot;buffer&quot;);      AVFilter *buffersink = avfilter_get_by_name(&quot;buffersink&quot;);      AVFilterInOut *outputs = avfilter_inout_alloc();      AVFilterInOut *inputs  = avfilter_inout_alloc();      enum AVPixelFormat pix_fmts[] = &#123; AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE &#125;;      AVBufferSinkParams *buffersink_params;      filter_graph = avfilter_graph_alloc();      /* buffer video source: the decoded frames from the decoder will be inserted here. */      snprintf(args, sizeof(args), &quot;video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:pixel_aspect=%d/%d&quot;, width,height,AV_PIX_FMT_YUV420P, 1, 25,1,1);    int ret = avfilter_graph_create_filter(&amp;buffersrc_ctx, buffersrc, &quot;in&quot;, args, NULL, filter_graph);      if (ret &lt; 0)     &#123;        printf(&quot;Error: cannot create buffer source.\n&quot;);          return ret;      &#125;      /* buffer video sink: to terminate the filter chain. */      buffersink_params = av_buffersink_params_alloc();      buffersink_params-&gt;pixel_fmts = pix_fmts;      ret = avfilter_graph_create_filter(&amp;buffersink_ctx, buffersink, &quot;out&quot;, NULL, buffersink_params, filter_graph);      av_free(buffersink_params);      if (ret &lt; 0)     &#123;        printf(&quot;Error: cannot create buffer sink\n&quot;);          return ret;    &#125;      /* Endpoints for the filter graph. */      outputs-&gt;name       = av_strdup(&quot;in&quot;);      outputs-&gt;filter_ctx = buffersrc_ctx;      outputs-&gt;pad_idx    = 0;      outputs-&gt;next       = NULL;      inputs-&gt;name       = av_strdup(&quot;out&quot;);      inputs-&gt;filter_ctx = buffersink_ctx;      inputs-&gt;pad_idx    = 0;      inputs-&gt;next       = NULL;      if ((ret = avfilter_graph_parse_ptr(filter_graph, filter_descr,    &amp;inputs, &amp;outputs, NULL)) &lt; 0)    &#123;        printf(&quot;Error: avfilter_graph_parse_ptr failed.\n&quot;);        return ret;      &#125;    if ((ret = avfilter_graph_config(filter_graph, NULL)) &lt; 0)      &#123;        printf(&quot;Error: avfilter_graph_config&quot;);        return ret;      &#125;    return 0;&#125;</code></pre><p>###3. 初始化输入输出AVFrame并分配内存</p><p>我们首先声明AVFrame类型的对象和指向像素缓存的指针：</p><pre><code>AVFrame *frame_in = NULL;  AVFrame *frame_out = NULL;  unsigned char *frame_buffer_in = NULL;  unsigned char *frame_buffer_out = NULL; </code></pre><p>然后分配AVFrame对象，并分配其中的缓存区：</p><pre><code>void Init_video_frame_in_out(AVFrame **frameIn, AVFrame **frameOut, unsigned char **frame_buffer_in, unsigned char **frame_buffer_out, int frameWidth, int frameHeight)&#123;    *frameIn = av_frame_alloc();      *frame_buffer_in = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, frameWidth,frameHeight,1));      av_image_fill_arrays((*frameIn)-&gt;data, (*frameIn)-&gt;linesize,*frame_buffer_in, AV_PIX_FMT_YUV420P,frameWidth,frameHeight,1);      *frameOut = av_frame_alloc();      *frame_buffer_out = (unsigned char *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, frameWidth,frameHeight,1));      av_image_fill_arrays((*frameOut)-&gt;data, (*frameOut)-&gt;linesize,*frame_buffer_out, AV_PIX_FMT_YUV420P,frameWidth,frameHeight,1);      (*frameIn)-&gt;width = frameWidth;      (*frameIn)-&gt;height = frameHeight;      (*frameIn)-&gt;format = AV_PIX_FMT_YUV420P;&#125;</code></pre><p>###4. Video Filtering循环体</p><p>这一部分主要包括三大部分：</p><ol><li>读取原始的YUV数据到输入的frame；</li><li>使用预先定义好的filter_graph处理输入frame，生成输出frame；</li><li>将输出frame中的像素值写入输出yuv文件；</li></ol><p>第一部分，读取原始yuv的实现由自定义函数Read_yuv_data_to_buf实现：</p><pre><code>//从输入yuv文件中读取数据到buffer和frame结构bool Read_yuv_data_to_buf(unsigned char *frame_buffer_in, const IOFiles &amp;files, AVFrame **frameIn)&#123;    AVFrame *pFrameIn = *frameIn;    int width = files.frameWidth, height = files.frameHeight;    int frameSize = width * height * 3 / 2;    if (fread_s(frame_buffer_in, frameSize, 1, frameSize, files.iFile) != frameSize)    &#123;        return false;    &#125;    pFrameIn-&gt;data[0] = frame_buffer_in;    pFrameIn-&gt;data[1] = pFrameIn-&gt;data[0] + width * height;    pFrameIn-&gt;data[2] = pFrameIn-&gt;data[1] + width * height / 4;    return true;&#125;</code></pre><p>第二部分实际上分为两部分，即将输入frame送入filter graph，以及从filter graph中取出输出frame。实现方法分别为：</p><pre><code>//将待处理的输入frame添加进filter graphbool Add_frame_to_filter(AVFrame *frameIn)&#123;    if (av_buffersrc_add_frame(buffersrc_ctx, frameIn) &lt; 0)     &#123;          return false;      &#125;      return true;&#125;//从filter graph中获取输出frameint Get_frame_from_filter(AVFrame **frameOut)&#123;    if (av_buffersink_get_frame(buffersink_ctx, *frameOut) &lt; 0)    &#123;        return false;    &#125;    return true;&#125;</code></pre><p>第三部分，写出输出frame到输出yuv文件：</p><pre><code>//从输出frame中写出像素数据到输出文件void Write_yuv_to_outfile(const AVFrame *frame_out, IOFiles &amp;files)&#123;    if(frame_out-&gt;format==AV_PIX_FMT_YUV420P)    &#123;          for(int i=0;i&lt;frame_out-&gt;height;i++)        &#123;              fwrite(frame_out-&gt;data[0]+frame_out-&gt;linesize[0]*i,1,frame_out-&gt;width,files.oFile);          &#125;          for(int i=0;i&lt;frame_out-&gt;height/2;i++)        &#123;              fwrite(frame_out-&gt;data[1]+frame_out-&gt;linesize[1]*i,1,frame_out-&gt;width/2,files.oFile);          &#125;          for(int i=0;i&lt;frame_out-&gt;height/2;i++)        &#123;              fwrite(frame_out-&gt;data[2]+frame_out-&gt;linesize[2]*i,1,frame_out-&gt;width/2,files.oFile);          &#125;      &#125;  &#125;</code></pre><p>该部分的综合实现如下：</p><pre><code>while (Read_yuv_data_to_buf(frame_buffer_in, files, &amp;frame_in)) &#123;    //将输入frame添加到filter graph    if (!Add_frame_to_filter(frame_in))    &#123;        printf(&quot;Error while adding frame.\n&quot;);        goto end;    &#125;    //从filter graph中获取输出frame    if (!Get_frame_from_filter(&amp;frame_out))    &#123;        printf(&quot;Error while getting frame.\n&quot;);        goto end;    &#125;    //将输出frame写出到输出文件    Write_yuv_to_outfile(frame_out, files);    printf(&quot;Process 1 frame!\n&quot;);      av_frame_unref(frame_out);  &#125;</code></pre><p>###5、 收尾工作</p><p>整体实现完成后，需要进行善后的收尾工作有释放输入和输出frame、关闭输入输出文件，以及释放filter graph：</p><pre><code>//关闭文件及相关结构fclose(files.iFile);fclose(files.oFile);av_frame_free(&amp;frame_in);av_frame_free(&amp;frame_out);avfilter_graph_free(&amp;filter_graph);</code></pre><hr><h2 id="八、-FFMpeg实现视频缩放"><a href="#八、-FFMpeg实现视频缩放" class="headerlink" title="八、 FFMpeg实现视频缩放"></a>八、 FFMpeg实现视频缩放</h2><p>视频缩放是视频开发中一项最基本的功能。通过对视频的像素数据进行采样或插值，可以将低分辨率的视频转换到更高的分辨率，或者将高分辨率的视频转换为更低的分辨率。通过FFMpeg提供了libswscale库，可以轻松实现视频的分辨率转换功能。除此之外，libswscale库还可以实现颜色空间转换等功能。</p><p>通常情况下视频缩放的主要思想是对视频进行解码到像素域后，针对像素域的像素值进行采样或差值操作。这种方式需要在解码端消耗一定时间，但是通用性最好，不需要对码流格式作出任何特殊处理。在FFMpeg中libswscale库也是针对AVFrame结构进行缩放处理。</p><h3 id="1-解析命令行参数"><a href="#1-解析命令行参数" class="headerlink" title="1. 解析命令行参数"></a>1. 解析命令行参数</h3><p>输入输出的数据使用以下结构进行封装：</p><pre><code>typedef struct _IOFiles&#123;    char *inputName;            //输入文件名    char *outputName;            //输出文件名    char *inputFrameSize;        //输入图像的尺寸    char *outputFrameSize;        //输出图像的尺寸    FILE *iFile;                //输入文件指针    FILE *oFile;                //输出文件指针&#125; IOFiles;</code></pre><p>输入参数解析过程为：</p><pre><code>static bool hello(int argc, char **argv, IOFiles &amp;files)&#123;    printf(&quot;FFMpeg Scaling Demo.\nCommand format: %s input_file input_frame_size output_file output_frame_size\n&quot;, argv[0]);    if (argc != 5)    &#123;        printf(&quot;Error: command line error, please re-check.\n&quot;);        return false;    &#125;    files.inputName = argv[1];    files.inputFrameSize = argv[2];    files.outputName = argv[3];    files.outputFrameSize = argv[4];    fopen_s(&amp;files.iFile, files.inputName, &quot;rb+&quot;);    if (!files.iFile)    &#123;        printf(&quot;Error: cannot open input file.\n&quot;);        return false;    &#125;    fopen_s(&amp;files.oFile, files.outputName, &quot;wb+&quot;);    if (!files.oFile)    &#123;        printf(&quot;Error: cannot open output file.\n&quot;);        return false;    &#125;    return true;&#125;</code></pre><p>在参数读入完成后，需要从表示视频分辨率的字符串中解析出图像的宽和高两个值。我们在命令行中传入的视频分辨率字符串的格式为“width x height”，例如”720x480”。解析过程需要调用av_parse_video_size函数。声明如下：</p><pre><code>int av_parse_video_size(int *width_ptr, int *height_ptr, const char *str);</code></pre><p>例如，我们传入下面的参数：</p><pre><code>int frameWidth, frameHeight;av_parse_video_size(&amp;frameWidth, &amp;frameHeight, &quot;720x480&quot;);</code></pre><p>函数将分别把720和480传入frameWidth和frameHeight中。</p><p>在获取命令行参数后，调用该函数解析图像分辨率：</p><pre><code>int srcWidth, srcHeight, dstWidth, dstHeight;if (av_parse_video_size(&amp;srcWidth, &amp;srcHeight, files.inputFrameSize))&#123;    printf(&quot;Error: parsing input size failed.\n&quot;);    goto end;&#125;if (av_parse_video_size(&amp;dstWidth, &amp;dstHeight, files.outputFrameSize))&#123;    printf(&quot;Error: parsing output size failed.\n&quot;);    goto end;&#125;</code></pre><p>这样，我们就获得了源和目标图像的宽和高度。</p><h3 id="2-创建SwsContext结构"><a href="#2-创建SwsContext结构" class="headerlink" title="2. 创建SwsContext结构"></a>2. 创建SwsContext结构</h3><p>进行视频的缩放操作离不开libswscale的一个关键的结构，即SwsContext，该结构提供了缩放操作的必要参数。创建该结构需调用函数sws_getContext。该函数的声明如下：</p><pre><code>struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,                                  int dstW, int dstH, enum AVPixelFormat dstFormat,                                  int flags, SwsFilter *srcFilter,                                  SwsFilter *dstFilter, const double *param);</code></pre><p>该函数的前两行参数分别表示输入和输出图像的宽、高、像素格式，参数flags表示采样和差值使用的算法，常用的有SWS_BILINEAR表示双线性差值等。剩余的不常用参数通常设为NULL。创建该结构的代码如：</p><pre><code>//创建SwsContext结构enum AVPixelFormat src_pix_fmt = AV_PIX_FMT_YUV420P;enum AVPixelFormat dst_pix_fmt = AV_PIX_FMT_YUV420P;struct SwsContext *sws_ctx = sws_getContext(srcWidth, srcHeight, src_pix_fmt, dstWidth, dstHeight, dst_pix_fmt, SWS_BILINEAR, NULL,NULL,NULL );if (!sws_ctx)&#123;    printf(&quot;Error: parsing output size failed.\n&quot;);    goto end;&#125;</code></pre><h3 id="3-分配像素缓存"><a href="#3-分配像素缓存" class="headerlink" title="3. 分配像素缓存"></a>3. 分配像素缓存</h3><p>视频缩放实际上是在像素域实现，但是实际上我们没有必要真的建立一个个AVFrame对象，我们只需要其像素缓存空间即可，我们定义两个指针数组和两个保存stride的数组，并为其分配内存区域：</p><pre><code>//分配input和outputuint8_t *src_data[4], *dst_data[4];int src_linesize[4], dst_linesize[4];if ((ret = av_image_alloc(src_data, src_linesize, srcWidth, srcHeight, src_pix_fmt, 32)) &lt; 0)&#123;    printf(&quot;Error: allocating src image failed.\n&quot;);    goto end;&#125;    if ((ret = av_image_alloc(dst_data, dst_linesize, dstWidth, dstHeight, dst_pix_fmt, 1)) &lt; 0)&#123;    printf(&quot;Error: allocating dst image failed.\n&quot;);    goto end;&#125;</code></pre><h3 id="4-循环处理输入frame"><a href="#4-循环处理输入frame" class="headerlink" title="4. 循环处理输入frame"></a>4. 循环处理输入frame</h3><p>循环处理的代码为：</p><pre><code>//从输出frame中写出到输出文件int dst_bufsize = ret;for (int idx = 0; idx &lt; MAX_FRAME_NUM; idx++)&#123;    read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 0, files);    read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 1, files);    read_yuv_from_ifile(src_data, src_linesize, srcWidth, srcHeight, 2, files);    sws_scale(sws_ctx, (const uint8_t * const*)src_data, src_linesize, 0, srcHeight, dst_data, dst_linesize);    fwrite(dst_data[0], 1, dst_bufsize, files.oFile);&#125;</code></pre><p>其核心函数为sws_scale，其声明为：</p><pre><code>int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],          const int srcStride[], int srcSliceY, int srcSliceH,          uint8_t *const dst[], const int dstStride[]);</code></pre><p>该函数的各个参数比较容易理解，除了第一个是之前创建的SwsContext之外，其他基本上都是源和目标图像的缓存区和大小等。在写完一帧后，调用fwrite将输出的目标图像写入输出yuv文件中。</p><h3 id="5-收尾工作"><a href="#5-收尾工作" class="headerlink" title="5. 收尾工作"></a>5. 收尾工作</h3><p>收尾工作除了释放缓存区和关闭输入输出文件之外，就是需要释放SwsContext结构，需调用函数：sws_freeContext。实现过程为：</p><pre><code>fclose(files.iFile);fclose(files.oFile);av_freep(&amp;src_data[0]);av_freep(&amp;dst_data[0]);sws_freeContext(sws_ctx);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于php 编译安装 遇到的坑总结</title>
      <link href="2020/07/03/php-php-install-log-2020-07-03/"/>
      <url>2020/07/03/php-php-install-log-2020-07-03/</url>
      
        <content type="html"><![CDATA[<h2 id="关于php-编译安装-遇到的坑总结"><a href="#关于php-编译安装-遇到的坑总结" class="headerlink" title="关于php 编译安装 遇到的坑总结"></a>关于php 编译安装 遇到的坑总结</h2><blockquote><p>每一次记录都是成长的过程</p></blockquote><p>因为公司服务器问题，我们临时打算将测试环境的php 环境 先升级到 7.0 左右 ，然后我就接下了这个坑。</p><p>我的系统环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISTRIB_ID&#x3D;Ubuntu</span><br><span class="line">DISTRIB_RELEASE&#x3D;14.04</span><br><span class="line">DISTRIB_CODENAME&#x3D;trusty</span><br><span class="line">DISTRIB_DESCRIPTION&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line"></span><br><span class="line">Linux iZbp13psr6fb9tfovzicnmZ 3.2.0-126-generic #169-Ubuntu SMP Fri Mar 31 14:15:21 UTC 2017 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><p>话不多说，首先贴出我这次遇到的问题</p><ul><li>问题一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: xslt-config not found. Please reinstall the libxslt &gt;&#x3D; 1.1.0 distribution</span><br></pre></td></tr></table></figure><ul><li>问题二：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: Unable to locate package libxslt1-devel</span><br></pre></td></tr></table></figure></li><li>问题三：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php 7.0 make: *** [ext&#x2F;gd&#x2F;libgd&#x2F;gd_png.lo] error 1</span><br></pre></td></tr></table></figure></li><li>问题四：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [sapi&#x2F;cli&#x2F;php] Error 1</span><br></pre></td></tr></table></figure></li></ul><p>具体问题 我就不过多阐述了，上述问题也不是最终的问题指向，其他因为扩展的问题，我也不多说了。总之一句话，直接升级除了坑就是麻烦</p><h3 id="老系统建议直接升级"><a href="#老系统建议直接升级" class="headerlink" title="老系统建议直接升级"></a>老系统建议直接升级</h3><ul><li>问题一、问题二</li></ul><p>这个问题其实很简单，但是对于 一个 浅度的 Ubuntu 用户来说，其实这是致命的一个问题</p><p>看到这个问题 我们可以直接去 用系统的命令去安装，可是 ubuntu 使用 apt-get install 的时候 就会出现第二个问题。</p><p>发生这种情况的时候，我们有两个解决方案 </p><ol><li>直接去 google 上面 搜索对应的扩展包，执行编译 安装到系统</li><li>搜索大佬的解决方案</li></ol><p>本着能偷懒就偷懒的性格，我选择了第二个方案</p><p>然后 我就看到各种 关于 ubuntu 的系统 search package 的解决方案</p><p>有 提示 让我直接 apt-get update 的。（公司服务器 阿里云）<br>当我直接 更新后，第二个问题基本没有解决，而且，还更严重了，直接 就是 对应的 libgd 的扩展 全部都找不到了</p><p>这让我如何是好啊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libbz2-dev libcurl4-gnutls-dev libssl-dev libc-client2007e libc-client2007e-dev libcurl4-openssl-dev libpq-dev libxslt1-dev libxpm-dev build-essential</span><br></pre></td></tr></table></figure><p>然后我发现 在 ubuntu 上 需要这样去找 你敢信 <strong><em>libbz2-dev</em></strong> <strong><em>libxslt1-dev</em></strong> 还有先后顺序</p><p>不过好在 问题 顺利解决了</p><h3 id="魔鬼出在细节里"><a href="#魔鬼出在细节里" class="headerlink" title="魔鬼出在细节里"></a>魔鬼出在细节里</h3><p>为了保证 有一个 良好的周六日 不会被公司的小伙伴们 用远程电话叫醒 这次安装环境 原先的环境 我并没有删除</p><p>然后 <strong><em>问题三</em></strong> 出现了 （原报错非常多，没有一一记录）</p><p>大致的问题就是 我使用的 <strong><em>gd_png</em></strong> 出现了不可知的意外错误</p><p>看到这里 我已经开始怀疑 php 关于gd 库的bug 是不是没有解决的问题了。熟练的上 <a href="php.net">php.net</a> 搜索了一会儿 版本记录。发现这个问题已经被解决了。那就很奇怪，我这里的问题又是怎么发生的呢？</p><p>上面的 php 环境没有删除 划重点 &lt;\-_-/&gt;</p><p>仔细 看了看错误信息 因为 ./configure 已经通过了 现在是 make 失败 说明 php 不存在 bug 那么多半出在 扩展上</p><blockquote><p>ext/gd/libgd/gd_png.c</p></blockquote><p>我根据提示错误信息 找到了 对应文件 然后 搜索了自己的系统 发现存在多个 png.h 的文件 </p><p>难道是 png.h 引用错误？</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/04/NvMe0J.png" alt="NvMe0J.png"></p><p>上面图片 请根据 自己系统中的文件 更换 绝对路径</p><h3 id="发生了问题，多半都是基础知识的复习"><a href="#发生了问题，多半都是基础知识的复习" class="headerlink" title="发生了问题，多半都是基础知识的复习"></a>发生了问题，多半都是基础知识的复习</h3><p>当解决掉一大堆问题之后，我们终于来到了最后一步，看着终端不停的输出 我甚至在 make 后面 加上了 j4</p><p>然后就发生了第四个问题</p><blockquote><p>这次的报错还是 gd 库的问题</p></blockquote><p>无奈，我们已经排除了所有的答案，但是 这个错误很迷惑 因为它涉及到了 sapi 的问题 说明 已经进入了编译的后半段阶段，按道理来说 gd 库已经编译成功了，应该已经进入 其他阶段了，请看下面的示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/07/04/NvM2As.png" alt="NvM2As.png"></p><p>在安裝 PHP 到系统中时要是发生「undefined reference to libiconv_open’」之类的错误信息，那表示在「./configure 」沒抓好一些环境变数值。错误发生点在建立「-o sapi/cli/php」是出错，没給到要 link 的 iconv 函式库参数。 解决方法：编辑Makefile 大约77 行左右的地方: EXTRA_LIBS = ….. -lcrypt 在最后加上 -liconv，例如: EXTRA_LIBS = ….. -lcrypt -liconv 然后重新再次 make 即可。</p><p>或者用另一种办法</p><p>make ZEND_EXTRA_LIBS=’-liconv’</p><p>ln -s /usr/local/lib/libiconv.so.2 /usr/lib64/</p><p>记得先make clean一下</p><h3 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp13psr6fb9tfovzicnmZ:&#x2F;alidata&#x2F;server&#x2F;php-7.0.23# make install</span><br><span class="line">Installing shared extensions:     &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20151012&#x2F;</span><br><span class="line">Installing PHP CLI binary:        &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin&#x2F;</span><br><span class="line">Installing PHP CLI man page:      &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;man&#x2F;man1&#x2F;</span><br><span class="line">Installing PHP FPM binary:        &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;sbin&#x2F;</span><br><span class="line">Installing PHP FPM defconfig:     &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;etc&#x2F;</span><br><span class="line">Installing PHP FPM man page:      &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;man&#x2F;man8&#x2F;</span><br><span class="line">Installing PHP FPM status page:   &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;php&#x2F;fpm&#x2F;</span><br><span class="line">Installing phpdbg binary:         &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin&#x2F;</span><br><span class="line">Installing phpdbg man page:       &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;man&#x2F;man1&#x2F;</span><br><span class="line">Installing PHP CGI binary:        &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin&#x2F;</span><br><span class="line">Installing PHP CGI man page:      &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;man&#x2F;man1&#x2F;</span><br><span class="line">Installing build environment:     &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;lib&#x2F;php&#x2F;build&#x2F;</span><br><span class="line">Installing header files:          &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;include&#x2F;php&#x2F;</span><br><span class="line">Installing helper programs:       &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin&#x2F;</span><br><span class="line">  program: phpize</span><br><span class="line">  program: php-config</span><br><span class="line">Installing man pages:             &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;php&#x2F;man&#x2F;man1&#x2F;</span><br><span class="line">  page: phpize.1</span><br><span class="line">  page: php-config.1</span><br><span class="line">Installing PEAR environment:      &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;lib&#x2F;php&#x2F;</span><br><span class="line">[PEAR] Archive_Tar    - installed: 1.4.3</span><br><span class="line">[PEAR] Console_Getopt - installed: 1.4.1</span><br><span class="line">[PEAR] Structures_Graph- installed: 1.1.1</span><br><span class="line">[PEAR] XML_Util       - installed: 1.4.2</span><br><span class="line">[PEAR] PEAR           - installed: 1.10.5</span><br><span class="line">Wrote PEAR system config file at: &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;etc&#x2F;pear.conf</span><br><span class="line">You may want to add: &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;lib&#x2F;php to your php.ini include_path</span><br><span class="line">&#x2F;alidata&#x2F;server&#x2F;php-7.0.23&#x2F;build&#x2F;shtool install -c ext&#x2F;phar&#x2F;phar.phar &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin</span><br><span class="line">ln -s -f phar.phar &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;bin&#x2F;phar</span><br><span class="line">Installing PDO headers:           &#x2F;alidata&#x2F;server&#x2F;php70&#x2F;include&#x2F;php&#x2F;ext&#x2F;pdo&#x2F;</span><br></pre></td></tr></table></figure><h3 id="附属链接-帮助记录"><a href="#附属链接-帮助记录" class="headerlink" title="附属链接-帮助记录"></a>附属链接-帮助记录</h3><p>软件包: libxslt1-dev (1.1.28-2.1ubuntu0.3 以及其他的) [security]</p><p><a href="https://packages.ubuntu.com/xenial/libxslt1-dev">https://packages.ubuntu.com/xenial/libxslt1-dev</a></p><p>Ubuntu 16.04 编译安装Nginx-1.10.3、 PHP7.0.9、Redis3.0 扩展、Phalcon3.1 扩展、Swoole1.9.8 扩展、ssh2扩展（全程编译安装）<br><a href="https://www.cnblogs.com/tinywan/p/6607395.html">https://www.cnblogs.com/tinywan/p/6607395.html</a></p><h4 id="下载必要软件包"><a href="#下载必要软件包" class="headerlink" title="下载必要软件包"></a>下载必要软件包</h4><ol><li>libxml2-2.6.30.tar.gz （一个xml c语言版的解析器）<br><a href="ftp://ftp.gnome.org/pub/GNOME/sources/libxml2/2.6/libxml2-2.6.30.tar.gz">ftp://ftp.gnome.org/pub/GNOME/sources/libxml2/2.6/libxml2-2.6.30.tar.gz</a></li><li>libmcrypt-2.5.8.tar.gz （php中mcrypt扩展,libmcrypt是加密算法扩展库）<br><a href="http://prdownloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?use_mirror=peterhost">http://prdownloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?use_mirror=peterhost</a></li><li>zlib-1.2.7.tar.gz （提供数据压缩用的函式库，为安装gd库做准备）<br><a href="http://zlib.net/fossils/zlib-1.2.7.tar.gz">http://zlib.net/fossils/zlib-1.2.7.tar.gz</a></li><li>libpng-1.2.31.tar.gz （软件包包含 libpng 库.这些库被其他程式用于读写png文件，为安装gd库做准备）<br><a href="ftp://194.54.81.27/services/customapache/libpng-1.2.31.tar.gz">ftp://194.54.81.27/services/customapache/libpng-1.2.31.tar.gz</a></li><li>jpegsrc.v6b.tar.gz （为安装gd库做准备）<br><a href="http://www.ijg.org/files/jpegsrc.v6b.tar.gz">http://www.ijg.org/files/jpegsrc.v6b.tar.gz</a></li><li>freetype-2.3.5.tar.gz （字体库文件，为GD库做准备） <a href="http://download.savannah.gnu.org/releases/freetype/freetype-2.3.5.tar.gz">http://download.savannah.gnu.org/releases/freetype/freetype-2.3.5.tar.gz</a></li><li>autoconf-2.61.tar.gz （是用来产生configure文件的。）<br><a href="ftp://ftp.gnu.org/gnu/autoconf/autoconf-2.61.tar.gz">ftp://ftp.gnu.org/gnu/autoconf/autoconf-2.61.tar.gz</a></li><li>libgd-2.1.0.tar.gz（是php处理图形的扩展库）<br><a href="https://bitbucket.org/libgd/gd-libgd/downloads/libgd-2.1.0.tar.gz">https://bitbucket.org/libgd/gd-libgd/downloads/libgd-2.1.0.tar.gz</a></li><li>ngnix<br><a href="http://nginx.org/download/nginx-1.0.15.tar.gz">http://nginx.org/download/nginx-1.0.15.tar.gz</a></li><li>pcre （一个正则表达式库，nginx伪静态可以用到）<br><a href="http://ftp.exim.llorien.org/pcre/pcre-8.36.tar.gz">http://ftp.exim.llorien.org/pcre/pcre-8.36.tar.gz</a></li><li>mysql<br><a href="http://mysql.mirror.kangaroot.net/Downloads/MySQL-5.6/mysql-5.6.27.tar.gz">http://mysql.mirror.kangaroot.net/Downloads/MySQL-5.6/mysql-5.6.27.tar.gz</a></li><li>php<br><a href="http://cn2.php.net/get/php-5.6.9.tar.gz/from/a/mirror">http://cn2.php.net/get/php-5.6.9.tar.gz/from/a/mirror</a></li><li>cmake （编译mysql）<br><a href="http://www.cmake.org/files/v3.2/cmake-3.2.2.tar.gz">http://www.cmake.org/files/v3.2/cmake-3.2.2.tar.gz</a></li><li>zend guard （php脚本加密）<br><a href="http://downloads.zend.com/guard/5.5.0/ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz">http://downloads.zend.com/guard/5.5.0/ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz</a><br>下载apache<br><a href="http://www.apache.org/dist/httpd/httpd-2.4.17.tar.gz">http://www.apache.org/dist/httpd/httpd-2.4.17.tar.gz</a><br>下载apr（Apache库文件）<br><a href="http://mirror.bit.edu.cn/apache/apr/apr-1.5.2.tar.gz">http://mirror.bit.edu.cn/apache/apr/apr-1.5.2.tar.gz</a><br>下载apr-util（Apache库文件）<br><a href="http://mirror.bit.edu.cn/apache/apr/apr-util-1.5.4.tar.gz">http://mirror.bit.edu.cn/apache/apr/apr-util-1.5.4.tar.gz</a><br>php7<br><a href="https://github.com/php/php-src/archive/php-7.0.0.tar.gz">https://github.com/php/php-src/archive/php-7.0.0.tar.gz</a></li></ol><h4 id="一些排错的坑"><a href="#一些排错的坑" class="headerlink" title="一些排错的坑"></a>一些排错的坑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; makeinstall</span><br></pre></td></tr></table></figure><p><strong>错误处理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** [nanohttp.lo] Error 1打开目录下的nanohttp.c，第1588行由</span><br><span class="line">fd &#x3D; open(filename, O_CREAT | O_WRONLY);更换为 fd &#x3D; open(filename, O_CREAT | O_WRONLY,0777);</span><br></pre></td></tr></table></figure><ul><li>cd /usr/local/src/libmcrypt-2.5.8<br>./configure –prefix=/usr/local/libmcrypt<br>出现错误：<br>checking for C++ compiler default output file name… configure: error: C++ compiler cannot create executablesSee `config.log’ for more details.<br>解决办法：<br>sudo apt-get install g++<br>make &amp;&amp; make install</li></ul><h5 id="cd-usr-local-src-zlib-1-2-3"><a href="#cd-usr-local-src-zlib-1-2-3" class="headerlink" title="cd /usr/local/src/zlib-1.2.3"></a>cd /usr/local/src/zlib-1.2.3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;zlib</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="cd-usr-local-src-libpng-1-2-3"><a href="#cd-usr-local-src-libpng-1-2-3" class="headerlink" title="cd /usr/local/src/libpng-1.2.3"></a>cd /usr/local/src/libpng-1.2.3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;libpng</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="cd-usr-local-src-zlib-1-2-3-1"><a href="#cd-usr-local-src-zlib-1-2-3-1" class="headerlink" title="cd /usr/local/src/zlib-1.2.3"></a>cd /usr/local/src/zlib-1.2.3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;zlib</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>在安装过程中会出现如下错误：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: zlib not installed </span><br></pre></td></tr></table></figure><p><strong>解决的办法是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib-1.2.3 </span><br><span class="line">make clean 清除上一次make产生的文件，然后 .&#x2F;configure make &amp;&amp; make install </span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;libpng-1.2.3</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;libpng</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="安装jpeg6库文件"><a href="#安装jpeg6库文件" class="headerlink" title="安装jpeg6库文件"></a>安装jpeg6库文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jpeg6</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jpeg6&#x2F;bin</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jpeg6&#x2F;lib</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;jpeg6&#x2F;include</span><br><span class="line">mkdir  -p &#x2F;usr&#x2F;local&#x2F;jpeg6&#x2F;man&#x2F;man1</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;jpeg6&#x2F;jpeg-6b</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;jpeg6 </span><br><span class="line">--enable-shared    建立共享库使用的GNU libtool</span><br><span class="line">--enable-static      建立静态库使用的libtool</span><br><span class="line">make &amp;&amp; make insall </span><br></pre></td></tr></table></figure><h5 id="cd-usr-local-src-freetype-2-3-5"><a href="#cd-usr-local-src-freetype-2-3-5" class="headerlink" title="cd  /usr/local/src/freetype-2.3.5"></a>cd  /usr/local/src/freetype-2.3.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;freetype</span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure><h5 id="cd-usr-local-src-autoconf-2-61"><a href="#cd-usr-local-src-autoconf-2-61" class="headerlink" title="cd /usr/local/src/autoconf-2.61"></a>cd /usr/local/src/autoconf-2.61</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure make &amp;&amp; makeinstall</span><br></pre></td></tr></table></figure><h5 id="安装GD库"><a href="#安装GD库" class="headerlink" title="安装GD库"></a>安装GD库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;libgd-2.1.0</span><br><span class="line">.&#x2F;configure \</span><br><span class="line"> --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gd2&#x2F;  \</span><br><span class="line"> --with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;zlib&#x2F; \</span><br><span class="line"> --with-jpeg&#x3D;&#x2F;usr&#x2F;local&#x2F;jpeg6&#x2F; \</span><br><span class="line"> --with-png&#x3D;&#x2F;usr&#x2F;local&#x2F;libpng&#x2F; \</span><br><span class="line"> --with-freetype&#x3D;&#x2F;usr&#x2F;local&#x2F;freetype&#x2F; </span><br><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure><p><strong>以上子make过程中会出现如下错误：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">“gd_png.c:16:53: error: png.h: No such file or directory</span><br><span class="line">gd_png.c:47: error: expected specifier-qualifier-list before &#39;jmp_buf&#39;</span><br><span class="line">gd_png.c:54: error: expected &#39;)&#39; before &#39;png_ptr&#39;</span><br><span class="line">gd_png.c:82: error: expected &#39;)&#39; before &#39;png_ptr&#39;</span><br><span class="line">gd_png.c:92: error: expected &#39;)&#39; before &#39;png_ptr&#39;</span><br><span class="line">gd_png.c:98: error: expected &#39;)&#39; before &#39;png_ptr&#39;”</span><br></pre></td></tr></table></figure><p>处理方法：<br>vi gd_png.c<br>将#include “png.h”<br>替换成：#include “/usr/local/libpng/include/png.h”<br>然后再make就可以了<br>注：include“”双引号里包含的是libpng安装的路径里的include文件夹里的png.h文件</p><h5 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">tar zxvf cmake-2.8.9.tar.gz</span><br><span class="line">cd cmake-2.8.9</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="pcre"><a href="#pcre" class="headerlink" title="pcre"></a>pcre</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;pcre #创建安装目录</span><br><span class="line">tar zxvf pcre-8.30.tar.gz</span><br><span class="line">cd pcre-8.30</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;pcre #配置</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="安装apr"><a href="#安装apr" class="headerlink" title="安装apr"></a>安装apr</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">tar zxvf  apr-1.4.6.tar.gzcd apr-1.4.6</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr makemake install</span><br></pre></td></tr></table></figure><h5 id="安装apr-util"><a href="#安装apr-util" class="headerlink" title="安装apr-util"></a>安装apr-util</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf apr-util-1.4.1.tar.gz</span><br><span class="line">cd apr-util-1.4.1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr-util --with-apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr&#x2F;bin&#x2F;apr-util</span><br><span class="line">.&#x2F;configure make &amp;&amp; make install </span><br></pre></td></tr></table></figure><h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h5><ul><li>groupadd mysql #添加mysql组</li><li>useradd -g mysql mysql -s /bin/false #创建用户mysql并加入到mysql组，不允许mysql用户直接登录系统</li><li>mkdir -p /data/mysql #创建MySQL数据库存放目录</li><li>chown -R mysql:mysql /data/mysql #设置MySQL数据库目录权限</li><li>mkdir -p /usr/local/mysql #创建MySQL安装目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">tar zxvf mysql-5.5.27.tar.gz</span><br><span class="line">cd mysql-5.5.27</span><br><span class="line">cmake . -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql -DMYSQL_DATADIR&#x3D;&#x2F;data&#x2F;mysql -DSYSCONFDIR&#x3D;&#x2F;etc #配置 </span><br></pre></td></tr></table></figure></li><li>*出现如下错误：**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at cmake&#x2F;readline.cmake:83 (MESSAGE):</span><br><span class="line">  ...</span><br><span class="line">  cmake&#x2F;readline.cmake:127 (FIND_CURSES)</span><br><span class="line">  cmake&#x2F;readline.cmake:217 (MYSQL_USE_BUNDLED_LIBEDIT)</span><br><span class="line">  CMakeLists.txt:268 (MYSQL_CHECK_READLINE)</span><br><span class="line">  Configuring incomplete, errors occurred!</span><br><span class="line"> 如回显所示，ubuntu下安装libncurses5-dev；redhat下安装ncurses-devel，并删除当前目录CMakeCache.txt(必须删除，否则报错依旧)并重新运行：$ cmake .</span><br></pre></td></tr></table></figure></li><li>*解决：**</li></ul><ol><li>remove CMakeCache.txt；</li><li>yum install ncurses-devel  或 sudo apt-get install libncurses5-dev</li><li>重新运行cmake  .</li></ol><p>make &amp;&amp; make install</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">* 配置mysql: cd &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">cp .&#x2F;support-files&#x2F;my-huge.cnf &#x2F;etc&#x2F;my.cnf </span><br><span class="line"></span><br><span class="line">#拷贝配置文件（注意：如果&#x2F;etc目录下面默认有一个my.cnf，直接覆盖即可）</span><br><span class="line"></span><br><span class="line">vi &#x2F;etc&#x2F;my.cnf </span><br><span class="line">#编辑配置文件,在 [mysqld] 部分增加 datadir &#x3D; &#x2F;data&#x2F;mysql </span><br><span class="line">#添加MySQL数据库路径</span><br><span class="line">.&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql </span><br><span class="line">#生成mysql系统数据库</span><br><span class="line">cp .&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld </span><br><span class="line">#把Mysql加入系统启动</span><br><span class="line">chmod 755 &#x2F;etc&#x2F;init.d&#x2F;mysqld </span><br><span class="line">#增加执行权限</span><br><span class="line">chkconfig mysqld on </span><br><span class="line">#加入开机启动</span><br><span class="line">vi &#x2F;etc&#x2F;init.d&#x2F;mysqld </span><br><span class="line">#编辑</span><br><span class="line">basedir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql </span><br><span class="line">#MySQL程序安装路径</span><br><span class="line">datadir &#x3D; &#x2F;data&#x2F;mysql </span><br><span class="line">#MySQl数据库存放目录</span><br><span class="line">service mysqld start </span><br><span class="line">#启动</span><br><span class="line">vi &#x2F;etc&#x2F;profile </span><br><span class="line">#把mysql服务加入系统环境变量：在最后添加下面这一行 export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin</span><br><span class="line"></span><br><span class="line">下面这两行把myslq的库文件链接到系统默认的位置，这样你在编译类似PHP等软件时可以不用指定mysql的库文件地址。</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;mysql &#x2F;usr&#x2F;lib&#x2F;mysql</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;include&#x2F;mysql &#x2F;usr&#x2F;include&#x2F;mysql</span><br><span class="line"></span><br><span class="line">shutdown -r now </span><br><span class="line">#需要重启系统，等待系统重新启动之后继续在终端命令行下面操作</span><br><span class="line"></span><br><span class="line">mysql_secure_installation </span><br><span class="line">#设置Mysql密码</span><br><span class="line"></span><br><span class="line">根据提示按Y 回车输入2次密码</span><br><span class="line"></span><br><span class="line">或者直接修改密码&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqladmin -u root -p password &quot;123456&quot; </span><br><span class="line">#修改密码</span><br><span class="line">service mysqld restart </span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line"></span><br><span class="line">到此，mysql安装完成！</span><br></pre></td></tr></table></figure><h5 id="安装apache2"><a href="#安装apache2" class="headerlink" title="安装apache2"></a>安装apache2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;srctar -zvxf httpd-2.4.1.tar.gzcd  httpd-2.4.1mkdir -p &#x2F;usr&#x2F;local&#x2F;apache2  </span><br><span class="line">#创建安装目录1 </span><br></pre></td></tr></table></figure><ul><li><p>配置一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apache2 --with-apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr --with-apr-util&#x3D;&#x2F;usr&#x2F;local&#x2F;apr-util --with-ssl --enable-ssl --enable-module&#x3D;so --enable-rewrite --enable-cgid --enable-cgi --with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;pcre</span><br></pre></td></tr></table></figure></li><li><p>配置二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apache2 --with-apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr --with-apr-util&#x3D;&#x2F;usr&#x2F;local&#x2F;apr-util --with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;zlib --with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;pcre --enable-so --enable-rewrite&#x3D;shared --enable-deflate&#x3D;shared --enable-expires&#x3D;shared --enable-static-support </span><br><span class="line">make   &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>配置apache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apachectl -k start  #启动</span><br><span class="line">vi &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F;httpd.conf   #编辑配置文件</span><br><span class="line">找到：#ServerName www.example.com:80</span><br><span class="line">修改为：ServerName www.osyunwei.com:80</span><br><span class="line">找到：DirectoryIndex index.html</span><br><span class="line">修改为：DirectoryIndex index.html index.php</span><br><span class="line">找到：Options Indexes FollowSymLinks</span><br><span class="line">修改为：Options FollowSymLinks    #不显示目录结构</span><br><span class="line">找到AllowOverride None </span><br><span class="line">修改为：AllowOverride All   #开启apache支持伪静态，有两处都做修改</span><br><span class="line">LoadModule rewrite_module modules&#x2F;mod_rewrite.so   #取消前面的注释，开启apache支持伪静态</span><br><span class="line">vi &#x2F;etc&#x2F;profile  #添加apache服务系统环境变量</span><br><span class="line">在最后添加下面这一行</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apachectl &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd      #把apache加入到系统启动</span><br><span class="line">vi &#x2F;etc&#x2F;init.d&#x2F;httpd   #编辑文件</span><br><span class="line">在#!&#x2F;bin&#x2F;sh下面添加以下两行</span><br><span class="line">chkconfig:2345 10 90</span><br><span class="line">descrption:Activates&#x2F;Deactivates Apache Web Server</span><br><span class="line">chown  daemon.daemon  -R &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs  #更改目录所有者</span><br><span class="line">chmod   700 &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs  -R #更改apache网站目录权限</span><br><span class="line">chkconfig httpd on    #设置开机启动</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;httpd start</span><br><span class="line">service httpd restart</span><br></pre></td></tr></table></figure></li></ul><h5 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h5><ul><li>groupadd www</li><li>useradd -g www -s /bin/false www</li><li>cd /usr/local/src/nginx-1.2.6</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure \</span><br><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \ </span><br><span class="line">--with-pcre&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;pcre-8.21\   &#x2F;&#x2F;pcre的源代码路径，而不是安装路径</span><br><span class="line">--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf \ </span><br><span class="line">--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid \ </span><br><span class="line">--with-zlib&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;zlib-1.2.7 \  &#x2F;&#x2F;zlib的源代码路径</span><br><span class="line">--with-http_stub_status_module --user&#x3D;www --group&#x3D;www</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h5 id="php7"><a href="#php7" class="headerlink" title="php7"></a>php7</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">tar -zvxf php-7.0.0.tar.gz</span><br><span class="line">cd php-7.0.0</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;php7 #建立php安装目录 </span><br><span class="line">编译安装php配合apache和nginx</span><br><span class="line"> sudo .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php --with-apxs2&#x3D;&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apxs --with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php  --with-mysql&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --with-mysqli&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql_config  --with-libxml-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;libxml2 --with-gd&#x3D;&#x2F;usr&#x2F;local&#x2F;libgd2 --with-jpeg-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;jpeg-9a  --with-png-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;libpng --with-bz2 --with-freetype-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;freetype-2.4  --with-iconv-dir --with-pcre-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;pcre --with-zlib-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;zlib --with-libzip&#x3D;&#x2F;usr&#x2F;local&#x2F;libzip --enable-zip --with-openssl --with-mcrypt&#x3D;&#x2F;usr&#x2F;local&#x2F;libmcrypt --with-xmlrpc --with-curl --with-gettext --enable-xml --enable-mbregex  --enable-soap --enable-gd-native-ttf --enable-ftp --enable-mbstring --enable-exif --enable-safe-mode --enable-sockets --enable-session --enable-magic-quotes --enable-bcmath --disable-rpath --disable-debug --disable-ipv6 --enable-fastcgi --enable-fpm --without-pear --enable-opcache&#x3D;no  --with-xpm-dir&#x3D;&#x2F;usr&#x2F;lib&#x2F;i386-linux-gnu&#x2F;</span><br><span class="line">**选项--with-apxs2&#x3D;&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apxs支持apache</span><br><span class="line">选项 --enable-fastcgi 和 --enable-fpm 支持nginx**</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>make 过程中提示：<br>In file included from /usr/local/packages/php-5.6.9/ext/zip/lib/zip_add.c:37:/usr/local/packages/php-5.6.9/ext/zip/lib/zipint.h:118:2: error: #error unsupported size of off_tmake: *** [ext/zip/lib/zip_add.lo] Error 1<br>是因为　–with-zlib-dir=DIR    –with-pcre-dir=DIR    –with-libzip=DIR  , zip都基于这三个模块，后来瞎试试发现装好后在./configure的参数加上这三个，然后成了……哎，php5.6以上才会发生这样的问题，以下貌似随便搞。</p></blockquote><ul><li>配置php <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-production &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php.ini #复制php配置文件到安装目录**</span><br><span class="line">rm -rf &#x2F;etc&#x2F;php.ini #删除系统自带配置文件</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php.ini &#x2F;etc&#x2F;php.ini #添加软链接</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php-fpm.conf.default &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php-fpm.conf #拷贝模板文件为php-fpm配置文件</span><br><span class="line">vi &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php-fpm.conf #编辑</span><br><span class="line">user &#x3D; www #设置php-fpm运行账号为www</span><br><span class="line">group &#x3D; www #设置php-fpm运行组为www</span><br><span class="line">pid &#x3D; run&#x2F;php-fpm.pid #取消前面的分号</span><br><span class="line">设置 php-fpm开机启动</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;src&#x2F;php-5.3.16&#x2F;sapi&#x2F;fpm&#x2F;init.d.php-fpm &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;php-fpm #拷贝php-fpm到启动目录</span><br><span class="line">chmod +x &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;php-fpm #添加执行权限</span><br><span class="line">chkconfig php-fpm on #设置开机启动</span><br><span class="line">vi &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php.ini #编辑配置文件</span><br><span class="line">找到：;open_basedir &#x3D;</span><br><span class="line">修改为：open_basedir &#x3D; .:&#x2F;tmp&#x2F; #防止php木马跨站，重要！！</span><br><span class="line">找到：disable_functions &#x3D;</span><br><span class="line">修改为：disable_functions &#x3D; passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,getservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid, posix_getppid,posix_getpwnam,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname</span><br><span class="line">列出PHP可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用。</span><br><span class="line">找到：;date.timezone &#x3D;</span><br><span class="line">修改为：date.timezone &#x3D; PRC #设置时区</span><br><span class="line">找到：expose_php &#x3D; On</span><br><span class="line">修改为：expose_php &#x3D; OFF #禁止显示php版本的信息</span><br><span class="line">找到：display_errors &#x3D; On</span><br><span class="line">修改为：display_errors &#x3D; OFF #关闭错误提示</span><br></pre></td></tr></table></figure></li></ul><h5 id="配置apache支持php"><a href="#配置apache支持php" class="headerlink" title="配置apache支持php"></a>配置apache支持php</h5><ul><li>vi /usr/local/apache2/conf/httpd.conf  #编辑apache配置文件</li><li>在LoadModule php5_module        modules/libphp5.so这一行下面添加、</li><li>AddType application/x-httpd-php .php  （注意：php .php这个点前面有一个空格）</li><li>service httpd restart    #重启apache</li><li>service mysqld restart   #重启mysql</li><li>测试篇</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocsvi index.php   #输入下面内容</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h5 id="配置php支持Zend-Guard"><a href="#配置php支持Zend-Guard" class="headerlink" title="配置php支持Zend Guard"></a>配置php支持Zend Guard</h5><ul><li>安装Zend Guard</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;zend #建立Zend安装目录</span><br><span class="line">tar xvfz ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz #解压安装文件</span><br><span class="line">cp ZendGuardLoader-php-5.3-linux-glibc23-i386&#x2F;php-5.3.x&#x2F;ZendGuardLoader.so &#x2F;usr&#x2F;local&#x2F;zend&#x2F; #拷贝文件到安装目录</span><br><span class="line">vi &#x2F;usr&#x2F;local&#x2F;php5&#x2F;etc&#x2F;php.ini #编辑文件</span><br><span class="line">在最后位置添加以下内容</span><br><span class="line">[Zend Guard]</span><br><span class="line">zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;zend&#x2F;ZendGuardLoader.so</span><br><span class="line">zend_loader.enable&#x3D;1</span><br><span class="line">zend_loader.disable_licensing&#x3D;0</span><br><span class="line">zend_loader.obfuscation_level_support&#x3D;3</span><br><span class="line">zend_loader.license_path&#x3D;</span><br></pre></td></tr></table></figure><p>ok！</p><p>安装Zend Guard<br>cd /usr/local/src<br>mkdir /usr/local/zend #建立Zend安装目录<br>tar xvfz ZendGuardLoader-php-5.3-linux-glibc23-i386.tar.gz #解压安装文件<br>cp ZendGuardLoader-php-5.3-linux-glibc23-i386/php-5.3.x/ZendGuardLoader.so /usr/local/zend/ #拷贝文件到安装目录<br>vi /usr/local/php5/etc/php.ini #编辑文件<br>在最后位置添加以下内容<br>[Zend Guard]<br>zend_extension=/usr/local/zend/ZendGuardLoader.so<br>zend_loader.enable=1<br>zend_loader.disable_licensing=0<br>zend_loader.obfuscation_level_support=3<br>zend_loader.license_path=<br>ok！<br>Vimium has been updated to 1.41.x</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> php 安装 </tag>
            
            <tag> 编译安装 </tag>
            
            <tag> 错误排坑 </tag>
            
            <tag> php 编译错误解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 命令笔记</title>
      <link href="2020/06/26/docker-command-2019-08-01/"/>
      <url>2020/06/26/docker-command-2019-08-01/</url>
      
        <content type="html"><![CDATA[<h2 id="docker简介-docker-命令笔记"><a href="#docker简介-docker-命令笔记" class="headerlink" title="docker简介(docker 命令笔记)"></a>docker简介(docker 命令笔记)</h2><h3 id="为什么要使用docker"><a href="#为什么要使用docker" class="headerlink" title="为什么要使用docker"></a>为什么要使用docker</h3><p>简单粗暴的一句话，docker已经实现了在linux 容器化技术上，达到‘任何时间、任何地点’可以一键部署等完美操作，当然，这只是docker的 一部分骚操作</p><ul><li> 更快速的交付和部署</li><li> 更高效的资源利用</li><li> 更轻松的迁移和扩展</li><li> 更简单的更新和管理</li></ul><h4 id="docker-核心概念"><a href="#docker-核心概念" class="headerlink" title="docker 核心概念"></a>docker 核心概念</h4><p>docker 大部分的操作都围绕这它的三大核心概念：镜像、容器和仓库。因此、这三大概念也尤为重要</p><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><blockquote><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/">官方教程:https://docs.docker.com/install/linux/docker-ce/centos/</a></p></blockquote><h3 id="使用docker镜像"><a href="#使用docker镜像" class="headerlink" title="使用docker镜像"></a>使用docker镜像</h3><p>镜像是docker 三大核心概念中最重要的</p><p>docker 运行容器前需要本地存在对应的镜像，如果镜像不存在，docker 会尝试先从默认镜像仓库下载（默认使用docker hub 公共注册服务器中的仓库）</p><p>如果你的服务器在国外（香港也算 台湾也算，非大陆）推荐docker hub</p><p>如果在国内 推荐阿里云的镜像仓库 地址:请自行百度</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><h5 id="docker-image-pull"><a href="#docker-image-pull" class="headerlink" title="docker [image] pull"></a>docker [image] pull</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] pull</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><p>对于docker 镜像而言 如果不显式指定tag 则默认会选择latest标签，这回下载仓库中最新版本的镜像 </p><p>如果从非官方的仓库进行下载，则需要在仓库名称钱指定完整的仓库地址。例如从网易蜂巢的镜像源来下载ubuntu:18.04:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com&#x2F;public&#x2F;ubuntu:18.04</span><br></pre></td></tr></table></figure><p>pull 子命令支持的选型主要包括：</p><ul><li>-a , –all-tags=true|false:是否获取仓库中的所有镜像，默认为否；</li><li>–disable-content-trust:取消镜像的内容校验，默认为真。</li></ul><p>另外，有时需要使用镜像代理服务来加速 <strong>docker</strong> 镜像获取过程，可以在docker服务启动配置中增加–registry-mirror=proxy_URL来指定镜像代理服务地址（如<a href="https://registry.docker-cn.com)/">https://registry.docker-cn.com）</a></p><h5 id="docker-images-docker-image-ls"><a href="#docker-images-docker-image-ls" class="headerlink" title="docker images | docker image ls"></a>docker images | docker image ls</h5><p>使用docker images 或者 docker image ls 命令可以列出本地主机上已有镜像的基本信息。</p><h5 id="docker-tag-image-new-image"><a href="#docker-tag-image-new-image" class="headerlink" title="docker tag [image] [new image]"></a>docker tag [image] [new image]</h5><p>使用 tag 命令为镜像添加标签<br>为了方便在后续的工作中使用特定镜像，还可以使用 docker tag 命令来为本地镜像任意的添加新的名称或者标签。</p><h5 id="docker-image-inspect"><a href="#docker-image-inspect" class="headerlink" title="docker [image] inspect"></a>docker [image] inspect</h5><p>使用该命令可以获取镜像的详细信息，包括制作者、适应框架、各层的数字摘要等</p><h5 id="docker-history-image"><a href="#docker-history-image" class="headerlink" title="docker history [image]"></a>docker history [image]</h5><p>使用该命令则可以查看历史镜像</p><h5 id="docker-search-option-keyword"><a href="#docker-search-option-keyword" class="headerlink" title="docker search [option] keyword"></a>docker search [option] keyword</h5><p>命令选项支持</p><ul><li>-f –filter filter:过滤输出内容</li><li>–format string:格式化输出内容；</li><li>–limit int: 限制输出结果个数,默认25个</li><li>–no-trunc: 不截断输出结果</li></ul><h5 id="docker-rm-rmi-prune"><a href="#docker-rm-rmi-prune" class="headerlink" title="docker rm | rmi | prune"></a>docker rm | rmi | prune</h5><h6 id="通过标签删除镜像"><a href="#通过标签删除镜像" class="headerlink" title="通过标签删除镜像"></a>通过标签删除镜像</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除镜像（注意：镜像）</span><br><span class="line">docker rmi </span><br><span class="line">docker image rm </span><br></pre></td></tr></table></figure><p>命令选项支持</p><ul><li>-f ,-force: 强制删除镜像，即使存在依赖容器</li><li>-no-prune: 不要清理未带标签的父镜像</li></ul><h6 id="通过镜像id-删除镜像"><a href="#通过镜像id-删除镜像" class="headerlink" title="通过镜像id 删除镜像"></a>通过镜像id 删除镜像</h6><p>当使用docker rmi 命令，并且后面跟上镜像的ID(也可以是能够区分的部分ID串前缀）时，会先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身</p><h6 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h6><p>当镜像使用超过一段时间之后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过<em>docker image prune</em>来进行清理</p><p>命令的选项支持</p><ul><li>-a , -all 删除所有无用镜像，不光是临时镜像</li><li>-filter filter 只清理符合给定过滤器的镜像</li><li>-f , -force 强制删除镜像，而不进行提示确认</li></ul><h5 id="docker-ps-a"><a href="#docker-ps-a" class="headerlink" title="docker ps -a"></a>docker ps -a</h5><p>该命令可以让你看到本机上面存在的所有容器</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识 Swing</title>
      <link href="2020/06/26/java-swing-helloSwing-2020-04-14/"/>
      <url>2020/06/26/java-swing-helloSwing-2020-04-14/</url>
      
        <content type="html"><![CDATA[<h2 id="初识-Swing"><a href="#初识-Swing" class="headerlink" title="初识 Swing"></a>初识 Swing</h2><h3 id="什么是Swing"><a href="#什么是Swing" class="headerlink" title="什么是Swing?"></a>什么是Swing?</h3><p>Swing 是一个为Java设计的GUI工具包。</p><p>Swing是JAVA基础类的一部分。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p>Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。</p><h4 id="Swing-和-AWT"><a href="#Swing-和-AWT" class="headerlink" title="Swing 和 AWT"></a>Swing 和 AWT</h4><p>AWT（Abstract Window Toolkit，抽象窗口工具）是一套早期的 Java GUI 开发工具，Swing 也是在 AWT 的基础上发展起来的。</p><p>AWT 的初衷是用来开发小型的图形界面程序，提供的功能较少，诸如剪切板、打印支持、键盘导航、弹出式菜单、滚动窗格等很多重要的功能在 AWT 中都不具备；此外，AWT 发生错误的几率也很高</p><p>Java 官方看到了 AWT 的不足，就开始着手开发新的 GUI 类库，以继续占领 Java GUI 开发的市场，这就是后来的 Swing。</p><p>Swing 弥补了 AWT 的不足，并对 AWT 进行了扩充，几乎支持了所有的常用控件和功能，它们不但更加漂亮，而且更加易用，真正实现了“一次编译，到处运行”的承诺。</p><p>目前，Swing 已经代替 AWT 成为 Java 图形界面设计的首选，相对于 AWT 来说，Swing 有过之而无不及。</p><h3 id="Swing-概念"><a href="#Swing-概念" class="headerlink" title="Swing 概念"></a>Swing 概念</h3><p>Swing 是新一代的图形界面工具。使用 Swing 来开发图形界面比 AWT 更加优秀，因为 Swing 是一种轻量级组件，它采用纯 Java 实现，不再依赖于本地平台的图形界面，所以可以在所有平台上保持相同的运行效果，对跨平台支持比较出色。除此之外，Swing 提供了比 AWT 更多的图形界面组件，因此可以开发出美观的图形界面程序。</p><h4 id="Swing-类库结构"><a href="#Swing-类库结构" class="headerlink" title="Swing 类库结构"></a>Swing 类库结构</h4><p><img src= "/img/loading.gif" data-lazy-src="https://ae01.alicdn.com/kf/U18270a17da5a43829ad68f2dbf8450c7r.png" alt="图1"></p><p>从图 1 可以看出，Swing 组件除了 AbstmctButton 类之外都以 J 开头。Swing 容器组件直接继承 AWT 类库中的容器组件类，其他大部分组件都是继承 JComponet 组件。组件可以划分为容器组件和非容器组件，容器组件包括 JFmme 和 JDialog。其中 JComponent 定义了非容器类的轻量级组件（JBntton、JPanel、JMenu 等）</p><h4 id="Swing-包"><a href="#Swing-包" class="headerlink" title="Swing 包"></a>Swing 包</h4><p>Swing 类库由许多包组成，通过这些包中的类相互协作来完成 GUI 设计。其中，javax.swing 包是 Swing 提供的最大包，它包含将近 100 个类和 25 个接口。几乎所有 Swing 组件都在该包中。表 1 列出了常用的 Swing 包。</p><table><thead><tr><th>包名称</th><th>描述</th></tr></thead><tbody><tr><td>javax.swing</td><td>提供一组“轻量级”组件，尽量让这些组件在所有平台上的工作方式都相同</td></tr><tr><td>javax.swing.border</td><td>提供围绕 Swing 组件绘制特殊边框的类和接口</td></tr><tr><td>javax.swing.event</td><td>提供 Swing 组件触发的事件</td></tr><tr><td>javax.swing.filechooser</td><td>提供 JFileChooser 组件使用的类和接口</td></tr><tr><td>javax.swing.table</td><td>提供用于处理 javax.swing.JTable 的类和接口</td></tr><tr><td>javax.swing.text</td><td>提供类 HTMLEditorKit 和创建 HTML 文本编辑器的支持类</td></tr><tr><td>javax.swing.tree</td><td>提供处理 javax.swingJTree 的类和接口</td></tr></tbody></table><p>javax.swing.event 包中定义了事件和事件监听器类，javax.swing.event 包与 AWT 的 event 包类似。Java.awt.event 和 javax.swing.event 都包含事件类和监听器接口，它们分别响应由 AWT 组件和 Swing 组件触发的事件。</p><p>例如，当在树组件中需要节点扩展（或折叠）的通知时，则要实现 Swing 的 TreeExpansionListener 接口，并把一个 TreeExpansionEvent 实例传送给 TreeExpansionListener 接口中定义的方法，而 TreeExpansionListener 和 TreeExpansionEvent 都是在 swing.event 包中定义的。</p><p>虽然 Swing 的表格组件（JTable）在 javax.swing 包中，但它的支持类却在 javax.swing.table 包中。表格模型、图形绘制类和编辑器等也都在 javax.swing.table 包中。</p><p>与 JTable 类一样，Swing 中的树 JTree（用于按层次组织数据的结构组件）也在 javax.swing 包中，而它的支持类却在 javax.swing.tree 包中。javax.swing.tree 包提供树模型、树节点、树单元编辑类和树绘制类等支持类。</p><h4 id="Swing-容器"><a href="#Swing-容器" class="headerlink" title="Swing 容器"></a>Swing 容器</h4><p>创建图形用户界面程序的第一步是创建一个容器类以容纳其他组件，常见的窗口就是一种容器。容器本身也是一种组件，它的作用就是用来组织、管理和显示其他组件。</p><h5 id="Swing-中容器可以分为两类：顶层容器和中间容器。"><a href="#Swing-中容器可以分为两类：顶层容器和中间容器。" class="headerlink" title="Swing 中容器可以分为两类：顶层容器和中间容器。"></a>Swing 中容器可以分为两类：顶层容器和中间容器。</h5><p>顶层容器是进行图形编程的基础，一切图形化的东西都必须包括在顶层容器中。顶层容器是任何图形界面程序都要涉及的主窗口，是显示并承载组件的容器组件。在 Swing 中有三种可以使用的顶层容器，分别是 JFrame、JDialog 和 JApplet。</p><ol><li>JFrame：用于框架窗口的类，此窗口带有边框、标题、关闭和最小化窗口的图标。带 GUI 的应用程序至少使用一个框架窗口。</li><li>JDialog：用于对话框的类。</li><li>JApplet：用于使用 Swing 组件的 Java Applet 类。</li></ol><p>中间容器是容器组件的一种，也可以承载其他组件，但中间容器不能独立显示，必须依附于其他的顶层容器。常见的中间容器有 JPanel、JScrollPane、JTabbedPane 和 JToolBar。</p><ul><li>JPanel：表示一个普通面板，是最灵活、最常用的中间容器。</li><li>JScrollPane：与 JPanel 类似，但它可在大的组件或可扩展组件周围提供滚动条。</li><li>JTabbedPane：表示选项卡面板，可以包含多个组件，但一次只显示一个组件，用户可在组件之间方便地切换。</li><li>JToolBar：表示工具栏，按行或列排列一组组件（通常是按钮）。</li></ul><h3 id="Swing-优缺点"><a href="#Swing-优缺点" class="headerlink" title="Swing 优缺点"></a>Swing 优缺点</h3><ol><li>与直觉不太一致：Swing的GUI上的各种组件如果添加的面板过多的话，就造成各个组件的层次很深，处理类似focus管理这样的问题就很麻烦，坐标的转换也很复杂，由于父子关系过多，您不看代码只看GUI，凭直觉难以区分组件的父子关系。</li></ol><ol start="2"><li>布局上的困难：使用Swing开发界面的程序员会发现，即使Swing提供了这么多布局管理器，然而您想通过这些布局管理器做出很专业的界面却非常难，因为布局管理器非常依赖父容器和子组件的各种状态，尽管Swing最新的版本提供了类似组件和容器间隔的方法，然而还没有被大部分布局管理器采用，其实并不是布局管理器不够强大的问题，事实上，很多专业的界面需要从组件级别做出良好的定义，另外，不少Swing组件会根据容器的大小进行绘制，这也造成了很多不确定性，很多人喜欢使用NullLayout，可能就是这个原因，客户需要的是一个稳定的，可预知的界面，如果使用了布局管理器，会发现界面在不同的系统下展示的不同</li></ol><ol start="3"><li>使用上的困扰：Swing组件本身由于不能分清是组件还是容器，很多容器方法比如setEnabled就没有效果，需要写代码遍历所有子组件，调用所 有的子组件相同的方法，而类似设置透明的方法也有这个问题，如果设置某个容器透明，也需要设置所有的子组件的透明属性，组件和容器的很多方法没有很好的定 义，这对了解Swing结构的人不是问题，但是对于熟悉别的ＧＵＩ类库的人就产生了很大的困惑，因为不少容器上的方法调用后是没有效果的。</li></ol><p>总得来说，对Composite设计模式应该慎用，如果一定要用，一定要良好的定义组件（Component）和容器（Container）的边界，避免很多功能陷入没有意义的父子遍历例程，增加了复杂性。</p><h3 id="HelloWord"><a href="#HelloWord" class="headerlink" title="HelloWord"></a>HelloWord</h3><blockquote><p>本示例来自菜鸟教程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import javax.swing.*;</span><br><span class="line">public class HelloWorldSwing &#123;</span><br><span class="line">    &#x2F;**&#123;</span><br><span class="line">     * 创建并显示GUI。出于线程安全的考虑，</span><br><span class="line">     * 这个方法在事件调用线程中调用。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void createAndShowGUI() &#123;</span><br><span class="line">        &#x2F;&#x2F; 确保一个漂亮的外观风格</span><br><span class="line">        JFrame.setDefaultLookAndFeelDecorated(true);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建及设置窗口</span><br><span class="line">        JFrame frame &#x3D; new JFrame(&quot;HelloWorldSwing&quot;);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 添加 &quot;Hello World&quot; 标签</span><br><span class="line">        JLabel label &#x3D; new JLabel(&quot;Hello World&quot;);</span><br><span class="line">        frame.getContentPane().add(label);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 显示窗口</span><br><span class="line">        frame.pack();</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 显示应用 GUI</span><br><span class="line">        javax.swing.SwingUtilities.invokeLater(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                createAndShowGUI();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Swing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Swing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Web MVC 框架</title>
      <link href="2020/06/25/java-spring-web-mvc-framwork-2020-06-26/"/>
      <url>2020/06/25/java-spring-web-mvc-framwork-2020-06-26/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Web-MVC-框架"><a href="#Spring-Web-MVC-框架" class="headerlink" title="Spring Web MVC 框架"></a>Spring Web MVC 框架</h2><p>Spring MVC 框架，这个框架适用于 Web 开发的，它代替了 servlet 的页面跳转。</p><p>本篇是对 Spring MVC 框架的一个简单讲解，不会讲理论只是，如果想进一步学习的话，可以看 <a href="">Spring MVC 简易教程</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>Spring Web Hello World 例子</li><li>Spring MVC 表单处理例子</li><li>Spring MVC 页面重定向例子</li><li>Spring MVC 异常处理例子</li></ul><h3 id="Spring-Web-Hello-World-例子"><a href="#Spring-Web-Hello-World-例子" class="headerlink" title="Spring Web Hello World 例子"></a>Spring Web Hello World 例子</h3><p>首先创建一个新的项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId&#x3D;com.learn-DartifactId&#x3D;springMVCTest -DarchetypeArtifactId&#x3D;maven-archetype-webapp</span><br></pre></td></tr></table></figure><p>修改 pom.xml 文件，添加 Spring 的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springMVCTest&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;springMVCTest Maven Webapp&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;!--jetty maven 插件，为 maven 提供运行 web 程序的能力--&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;9.4.12.v20180830&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;scanIntervalSeconds&gt;10&lt;&#x2F;scanIntervalSeconds&gt;</span><br><span class="line">                    &lt;webApp&gt;</span><br><span class="line">                        &lt;contextPath&gt;&#x2F;&lt;&#x2F;contextPath&gt;</span><br><span class="line">                    &lt;&#x2F;webApp&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>修改 web.xml 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns &#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:web &#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;</span><br><span class="line">    id &#x3D; &quot;WebApp_ID&quot; version &#x3D; &quot;3.0&quot;&gt;</span><br><span class="line">    &lt;display-name&gt;springMVCTest&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 Spring MVC DispatchcerServlet 前端控制器 --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;!-- contextConfigLocation 是参数名称，该参数的值包含 Spring MVC 的配置文件路径 --&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;&#x2F;WEB-INF&#x2F;springmvc-config.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;!-- 在 Web 应用启动时立即加载 Servlet --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line">    &lt;!-- Servlet 映射声明 --&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;!-- 监听当前域的所有请求 --&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">        &lt;!-- 添加 register.jsp 为首页 --&gt;</span><br><span class="line">    &lt;welcome-file-list&gt;</span><br><span class="line">        &lt;welcome-file&gt;register.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">    &lt;&#x2F;welcome-file-list&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure><p>在 web.xml 中配置了 DispatchcerServlet，DispatchcerServlet 加载时需要一个 Spring MVC 的配置文件，默认会去 WEB-INF 下查找对应的 servlet-name-servlet.xml 文件，如本例中默认查找的是 springmvc-servlet.xml。</p><p>Spring MVC 的配置文件可以放在任何地方，用 servlet 的子元素 init-param 描述即可，见上述示例代码，这时 DispatchcerServlet 就会去查找 /WEB-INF/springmvc-config.xml。</p><p>在 webapp/WEB-INF/ 目录下新建 Spring MVC 配置文件 springmvc-config.xml，配置 Spring MVC 的 Controller，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xmlns:mvc &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.2.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-4.2.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 开启注解 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line">    &lt;!-- 配置自动扫描的包，完成 Bean 的创建和自动依赖注入的功能 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package &#x3D; &quot;com.learn.controller&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 默认静态资源处理 --&gt;</span><br><span class="line">    &lt;mvc:default-servlet-handler&#x2F;&gt;</span><br><span class="line">    &lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;viewResolver&quot; class &#x3D; &quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;prefix&quot; value &#x3D; &quot;&#x2F;WEB-INF&#x2F;views&#x2F;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;suffix&quot; value &#x3D; &quot;.jsp&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>在包 com.learn.controller 下新建 HelloController 类 HelloController.java，具体解释注释已经给出，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Controller 是一个基于注解的控制器</span><br><span class="line"> * 可以同时处理多个请求动作</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * RequestMapping 用来映射一个请求和请求的方法</span><br><span class="line">     * value &#x3D; &quot;&#x2F;hello&quot; 表示请求由 hello 方法进行处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回一个字符串 &quot;success&quot; 作为视图名称</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 webapp/WEB-INF 目录下新建文件夹 views，并在该路径下新建一个 JSP 页面命名为 hello.jsp，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Hello World!&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>输入 mvn jetty:run 运行程序，访问 spring mvc。</p><blockquote><p>地址 <strong><em>127.0.0.1:8080/hello</em></strong></p></blockquote><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">springMVCTest&#x2F; $ curl 127.0.0.1:8080&#x2F;hello</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Hello World!&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;%     </span><br></pre></td></tr></table></figure><h3 id="Spring-MVC-表单处理"><a href="#Spring-MVC-表单处理" class="headerlink" title="Spring MVC 表单处理"></a>Spring MVC 表单处理</h3><p>在项目目录 src/main/java 的包 com.learn.entity 下新建类 User.java，包含 id、username、password 和 age 属性，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.entity;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在包 com.learn.controller 下新建 Controller 类 UserController.java，具体解释注释已经给出，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">import com.learn.entity.User;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * UserController 是一个基于注解的控制器</span><br><span class="line"> * 可以同时处理多个请求动作</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * RequestMapping 用来映射一个请求和请求的方法</span><br><span class="line">     * value &#x3D; &quot;&#x2F;register&quot; 表示请求由 register 方法进行处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;register&quot;)</span><br><span class="line">    public String Register(User user, Model model) &#123;  &#x2F;&#x2F; user:视图层传给控制层的表单对象；model：控制层返回给视图层的对象</span><br><span class="line">        &#x2F;&#x2F; 在 model 中添加一个名为 &quot;user&quot; 的 user 对象</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">        &#x2F;&#x2F; 返回一个字符串 &quot;success&quot; 作为视图名称</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 webapp 目录下新建一个 JSP 页面命名为 register.jsp，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language &#x3D; &quot;java&quot; contentType &#x3D; &quot;text&#x2F;html; charset &#x3D; UTF-8&quot;</span><br><span class="line">pageEncoding &#x3D; &quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset &#x3D; UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;register page&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;register&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">      &lt;h5&gt;User registration&lt;&#x2F;h5&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;label&gt;name &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot; tabindex&#x3D;&quot;1&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;label&gt;password &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; tabindex&#x3D;&quot;2&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;label&gt;age &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot; tabindex&#x3D;&quot;3&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p id&#x3D;&quot;buttons&quot;&gt;</span><br><span class="line">        &lt;input id&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; tabindex&#x3D;&quot;4&quot; value&#x3D;&quot;register&quot; &#x2F;&gt;</span><br><span class="line">        &lt;input id&#x3D;&quot;reset&quot; type&#x3D;&quot;reset&quot; tabindex&#x3D;&quot;5&quot; value&#x3D;&quot;reset&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在 webapp/WEB-INF/views 新建一个 JSP 页面命名为 success.jsp，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language &#x3D; &quot;java&quot; contentType &#x3D; &quot;text&#x2F;html; charset &#x3D; UTF-8&quot;</span><br><span class="line">pageEncoding &#x3D; &quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset &#x3D; UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;success page&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h5&gt;login was successful&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      name：$&#123;requestScope.user.username&#125;&lt;br &#x2F;&gt;</span><br><span class="line">      password：$&#123;requestScope.user.password&#125;&lt;br &#x2F;&gt;</span><br><span class="line">      age：$&#123;requestScope.user.age&#125;&lt;br &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>输入 mvn jetty:run 运行程序</p><p>然后在 浏览器直接访问 之前的地址即可</p><h3 id="Spring-页面重定向"><a href="#Spring-页面重定向" class="headerlink" title="Spring 页面重定向"></a>Spring 页面重定向</h3><p>修改 HelloController.java 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;redirect&quot;)</span><br><span class="line">    public String redirect()&#123;</span><br><span class="line">        return &quot;redirect:finalPage&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;finalPage&quot;)</span><br><span class="line">    public String finalPage()&#123;</span><br><span class="line">        return &quot;final&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 hello.jsp 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType &#x3D; &quot;text&#x2F;html; charset &#x3D; UTF-8&quot; language &#x3D; &quot;java&quot; %&gt;</span><br><span class="line">&lt;%@taglib uri &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&#x2F;form&quot; prefix &#x3D; &quot;form&quot;%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Spring MVC页面重定向&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Spring MVC页面重定向&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;点击下面的按钮将结果重定向到新页面&lt;&#x2F;p&gt;</span><br><span class="line">&lt;form:form method &#x3D; &quot;GET&quot; action &#x3D; &quot;redirect&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type &#x3D; &quot;submit&quot; value &#x3D; &quot;页面重定向&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在同目录下新建 final.jsp，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType &#x3D; &quot;text&#x2F;html; charset &#x3D; UTF-8&quot; language &#x3D; &quot;java&quot; %&gt;</span><br><span class="line">&lt;%@taglib uri &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&#x2F;form&quot; prefix &#x3D; &quot;form&quot;%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Spring重定向页面&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;重定向页面...&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>输入 mvn jetty:run 运行程序</p><p>然后访问 127.0.0.1:8080/hello 地址即可</p><h3 id="Spring-MVC-异常处理"><a href="#Spring-MVC-异常处理" class="headerlink" title="Spring MVC 异常处理"></a>Spring MVC 异常处理</h3><p>在 com.learn.controller 包下新建 ExceptionIntegratedHandleController.java，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.learn.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class ExceptionIntegratedHandleController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;exceptionIntegratedHandleController&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Object hello(@PathVariable String id) &#123;</span><br><span class="line"></span><br><span class="line">        if (id.equals(&quot;1&quot;)) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;我这里是手动抛出的异常,期望被SpringMVC集中处理&quot;);</span><br><span class="line">        &#125; else if (id.equals(&quot;2&quot;)) &#123;</span><br><span class="line">            int value &#x3D; 1 &#x2F; 0;</span><br><span class="line">            return &quot;手动运算错误&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;no exception&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 com.learn.exception 包下新建 MySpringExceptionIntegratedHandler.java，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.exception;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自己手动编写 Java 代码来实现定制异常信息处理</span><br><span class="line">public class MySpringExceptionIntegratedHandler implements HandlerExceptionResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里可以根据异常的类型来决定什么样的对策</span><br><span class="line">        System.out.println(&quot;异常已经被处理了&quot;);</span><br><span class="line">        System.out.println(&quot;异常的类型是:&quot; + ex.getClass().getName());</span><br><span class="line">        request.setAttribute(&quot;ex&quot;, ex);</span><br><span class="line">        return new ModelAndView(&quot;runtimeExceptionPage&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 springmvc-config.xml 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;mySpringExceptionIntegratedHandler&quot; class &#x3D; &quot;com.learn.exception.MySpringExceptionIntegratedHandler&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>最后在 views 目录下新建一个 runtimeExceptionPage.jsp，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType &#x3D; &quot;text&#x2F;html; charset &#x3D; UTF-8&quot;%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;title&gt;Exception!&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% Exception e &#x3D; (Exception)request.getAttribute(&quot;ex&quot;); %&gt;</span><br><span class="line">    &lt;H2&gt;业务错误: &lt;%&#x3D; e.getClass().getSimpleName()%&gt;&lt;&#x2F;H2&gt;</span><br><span class="line">    &lt;hr &#x2F;&gt;</span><br><span class="line">    &lt;P&gt;错误描述：&lt;&#x2F;P&gt;</span><br><span class="line">    &lt;%&#x3D; e.getMessage()%&gt;</span><br><span class="line">    &lt;P&gt;错误信息：&lt;&#x2F;P&gt;</span><br><span class="line">    &lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>输入 mvn jetty:run 运行程序</p><p><a href="https://imgchr.com/i/ND2HUg"><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/06/26/ND2HUg.md.png" alt="ND2HUg.md.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> 事务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务管理</title>
      <link href="2020/06/25/java-spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-2020-06-25/"/>
      <url>2020/06/25/java-spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-2020-06-25/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-事务管理"><a href="#Spring-事务管理" class="headerlink" title="Spring 事务管理"></a>Spring 事务管理</h2><p>Spring 的事务管理，事务在日常开发中非常重要，它可以对数据库中的一些异常进行回滚，这样就可以保证数据的一致性。</p><p>事务的四个特性：</p><ul><li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li><li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li><li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li></ul><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>Spring 编程式事务管理</li><li>Spring 申明式事务管理</li></ul><h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><p>Spring 中有两种事务管理的方式，一种是编程式事务管理，另一种是声明式事务管理。</p><ul><li>编程式事务管理：所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于 JDBC 编程实现事务管理。管理使用 TransactionTemplate 或者直接使用底层的 PlatformTransactionManager。对于编程式事务管理，spring 推荐使用 TransactionTemplate。</li><li>声明式事务管理：管理建立在 AOP 之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional 注解的方式)，便可以将事务规则应用到业务逻辑中。</li></ul><p>接下我们将通过一个转账的案例来分别讲解这两种事务管理方式。</p><h3 id="Spring-编程式事务管理"><a href="#Spring-编程式事务管理" class="headerlink" title="Spring 编程式事务管理"></a>Spring 编程式事务管理</h3><p>数据库准备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create database transaction;</span><br><span class="line">use transaction</span><br><span class="line">create table account(</span><br><span class="line">    id int,</span><br><span class="line">    username varchar(20),</span><br><span class="line">     money int);</span><br><span class="line"></span><br><span class="line">insert into account values(1,&#39;Tom&#39;,10000),(2,&#39;Marry&#39;,10000);</span><br></pre></td></tr></table></figure><p>新建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId &#x3D; com.learn.tx -DartifactId &#x3D; springTansaction -DarchetypeArtifactId &#x3D; maven-archetype-quickstart</span><br></pre></td></tr></table></figure><p>修改 pom.xml 文件，添加 Spring 的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.learn.tx&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springTransaction&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;springTransaction&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.46&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>首先创建包 com.learn.tx.dao，创建 AccountDao.java，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.dao;</span><br><span class="line"></span><br><span class="line">public interface AccountDao &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 汇款</span><br><span class="line">     * @param outer 汇款人</span><br><span class="line">     * @param money 汇款金额</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void out(String outer,int money);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 收款</span><br><span class="line">     * @param inner 收款人</span><br><span class="line">     * @param money 收款金额</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void in(String inner,int money);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在再这个包下创建 AccountDaoImpl.java，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.dao;</span><br><span class="line"></span><br><span class="line">import org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line">import com.learn.tx.dao.AccountDao;</span><br><span class="line"></span><br><span class="line">public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据用户名减少账户金额</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void out(String outer, int money) &#123;</span><br><span class="line">        this.getJdbcTemplate().update(&quot;update account set money &#x3D; money - ? where username &#x3D; ?&quot;,money,outer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据用户名增加账户金额</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void in(String inner, int money) &#123;</span><br><span class="line">        this.getJdbcTemplate().update(&quot;update account set money &#x3D; money + ? where username &#x3D; ?&quot;,money,inner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建包 com.learn.tx.service，创建 AccountService.java，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.service;</span><br><span class="line"></span><br><span class="line">public interface AccountService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 转账</span><br><span class="line">     * @param outer 汇款人</span><br><span class="line">     * @param inner 收款人</span><br><span class="line">     * @param money 交易金额</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void transfer(String outer,String inner,int money);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在这个包下创建 AccountServiceImpl.java，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.service;</span><br><span class="line"></span><br><span class="line">import org.springframework.transaction.TransactionStatus;</span><br><span class="line">import org.springframework.transaction.support.TransactionCallbackWithoutResult;</span><br><span class="line">import org.springframework.transaction.support.TransactionTemplate;</span><br><span class="line"></span><br><span class="line">import com.learn.tx.dao.AccountDao;</span><br><span class="line">import com.learn.tx.service.AccountService;</span><br><span class="line"></span><br><span class="line">public class AccountServiceImpl implements AccountService&#123;</span><br><span class="line"></span><br><span class="line">    private AccountDao accountDao;</span><br><span class="line">    private TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123;</span><br><span class="line">        this.transactionTemplate &#x3D; transactionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAccountDao(AccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao &#x3D; accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transfer(final String outer,final String inner,final int money) &#123;</span><br><span class="line">        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void doInTransactionWithoutResult(TransactionStatus arg0) &#123;</span><br><span class="line">                accountDao.out(outer, money);</span><br><span class="line">                int i &#x3D; 1&#x2F;0;</span><br><span class="line">                accountDao.in(inner, money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。</p><p>编辑 SpringBeans.xml 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:aop &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;dataSource&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;driverClassName&quot; value &#x3D; &quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;transaction&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;username&quot; value &#x3D; &quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;password&quot; value &#x3D; &quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountDao&quot; class &#x3D; &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountService&quot; class &#x3D; &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;accountDao&quot; ref &#x3D; &quot;accountDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;transactionTemplate&quot; ref &#x3D; &quot;transactionTemplate&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 创建模板 --&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;transactionTemplate&quot; class &#x3D; &quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;transactionManager&quot; ref &#x3D; &quot;txManager&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置事务管理器，管理器需要事务，事务从 Connection 获得，连接从连接池DataSource获得 --&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;txManager&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>最后创建 App.java，在包路径 com.learn.tx 下，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.learn.tx.service.AccountService;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        AccountService account &#x3D; (AccountService) context.getBean(&quot;accountService&quot;);</span><br><span class="line">        &#x2F;&#x2F; Tom 向 Marry 转账1000</span><br><span class="line">        account.transfer(&quot;Tom&quot;, &quot;Marry&quot;, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.tx.App&quot;</span><br></pre></td></tr></table></figure><p>程序发生异常，此时数据库会回滚，所以没有数据的变化，查看数据库：</p><p>现在让我们修改 AccountServiceImpl.java 中的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.service;</span><br><span class="line"></span><br><span class="line">import com.learn.tx.dao.AccountDao;</span><br><span class="line">import com.learn.tx.service.AccountService;</span><br><span class="line"></span><br><span class="line">public class AccountServiceImpl implements AccountService&#123;</span><br><span class="line"></span><br><span class="line">    private AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void setAccountDao(AccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao &#x3D; accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transfer(String outer, String inner, int money) &#123;</span><br><span class="line">        accountDao.out(outer, money);</span><br><span class="line">        int i &#x3D; 1&#x2F;0;</span><br><span class="line">        accountDao.in(inner, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改 SpringBeans.xml 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:aop &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;dataSource&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;driverClassName&quot; value &#x3D; &quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;transaction&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;username&quot; value &#x3D; &quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;password&quot; value &#x3D; &quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountDao&quot; class &#x3D; &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountService&quot; class &#x3D; &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;accountDao&quot; ref &#x3D; &quot;accountDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.tx.App&quot;</span><br></pre></td></tr></table></figure><p>程序发生异常，由于没有加入事务，就算发生异常，还是会更新数据库的数据</p><h3 id="Spring-申明式事务管理"><a href="#Spring-申明式事务管理" class="headerlink" title="Spring 申明式事务管理"></a>Spring 申明式事务管理</h3><p>首先修改 SpringBeans.xml 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:aop &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:tx &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;dataSource&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;driverClassName&quot; value &#x3D; &quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;transaction&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;username&quot; value &#x3D; &quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;password&quot; value &#x3D; &quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountDao&quot; class &#x3D; &quot;com.learn.tx.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;accountService&quot; class &#x3D; &quot;com.learn.tx.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;accountDao&quot; ref &#x3D; &quot;accountDao&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 1 事务管理器 --&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;txManager&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 2 将管理器交予 spring</span><br><span class="line">        * transaction-manager 配置事务管理器</span><br><span class="line">        * proxy-target-class</span><br><span class="line">            true ： 底层强制使用 cglib 代理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager &#x3D; &quot;txManager&quot; proxy-target-class &#x3D; &quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>然后修改 AccountServiceImpl.java 中的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.tx.service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Isolation;</span><br><span class="line">import org.springframework.transaction.annotation.Propagation;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import com.learn.tx.dao.AccountDao;</span><br><span class="line">import com.learn.tx.service.AccountService;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation &#x3D; Propagation.REQUIRED , isolation &#x3D; Isolation.DEFAULT)</span><br><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements AccountService&#123;</span><br><span class="line">    @Resource(name &#x3D; &quot;accountDao&quot;)</span><br><span class="line">    private AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void setAccountDao(AccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao &#x3D; accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transfer(String outer, String inner, int money) &#123;</span><br><span class="line">        accountDao.out(outer, money);</span><br><span class="line">        &#x2F;&#x2F; int i &#x3D; 1&#x2F;0;</span><br><span class="line">        accountDao.in(inner, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将 AccountServiceImpl.java 中的 int i = 1/0 注释掉，以验证代码的正确性，然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.tx.App&quot;</span><br></pre></td></tr></table></figure><p>查看数据库：<br>数据发生了变化，说明在没有异常的时候代码是正确的，然后再将 int i = 1/0 取消注释，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.tx.App&quot;</span><br></pre></td></tr></table></figure><p>查看数据库：<br>由于添加了事务，发生异常过后会回滚，所以数据没有变化。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> 事务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring JDBC Template</title>
      <link href="2020/06/25/java-spring-jdbc-template-2020-06-26/"/>
      <url>2020/06/25/java-spring-jdbc-template-2020-06-26/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-JDBC-Template"><a href="#Spring-JDBC-Template" class="headerlink" title="Spring JDBC Template"></a>Spring JDBC Template</h2><p>Spring 框架中的 JDBC Template，有了 JDBC Template 就不需要自己再手动书写很长的 JDBC 代码来访问数据库了。</p><p><strong><em>知识点</em></strong></p><ul><li>Spring JDBC Template 增</li><li>Spring JDBC Template 删</li><li>Spring JDBC Template 改</li><li>Spring JDBC Template 查</li></ul><h3 id="Spring-JDBC-框架"><a href="#Spring-JDBC-框架" class="headerlink" title="Spring JDBC 框架"></a>Spring JDBC 框架</h3><blockquote><p>Spring 框架核心的思想就是建立一个 Java 对象的大工厂，用户只要给工厂一个指令，工厂就能将用户需要的对象根据配置文件组装好返还给用户。用户需要做的许多工作则可以写成简单的配置文件。传统的使用 JDBC 的方法，有时候需要组合复杂的的 SQL 语句，还需要去拼接，稍不注意空格、引号，都会导致错误。Spring Jdbc Template 正是为了减少上述的麻烦而设计出来的。它是对 JDBC 的一种封装，抽象我们常用的一些方法。Simple and Stupid 就是它的目标。</p></blockquote><p>Spring Jdbc Template 使用 Spring 的注入功能，可以把 DataSource 注册到 JdbcTemplate 之中。JdbcTemplate 的全限定命名为 org.springframework.jdbc.core.JdbcTemplate。要使用 JdbcTemlate 还需一个 spring-tx 包，这个包包含了事务和异常控制。</p><p>JdbcTemplate 主要提供以下五类方法：</p><ul><li>execute 方法：可以用于执行任何 SQL 语句，一般用于执行 DDL 语句。</li><li>update 方法：用于执行新增、修改、删除等语句。</li><li>batchUpdate 方法：用于执行批处理相关语句。</li><li>queryForXXX 方法：用于执行查询相关语句。</li><li>call 方法：用于执行查询相关语句，执行存储过程、函数相关语句。</li></ul><p>接下来我们就将依次看看 JdbcTemplate 中的常用方法，来实现对数据库的增删改查。</p><h3 id="Spring-JDBC-Template-增"><a href="#Spring-JDBC-Template-增" class="headerlink" title="Spring JDBC Template 增"></a>Spring JDBC Template 增</h3><p>为了方便，我们在这里新建一个数据库并取名 jdbc 用作本次编程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create database jdbc;</span><br><span class="line">use jdbc;</span><br><span class="line">create tables student(id int,name varchat(20),age int);</span><br><span class="line">insert into student values(1,&#39;admin&#39;,18);</span><br></pre></td></tr></table></figure><p>完成上面的sql </p><h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId&#x3D;com.learn.jdbc -DartifactId&#x3D;springJdbc -DarchetypeArtifactId&#x3D;maven-archetype-quickstart</span><br></pre></td></tr></table></figure><p>修改 pom.xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.learn.jdbc&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springJdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;springJdbc&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.46&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。</p><p>编辑 SpringBeans.xml 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;dataSource&quot; class &#x3D; &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;driverClassName&quot; value &#x3D; &quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;jdbc&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;username&quot; value &#x3D; &quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;password&quot; value &#x3D; &quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;jdbcTemplate&quot; class &#x3D; &quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;dataSource&quot; ref &#x3D; &quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意 上面的mysql 配置 一定要配置自己的 （如果你的环境和我不一样的话）</p></blockquote><p>最后创建 App.java，在包路径 com.learn.jdbc 下，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">        String sql &#x3D; &quot;insert into student values(?,?,?)&quot;;</span><br><span class="line">        int count &#x3D; jdbcTemplate.update(sql,new Object[]&#123;2,&quot;learn2&quot;,18&#125;);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.jdbc.App&quot;</span><br></pre></td></tr></table></figure><p>然后我们去查看数据库 应该可以 查看 到数据库已经多了一条数据</p><h3 id="Spring-JDBC-Template-删"><a href="#Spring-JDBC-Template-删" class="headerlink" title="Spring JDBC Template 删"></a>Spring JDBC Template 删</h3><p>JdbcTemplate 删除数据还是通过调用 update() 方法实现的，修改 App.java 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">        String sql &#x3D; &quot;delete from student where id&#x3D;?&quot;;</span><br><span class="line">        int count &#x3D; jdbcTemplate.update(sql,2);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.jdbc.App&quot;</span><br></pre></td></tr></table></figure><p>运行完毕之后 我们会发现,ID=2的数据已经被删除了.</p><h3 id="Spring-JDBC-Template-改"><a href="#Spring-JDBC-Template-改" class="headerlink" title="Spring JDBC Template 改"></a>Spring JDBC Template 改</h3><p>JdbcTemplate 修改数据还是通过调用 update() 方法实现的，修改 App.java 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">        String sql &#x3D; &quot;update student set name&#x3D;?,age&#x3D;? where id&#x3D;?&quot;;</span><br><span class="line">        int count &#x3D; jdbcTemplate.update(sql,new Object[]&#123;&quot;learn1&quot;,20,1&#125;);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.jdbc.App&quot;</span><br></pre></td></tr></table></figure><h3 id="Spring-JDBC-Template-查"><a href="#Spring-JDBC-Template-查" class="headerlink" title="Spring JDBC Template 查"></a>Spring JDBC Template 查</h3><p>JdbcTemplate 查询数据可以通过 queryForObject 和 query 来实现，queryForObject 用于查询单条数据，query 用于查询多条语句。</p><h4 id="查询单条语句"><a href="#查询单条语句" class="headerlink" title="查询单条语句"></a>查询单条语句</h4><p>首先创建包 com.learn.jdbc.entity，创建 Student.java，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc.entity;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 App.java 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc;</span><br><span class="line"></span><br><span class="line">import com.learn.jdbc.entity.Student;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">        String sql &#x3D; &quot;select * from student&quot;;</span><br><span class="line"></span><br><span class="line">        RowMapper&lt;Student&gt; rowMapper &#x3D; new BeanPropertyRowMapper&lt;Student&gt;(Student.class);</span><br><span class="line">        Student student &#x3D; jdbcTemplate.queryForObject(sql,rowMapper);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.jdbc.App&quot;</span><br></pre></td></tr></table></figure><p>可以看到终端中已经打印出了查询到的数据</p><h4 id="查询多条语句"><a href="#查询多条语句" class="headerlink" title="查询多条语句"></a>查询多条语句</h4><p>首先在 student 数据库中添加几条数据</p><p>修改 App.java 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.jdbc;</span><br><span class="line"></span><br><span class="line">import com.learn.jdbc.entity.Student;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; (JdbcTemplate) context.getBean(&quot;jdbcTemplate&quot;);</span><br><span class="line">        String sql &#x3D; &quot;select * from student&quot;;</span><br><span class="line"></span><br><span class="line">        RowMapper&lt;Student&gt; rowMapper &#x3D; new BeanPropertyRowMapper&lt;Student&gt;(Student.class);</span><br><span class="line">        List&lt;Student&gt; students &#x3D; jdbcTemplate.query(sql,rowMapper);</span><br><span class="line">        for(Student student:students)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.jdbc.App&quot;</span><br></pre></td></tr></table></figure><p>可以看到终端中已经打印了三条数据</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> JDBC </tag>
            
            <tag> Templeate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器</title>
      <link href="2020/06/25/java-spring-IOC-contrion-2020-06-25/"/>
      <url>2020/06/25/java-spring-IOC-contrion-2020-06-25/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-IOC-容器"><a href="#Spring-IOC-容器" class="headerlink" title="Spring IOC 容器"></a>Spring IOC 容器</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="IoC-是什么"><a href="#IoC-是什么" class="headerlink" title="IoC 是什么"></a>IoC 是什么</h4><p>Ioc，Inversion of Control，即“控制反转”。它不是什么技术，而是一种设计思想。在 Java 开发中，Ioc 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好 Ioc 呢？理解好 Ioc 的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><ul><li><p>谁控制谁，控制什么：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 IoC 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象，还包括文件等）。</p></li><li><p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p></li></ul><p>用图例说明一下，传统程序设计都是主动去创建相关对象然后再组合起来：</p><p><img src= "/img/loading.gif" data-lazy-src="https://ae01.alicdn.com/kf/Ub4bb3b981a2d4e509d813ab5af22631c0.png" alt="图一"></p><p>当有了 IoC/DI 的容器后，在客户端类中不再主动去创建这些对象了，如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://ae01.alicdn.com/kf/U294e29fb17f54c5d952d5de7f705db22q.png" alt="图二"></p><h4 id="IoC-能做什么"><a href="#IoC-能做什么" class="headerlink" title="IoC 能做什么"></a>IoC 能做什么</h4><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。</p><p>IoC 很好的体现了面向对象设计法则之一的好莱坞法则：“别找我们，我们找你”。即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h4 id="IoC-和-DI"><a href="#IoC-和-DI" class="headerlink" title="IoC 和 DI"></a>IoC 和 DI</h4><p>DI，Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”。我们来深入分析一下：</p><ul><li>谁依赖于谁：当然是某个容器管理对象依赖于 IoC 容器；“被注入对象的对象”依赖于“依赖对象”。</li><li>为什么需要依赖：容器管理对象需要 IoC 容器来提供对象需要的外部资源。</li><li>谁注入谁：很明显是 IoC 容器注入某个对象，也就是注入“依赖对象”。</li><li>注入了什么：就是注入某个对象所需要的外部资源，包括对象、资源、常量数据。</li></ul><p>IoC 和 DI 有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“<strong>被注入对象依赖 IoC 容器配置依赖对象</strong>”。</p><h4 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h4><p>IoC 容器就是具有依赖注入功能的容器，IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。</p><p>Spring IoC 容器如何知道哪些是它管理的对象呢？</p><blockquote><p>这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 java 文件的、基于属性文件的配置都可以。</p></blockquote><blockquote><p>在 Spring Ioc 容器的代表就是 org.springframework.beans 包中的 BeanFactory 接口，BeanFactory 接口提供了 IoC 容器最基本功能；而 org.springframework.context 包下的 ApplicationContext 接口扩展了 BeanFactory，还提供了与 Spring AOP 集成、国际化处理、事件传播及提供不同层次的 context 实现，如针对 web 应用的 WebApplicationContext。简单说，BeanFactory 提供了 IoC 容器最基本功能，而 ApplicationContext 则增加了更多支持企业级功能支持。ApplicationContext 完全继承 BeanFactory，因而 BeanFactory 所具有的语义也适用于 ApplicationContext。</p></blockquote><ul><li>XmlBeanFactory：BeanFactory 实现，提供基本的 IoC 容器功能，可以从 classpat h 或文件系统等获取资源。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file &#x3D; new File(&quot;fileSystemConfig.xml&quot;);</span><br><span class="line">Resource resource &#x3D; new FileSystemResource(file);</span><br><span class="line">BeanFactory beanFactory &#x3D; new XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource resource &#x3D; new ClassPathResource(&quot;classpath.xml&quot;);</span><br><span class="line">BeanFactory beanFactory &#x3D; new XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure><ul><li><p>ClassPathXmlApplicationContext：ApplicationContext 实现，从 classpath 获取配置文件。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory &#x3D; new ClassPathXmlApplicationContext(&quot;classpath.xml&quot;);</span><br></pre></td></tr></table></figure></li><li><p>FileSystemXmlApplicationContext：ApplicationContext 实现，从文件系统获取配置文件。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory &#x3D; new FileSystemXmlApplicationContext(&quot;fileSystemConfig.xml&quot;);</span><br></pre></td></tr></table></figure><h3 id="Spring-中-Bean-的定义及注入-Value"><a href="#Spring-中-Bean-的定义及注入-Value" class="headerlink" title="Spring 中 Bean 的定义及注入 Value"></a>Spring 中 Bean 的定义及注入 Value</h3><p>Spring 中，bean 的定义有三种方式：</p><ol><li>基于 XML 的配置</li><li>基于注解的配置</li><li>基于 Java 类的配置</li></ol><p>Bean 的注入有两种方式：基于构造函数的依赖注入和基于设值函数的依赖注入。</p><p>这里我们先给大家介绍第一种，基于 XML 的配置方法，这种方法在 Spring 中是最常见的</p><h4 id="基于-XML-的配置方法"><a href="#基于-XML-的配置方法" class="headerlink" title="基于 XML 的配置方法"></a>基于 XML 的配置方法</h4><p>基于 XML 的配置方法又分为三种写法：一般方法，缩写方法，pschema 方法。先看下面的 Bean：FileNameGenerator.java，其中包含两个 properties，name 和 type，我们向两个 properties 注入 value。</p><p>新建一个 Maven 项目，步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId&#x3D;com.nobady.spring -DartifactId&#x3D;bean -DarchetypeArtifact</span><br><span class="line">Id&#x3D;maven-archetype-quickstart</span><br></pre></td></tr></table></figure><p>执行上述命令之后我们创建了一个 bean 的项目</p><p>然后切换工作区</p><p>修改 pom.xml 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.nobady.spring&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;bean&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;name&gt;bean&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line">  &lt;&#x2F;properties&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>在 src/main/java 路径下，新建类：FileNameGenerator.java，所属包为：com.shiyanlou.spring.bean，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.shiyanlou.spring.bean;</span><br><span class="line"></span><br><span class="line">public class FileNameGenerator &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">       this.type &#x3D; type;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    *打印文件名和文件类型的方法</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public void printFileName() &#123;</span><br><span class="line">        System.out.println(&quot;FileName &amp; FileType  is  :  &quot;+name+&quot; &amp; &quot;+type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先在 src/main/ 下新建一个 Folder，命名为 resources，接着在 src/main/resources 路径下新建 SpringBeans.xml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--一般方法--&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;FileNameGenerator&quot; class &#x3D; &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot;&gt;</span><br><span class="line">            &lt;value&gt;hehe&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;type&quot;&gt;</span><br><span class="line">            &lt;value&gt;txt&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!-- 另一重配置方法 缩写方法--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        &lt;bean id &#x3D; &quot;FileNameGenerator&quot; class &#x3D; &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt;</span><br><span class="line">               &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;ceshi&quot; &#x2F;&gt;</span><br><span class="line">               &lt;property name &#x3D; &quot;type&quot; value &#x3D; &quot;txt&quot; &#x2F;&gt;</span><br><span class="line">           &lt;&#x2F;bean&gt;</span><br><span class="line">     --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>第三种方法：pschema 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;bean id &#x3D; &quot;FileNameGenerator&quot; class &#x3D; &quot;com.nobady.spring.bean.FileNameGenerator&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot;&gt;</span><br><span class="line">            &lt;value&gt;study&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;type&quot;&gt;</span><br><span class="line">            &lt;value&gt;txt&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;--&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;FileNameGenerator&quot; class &#x3D; &quot;com.nobady.spring.bean.FileNameGenerator&quot;</span><br><span class="line">             p:name &#x3D; &quot;study&quot; p:type &#x3D; &quot;txt&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>注意，这种方法需要在 bean 的配置文件 xml 中，加入声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br></pre></td></tr></table></figure><p>然后直接修改 App.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.nobady.spring;</span><br><span class="line"></span><br><span class="line">import com.nobady.spring.bean.FileNameGenerator;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Hello world!</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class App</span><br><span class="line">&#123;</span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">        FileNameGenerator obj &#x3D; (FileNameGenerator) context.getBean(&quot;FileNameGenerator&quot;);</span><br><span class="line">        obj.printFileName();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后打开终端开始执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass&#x3D;&quot;com.nobady.spring.App&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://ae01.alicdn.com/kf/U930b8694475a42dca7d31b59f4df407cK.png" alt="图3"></p><h4 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h4><p>注解是为 Spring 容器提供 Bean 定义的信息，把 XML 定义的信息通过类注解描述出来。众所周知，Spring 容器三大要素：Bean 定义、Bean 实现类以及 Spring 框架。如果采用 XML 配置，Bean 定义和 Bean 实现类本身分离，而采用注解配置，Bean 定义在 Bean 实现类上注解就可以实现。以下先简单列举几个注解方式。</p><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><p>被此注解标注的类将被 Spring 容器自动识别，自动生成 Bean 定义。即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">packeage com.nobady.spring;</span><br><span class="line"></span><br><span class="line">@Component(&quot;Study&quot;)</span><br><span class="line">public class Study&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与在 XML 中配置以下效果相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;shiyanlou&quot; class &#x3D; &quot;com.shiyanlou.spring.shiyanlou&quot;&gt;</span><br></pre></td></tr></table></figure><p>除此之外，Spring 有三个与 @Component 等效的注解：</p><ol><li>@Controller：对应表现层的 Bean，也就是 Action。</li><li>@Service：对应的是业务层 Bean。</li><li>@Repository：对应数据访问层 Bean。</li></ol><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><p>@Autowired 可以用来装配 bean，都可以写在字段上，或者方法上。使用 @Autowired，首先要在在 applicationContext.xml 中加入 <strong><em><bean class = "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/></em></strong> 。@Autowired 默认按类型装配，默认情况下要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired()</span><br><span class="line">@Qualifier(&quot;studentDao&quot;)</span><br><span class="line">private StudentDao studentDao;</span><br></pre></td></tr></table></figure><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><p>通过使用注释 @Configuration 告诉 Spring，这个 Class 是 Spring 的核心配置文件，并且通过使用注解 @Bean 定义 bean，举例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.nobady.spring.java_config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;animal&quot;)</span><br><span class="line">    public IAnimal getAnimal()&#123;</span><br><span class="line">        return new Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App.java 内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.nobady.spring.java_config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        IAnimal obj &#x3D; (IAnimal) context.getBean(&quot;animal&quot;);</span><br><span class="line">        obj.makeSound();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的 @Configuration 注解，相当于在 ApplicationContext.xml 文件中添加如下配置，使用了 @Configuration + @Bean 就不需要添加了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;animal&quot; class &#x3D; &quot;com.shiyanlou.spring.java_config.Dog&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Aop</title>
      <link href="2020/06/21/java-spring-aop-2020-06-22/"/>
      <url>2020/06/21/java-spring-aop-2020-06-22/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h2><p><strong><em>知识点</em></strong></p><ul><li>AOP（面向切面编程）</li><li>AOP 通知 —— Advice</li><li>Pointcut</li><li>Advisor</li><li>自动创建 Proxy</li><li>AspectJ 框架</li></ul><p>Spring AOP 即 Aspect-oriented programming，面向切面编程，是作为面向对象编程的一种补充，专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题。简单地说，就是一个拦截器（interceptor）拦截一些处理过程。</p><p>例如，当一个 method 被执行，Spring AOP 能够劫持正在运行的 method，在 method 执行前或者后加入一些额外的功能。</p><p>在 Spring AOP 中，支持 4 种类型的通知（Advice）：</p><ul><li>Before advice - method 执行前通知。</li><li>After returning advice - method 返回一个结果后通知。</li><li>After throwing advice - method 抛出异常后通知。</li><li>Around advice - 环绕通知，结合了以上三种。</li></ul><h3 id="一个-Spring-AOP-的实例"><a href="#一个-Spring-AOP-的实例" class="headerlink" title="一个 Spring AOP 的实例"></a>一个 Spring AOP 的实例</h3><p>下边这个例子解释 Spring AOP 怎样工作。首先一个简单的不使用 AOP 的例子。先创建一个简单的 Service，为了稍后演示，这个类中加了几个简单的打印 method。</p><p>创建一个 Maven 项目 SpringAop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId &#x3D; com.learn.spring -DartifactId &#x3D; SpringAop -DarchetypeArtifactId &#x3D; maven-archetype-quickstart</span><br></pre></td></tr></table></figure><p>添加 maven 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.learn&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;SpringAop&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;SpringAop&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjrt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.2.9&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>创建类 CustomerService.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">public class CustomerService &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printName() &#123;</span><br><span class="line">        System.out.println(&quot;Customer name : &quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printURL() &#123;</span><br><span class="line">        System.out.println(&quot;Customer website : &quot; + this.url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printThrowException() &#123;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 src/main/resources/ 下新建 xml 配置文件 SpringAOPAdvice.xml 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;learn&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;http:&#x2F;&#x2F;learn.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>App.java 编写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext appContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">                new String[] &#123; &quot;SpringAOPAdvice.xml&quot; &#125;);</span><br><span class="line"></span><br><span class="line">        CustomerService cust &#x3D; (CustomerService) appContext.getBean(&quot;customerService&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line">        cust.printName();</span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line">        cust.printURL();</span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            cust.printThrowException();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.spring.aop.advice.App&quot;</span><br></pre></td></tr></table></figure><h3 id="四种类型的通知（Advice）"><a href="#四种类型的通知（Advice）" class="headerlink" title="四种类型的通知（Advice）"></a>四种类型的通知（Advice）</h3><p>下面来介绍 4 种类型的通知（Advice）。</p><h4 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a>Before Advice</h4><p>method 运行前，将运行下面的代码。</p><p>HijackBeforeMethod.java 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line">public class HijackBeforeMethod implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public void before(Method arg0, Object[] args, Object target)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;HijackBeforeMethod : Before method hijacked!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中加入新的 bean 配置 HijackBeforeMethod，然后创建一个新的代理（proxy），命名为 customerServiceProxy。target 定义你想劫持哪个 bean；interceptorNames 定义想用哪个 class(advice) 劫持 target。ApringAOPAdvice.xml 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;learn&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;http:&#x2F;&#x2F;learn.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackBeforeMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;hijackBeforeMethodBean&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>用 Spring proxy 之前，必须添加 CGLIB 类库，在之前的 pom.xml 文件中，已经添加到了其中，以下是 pom.xml 依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>App.java 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext appContext &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">                new String[] &#123; &quot;SpringAOPAdvice.xml&quot; &#125;);</span><br><span class="line"></span><br><span class="line">        CustomerService cust &#x3D; (CustomerService) appContext.getBean(&quot;customerServiceProxy&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用Spring AOP 如下&quot;);</span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line">        cust.printName();</span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line">        cust.printURL();</span><br><span class="line">        System.out.println(&quot;*************************&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            cust.printThrowException();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.spring.aop.advice.App&quot;</span><br></pre></td></tr></table></figure><blockquote><p>每一个 customerService 的 method 运行前，都将先执行 HijackBeforeMethod 的 before 方法。</p></blockquote><h4 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a>After Returning Advice</h4><p>创建一个实现了接口 AfterReturningAdvice 的 class，method 运行后，直到返回结果后，才运行下边的代码，如果没有返回结果，将不运行切入的代码。</p><p>HijackAfterMethod.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line">public class HijackAfterMethod implements AfterReturningAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;HijackAfterMethod : After method hijacked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 bean 配置文件，加入 hijackAfterMethodBean 配置，ApringAOPAdvice.xml 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobady&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobady.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackBeforeMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAfterMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;hijackAfterMethodBean&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>现在再运行 App.java 后输出如下：</p><p>每一个 customerService 的 method 运行后，都将先执行 HijackAfterMethod 的 afterReturning 方法。</p><h4 id="Afetr-Throwing-Advice"><a href="#Afetr-Throwing-Advice" class="headerlink" title="Afetr Throwing Advice"></a>Afetr Throwing Advice</h4><p>创建一个实现了 ThrowsAdvice 接口的 class，劫持 IllegalArgumentException 异常，目标 method 运行时，抛出 IllegalArgumentException 异常后，运行切入的方法。HijackThrowExceptionMethod.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.ThrowsAdvice;</span><br><span class="line"></span><br><span class="line">public class HijackThrowExceptionMethod implements ThrowsAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public void afterThrowing(IllegalArgumentException e) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;HijackThrowException : Throw exception hijacked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 bean 配置文件，加入了 hijackThrowExceptionBean，ApringAOPAdvice.xml 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackBeforeMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAfterMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackThrowExceptionBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackThrowExceptionMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;hijackThrowExceptionBean&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h4 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a>Around Advice</h4><p>结合了以上 3 种形式的 Advice，创建一个实现了接口 MethodInterceptor 的 class，你必须通过 methodInvocation.proceed() 来调用原来的方法，即通过调用 methodInvocation.proceed() 来调用 CustomerService 中的每一个方法，当然也可以不调用原方法 HijackAroundMethod.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.advice;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">public class HijackAroundMethod implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Method name : &quot;</span><br><span class="line">                + methodInvocation.getMethod().getName());</span><br><span class="line">        System.out.println(&quot;Method arguments : &quot;</span><br><span class="line">                + Arrays.toString(methodInvocation.getArguments()));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 相当于 MethodBeforeAdvice</span><br><span class="line">        System.out.println(&quot;HijackAroundMethod : Before method hijacked!&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用原方法，即调用 CustomerService 中的方法</span><br><span class="line">            Object result &#x3D; methodInvocation.proceed();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 相当于 AfterReturningAdvice</span><br><span class="line">            System.out.println(&quot;HijackAroundMethod : After method hijacked!&quot;);</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 相当于 ThrowsAdvice</span><br><span class="line">            System.out.println(&quot;HijackAroundMethod : Throw exception hijacked!&quot;);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 bean 配置文件，加入了 hijackAroundMethodBean，ApringAOPAdvice.xml 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackBeforeMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackBeforeMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAfterMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAfterMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackThrowExceptionBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackThrowExceptionMethod&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;hijackAroundMethodBean&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上边的结果中，CustomerService.java 中，全部的 method 方法全部被拦截了，下边我们将展示怎样利用 Pointcuts 只拦截 printName()。</p><p>在 Spring AOP 中，有 3 个常用的概念，Advices、Pointcut、Advisor，解释如下：</p><ul><li>Advices：表示一个 method 执行前或执行后的动作。</li><li>Pointcut：表示根据 method 的名字或者正则表达式去拦截一个 method。</li><li>Advisor：Advice 和 Pointcut 组成的独立的单元，并且能够传给 proxy factory 对象。</li></ul><p>我们可以用名字匹配法和正则表达式匹配法去匹配要拦截的 method。</p><h4 id="Pointcut-Name-match-example"><a href="#Pointcut-Name-match-example" class="headerlink" title="Pointcut - Name match example"></a>Pointcut - Name match example</h4><p>通过 pointcut 和 advisor 拦截 printName() 方法。创建一个 NameMatchMethodPointcut 的 bean，将你想拦截的方法的名字 printName 注入到属性 mappedName，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;customerPointcut&quot;</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcut&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DefaultPointcutAdvisor 的 advisor bean，将 pointcut 和 advice 关联起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;customerAdvisor&quot;</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;pointcut&quot; ref &#x3D; &quot;customerPointcut&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>更改代理的 interceptorNames 值，将上边的 advisor（customerAdvisor）替代原来的 hijackAroundMethodBean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;customerServiceProxy&quot;</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>所有的配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerPointcut&quot; class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcut&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;pointcut&quot; ref &#x3D; &quot;customerPointcut&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>再运行一下 App.java</p><p>运行结果显示，只拦截了 printName() 方法。</p><p>注意：以上配置中 pointcut 和 advisor 可以合并在一起配置，即不用单独配置 customerPointcut 和 customerAdvisor，只要配置 customerAdvisor 时 class 选择 NameMatchMethodPointcutAdvisor 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>这样，整个配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>实际上这种做法将 method 名字与具体的 advice 捆绑在一起，有悖于 Spring 松耦合理念，如果将 method 名字单独配置成 pointcut（切入点），advice 和 pointcut 的结合会更灵活，使一个 pointcut 可以和多个 advice 结合。</p><h4 id="Pointcut-Regular-exxpression-match-example"><a href="#Pointcut-Regular-exxpression-match-example" class="headerlink" title="Pointcut - Regular exxpression match example"></a>Pointcut - Regular exxpression match example</h4><p>你可以配置用正则表达式匹配需要拦截的 method，如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;patterns&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;.*URL.*&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>配置文件详情如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot;com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot;com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot; class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;patterns&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;.*URL.*&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="利用-BeanNameAutoProxyCreator-自动创建-proxy"><a href="#利用-BeanNameAutoProxyCreator-自动创建-proxy" class="headerlink" title="利用 BeanNameAutoProxyCreator 自动创建 proxy"></a>利用 BeanNameAutoProxyCreator 自动创建 proxy</h3><p>在前面两节的例子中，在配置文件中，我们必须手动为每一个需要 AOP 的 bean 创建 Proxy bean（ProxyFactoryBean）。</p><p>这不是一个好的体验，例如，我们想让 DAO 层的所有 bean 都支持 AOP，以便写 SQL 日志，那么必须手工创建很多的 ProxyFactoryBean，这样会直接导致 xml 配置文件内容成几何级的倍增，不利于 xml 配置维护。幸运的是，Spring 有两种方法，可以为你自动创建 proxy。</p><p>手工创建 ProxyFactoryBean 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerServiceProxy&quot;</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;target&quot; ref &#x3D; &quot;customerService&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot;    class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot; hijackAroundMethodBean &quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>配置完后要得到 customerServiceProxy，需要如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerService cust &#x3D; (CustomerService) appContext.getBean(&quot;customerServiceProxy&quot;);</span><br></pre></td></tr></table></figure><p>在自动模式中，我们需要创建 BeanNameAutoProxyCreator，将所有的 bean（通过名字或正则表达式匹配）和 advisor 形成一个独立的单元，SpringAOPAdvice.xml 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean</span><br><span class="line">    class &#x3D; &quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;beanNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;*Service&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;customerAdvisor&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot; class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>以上配置中只要 bean 的 id 符合 *Service，就会自动创建 proxy，所以，可以用以下代码获得 proxy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerService cust &#x3D; (CustomerService) appContext.getBean(&quot;customerService&quot;);</span><br></pre></td></tr></table></figure><h3 id="利用-DefaultAdvisorAutoProxyCreator-创建-Proxy"><a href="#利用-DefaultAdvisorAutoProxyCreator-创建-Proxy" class="headerlink" title="利用 DefaultAdvisorAutoProxyCreator 创建 Proxy"></a>利用 DefaultAdvisorAutoProxyCreator 创建 Proxy</h3><p>这种方式利用 DefaultAdvisorAutoProxyCreator 实现自动创建 Proxy，此种方式威力巨大，任何匹配 Advisor 的 bean，都会自动创建 Proxy 实现 AOP，所以慎用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerService&quot; class &#x3D; &quot; com.learn.spring.aop.advice.CustomerService&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;Nobody&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name  &#x3D;&quot;url&quot; value &#x3D; &quot;Nobody.com&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;hijackAroundMethodBean&quot; class &#x3D; &quot; com.learn.spring.aop.advice.HijackAroundMethod&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerAdvisor&quot;</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;mappedName&quot; value &#x3D; &quot;printName&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;advice&quot; ref &#x3D; &quot;hijackAroundMethodBean&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean</span><br><span class="line">        class &#x3D; &quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>以上例子中，xml 中任何 bean，只要有 method 名字为 printName，使用以下代码时，都会自动创建 Proxy，来支持 AOP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomerService cust &#x3D; (CustomerService) appContext.getBean(&quot;customerService&quot;);</span><br></pre></td></tr></table></figure><p>结果同上。</p><h3 id="使用-AspectJ-框架实现-Spring-AOP"><a href="#使用-AspectJ-框架实现-Spring-AOP" class="headerlink" title="使用 AspectJ 框架实现 Spring AOP"></a>使用 AspectJ 框架实现 Spring AOP</h3><p>AspectJ 是基于注释（Annotation）的，所以需要 JDK5.0 以上的支持。</p><p>AspectJ 支持的注解类型如下：</p><ul><li>@Before</li><li>@After</li><li>@AfterReturning</li><li>@AfterThrowing</li><li>@Around</li></ul><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先定义一个简单的 bean，CustomerBo 实现了接口 ICustomerBo。ICustomerBo.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">public interface ICustomerBo &#123;</span><br><span class="line">    void addCustomer();</span><br><span class="line">    void deleteCustomer();</span><br><span class="line">    String AddCustomerReturnValue();</span><br><span class="line">    void addCustomerThrowException() throws Exception;</span><br><span class="line">    void addCustomerAround(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CustomerBo.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">public class CustomerBo implements ICustomerBo &#123;</span><br><span class="line"></span><br><span class="line">    public void addCustomer() &#123;</span><br><span class="line">        System.out.println(&quot;addCustomer() is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteCustomer() &#123;</span><br><span class="line">        System.out.println(&quot;deleteCustomer() is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String AddCustomerReturnValue() &#123;</span><br><span class="line">        System.out.println(&quot;AddCustomerReturnValue() is running ...&quot;);</span><br><span class="line">        return &quot;abc&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addCustomerThrowException() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;addCustomerThrowException() is running ...&quot;);</span><br><span class="line">        throw new Exception(&quot;Generic Error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addCustomerAround(String name) &#123;</span><br><span class="line">        System.out.println(&quot;addCustomerAround() is running ,args:&quot;+name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单的-AspectJ，Advice-和-Pointcut-结合在一起"><a href="#简单的-AspectJ，Advice-和-Pointcut-结合在一起" class="headerlink" title="简单的 AspectJ，Advice 和 Pointcut 结合在一起"></a>简单的 AspectJ，Advice 和 Pointcut 结合在一起</h4><p>首先没有引入 Aspect 之前，Advice 和 Pointcut 是混在一起的，步骤如下：</p><ul><li>创建一个 Aspect 类</li><li>配置 Spring 配置文件</li></ul><p>由于接下来要使用 aspectj 的 jar 包，首先添加 maven 依赖。需要在 pom.xml 添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjrt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注:我们在新建项目时就已经添加了这些依赖，这里写出来只是知道这些包的作用</p></blockquote><p>创建 AspectJ 类，LoggingAspect.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;execution(public * com.learn.spring.aop.aspectj.CustomerBo.addCustomer(..))&quot;)</span><br><span class="line">    public void logBefore(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;logBefore() is running ...&quot;);</span><br><span class="line">        System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(&quot;**********&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;execution(public * com.learn.spring.aop.aspectj.CustomerBo.deleteCustomer(..))&quot;)</span><br><span class="line">    public void logAfter(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;logAfter() is running ...&quot;);</span><br><span class="line">        System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(&quot;**********&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>必须使用 @Aspect 在 LoggingAspect 声明之前注释，以便被框架扫描到。</li><li>此例 Advice 和 Pointcut 结合在一起，类中的具体方法 logBefore 和 logAfter 即为 Advice，是要注入的代码，Advice 方法上的表达式为 Pointcut 表达式，即定义了切入点，上例中 @Before 注释的表达式代表执行 CustomerBo.addCustomer 方法时注入 logBefore 代码。</li><li>在 LoggingAspect 方法上加入 @Before 或者 @After 等注释。</li><li>execution(public * com.learn.spring.aop.aspectj.CustomerBo.addCustomer(..)) 是 Aspect 的切入点表达式，其中，* 代表返回类型，后边的就要定义要拦截的方法名。这里写的的是 com.learn.spring.aop.aspectj.CustomerBo.addCustomer 表示拦截 CustomerBo 中的 addCustomer 方法，(..) 代表参数匹配，此处表示匹配任意数量的参数，可以是 0 个也可以是多个，如果你确定这个方法不需要使用参数可以直接用 ()，还可以使用 (*) 来匹配一个任意类型的参数，还可以使用 (* , String )，这样代表匹配两个参数，第二个参数必须是 String 类型的参数。</li><li>AspectJ 表达式，可以对整个包定义，例如 execution ( * com.learn.spring.aop.aspectj.*.*(..)) 表示切入点是 com.learn.spring.aop.aspectj 包中的任意一个类的任意方法，具体的表达式请自行搜索。</li></ol><p>配置 SpringAopAspectj.xml 文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerBo&quot; class &#x3D; &quot;com.learn.spring.aop.aspectj.CustomerBo&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;logAspect&quot; class &#x3D; &quot;com.learn.spring.aop.aspectj.LoggingAspect&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>&lt;aop:aspectj-autoproxy/&gt; 启动 AspectJ 支持，这样 Spring 会自动寻找用 @Aspect 注释过的类，其他的配置与 Spring 普通 bean 配置一样。</p><p>执行 App.java 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext appContext &#x3D; new ClassPathXmlApplicationContext(new String[] &#123; &quot;SpringAOPAspectJ.xml&quot; &#125;);</span><br><span class="line">        ICustomerBo customer &#x3D; (ICustomerBo)appContext.getBean(&quot;customerBo&quot;);</span><br><span class="line"></span><br><span class="line">        customer.addCustomer();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        customer.deleteCustomer();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.learn.spring.aop.aspectj.App&quot;</span><br></pre></td></tr></table></figure><p>将 Advicd 和 Pointcut 分开<br>需要三步：</p><ol><li>创建 Pointcut</li><li>创建 Advice</li><li>配置 Spring 的配置文件</li></ol><p>定义 Pointcut，创建 PointcutsDefinition.java，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class PointcutsDefinition &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(* com.learn.spring.aop.aspectj.CustomerBo.*(..))&quot;)</span><br><span class="line">    public void customerLog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>类声明前加入 @Aspect 注释，以便被框架扫描到。</li><li>@Pointcut 是切入点声明，指定需要注入的代码的位置，如上例中指定切入点为 CustomerBo 类中的所有方法，在实际业务中往往是指定切入点到一个逻辑层，例如 execution (* com.learn.spring.aop.aspectj.*.*(..)），表示 aop 切入点为 aspectj 包中所有类的所有方法，具体的表达式后边会有介绍。</li><li>方法 customerLog 是一个签名，在 Advice 中可以用此签名代替切入点表达式，所以不需要在方法体内编写实际代码，只起到助记功能，例如此处代表操作 CustomerBo 类时需要的切入点。<br>创建 LoggingAspect.java：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.learn.spring.aop.aspectj;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.After;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;com.learn.spring.aop.aspectj.PointcutsDefinition.customerLog()&quot;)</span><br><span class="line">    public void logBefore(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;logBefore() is running ...&quot;);</span><br><span class="line">        System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(&quot;**********&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;com.learn.spring.aop.aspectj.PointcutsDefinition.customerLog()&quot;)</span><br><span class="line">    public void logAfter(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;logAfter() is running ...&quot;);</span><br><span class="line">        System.out.println(&quot;hijacked:&quot;+joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(&quot;**********&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>@Before 和 @After 使用 PointcutsDefinition 中的方法签名代替 Pointcut 表达式找到相应的切入点，即通过签名找到 PointcutsDefinition 中 customerLog 签名上的 Pointcut 表达式，表达式指定切入点为 CustomerBo 类中的所有方法。所以此例中 Advice 类 LoggingAspect，为 CustomerBo 中的所有方法都加入了 @Before 和 @After 两种类型的两种操作。</li><li>对于 PointcutsDefinition 来说，主要职责是定义 Pointcut，可以在其中定义多个切入点，并且可以用便于记忆的方法签名进行定义。</li><li>单独定义 Pointcut 的好处是，一是通过使用有意义的方法名，而不是难读的 Pointcut 表达式，使代码更加直观；二是 Pointcut 可以实现共享，被多个 Advice 直接调用。若有多个 Advice 调用某个 Pointcut，而这个 Pointcut 的表达式在将来有改变时，只需修改一个地方，维护更加方便。</li></ol><p>配置 Spring 配置文件。</p><p>配置 SpringAOPAspectJ.xml 文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;customerBo&quot; class &#x3D; &quot;com.learn.spring.aop.aspectj.CustomerBo&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;logAspect&quot; class &#x3D; &quot;com.learn.spring.aop.aspectj.LoggingAspect&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pcntl 多进程扩展探寻</title>
      <link href="2020/06/12/php-pcntl-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%89%A9%E5%B1%95%E6%8E%A2%E5%AF%BB-2020-06-12/"/>
      <url>2020/06/12/php-pcntl-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%89%A9%E5%B1%95%E6%8E%A2%E5%AF%BB-2020-06-12/</url>
      
        <content type="html"><![CDATA[<h2 id="php-实现-并发-进程控制-pcntl"><a href="#php-实现-并发-进程控制-pcntl" class="headerlink" title="php 实现 并发-进程控制 pcntl"></a>php 实现 并发-进程控制 pcntl</h2><p>PCNTL 是 PHP 中的一组进程控制函数，可以用来 fork（创建）进程，传输控制信号等。</p><p>在PHP中，进程控制支持默认关闭。编译时通过 –enable-pcntl 配置选项可以使 PHP的 CGI 或 CLI 版本打开进程控制支持（但是注意不要在 web 服务器中用 PCNTL，会导致不可预料的问题）。仅 Unix 类系统支持 PCNTL 模块。</p><h3 id="PCNTL-原理"><a href="#PCNTL-原理" class="headerlink" title="PCNTL 原理"></a>PCNTL 原理</h3><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在当前进程当前位置产生分支（子进程）</span><br><span class="line">$pid &#x3D; pcntl_fork();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父进程和子进程都会执行下面代码</span><br><span class="line">if ($pid &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    &#x2F;&#x2F;错误处理：创建子进程失败时返回-1.</span><br><span class="line">     die(&#39;could not fork&#39;);</span><br><span class="line">&#125; else if ($pid) &#123;</span><br><span class="line">     &#x2F;&#x2F;父进程会得到子进程号，所以这里是父进程执行的逻辑</span><br><span class="line">     pcntl_wait($status); &#x2F;&#x2F;等待子进程中断，防止子进程成为僵尸进程。</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F;子进程得到的$pid为0, 所以这里是子进程执行的逻辑。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>PCNTL 中的一系列函数，都对应操作系统中的函数，例如 pcntl_fork 就对应 Linux 系统中的 fork 函数。</p><p>每次在进程中调用 fork 函数时，操作系统会把进程完整的复制一份，作为这个进程的子进程。此时，两个进程的唯一区别就是 PID（进程ID）和 PPID（父进程ID）。根据 fork 返回值的不同可以判断当前是在父进程还是子进程中，从而可以有不同的处理逻辑。</p><p>为了保证系统资源利用率，必须防止出现僵尸进程（进程结束后未回收资源）或孤儿进程（父进程提前结束），可以通过 pcntl_wait 或 pcntl_waitpid 函数来监控子进程。</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="pcntl-fork"><a href="#pcntl-fork" class="headerlink" title="pcntl_fork"></a>pcntl_fork</h4><p>在当前进程的当前位置产生分支（子进程），父进程和子进程都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程号，而子进程得到的是0。子进程仅PID（进程号） 和PPID（父进程号）与其父进程不同。</p><p>语法：</p><p>int pcntl_fork ( void )</p><p>返回值：</p><ul><li>成功时，产生进程分支：</li><li><ul><li>在父进程执行线程内返回产生的子进程的PID</li></ul></li><li><ul><li>在子进程执行线程内返回0</li></ul></li><li>失败时，在 父进程上下文返回-1，不会创建子进程，并且会引发一个PHP错误。</li></ul><h4 id="pcntl-waitpid"><a href="#pcntl-waitpid" class="headerlink" title="pcntl_waitpid"></a>pcntl_waitpid</h4><p>挂起当前进程的执行，直到参数pid指定的进程号对应的进程退出， 或接收到一个信号要求中断当前进程或调用一个信号处理函数。<br>如果pid指定的子进程在此函数调用时已经退出（僵尸进程），此函数将立刻返回。</p><p>语法：</p><p>int pcntl_waitpid ( int $pid , int &amp;$status [, int $options = 0 ] )</p><p>返回值：</p><ul><li>正常执行时返回退出的子进程进程号</li><li>发生错误时返回-1,如果提供了 WNOHANG作为option（wait3可用的系统）并且没有可用子进程时返回0。</li></ul><h4 id="pcntl-wait"><a href="#pcntl-wait" class="headerlink" title="pcntl_wait"></a>pcntl_wait</h4><p>挂起当前进程，直到当前进程的一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。如果当前进程的一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将被释放。</p><p>pcntl_wait 等同于以-1作为参数pid 的值并且没有options参数来调用pcntl_waitpid() 函数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="多子进程实现并发"><a href="#多子进程实现并发" class="headerlink" title="多子进程实现并发"></a>多子进程实现并发</h4><p>多子进程时，需要注意避免僵尸进程，浪费资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$procNum &#x3D; 3;</span><br><span class="line">for($i &#x3D; 0; $i &lt; $procNum; $i++)&#123;</span><br><span class="line">$nPID &#x3D; pcntl_fork();&#x2F;&#x2F;创建子进程</span><br><span class="line">if ($nPID &#x3D;&#x3D; 0)&#123;</span><br><span class="line">work();</span><br><span class="line">exit(0);</span><br><span class="line">&#125; elseif ($nPID &#x3D;&#x3D; -1) &#123;</span><br><span class="line">die(&#39;could not fork&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 如果在这里写 pcntl_wait($status)，则只有当前进程执行完毕后才会创建下一个进程</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 父进程会执行下面的代码，等待子进程执行完毕，避免僵尸进程</span><br><span class="line">$n &#x3D; 0;</span><br><span class="line">while ($n &lt; $procNum) &#123;</span><br><span class="line">$nStatus &#x3D; -1;</span><br><span class="line">$nPID &#x3D; pcntl_wait($nStatus);</span><br><span class="line">if ($nPID &gt; 0) &#123;</span><br><span class="line">++$n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function work()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">$nPID &#x3D; pcntl_fork();&#x2F;&#x2F;创建子进程</span><br><span class="line">if ($nPID &#x3D;&#x3D; 0)&#123;</span><br><span class="line">echo time();</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">pcntl_waitpid($nPID,$nStatus);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_139_38_centos ~]# ps -ef | grep php</span><br><span class="line">root     26355 24175  0 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     26356 26355  3 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     26357 26355  5 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     26358 26355  3 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     27078 24819  0 23:17 pts&#x2F;4    00:00:00 grep --color&#x3D;auto php</span><br><span class="line">root     27079 26357  0 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     27080 26358  0 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br><span class="line">root     27081 26356  0 23:17 pts&#x2F;0    00:00:00 php pcntl2.php</span><br></pre></td></tr></table></figure><h4 id="单子进程"><a href="#单子进程" class="headerlink" title="单子进程"></a>单子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$pid &#x3D; pcntl_fork();</span><br><span class="line"></span><br><span class="line">if ($pid &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    die(&#39;could not fork&#39;);</span><br><span class="line">&#125; elseif ($pid) &#123;</span><br><span class="line">    pcntl_wait($status);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        echo time();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/aizuyan/daemon">https://github.com/aizuyan/daemon</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> Pcntl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> pcntl </tag>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP文件上传源码分析(RFC1867)</title>
      <link href="2020/04/09/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/"/>
      <url>2020/04/09/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP文件上传源码分析"><a href="#PHP文件上传源码分析" class="headerlink" title="PHP文件上传源码分析"></a>PHP文件上传源码分析</h2><blockquote><p>@author 风雪之隅 </p></blockquote><ul><li>本文地址: <a href="https://www.laruence.com/2009/09/26/1103.html">https://www.laruence.com/2009/09/26/1103.html</a></li><li>转载请注明出处</li></ul><p>文件上传,一般分为俩种方式FTP和HTTP, 对于我们的互联网应用来说: FTP上传虽然传输稳定, 但是易用性和安全性都是个问题.<br>你总不至于在用户要上传头像的时候告诉用户”请打开FTP客户端,上传文件到<a href="http://www.laruence.com/uploads/%E4%B8%AD">http://www.laruence.com/uploads/中</a>, 并以2dk433423l.jpg命名”吧?<br>而基于HTTP的上传,相对来说易用性和安全性上就比FTP要增强了很多.<br>可以应用的上传方式有PUT, WEBDAV, 和RFC1867三种,<br>本文将分析在PHP中,是如何基于RFC1867实现文件上传的.</p><h3 id="RFC1867"><a href="#RFC1867" class="headerlink" title="RFC1867"></a>RFC1867</h3><p>RCF1867是Form-based File Upload in HTML标准协议, RFC1867标准对HTML做出了两处修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 为input元素的type属性增加了一个file选项。</span><br><span class="line">2 input标记可以具有accept属性，该属性能够指定可被上传的文件类型或文件格式列表。</span><br></pre></td></tr></table></figure><p>另外，本标准还定义了一种新的mime类型：multipart/form-data，<br>以及当处理一个带有enctype=”multipart/form-data”<br>并且/或含有<input type="file">的标记的表单时所应该采取的行为。<br>　　<br>举例来说，当HTML想让用户能够上传一个或更多的文件时，他可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;upload.php&quot; method&#x3D;post&gt;</span><br><span class="line">选择文件:</span><br><span class="line">&lt;input name&#x3D;&quot;userfile&quot; type&#x3D;&quot;file&quot;&gt;</span><br><span class="line">文件描述:</span><br><span class="line">&lt;input name&#x3D;&quot;description&quot; type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>这个表单, 大家一定不陌生, 而对于PHP来说, 它自己另外定义了一个默认表单元素MAX_FILE_SIZE,<br>用户可以通过这个隐藏的表单元素来建议PHP最多只容许上传文件的大小,<br>比如对于上面的例子, 我们希望用户上传的文件不能大于5000(5k)字节,<br>那么可以如下写:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;upload.php&quot; method&#x3D;post&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;5000&quot; name&#x3D;&quot;MAX_FILE_SIZE&quot;&gt; &lt;!--文件大小--&gt;</span><br><span class="line">选择文件:</span><br><span class="line">&lt;input name&#x3D;&quot;userfile&quot; type&#x3D;&quot;file&quot;&gt;</span><br><span class="line">文件描述:</span><br><span class="line">&lt;input name&#x3D;&quot;description&quot; type&#x3D;&quot;text&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>姑且不说, 这个MAX_FILE_SIZE是多么的不可靠(所以基于浏览器的控制,都是不可靠的), 我们单纯从实现来介绍这个MAX_FILE_SIZE是如何起作用的.<br>当用户选择了一个文件(laruence.txt), 并填写好文件描述(“laruence的个人介绍”), 点击上传后, 发生了什么呢?</p><h3 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h3><p>在用户确定提交以后, 浏览器会根据用户选择的输入, 读取要上传的文件, 连同表单中的其他元素,<br>组织成一定格式(如下)的数据发送到form中action属性指定的页面(在本例中是upload.php):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请求头</span><br><span class="line">POST &#x2F;upload.php HTTP&#x2F;1.0\r\n</span><br><span class="line">...</span><br><span class="line">Host: www.laruence.com\r\n</span><br><span class="line">...</span><br><span class="line">Content-length: xxxxx\r\n</span><br><span class="line">...</span><br><span class="line">Content-type: multipart&#x2F;form-data, boundary&#x3D;7d51863950254\r\n</span><br><span class="line">...\r\n\r\n</span><br><span class="line">&#x2F;&#x2F;开始POST数据内容</span><br><span class="line">--7d51863950254</span><br><span class="line">content-disposition: form-data; name&#x3D;&quot;description&quot;\r\n</span><br><span class="line">laruence的个人介绍</span><br><span class="line">--7d51863950254</span><br><span class="line">content-disposition: form-data; name&#x3D;&quot;userfile&quot;; filename&#x3D;&quot;laruence.txt&quot;</span><br><span class="line">Content-Type: text&#x2F;plain\r\n</span><br><span class="line">... laruence.txt 的内容...</span><br><span class="line">--7d51863950254--</span><br></pre></td></tr></table></figure><p>接下来, 就是服务器, 是如何处理这些数据了</p><h3 id="接受上传"><a href="#接受上传" class="headerlink" title="接受上传"></a>接受上传</h3><p>当Web服务器, 此处假设为Apache(另外假设PHP是以module方式安装在Apache上的), 接受到用户的数据时,<br>首先它根据HTTP请求头, 通过确定MIME TYPE为PHP类型, 然后经过一些过程以后<br>(这部分,可以参看我之前的<a href="http://www.laruence.com/2008/08/15/283.html">PHP Life Cycle ppt</a>), 最终会把控制权交给PHP模块.  </p><p>这个时候, PHP会调用sapi_activate来初始化一个请求,<br>在这个过程中, 首先判断请求类型, 此时是POST, 从而去调用sapi_read_post_data, 通过Content-type, 找到rfc1867的处理函数rfc1867_post_handler,<br>从而调用这个handler, 来分析POST来的数据.</p><p>关于rfc1867_post_handler这部分的源代码, 可以在mian/rfc1867.c找到,<br>另外也可以参看我之前的<a href="/2020/04/10/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8E%9F%E7%90%86%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/">深入理解PHP之文件上传</a>, 其中也列出的源代码.</p><p>然后, PHP通过boundary, 对于每一个分段, 都通过检查, 是否同时定义了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name和filename属性(有名文件上传)</span><br><span class="line">没有定义name定义了filename(无名上传)</span><br><span class="line">定义了name没有定义filename(普通数据),</span><br></pre></td></tr></table></figure><p>从而进行不同的处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if ((cd &#x3D; php_mime_get_hdr_value(header, &quot;Content-Disposition&quot;))) &#123;</span><br><span class="line">     char *pair&#x3D;NULL;</span><br><span class="line">     int end&#x3D;0;</span><br><span class="line">     while (isspace(*cd)) &#123;</span><br><span class="line">          ++cd;</span><br><span class="line">     &#125;</span><br><span class="line">     while (*cd &amp;&amp; (pair &#x3D; php_ap_getword(&amp;cd, &#39;;&#39;)))</span><br><span class="line">     &#123;</span><br><span class="line">          char *key&#x3D;NULL, *word &#x3D; pair;</span><br><span class="line">          while (isspace(*cd)) &#123;</span><br><span class="line">               ++cd;</span><br><span class="line">          &#125;</span><br><span class="line">          if (strchr(pair, &#39;&#x3D;&#39;)) &#123;</span><br><span class="line">               key &#x3D; php_ap_getword(&amp;pair, &#39;&#x3D;&#39;);</span><br><span class="line">               if (!strcasecmp(key, &quot;name&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;获取name字段</span><br><span class="line">                    if (param) &#123;</span><br><span class="line">                         efree(param);</span><br><span class="line">                    &#125;</span><br><span class="line">                    param &#x3D; php_ap_getword_conf(&amp;pair TSRMLS_CC);</span><br><span class="line">               &#125; else if (!strcasecmp(key, &quot;filename&quot;)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;获取filename字段</span><br><span class="line">                    if (filename) &#123;</span><br><span class="line">                         efree(filename);</span><br><span class="line">                    &#125;</span><br><span class="line">                    filename &#x3D; php_ap_getword_conf(&amp;pair TSRMLS_CC);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (key) &#123;</span><br><span class="line">               efree(key);</span><br><span class="line">          &#125;</span><br><span class="line">          efree(word);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中, PHP会去检查普通数据中,是否有MAX_FILE_SIZE.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Normal form variable, safe to read all data into memory *&#x2F;</span><br><span class="line">if (!filename &amp;&amp; param) &#123;</span><br><span class="line">     unsigned int value_len;</span><br><span class="line">     char *value &#x3D; multipart_buffer_read_body(mbuff, &amp;value_len TSRMLS_CC);</span><br><span class="line">     unsigned int new_val_len; &#x2F;* Dummy variable *&#x2F;</span><br><span class="line">     ......</span><br><span class="line">     if (!strcasecmp(param, &quot;MAX_FILE_SIZE&quot;)) &#123;</span><br><span class="line">                  max_file_size &#x3D; atol(value);</span><br><span class="line">    &#125;</span><br><span class="line">     efree(param);</span><br><span class="line">     efree(value);</span><br><span class="line">     continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的话, 就会按照它的值来检查文件大小是否超出.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (PG(upload_max_filesize) &gt; 0 &amp;&amp; total_bytes &gt; PG(upload_max_filesize)) &#123;</span><br><span class="line">     cancel_upload &#x3D; UPLOAD_ERROR_A;</span><br><span class="line">&#125; else if (max_file_size &amp;&amp; (total_bytes &gt; max_file_size)) &#123;</span><br><span class="line">#if DEBUG_FILE_UPLOAD</span><br><span class="line">     sapi_module.sapi_error(E_NOTICE,</span><br><span class="line">          &quot;MAX_FILE_SIZE of %ld bytes exceeded - file [%s&#x3D;%s] not saved&quot;,</span><br><span class="line">           max_file_size, param, filename);</span><br><span class="line">#endif</span><br><span class="line">     cancel_upload &#x3D; UPLOAD_ERROR_B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码,我们也可以看到, 判断分为俩部, </p><ul><li>第一部分是检查PHP默认的上传上限. </li><li>第二部分才是检查用户自定义的MAX_FILE_SIZE, </li></ul><p>所以表单中定义的MAX_FILE_SIZE并不能超过PHP中设置的最大上传文件大小.</p><p>通过对name和filename的判断, 如果是文件上传, 会根据php的设置, 在文件上传目录中创建一个随机名字的临时文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!skip_upload) &#123;</span><br><span class="line">     &#x2F;* Handle file *&#x2F;</span><br><span class="line">     fd &#x3D; php_open_temporary_fd_ex(PG(upload_tmp_dir),</span><br><span class="line">                &quot;php&quot;, &amp;temp_filename, 1 TSRMLS_CC);</span><br><span class="line">     if (fd&#x3D;&#x3D;-1) &#123;</span><br><span class="line">          sapi_module.sapi_error(E_WARNING,</span><br><span class="line">                &quot;File upload error - unable to create a temporary file&quot;);</span><br><span class="line">          cancel_upload &#x3D; UPLOAD_ERROR_E;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回文件句柄, 和临时随机文件名.<br>之后, 还会有一些验证,比如文件名合法, name合法等.<br>如果这些验证都通过, 那么就把内容读入, 写入到这个临时文件中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">else if (blen &gt; 0) &#123;</span><br><span class="line">     wlen &#x3D; write(fd, buff, blen); &#x2F;&#x2F;写入临时文件.</span><br><span class="line">     if (wlen &#x3D;&#x3D; -1) &#123;</span><br><span class="line">     &#x2F;* write failed *&#x2F;</span><br><span class="line">#if DEBUG_FILE_UPLOAD</span><br><span class="line">     sapi_module.sapi_error(E_NOTICE, &quot;write() failed - %s&quot;, strerror(errno));</span><br><span class="line">#endif</span><br><span class="line">     cancel_upload &#x3D; UPLOAD_ERROR_F;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>当循环读入完成后, 关闭临时文件句柄. 记录临时变量名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_add(SG(rfc1867_uploaded_files), temp_filename,</span><br><span class="line">     strlen(temp_filename) + 1, &amp;temp_filename, sizeof(char *), NULL);</span><br></pre></td></tr></table></figure><p>并且生成FILE变量, 这个时候, 如果是有名上传, 那么就会设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_FILES[&#39;userfile&#39;] &#x2F;&#x2F;name&#x3D;&quot;userfile&quot;</span><br></pre></td></tr></table></figure><p>如果是无名上传, 则会使用tmp_name来设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_FILES[&#39;tmp_name&#39;] &#x2F;&#x2F;无名上传</span><br></pre></td></tr></table></figure><p>最终交给用户编写的upload.php处理.<br>这时在upload.php中, 用户就可以通过move_uploaded_file来操作刚才生成的文件了~</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> 优秀文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 上传原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl上传文件$_FILES为空问题</title>
      <link href="2020/04/09/php-curl%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%BA%E7%A9%BA%E9%97%AE%E9%A2%98/"/>
      <url>2020/04/09/php-curl%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E4%B8%BA%E7%A9%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="php使用curl上传文件"><a href="#php使用curl上传文件" class="headerlink" title="php使用curl上传文件"></a>php使用curl上传文件</h2><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;* http:&#x2F;&#x2F;devtest.com&#x2F;upload.php:</span><br><span class="line">print_r($_POST);</span><br><span class="line">print_r($_FILES);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line"></span><br><span class="line">$data &#x3D; array(&#39;name&#39; &#x3D;&gt; &#39;Foo&#39;, &#39;file&#39; &#x3D;&gt; &#39;@&#x2F;home&#x2F;vagrant&#x2F;test.png&#39;);</span><br><span class="line"></span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &#39;http:&#x2F;&#x2F;devtest.com&#x2F;load_file.php&#39;);</span><br><span class="line">curl_setopt($ch, CURLOPT_POST, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, $data);</span><br><span class="line"></span><br><span class="line">curl_exec($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>接收代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print_r($_POST);</span><br><span class="line">print_r($_FILES);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">php -f demo.php</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">[name] &#x3D;&gt; Foo</span><br><span class="line">[file] &#x3D;&gt; @&#x2F;home&#x2F;vagrant&#x2F;test.png</span><br><span class="line">)</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这时我们发现 通过 curl 发送的文件 在另一边 $_FILES 接受不到</p><h3 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;* http:&#x2F;&#x2F;devtest.com&#x2F;upload.php:</span><br><span class="line">print_r($_POST);</span><br><span class="line">print_r($_FILES);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line"></span><br><span class="line">$data &#x3D; array(&#39;name&#39; &#x3D;&gt; &#39;Foo&#39;, &#39;file&#39; &#x3D;&gt; &#39;@&#x2F;home&#x2F;vagrant&#x2F;test.png&#39;);</span><br><span class="line"></span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &#39;http:&#x2F;&#x2F;devtest.com&#x2F;load_file.php&#39;);</span><br><span class="line">curl_setopt($ch, CURLOPT_POST, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);</span><br><span class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, $data);</span><br><span class="line"></span><br><span class="line">curl_exec($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2:"></a>解决方法2:</h3><blockquote><p>5.6版本下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;* http:&#x2F;&#x2F;devtest.com&#x2F;upload.php:</span><br><span class="line">print_r($_POST);</span><br><span class="line">print_r($_FILES);</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line"></span><br><span class="line">$data &#x3D; array(&#39;name&#39; &#x3D;&gt; &#39;Foo&#39;, &#39;file&#39; &#x3D;&gt; new \CURLFile(realpath(&#39;&#x2F;home&#x2F;vagrant&#x2F;test.png&#39;)));</span><br><span class="line"></span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &#39;http:&#x2F;&#x2F;devtest.com&#x2F;load_file.php&#39;);</span><br><span class="line">curl_setopt($ch, CURLOPT_POST, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);</span><br><span class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, $data);</span><br><span class="line"></span><br><span class="line">curl_exec($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="最后附上完整代码"><a href="#最后附上完整代码" class="headerlink" title="最后附上完整代码"></a>最后附上完整代码</h3><blockquote><p>使用时建议配上域名单独使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if ($_SERVER[&#39;REQUEST_METHOD&#39;] &#x3D;&#x3D; &#39;POST&#39;)&#123;</span><br><span class="line">&#x2F;&#x2F;    var_dump(file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;));die;</span><br><span class="line">    var_dump($_FILES);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;elseif ($_SERVER[&#39;REQUEST_METHOD&#39;] &#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">    $str &#x3D; &lt;&lt;&lt;EOT</span><br><span class="line">&lt;center&gt;&lt;h1&gt;curl 文件上传测试demo&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">EOT;</span><br><span class="line">    echo $str;</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ceshi()</span><br><span class="line">&#123;</span><br><span class="line">    $ch &#x3D; curl_init();</span><br><span class="line"></span><br><span class="line">    $data &#x3D; array(&#39;name&#39; &#x3D;&gt; &#39;Foo&#39;, &#39;file&#39; &#x3D;&gt; new \CURLFile(&#39;&#x2F;Users&#x2F;higanbana&#x2F;Desktop&#x2F;GM8A78.png&#39;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, &#39;http:&#x2F;&#x2F;devtest.com&#x2F;fileTest.php&#39;);</span><br><span class="line">    curl_setopt($ch, CURLOPT_POST, 1);</span><br><span class="line">    curl_setopt($ch, CURLOPT_SAFE_UPLOAD, false);</span><br><span class="line">    curl_setopt($ch, CURLOPT_POSTFIELDS, $data);</span><br><span class="line"></span><br><span class="line">    return curl_exec($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(ceshi()); &#x2F;&#x2F; version php 7.3.11</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> $_FILES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解PHP原理之文件上传（风雪之隅）</title>
      <link href="2020/04/09/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8E%9F%E7%90%86%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/"/>
      <url>2020/04/09/php-%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8E%9F%E7%90%86%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%A3%8E%E9%9B%AA%E4%B9%8B%E9%9A%85/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解PHP原理之文件上传"><a href="#深入理解PHP原理之文件上传" class="headerlink" title="深入理解PHP原理之文件上传"></a>深入理解PHP原理之文件上传</h2><blockquote><p>@author 风雪之隅</p></blockquote><ul><li>本文地址: <a href="https://www.laruence.com/2008/11/07/586.html">https://www.laruence.com/2008/11/07/586.html</a></li><li>转载请注明出处</li></ul><p>今天研究PHP注册POST/GET大变量的时候，看到了关于这块的一些东西，跟踪了半天，先记录下来，免得以后再如此麻烦的跟踪</p><p>处理器注册:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mod_php5.c, mod_php5模块初始化] php_init_handler(server_rec *s, pool *p)</span><br><span class="line">     -&gt;[main&#x2F;SAPI.c]sapi_startup(&amp;apache_sapi_module)</span><br><span class="line">          -&gt;[main&#x2F;SAPI.c] sapi_globals_ctor(&amp;sapi_globals)</span><br><span class="line">               -&gt;[main&#x2F;php_content_types.c]php_setup_sapi_content_types(TSRMLS_C)</span><br><span class="line">                    -&gt;[main&#x2F;php_content_types.c php_post_entries如下]sapi_register_post_entries(php_post_entries TSRMLS_CC)</span><br><span class="line">                         -&gt;[main&#x2F;SAPI.c]sapi_register_post_entry(p TSRMLS_CC)</span><br></pre></td></tr></table></figure><p>如下面的代码，共注册了俩个处理器，分别处理post数据和文件上传。</p><blockquote><p>注1:G(http_globals)[TRACK_VARS_COOKIE]这部分,可以参看我较早前的 <a href="http://www.laruence.com/2008/04/04/17.html">在PHP Module中获取$_GET/$_POST/$_COOKIE的方法研究</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[main&#x2F;rfc1867.h]</span><br><span class="line">      #define MULTIPART_CONTENT_TYPE &quot;multipart&#x2F;form-data&quot;</span><br><span class="line">  [main&#x2F;php_content_types.h]</span><br><span class="line">     #define DEFAULT_POST_CONTENT_TYPE &quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">  [main&#x2F;SAPI.c]</span><br><span class="line">     struct _sapi_post_entry &#123;</span><br><span class="line">         char *content_type;</span><br><span class="line">         uint content_type_len;</span><br><span class="line">         void (*post_reader)(TSRMLS_D);</span><br><span class="line">         void (*post_handler)(char *content_type_dup, void *arg TSRMLS_DC);</span><br><span class="line">     &#125;;</span><br><span class="line">  [main&#x2F;php_content_types.c]</span><br><span class="line">     static sapi_post_entry php_post_entries[] &#x3D; &#123;</span><br><span class="line">         &#123; DEFAULT_POST_CONTENT_TYPE, sizeof(DEFAULT_POST_CONTENT_TYPE)-1, sapi_read_standard_form_data, php_std_post_handler &#125;,</span><br><span class="line">         &#123; MULTIPART_CONTENT_TYPE,    sizeof(MULTIPART_CONTENT_TYPE)-1,    NULL,                         rfc1867_post_handler &#125;,</span><br><span class="line">         &#123; NULL, 0, NULL, NULL &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么对于rfc1867_post_handler函数来说,我罗列出源码如下, 加了我的注释.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line">SAPI_API SAPI_POST_HANDLER_FUNC(rfc1867_post_handler)</span><br><span class="line">&#123;</span><br><span class="line">        char *boundary, *s&#x3D;NULL, *boundary_end &#x3D; NULL, *start_arr&#x3D;NULL, *array_index&#x3D;NULL;</span><br><span class="line">        char *temp_filename&#x3D;NULL, *lbuf&#x3D;NULL, *abuf&#x3D;NULL;</span><br><span class="line">        int boundary_len&#x3D;0, total_bytes&#x3D;0, cancel_upload&#x3D;0, is_arr_upload&#x3D;0, array_len&#x3D;0;</span><br><span class="line">        int max_file_size&#x3D;0, skip_upload&#x3D;0, anonindex&#x3D;0, is_anonymous;</span><br><span class="line">        zval *http_post_files&#x3D;NULL; HashTable *uploaded_files&#x3D;NULL;</span><br><span class="line">#if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING)</span><br><span class="line">        int str_len &#x3D; 0, num_vars &#x3D; 0, num_vars_max &#x3D; 2*10, *len_list &#x3D; NULL;</span><br><span class="line">        char **val_list &#x3D; NULL;</span><br><span class="line">#endif</span><br><span class="line">        zend_bool magic_quotes_gpc;</span><br><span class="line">        multipart_buffer *mbuff;</span><br><span class="line">        zval *array_ptr &#x3D; (zval *) arg;</span><br><span class="line">        int fd&#x3D;-1;</span><br><span class="line">        zend_llist header;</span><br><span class="line">        void *event_extra_data &#x3D; NULL;</span><br><span class="line">        int llen &#x3D; 0;</span><br><span class="line">          &#x2F;&#x2F;检查是否超出最大上传文件大小</span><br><span class="line">        if (SG(request_info).content_length &gt; SG(post_max_size)) &#123;</span><br><span class="line">                sapi_module.sapi_error(E_WARNING, &quot;POST Content-Length of %ld bytes exceeds the limit of %ld bytes&quot;, SG(request_info).content_length, SG(post_max_size));</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;取得上传文件的分隔符</span><br><span class="line">        boundary &#x3D; strstr(content_type_dup, &quot;boundary&quot;);</span><br><span class="line">        if (!boundary || !(boundary&#x3D;strchr(boundary, &#39;&#x3D;&#39;))) &#123;</span><br><span class="line">                sapi_module.sapi_error(E_WARNING, &quot;Missing boundary in multipart&#x2F;form-data POST data&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        boundary++;</span><br><span class="line">        boundary_len &#x3D; strlen(boundary);</span><br><span class="line">        if (boundary[0] &#x3D;&#x3D; &#39;&quot;&#39;) &#123;</span><br><span class="line">                boundary++;</span><br><span class="line">                boundary_end &#x3D; strchr(boundary, &#39;&quot;&#39;);</span><br><span class="line">                if (!boundary_end) &#123;</span><br><span class="line">                        sapi_module.sapi_error(E_WARNING, &quot;Invalid boundary in multipart&#x2F;form-data POST data&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                &#x2F;* search for the end of the boundary *&#x2F;</span><br><span class="line">                boundary_end &#x3D; strchr(boundary, &#39;,&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (boundary_end) &#123;</span><br><span class="line">                boundary_end[0] &#x3D; &#39;&#39;;</span><br><span class="line">                boundary_len &#x3D; boundary_end-boundary;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;* Initialize the buffer *&#x2F;</span><br><span class="line">        if (!(mbuff &#x3D; multipart_buffer_new(boundary, boundary_len))) &#123;</span><br><span class="line">                sapi_module.sapi_error(E_WARNING, &quot;Unable to initialize the input buffer&quot;);</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;初始化$_FILE变量</span><br><span class="line">        zend_hash_init(&amp;PG(rfc1867_protected_variables), 5, NULL, NULL, 0);</span><br><span class="line">        ALLOC_HASHTABLE(uploaded_files);</span><br><span class="line">        zend_hash_init(uploaded_files, 5, NULL, (dtor_func_t) free_estring, 0);</span><br><span class="line">        SG(rfc1867_uploaded_files) &#x3D; uploaded_files;</span><br><span class="line">        ALLOC_ZVAL(http_post_files);</span><br><span class="line">        array_init(http_post_files);</span><br><span class="line">        INIT_PZVAL(http_post_files);</span><br><span class="line">        PG(http_globals)[TRACK_VARS_FILES] &#x3D; http_post_files; &#x2F;&#x2F;TRACK_VARS_FILE正是_FILE在php_core_globals.http_globals中的index (注1)</span><br><span class="line">#if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING)</span><br><span class="line">        if (php_mb_encoding_translation(TSRMLS_C)) &#123;</span><br><span class="line">                val_list &#x3D; (char **)ecalloc(num_vars_max+2, sizeof(char *));</span><br><span class="line">                len_list &#x3D; (int *)ecalloc(num_vars_max+2, sizeof(int));</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        zend_llist_init(&amp;header, sizeof(mime_header_entry), (llist_dtor_func_t) php_free_hdr_entry, 0);</span><br><span class="line">        if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                multipart_event_start event_start;</span><br><span class="line">                event_start.content_length &#x3D; SG(request_info).content_length;</span><br><span class="line">                if (php_rfc1867_callback(MULTIPART_EVENT_START, &amp;event_start, &amp;event_extra_data TSRMLS_CC) &#x3D;&#x3D; FAILURE) &#123;</span><br><span class="line">                        goto fileupload_done;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!multipart_buffer_eof(mbuff TSRMLS_CC))</span><br><span class="line">        &#123;</span><br><span class="line">                char buff[FILLUNIT];</span><br><span class="line">                char *cd&#x3D;NULL,*param&#x3D;NULL,*filename&#x3D;NULL, *tmp&#x3D;NULL;</span><br><span class="line">                size_t blen&#x3D;0, wlen&#x3D;0;</span><br><span class="line">                off_t offset;</span><br><span class="line">                zend_llist_clean(&amp;header);</span><br><span class="line">                if (!multipart_buffer_headers(mbuff, &amp;header TSRMLS_CC)) &#123;</span><br><span class="line">                        goto fileupload_done;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((cd &#x3D; php_mime_get_hdr_value(header, &quot;Content-Disposition&quot;))) &#123;</span><br><span class="line">                        char *pair&#x3D;NULL;</span><br><span class="line">                        int end&#x3D;0;</span><br><span class="line">                        while (isspace(*cd)) &#123;</span><br><span class="line">                                ++cd;</span><br><span class="line">                        &#125;</span><br><span class="line">                        while (*cd &amp;&amp; (pair &#x3D; php_ap_getword(&amp;cd, &#39;;&#39;)))</span><br><span class="line">                        &#123;</span><br><span class="line">                                char *key&#x3D;NULL, *word &#x3D; pair;</span><br><span class="line">                                while (isspace(*cd)) &#123;</span><br><span class="line">                                        ++cd;</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (strchr(pair, &#39;&#x3D;&#39;)) &#123;</span><br><span class="line">                                        key &#x3D; php_ap_getword(&amp;pair, &#39;&#x3D;&#39;);</span><br><span class="line">                                        if (!strcasecmp(key, &quot;name&quot;)) &#123;</span><br><span class="line">                                                if (param) &#123;</span><br><span class="line">                                                        efree(param);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                param &#x3D; php_ap_getword_conf(&amp;pair TSRMLS_CC);</span><br><span class="line">                                        &#125; else if (!strcasecmp(key, &quot;filename&quot;)) &#123;</span><br><span class="line">                                                if (filename) &#123;</span><br><span class="line">                                                        efree(filename);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                filename &#x3D; php_ap_getword_conf(&amp;pair TSRMLS_CC);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (key) &#123;</span><br><span class="line">                                        efree(key);</span><br><span class="line">                                &#125;</span><br><span class="line">                                efree(word);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Normal form variable, safe to read all data into memory *&#x2F;</span><br><span class="line">                        if (!filename &amp;&amp; param) &#123;</span><br><span class="line">                                unsigned int value_len;</span><br><span class="line">                                char *value &#x3D; multipart_buffer_read_body(mbuff, &amp;value_len TSRMLS_CC);</span><br><span class="line">                                unsigned int new_val_len; &#x2F;* Dummy variable *&#x2F;</span><br><span class="line">                                if (!value) &#123;</span><br><span class="line">                                        value &#x3D; estrdup(&quot;&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (sapi_module.input_filter(PARSE_POST, param, &amp;value, value_len, &amp;new_val_len TSRMLS_CC)) &#123;</span><br><span class="line">                                        if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                                                multipart_event_formdata event_formdata;</span><br><span class="line">                                                size_t newlength &#x3D; 0;</span><br><span class="line">                                                event_formdata.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                                                event_formdata.name &#x3D; param;</span><br><span class="line">                                                event_formdata.value &#x3D; &amp;value;</span><br><span class="line">                                                event_formdata.length &#x3D; new_val_len;</span><br><span class="line">                                                event_formdata.newlength &#x3D; &amp;newlength;</span><br><span class="line">                                                if (php_rfc1867_callback(MULTIPART_EVENT_FORMDATA, &amp;event_formdata, &amp;event_extra_data TSRMLS_CC) &#x3D;&#x3D; FAILURE) &#123;</span><br><span class="line">                                                        efree(param);</span><br><span class="line">                                                        efree(value);</span><br><span class="line">                                                        continue;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                new_val_len &#x3D; newlength;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING)</span><br><span class="line">                                        if (php_mb_encoding_translation(TSRMLS_C)) &#123;</span><br><span class="line">                                                php_mb_gpc_stack_variable(param, value, &amp;val_list, &amp;len_list,</span><br><span class="line">                                                                                                  &amp;num_vars, &amp;num_vars_max TSRMLS_CC);</span><br><span class="line">                                        &#125; else &#123;</span><br><span class="line">                                                safe_php_register_variable(param, value, new_val_len, array_ptr, 0 TSRMLS_CC);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        #else</span><br><span class="line">                                        safe_php_register_variable(param, value, new_val_len, array_ptr, 0 TSRMLS_CC);</span><br><span class="line">                                #endif</span><br><span class="line">                                &#125; else if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                                        multipart_event_formdata event_formdata;</span><br><span class="line">                                        event_formdata.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                                        event_formdata.name &#x3D; param;</span><br><span class="line">                                        event_formdata.value &#x3D; &amp;value;</span><br><span class="line">                                        event_formdata.length &#x3D; value_len;</span><br><span class="line">                                        event_formdata.newlength &#x3D; NULL;</span><br><span class="line">                                        php_rfc1867_callback(MULTIPART_EVENT_FORMDATA, &amp;event_formdata, &amp;event_extra_data TSRMLS_CC);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!strcasecmp(param, &quot;MAX_FILE_SIZE&quot;)) &#123;</span><br><span class="line">                                        max_file_size &#x3D; atol(value);</span><br><span class="line">                                &#125;</span><br><span class="line">                                efree(param);</span><br><span class="line">                                efree(value);</span><br><span class="line">                                continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* If file_uploads&#x3D;off, skip the file part *&#x2F;</span><br><span class="line">                        if (!PG(file_uploads)) &#123;</span><br><span class="line">                                skip_upload &#x3D; 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Return with an error if the posted data is garbled *&#x2F;</span><br><span class="line">                        if (!param &amp;&amp; !filename) &#123;</span><br><span class="line">                                sapi_module.sapi_error(E_WARNING, &quot;File Upload Mime headers garbled&quot;);</span><br><span class="line">                                goto fileupload_done;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!param) &#123;</span><br><span class="line">                                is_anonymous &#x3D; 1;</span><br><span class="line">                                param &#x3D; emalloc(MAX_SIZE_ANONNAME);</span><br><span class="line">                                snprintf(param, MAX_SIZE_ANONNAME, &quot;%u&quot;, anonindex++);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                is_anonymous &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* New Rule: never repair potential malicious user input *&#x2F;</span><br><span class="line">                        if (!skip_upload) &#123;</span><br><span class="line">                                char *tmp &#x3D; param;</span><br><span class="line">                                long c &#x3D; 0;</span><br><span class="line">                                while (*tmp) &#123;</span><br><span class="line">                                        if (*tmp &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                                                c++;</span><br><span class="line">                                        &#125; else if (*tmp &#x3D;&#x3D; &#39;]&#39;) &#123;</span><br><span class="line">                                                c--;</span><br><span class="line">                                                if (tmp[1] &amp;&amp; tmp[1] !&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">                                                        skip_upload &#x3D; 1;</span><br><span class="line">                                                        break;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        if (c &lt; 0) &#123;</span><br><span class="line">                                                skip_upload &#x3D; 1;</span><br><span class="line">                                                break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        tmp++;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        total_bytes &#x3D; cancel_upload &#x3D; 0;</span><br><span class="line">                        if (!skip_upload) &#123;</span><br><span class="line">                                &#x2F;* Handle file *&#x2F;</span><br><span class="line">                                fd &#x3D; php_open_temporary_fd_ex(PG(upload_tmp_dir), &quot;php&quot;, &amp;temp_filename, 1 TSRMLS_CC);</span><br><span class="line">                                if (fd&#x3D;&#x3D;-1) &#123;</span><br><span class="line">                                        sapi_module.sapi_error(E_WARNING, &quot;File upload error - unable to create a temporary file&quot;);</span><br><span class="line">                                        cancel_upload &#x3D; UPLOAD_ERROR_E;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!skip_upload &amp;&amp; php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                                multipart_event_file_start event_file_start;</span><br><span class="line">                                event_file_start.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                                event_file_start.name &#x3D; param;</span><br><span class="line">                                event_file_start.filename &#x3D; &amp;filename;</span><br><span class="line">                                if (php_rfc1867_callback(MULTIPART_EVENT_FILE_START, &amp;event_file_start, &amp;event_extra_data TSRMLS_CC) &#x3D;&#x3D; FAILURE) &#123;</span><br><span class="line">                                        if (temp_filename) &#123;</span><br><span class="line">                                                if (cancel_upload !&#x3D; UPLOAD_ERROR_E) &#123; &#x2F;* file creation failed *&#x2F;</span><br><span class="line">                                                        close(fd);</span><br><span class="line">                                                        unlink(temp_filename);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                efree(temp_filename);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        temp_filename&#x3D;&quot;&quot;;</span><br><span class="line">                                        efree(param);</span><br><span class="line">                                        efree(filename);</span><br><span class="line">                                        continue;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (skip_upload) &#123;</span><br><span class="line">                                efree(param);</span><br><span class="line">                                efree(filename);</span><br><span class="line">                                continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(strlen(filename) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                sapi_module.sapi_error(E_NOTICE, &quot;No file uploaded&quot;);</span><br><span class="line">                                #endif</span><br><span class="line">                                cancel_upload &#x3D; UPLOAD_ERROR_D;</span><br><span class="line">                        &#125;</span><br><span class="line">                        offset &#x3D; 0;</span><br><span class="line">                        end &#x3D; 0;</span><br><span class="line">                        while (!cancel_upload &amp;&amp; (blen &#x3D; multipart_buffer_read(mbuff, buff, sizeof(buff), &amp;end TSRMLS_CC)))</span><br><span class="line">                        &#123;</span><br><span class="line">                                if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                                        multipart_event_file_data event_file_data;</span><br><span class="line">                                        event_file_data.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                                        event_file_data.offset &#x3D; offset;</span><br><span class="line">                                        event_file_data.data &#x3D; buff;</span><br><span class="line">                                        event_file_data.length &#x3D; blen;</span><br><span class="line">                                        event_file_data.newlength &#x3D; &amp;blen;</span><br><span class="line">                                        if (php_rfc1867_callback(MULTIPART_EVENT_FILE_DATA, &amp;event_file_data, &amp;event_extra_data TSRMLS_CC) &#x3D;&#x3D; FAILURE) &#123;</span><br><span class="line">                                                cancel_upload &#x3D; UPLOAD_ERROR_X;</span><br><span class="line">                                                continue;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (PG(upload_max_filesize) &gt; 0 &amp;&amp; total_bytes &gt; PG(upload_max_filesize)) &#123;</span><br><span class="line">                                        #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                        sapi_module.sapi_error(E_NOTICE, &quot;upload_max_filesize of %ld bytes exceeded - file [%s&#x3D;%s] not saved&quot;, PG(upload_max_filesize), param, filename);</span><br><span class="line">                                        #endif</span><br><span class="line">                                        cancel_upload &#x3D; UPLOAD_ERROR_A;</span><br><span class="line">                                &#125; else if (max_file_size &amp;&amp; (total_bytes &gt; max_file_size)) &#123;</span><br><span class="line">                                        #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                        sapi_module.sapi_error(E_NOTICE, &quot;MAX_FILE_SIZE of %ld bytes exceeded - file [%s&#x3D;%s] not saved&quot;, max_file_size, param, filename);</span><br><span class="line">                                        #endif</span><br><span class="line">                                        cancel_upload &#x3D; UPLOAD_ERROR_B;</span><br><span class="line">                                &#125; else if (blen &gt; 0) &#123;</span><br><span class="line">                                        wlen &#x3D; write(fd, buff, blen);</span><br><span class="line">                                        if (wlen &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                                                &#x2F;* write failed *&#x2F;</span><br><span class="line">                                                #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                                sapi_module.sapi_error(E_NOTICE, &quot;write() failed - %s&quot;, strerror(errno));</span><br><span class="line">                                                #endif</span><br><span class="line">                                                cancel_upload &#x3D; UPLOAD_ERROR_F;</span><br><span class="line">                                        &#125; else if (wlen &lt; blen) &#123;</span><br><span class="line">                                                #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                                sapi_module.sapi_error(E_NOTICE, &quot;Only %d bytes were written, expected to write %d&quot;, wlen, blen);</span><br><span class="line">                                                #endif</span><br><span class="line">                                                cancel_upload &#x3D; UPLOAD_ERROR_F;</span><br><span class="line">                                        &#125; else &#123;</span><br><span class="line">                                                total_bytes +&#x3D; wlen;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        offset +&#x3D; wlen;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (fd!&#x3D;-1) &#123; &#x2F;* may not be initialized if file could not be created *&#x2F;</span><br><span class="line">                                close(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!cancel_upload &amp;&amp; !end) &#123;</span><br><span class="line">                                #if DEBUG_FILE_UPLOAD</span><br><span class="line">                                sapi_module.sapi_error(E_NOTICE, &quot;Missing mime boundary at the end of the data for file %s&quot;, strlen(filename) &gt; 0 ? filename : &quot;&quot;);</span><br><span class="line">                                #endif</span><br><span class="line">                                cancel_upload &#x3D; UPLOAD_ERROR_C;</span><br><span class="line">                        &#125;</span><br><span class="line">                        #if DEBUG_FILE_UPLOAD</span><br><span class="line">                        if(strlen(filename) &gt; 0 &amp;&amp; total_bytes &#x3D;&#x3D; 0 &amp;&amp; !cancel_upload) &#123;</span><br><span class="line">                                sapi_module.sapi_error(E_WARNING, &quot;Uploaded file size 0 - file [%s&#x3D;%s] not saved&quot;, param, filename);</span><br><span class="line">                                cancel_upload &#x3D; 5;</span><br><span class="line">                        &#125;</span><br><span class="line">                        #endif</span><br><span class="line">                        if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                                multipart_event_file_end event_file_end;</span><br><span class="line">                                event_file_end.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                                event_file_end.temp_filename &#x3D; temp_filename;</span><br><span class="line">                                event_file_end.cancel_upload &#x3D; cancel_upload;</span><br><span class="line">                                if (php_rfc1867_callback(MULTIPART_EVENT_FILE_END, &amp;event_file_end, &amp;event_extra_data TSRMLS_CC) &#x3D;&#x3D; FAILURE) &#123;</span><br><span class="line">                                        cancel_upload &#x3D; UPLOAD_ERROR_X;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (cancel_upload) &#123;</span><br><span class="line">                                if (temp_filename) &#123;</span><br><span class="line">                                        if (cancel_upload !&#x3D; UPLOAD_ERROR_E) &#123; &#x2F;* file creation failed *&#x2F;</span><br><span class="line">                                                unlink(temp_filename);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        efree(temp_filename);</span><br><span class="line">                                &#125;</span><br><span class="line">                                temp_filename&#x3D;&quot;&quot;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                zend_hash_add(SG(rfc1867_uploaded_files), temp_filename, strlen(temp_filename) + 1, &amp;temp_filename, sizeof(char *), NULL);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* is_arr_upload is true when name of file upload field</span><br><span class="line">                         * ends in [.*]</span><br><span class="line">                         * start_arr is set to point to 1st [</span><br><span class="line">                         *&#x2F;</span><br><span class="line">                        is_arr_upload &#x3D; (start_arr &#x3D; strchr(param,&#39;[&#39;)) &amp;&amp; (param[strlen(param)-1] &#x3D;&#x3D; &#39;]&#39;);</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                array_len &#x3D; strlen(start_arr);</span><br><span class="line">                                if (array_index) &#123;</span><br><span class="line">                                        efree(array_index);</span><br><span class="line">                                &#125;</span><br><span class="line">                                array_index &#x3D; estrndup(start_arr+1, array_len-2);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Add $foo_name *&#x2F;</span><br><span class="line">                        if (llen &lt; strlen(param) + MAX_SIZE_OF_INDEX + 1) &#123;</span><br><span class="line">                                llen &#x3D; strlen(param);</span><br><span class="line">                                lbuf &#x3D; (char *) safe_erealloc(lbuf, llen, 1, MAX_SIZE_OF_INDEX + 1);</span><br><span class="line">                                llen +&#x3D; MAX_SIZE_OF_INDEX + 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                if (abuf) efree(abuf);</span><br><span class="line">                                abuf &#x3D; estrndup(param, strlen(param)-array_len);</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s_name[%s]&quot;, abuf, array_index);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s_name&quot;, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING)</span><br><span class="line">                        if (php_mb_encoding_translation(TSRMLS_C)) &#123;</span><br><span class="line">                                if (num_vars&gt;&#x3D;num_vars_max)&#123;</span><br><span class="line">                                        php_mb_gpc_realloc_buffer(&amp;val_list, &amp;len_list, &amp;num_vars_max,</span><br><span class="line">                                                                                          1 TSRMLS_CC);</span><br><span class="line">                                &#125;</span><br><span class="line">                                val_list[num_vars] &#x3D; filename;</span><br><span class="line">                                len_list[num_vars] &#x3D; strlen(filename);</span><br><span class="line">                                num_vars++;</span><br><span class="line">                                if(php_mb_gpc_encoding_detector(val_list, len_list, num_vars, NULL TSRMLS_CC) &#x3D;&#x3D; SUCCESS) &#123;</span><br><span class="line">                                        str_len &#x3D; strlen(filename);</span><br><span class="line">                                        php_mb_gpc_encoding_converter(&amp;filename, &amp;str_len, 1, NULL, NULL TSRMLS_CC);</span><br><span class="line">                                &#125;</span><br><span class="line">                                s &#x3D; php_mb_strrchr(filename, &#39;\&#39; TSRMLS_CC);</span><br><span class="line">                                if ((tmp &#x3D; php_mb_strrchr(filename, &#39;&#x2F;&#39; TSRMLS_CC)) &gt; s) &#123;</span><br><span class="line">                                        s &#x3D; tmp;</span><br><span class="line">                                &#125;</span><br><span class="line">                                num_vars--;</span><br><span class="line">                                goto filedone;</span><br><span class="line">                        &#125;</span><br><span class="line">                        #endif</span><br><span class="line">                        &#x2F;* The  check should technically be needed for win32 systems only where</span><br><span class="line">                         * it is a valid path separator. However, IE in all it&#39;s wisdom always sends</span><br><span class="line">                         * the full path of the file on the user&#39;s filesystem, which means that unless</span><br><span class="line">                         * the user does basename() they get a bogus file name. Until IE&#39;s user base drops</span><br><span class="line">                         * to nill or problem is fixed this code must remain enabled for all systems.</span><br><span class="line">                         *&#x2F;</span><br><span class="line">                        s &#x3D; strrchr(filename, &#39;\&#39;);</span><br><span class="line">                        if ((tmp &#x3D; strrchr(filename, &#39;&#x2F;&#39;)) &gt; s) &#123;</span><br><span class="line">                                s &#x3D; tmp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        #ifdef PHP_WIN32</span><br><span class="line">                        if (PG(magic_quotes_gpc)) &#123;</span><br><span class="line">                                s &#x3D; s ? s : filename;</span><br><span class="line">                                tmp &#x3D; strrchr(s, &#39;&#39;&#39;);</span><br><span class="line">                                s &#x3D; tmp &gt; s ? tmp : s;</span><br><span class="line">                                tmp &#x3D; strrchr(s, &#39;&quot;&#39;);</span><br><span class="line">                                s &#x3D; tmp &gt; s ? tmp : s;</span><br><span class="line">                        &#125;</span><br><span class="line">                        #endif</span><br><span class="line">                        #if HAVE_MBSTRING &amp;&amp; !defined(COMPILE_DL_MBSTRING)</span><br><span class="line">                        filedone:</span><br><span class="line">                        #endif</span><br><span class="line">                        if (!is_anonymous) &#123;</span><br><span class="line">                                if (s &amp;&amp; s &gt; filename) &#123;</span><br><span class="line">                                        safe_php_register_variable(lbuf, s+1, strlen(s+1), NULL, 0 TSRMLS_CC);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        safe_php_register_variable(lbuf, filename, strlen(filename), NULL, 0 TSRMLS_CC);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Add $foo[name] *&#x2F;</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[name][%s]&quot;, abuf, array_index);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[name]&quot;, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (s &amp;&amp; s &gt; filename) &#123;</span><br><span class="line">                                register_http_post_files_variable(lbuf, s+1, http_post_files, 0 TSRMLS_CC);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                register_http_post_files_variable(lbuf, filename, http_post_files, 0 TSRMLS_CC);</span><br><span class="line">                        &#125;</span><br><span class="line">                        efree(filename);</span><br><span class="line">                        s &#x3D; NULL;</span><br><span class="line">                        &#x2F;* Possible Content-Type: *&#x2F;</span><br><span class="line">                        if (cancel_upload || !(cd &#x3D; php_mime_get_hdr_value(header, &quot;Content-Type&quot;))) &#123;</span><br><span class="line">                                cd &#x3D; &quot;&quot;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                &#x2F;* fix for Opera 6.01 *&#x2F;</span><br><span class="line">                                s &#x3D; strchr(cd, &#39;;&#39;);</span><br><span class="line">                                if (s !&#x3D; NULL) &#123;</span><br><span class="line">                                        *s &#x3D; &#39;&#39;;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Add $foo_type *&#x2F;</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s_type[%s]&quot;, abuf, array_index);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s_type&quot;, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!is_anonymous) &#123;</span><br><span class="line">                                safe_php_register_variable(lbuf, cd, strlen(cd), NULL, 0 TSRMLS_CC);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Add $foo[type] *&#x2F;</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[type][%s]&quot;, abuf, array_index);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[type]&quot;, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        register_http_post_files_variable(lbuf, cd, http_post_files, 0 TSRMLS_CC);</span><br><span class="line">                        &#x2F;* Restore Content-Type Header *&#x2F;</span><br><span class="line">                        if (s !&#x3D; NULL) &#123;</span><br><span class="line">                                *s &#x3D; &#39;;&#39;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        s &#x3D; &quot;&quot;;</span><br><span class="line">                        &#x2F;* Initialize variables *&#x2F;</span><br><span class="line">                        add_protected_variable(param TSRMLS_CC);</span><br><span class="line">                        magic_quotes_gpc &#x3D; PG(magic_quotes_gpc);</span><br><span class="line">                        PG(magic_quotes_gpc) &#x3D; 0;</span><br><span class="line">                        &#x2F;* if param is of form xxx[.*] this will cut it to xxx *&#x2F;</span><br><span class="line">                        if (!is_anonymous) &#123;</span><br><span class="line">                                safe_php_register_variable(param, temp_filename, strlen(temp_filename), NULL, 1 TSRMLS_CC);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;* Add $foo[tmp_name] *&#x2F;</span><br><span class="line">                        if (is_arr_upload) &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[tmp_name][%s]&quot;, abuf, array_index);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                snprintf(lbuf, llen, &quot;%s[tmp_name]&quot;, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        add_protected_variable(lbuf TSRMLS_CC);</span><br><span class="line">                        register_http_post_files_variable(lbuf, temp_filename, http_post_files, 1 TSRMLS_CC);</span><br><span class="line">                        PG(magic_quotes_gpc) &#x3D; magic_quotes_gpc;</span><br><span class="line">                        &#123;</span><br><span class="line">                                zval file_size, error_type;</span><br><span class="line">                                error_type.value.lval &#x3D; cancel_upload;</span><br><span class="line">                                error_type.type &#x3D; IS_LONG;</span><br><span class="line">                                &#x2F;* Add $foo[error] *&#x2F;</span><br><span class="line">                                if (cancel_upload) &#123;</span><br><span class="line">                                        file_size.value.lval &#x3D; 0;</span><br><span class="line">                                        file_size.type &#x3D; IS_LONG;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        file_size.value.lval &#x3D; total_bytes;</span><br><span class="line">                                        file_size.type &#x3D; IS_LONG;</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (is_arr_upload) &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s[error][%s]&quot;, abuf, array_index);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s[error]&quot;, param);</span><br><span class="line">                                &#125;</span><br><span class="line">                                register_http_post_files_variable_ex(lbuf, &amp;error_type, http_post_files, 0 TSRMLS_CC);</span><br><span class="line">                                &#x2F;* Add $foo_size *&#x2F;</span><br><span class="line">                                if (is_arr_upload) &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s_size[%s]&quot;, abuf, array_index);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s_size&quot;, param);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!is_anonymous) &#123;</span><br><span class="line">                                        safe_php_register_variable_ex(lbuf, &amp;file_size, NULL, 0 TSRMLS_CC);</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;* Add $foo[size] *&#x2F;</span><br><span class="line">                                if (is_arr_upload) &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s[size][%s]&quot;, abuf, array_index);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        snprintf(lbuf, llen, &quot;%s[size]&quot;, param);</span><br><span class="line">                                &#125;</span><br><span class="line">                                register_http_post_files_variable_ex(lbuf, &amp;file_size, http_post_files, 0 TSRMLS_CC);</span><br><span class="line">                        &#125;</span><br><span class="line">                        efree(param);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fileupload_done:</span><br><span class="line">        if (php_rfc1867_callback !&#x3D; NULL) &#123;</span><br><span class="line">                multipart_event_end event_end;</span><br><span class="line">                event_end.post_bytes_processed &#x3D; SG(read_post_bytes);</span><br><span class="line">                php_rfc1867_callback(MULTIPART_EVENT_END, &amp;event_end, &amp;event_extra_data TSRMLS_CC);</span><br><span class="line">        &#125;</span><br><span class="line">        SAFE_RETURN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> 优秀文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 上传原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 松耦合</title>
      <link href="2020/04/02/java-spring-%E6%9D%BE%E8%80%A6%E5%90%88-2020-04-02/"/>
      <url>2020/04/02/java-spring-%E6%9D%BE%E8%80%A6%E5%90%88-2020-04-02/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-松耦合"><a href="#Spring-松耦合" class="headerlink" title="Spring 松耦合"></a>Spring 松耦合</h2><blockquote><p>在电脑运算和系统设计中，一个松耦合的系统中的每一个组件对其他独立组件的定义所知甚少或一无所知。子范围包括类、接口、数据和服务之间的耦合。 松耦合是紧耦合的对立面。</p></blockquote><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><ul><li>优点</li></ul><p>松耦合系统中的组件能够被提供相同服务的替代实现所替换。松耦合系统中的组件不太受相同的平台、语言、操作系统或构建环境的约束。</p><ul><li>缺点</li></ul><p>如果系统在时间上是解耦的，那么也很难提供事务完整性；需要额外的协调协议。跨系统的数据复制提供了松耦合性（可用性），但是造成了维护一致性（数据同步）的问题。</p><h3 id="松耦合的目的"><a href="#松耦合的目的" class="headerlink" title="松耦合的目的"></a>松耦合的目的</h3><p>上一部分，我们已经创建了 Maven 项目，打印出了 HelloShiyanlou。为了方便，我使用上面的工程，pom.xml 文件一致，不必修改。下面，我们实验证明 Spring 的松耦合。假设项目需要输出到 CSV 或者 JSON。</p><h3 id="松耦合代码编写"><a href="#松耦合代码编写" class="headerlink" title="松耦合代码编写"></a>松耦合代码编写</h3><h4 id="IOutputGenerator-java"><a href="#IOutputGenerator-java" class="headerlink" title="IOutputGenerator.java"></a>IOutputGenerator.java</h4><p>创建 com.study.demo.loosely_coupled 包，新建一个 IOutputGenerator 接口，接口内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo.loosely_coupled;</span><br><span class="line"></span><br><span class="line">public interface IOutputGenerator&#123;</span><br><span class="line">  public void generateOutput();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CsvOutputGenerator-java"><a href="#CsvOutputGenerator-java" class="headerlink" title="CsvOutputGenerator.java"></a>CsvOutputGenerator.java</h4><p>CSV 输出，实现了 IOutputGenerator 接口。同样的包路径，新建一个 CsvOutputGenerator.java</p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo.loosely_coupled;</span><br><span class="line"></span><br><span class="line">public class CsvOutputGenerator implements IOutputGenerator&#123;</span><br><span class="line"></span><br><span class="line">  public void generateOutput()&#123;</span><br><span class="line">    System.out.println(&quot;Creating CsvOutputGenerator  Output......&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JsonOutputGenerator-java"><a href="#JsonOutputGenerator-java" class="headerlink" title="JsonOutputGenerator.java"></a>JsonOutputGenerator.java</h4><p>JSON 输出，实现了 IOutputGenerator 接口。同样的包路径，新建一个 JsonOutputGenerator.java。 </p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo.loosely_coupled;</span><br><span class="line"></span><br><span class="line">public class JsonOutputGenerator implements IOutputGenerator&#123;</span><br><span class="line"></span><br><span class="line">  public void generateOutput()&#123;</span><br><span class="line">    System.out.println(&quot;Creating JsonOutputGenerator  Output......&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用-Spring-依赖注入调用输出"><a href="#用-Spring-依赖注入调用输出" class="headerlink" title="用 Spring 依赖注入调用输出"></a>用 Spring 依赖注入调用输出</h3><p>用 Spring 的松耦合实现输出相应的格式。 首先在 com.shiyanlou.demo.loosely_coupled 包内创建一个需要用到输出的类 OutputHelper.java</p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo.loosely_coupled;</span><br><span class="line"></span><br><span class="line">public class OutputHelper&#123;</span><br><span class="line">  IOutputGenerator outputGenerator;</span><br><span class="line"></span><br><span class="line">  public void generateOutput()&#123;</span><br><span class="line">    this.outputGenerator.generateOutput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setOutputGenerator(IOutputGenerator outputGenerator)&#123;</span><br><span class="line">    this.outputGenerator &#x3D; outputGenerator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个-spring-配置文件"><a href="#创建一个-spring-配置文件" class="headerlink" title="创建一个 spring 配置文件"></a>创建一个 spring 配置文件</h3><p>此文件用于依赖管理 src/main/resources 下创建配置文件 Spring-Output.xml。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id &#x3D; &quot;OutputHelper&quot; class &#x3D; &quot;com.study.demo.loosely_coupled.OutputHelper&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;outputGenerator&quot; ref &#x3D; &quot;CsvOutputGenerator&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;CsvOutputGenerator&quot; class &#x3D; &quot;com.study.demo.loosely_coupled.CsvOutputGenerator&quot; &#x2F;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;JsonOutputGenerator&quot; class &#x3D; &quot;com.study.demo.loosely_coupled.JsonOutputGenerator&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="App-java"><a href="#App-java" class="headerlink" title="App.java"></a>App.java</h3><p>修改此文件用于通过 Spring 调用相应的 output</p><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.study.demo.loosely_coupled.OutputHelper;</span><br><span class="line"></span><br><span class="line">public class App&#123;</span><br><span class="line"></span><br><span class="line">  private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">  public static void main( String[] args )&#123;</span><br><span class="line">    context &#x3D; new ClassPathXmlApplicationContext(new String[] &#123;&quot;Spring-Output.xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    OutputHelper output &#x3D; (OutputHelper)context.getBean(&quot;OutputHelper&quot;);</span><br><span class="line">    output.generateOutput();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经实现了松耦合，当需要输出改变时，不必修改任何代码 .java 文件，只要修改 <strong>Spring-Output.xml</strong> 文件 <strong><em><property name = "outputGenerator" ref = "CsvOutputGenerator" /></em></strong> 中的 ref 值，就可以实现输出不同的内容，不修改代码就减少了出错的可能性。</p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.study.demo.App&quot;</span><br></pre></td></tr></table></figure><p><strong>注意：修改文件后都要使用 mvn compile 重新编译，然后再运行。</strong></p><p>当 Spring-Output 如下时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id &#x3D; &quot;OutputHelper&quot; class &#x3D; &quot;com.study.demo.loosely_coupled.OutputHelper&quot;&gt;</span><br><span class="line">       &lt;property name &#x3D; &quot;outputGenerator&quot; ref &#x3D; &quot;JsonOutputGenerator&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>输出 结果 又如何？？</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="2020/04/01/java-spring-helloworld-2020-04-01/"/>
      <url>2020/04/01/java-spring-helloworld-2020-04-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="什么是-Spring"><a href="#什么是-Spring" class="headerlink" title="什么是 Spring ?"></a>什么是 Spring ?</h3><blockquote><p>Spring 是一个容器，通过反转控制（IoC）和依赖注入（DI）来实现高内聚、低耦合的应用。除此之外它可以整合很多第三方框架，它还提供面向切面编程（AOP）的能力，对数据库事务的管理尤其方便</p></blockquote><h4 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么?"></a>Spring 是什么?</h4><p>Spring 是一个开源的轻量级 Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成的。所以开发一个应用除了要开发业务逻辑之外，最多的是关注使这些对象协作来完成所需功能的同时，实现低耦合、高内聚。所以，业务逻辑开发是不可避免的。如果有个框架可以帮我们来创建对象及管理这些对象之间的依赖关系，能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们必然会减少许多工作量，加快开发。Spring 框架问世之初主要就是来完成这个功能。</p><p>Spring 框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，可以帮我们管理最头疼的数据库事务，同时，它本身提供了一套简单的 JDBC 访问实现，能与第三方数据库访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 Web 框架集成。从这里我们可以认为 Spring 是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是 JAVA SE（C/S 架构）应用程序还是 JAVA EE（B/S 架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下 Spring 到底能帮我们做些什么？</p><h4 id="Spring-能帮我们做什么"><a href="#Spring-能帮我们做什么" class="headerlink" title="Spring 能帮我们做什么 ?"></a>Spring 能帮我们做什么 ?</h4><h5 id="Spring-能帮我们根据配置文件创建及组装对象之间的依赖关系"><a href="#Spring-能帮我们根据配置文件创建及组装对象之间的依赖关系" class="headerlink" title="Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系"></a>Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系</h5><p>传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署。而如果采用 Spring，则由 Spring 根据配置文件来进行创建及组装对象间依赖关系，只需要修改配置文件即可，无需重新编译。</p><h5 id="Spring-面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制"><a href="#Spring-面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制" class="headerlink" title="Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制"></a>Spring 面向切面编程能帮助我们无耦合的实现日志记录、性能统计、安全控制</h5><p>当我们要进行一些日志记录、权限控制、性能统计等工作时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使把通用部分提取出来，仍旧存在重复调用。</p><p>像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行时开始进行审核，可见这些工作急需优化。如果采用 Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过 Spring 支持的面向切面编程，动态添加这些功能，无需渗透到各个需要的方法或对象中。</p><p>反观其他的解决方案，通过使用“代理设计模式”或“包装器设计模式”，仍需通过编程方式来创建代理对象，仍需耦合这些代理对象，而采用 Spring 面向切面编程能提供一种更好的方式来完成上述功能。通过配置方式，而不需要在现有代码中添加任何额外代码，使现有代码专注业务逻辑。</p><h5 id="Spring-能非常简单的帮我们管理数据库事务"><a href="#Spring-能非常简单的帮我们管理数据库事务" class="headerlink" title="Spring 能非常简单的帮我们管理数据库事务"></a>Spring 能非常简单的帮我们管理数据库事务</h5><p>在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行 SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊。如果采用 Spring，我们只需获取连接，执行 SQL，其他的都交给 Spring 来管理，简单方便。</p><h5 id="除以上之外，Spring-还可以"><a href="#除以上之外，Spring-还可以" class="headerlink" title="除以上之外，Spring 还可以"></a>除以上之外，Spring 还可以</h5><ul><li>与第三方数据库访问框架（如 Hibernate、JPA）无缝集成，而且自己也提供了一套 JDBC 访问模板，来方便数据库访问。</li><li>与第三方 Web（如 Struts、JSF）框架无缝集成，而且自己也提供了一套 Spring MVC 框架，来方便 Web 层搭建。</li><li>与 Java EE（如 Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</li></ul><h4 id="Spring-的优点"><a href="#Spring-的优点" class="headerlink" title="Spring 的优点"></a>Spring 的优点</h4><h5 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h5><ul><li>应用程序：能完成我们所需要功能的成品，比如购物网站、OA 系统。</li><li>框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发。框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。</li><li>非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计；如果继承了这些框架类，就是侵入设计。如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</li><li>轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</li><li>POJO：Plain Ordinary Java Object，简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。<br>容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</li><li>控制反转：即 Inversion of Control，缩写为 IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</li><li>Bean：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。</li></ul><h5 id="Spring-的优点-1"><a href="#Spring-的优点-1" class="headerlink" title="Spring 的优点"></a>Spring 的优点</h5><ul><li>非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，除此之外还会负责管理对象生命周期，能组合成复杂的应用程序。Spring 容器是非侵入式的（不需要依赖任何 Spring 特定类），而且完全采用 POJOs 进行开发，使应用程序更容易测试、更容易管理。而且核心 jar 包非常小，Spring 3.0.5 不到 1 M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE 或 Java EE）。</li><li>AOP：AOP 是 Aspect Oriented Programming 的缩写，意思是面向切面编程。从另一个角度来考虑程序结构以完善面向对象编程（OOP），_即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术_。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中。比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方植入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</li><li>简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring 支持可插入的事务管理支持，而且无需 JavaEE 环境支持，通过 Spring 管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</li><li>JDBC 抽象及 ORM（对象关系映射）框架支持：Spring 使 JDBC 更加容易使用。提供 DAO（数据访问对象）支持，非常方便集成第三方 ORM 框架，比如 Hibernate 等。并且完全支持 Spring 事务和使用 Spring 提供的一致的异常体系。<br>灵活的 Web 层支持：Spring 本身提供一套非常强大的 MVC 框架，而且可以非常容易的与第三方 MVC 框架集成，比如 Struts 等。</li><li>简化各种技术集成：提供对 Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service 等的集成。</li></ul><blockquote><p>Spring 能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的 MVC 框架，可以把 Spring 看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发。有如上优点，我们没有理由不考虑使用它。</p></blockquote><h4 id="如何学好-Spring"><a href="#如何学好-Spring" class="headerlink" title="如何学好 Spring"></a>如何学好 Spring</h4><p>要学好 Spring，首先要明确 Spring 是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用 Spring 了。Spring 核心是 IoC 容器，所以一定要透彻理解什么是控制反转（IoC）容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的。理解好 IoC 后，接下来是面向切面编程（AOP），首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理。其实 Spring 管理事务是通过面向切面编程实现的，所以基础很重要，IoC 容器和 AOP 学好，其余都是基于这两个核心东西的实现，学起来就更加轻松了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/31/GM3Ss0.jpg" alt="架构图"></p><h6 id="核心容器：包括-Core、Beans、Context、EL-模块"><a href="#核心容器：包括-Core、Beans、Context、EL-模块" class="headerlink" title="核心容器：包括 Core、Beans、Context、EL 模块"></a>核心容器：包括 Core、Beans、Context、EL 模块</h6><ul><li>Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li><li>Beans 模块：提供了框架的基础部分，包括控制反转（IOC）和依赖注入（DI）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程。所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。</li><li>Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。核心接口是 ApplicationContext。<br>EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><h5 id="AOP、Aspects-模块"><a href="#AOP、Aspects-模块" class="headerlink" title="AOP、Aspects 模块"></a>AOP、Aspects 模块</h5><ul><li>AOP 模块：Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各专其职，降低业务逻辑和通用功能的耦合。</li><li>Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。<br>数据访问/集成模块：该模块包括了 JDBC、ORM、OXM、JMS 和事务管理。</li><li>事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</li><li>JDBC 模块：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li>ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate、JPA、MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。</li><li>OXM 模块：提供了一个对 Object/XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象，Object/XML 映射实现包括 JAXB、Castor、XMLBeans 和 XStream。</li><li>JMS 模块：用于 JMS（Java Messaging Service），提供一套“消息生产者、消息消费者”模板用于更加简单的使用 JMS。JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li>Web/Remoting 模块：Web/Remoting 模块包含了 Web、Web-Servlet、Web-Struts、Web-Porlet 模块。<br>Web 模块：提供了基础的 Web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（RMI、Hessian、Burlap）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。</li><li>Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li><li>Web-Struts 模块：提供了与 Struts 无缝集成，Struts 1.x 和 Struts 2.x 都支持。</li><li>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。</li></ul><h4 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h4><p>Spring 可以应用到许多场景，从最简单的标准 Java SE 程序到企业级应用程序都能使用 Spring 来构建。以下介绍几个比较流行的应用场景：</p><ul><li>典型 Web 应用程序应用场景：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/31/GM35Y4.png" alt="典型Web"></p><ul><li>远程访问应用场景</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/31/GM3Lm6.png" alt="远程访问应用场景"></p><ul><li>EJB 应用场景：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/31/GM8A78.png" alt="EJB应用场景"></p><h3 id="Hello-World-Hello-Spring"><a href="#Hello-World-Hello-Spring" class="headerlink" title="Hello World( Hello Spring )"></a>Hello World( Hello Spring )</h3><h4 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven 简介"></a>Maven 简介</h4><p>在项目开始之前，我们先来了解一下 Maven 相关知识。</p><blockquote><p>Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。</p></blockquote><blockquote><p>在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时能够创建报表，检查、构建和测试自动化设置。</p></blockquote><p>Maven 提供了开发人员的方式来管理：</p><ul><li>Builds</li><li>Documentation</li><li>Reporting</li><li>Dependencies</li><li>SCMs</li><li>Releases</li><li>Distribution</li><li>mailing list</li></ul><p>概括地说，Maven 简化和标准化项目建设过程，处理编译，分配，文档，团队协作和其他任务的无缝连接。Maven 增加可重用性并负责建立相关的任务。</p><blockquote><p>我们使用的是 maven 所以请本地安装好 maven</p></blockquote><p>导入 Maven 项目所需的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;labfile.oss.aliyuncs.com&#x2F;courses&#x2F;578&#x2F;m2.zip</span><br></pre></td></tr></table></figure><p>解压完成后，将生成的 .m2 文件夹移动到 maven 本地仓库</p><p>接下来就可以使用 maven 创建项目了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">  -DgroupId &#x3D; com.study.demo \</span><br><span class="line">  -DartifactId &#x3D; springExample \</span><br><span class="line">  -DarchetypeArtifactId &#x3D; maven-archetype-quickstart</span><br></pre></td></tr></table></figure><blockquote><p>在终端如果执行错误，请手动输入 一行执行</p></blockquote><p>参数说明：</p><ul><li>-DgourpId: 组织名，公司网址的反写 + 项目名称</li><li>-DartifactId: 项目名-模块名</li><li>-DarchetypeArtifactId: 指定 ArchetypeId，maven-archetype-quickstart，创建一个简单的 Java 应用</li><li>-DinteractiveMode: 是否使用交互模式。</li></ul><p>输入命令之后，maven 会提示我们输入版本号，这里可以直接定义版本号也可以直接回车，接着 maven 会提示当前要创建项目的基本信息，输入 y 然后回车确认</p><blockquote><p>我们也可以 加上交互模式 false 这样就不用输入版本号</p></blockquote><p>当你执行完 上面的 maven 命令 创建完成项目之后。</p><p>用你的编辑器 打开 生成的文件夹</p><blockquote><p>注意这里一定要重新进入文件夹，不然无法识别工作区</p></blockquote><p>然后 修改 pom.xml 添加依赖 </p><blockquote><p>关于 pom.xml 文件 另作文件描述</p></blockquote><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.study.demo&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springExample&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;springExample&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;spring.version&gt;5.1.1.RELEASE&lt;&#x2F;spring.version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上，Maven 使用以上配置来唯一指定一个项目。引用一个库文件也是通过以上配置来确定所引用的库及其版本号，比如本例引用 Spring 库版本为 5.1.1.RELEASE。</p><h5 id="创建-HelloWorld-java"><a href="#创建-HelloWorld-java" class="headerlink" title="创建 HelloWorld.java"></a>创建 HelloWorld.java</h5><p>然后 在你的 工作区内的 <strong><em>src/main/java/com/study/demo</em></strong> 文件内创建一个 <strong><em>helloworld</em></strong> 文件夹</p><p>然后 创建 HelloWorld.java 文件</p><p>编辑 HelloWorld.java 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo.helloworld;</span><br><span class="line"></span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  public void setName(String n)&#123;</span><br><span class="line">    this.name &#x3D; n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void printHello()&#123;</span><br><span class="line">    System.out.println(&quot;The first Spring :hello&quot;+name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建-SpringBeans-xml"><a href="#创建-SpringBeans-xml" class="headerlink" title="创建 SpringBeans.xml"></a>创建 SpringBeans.xml</h5><p>我们先在 src/main/ 下新建一个 Folder，命名为 resources，现在可以开始创建 Spring Bean 配置文件，创建文件 SpringBeans.xml，配置 bean 如下。文件位于 src/main/resources 下。</p><p>编辑 SpringBeans.xml 文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version &#x3D; &quot;1.0&quot; encoding &#x3D; &quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation &#x3D; &quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id &#x3D; &quot;helloBean&quot; class &#x3D; &quot;com.study.demo.helloworld.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name &#x3D; &quot;name&quot; value &#x3D; &quot;maven&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h5 id="创建测试-App"><a href="#创建测试-App" class="headerlink" title="创建测试 App"></a>创建测试 App</h5><p>在 com.study.demo 包下创建一个类，类名为 App:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.study.demo;</span><br><span class="line"></span><br><span class="line">import com.study.demo.helloworld.HelloWorld;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class App&#123;</span><br><span class="line">  private static ApplicationContext context;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    context &#x3D; new ClassPathXmlApplicationContext(&quot;SpringBeans.xml&quot;);</span><br><span class="line"></span><br><span class="line">    HelloWorld obj &#x3D; (HelloWorld) context.getBean(&quot;helloBean&quot;);</span><br><span class="line">    obj.printHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="作为-java-application-运行"><a href="#作为-java-application-运行" class="headerlink" title="作为 java application 运行"></a>作为 java application 运行</h5><p>首先打开终端，使用 mvn compile 编译 java 程序，然后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br><span class="line">mvn exec:java -Dexec.mainClass &#x3D; &quot;com.study.demo.App&quot;</span><br></pre></td></tr></table></figure><ul><li>这里用 maven 执行 java 程序，-Dexec.mainClass 参数指定 main 方法所在类。</li></ul><p>运行成功后 你就可以看到编译结果</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 文件操作</title>
      <link href="2020/03/23/java-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2020-03-24/"/>
      <url>2020/03/23/java-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-2020-03-24/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-文件操作"><a href="#Java-文件操作" class="headerlink" title="Java 文件操作"></a>Java 文件操作</h2><blockquote><p>在平时编写程序的时候，经常会对文件进行操作，比如文件的赋值，重命名，删除等。接下来学习使用 Java 操作文件。</p></blockquote><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>可以使用 Files 工具类的 copy(Path source,Path target,CopyOption… options) 拷贝文件或者目录。如果目标文件存在，那么赋值将失败，除非我们在 options 中指定了 REPLACE_EXISTING 属性。当该命令复制目录时，如果目录中已经有了文件，目录中的文件将不会被复制。CopyOption 参数支持以下 StandardCopyOption 和 LinkOption 枚举：</p><ul><li>REPLACE_EXISTING：即使目标文件已存在，也执行复制。如果目标是符号链接，则复制链接本身（而不是链接的目标）。如果目标是非空目录，则复制将失败并显示 FileAlreadyExistsException 异常。</li><li>COPY_ATTRIBUTES：将与文件关联的文件属性复制到目标文件。支持的确切 - 文件属性是文件系统和平台相关的，但 last-modified-time 跨平台支持并复制到目标文件。 NOFOLLOW_LINKS：表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）。</li></ul><h4 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建文件 1.txt。 在 项目目录下新建源代码文件 CopyDemo.java。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardCopyOption;</span><br><span class="line"></span><br><span class="line">public class CopyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;被拷贝的文件一定要存在 否则会抛出异常  这里的1.txt一定要存在</span><br><span class="line">            Files.copy(Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;1.txt&quot;), Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;2.txt&quot;), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javac CopyDemo.java</span><br><span class="line">$ java CopyDemo</span><br></pre></td></tr></table></figure><p>查看目录，如果没有报错，那么可以看到 1.txt 已经被复制了一份，叫做 2.txt。<br>(如果 1.txt 里面输入了内容 2.txt 也会存在)</p><h3 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h3><p>Files 类的 move(Path, Path, CopyOption… options) 方法移动文件或者目录，同样目标目录存在，那么比如使用REPLACE_EXISTING。 options 参数支持 StandardCopyOption 的以下枚举：</p><ul><li>REPLACE_EXISTING：即使目标文件已存在，也执行移动。如果目标是符号链接，则替换符号链接，但它指向的内容不受影响。</li><li>ATOMIC_MOVE：将移动作为原子文件操作执行。如果文件系统不支持原子移动，则抛出异常。使用，ATOMIC_MOVE 您可以将文件移动到目录中，并保证观察目录的任何进程都可以访问完整的文件。</li></ul><p>move 方法除了可以移动之外，也可以用与重命名。</p><h4 id="编程实例-1"><a href="#编程实例-1" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建源代码文件 MoveDemo.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardCopyOption;</span><br><span class="line"></span><br><span class="line">public class MoveDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可</span><br><span class="line">            Files.move(Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;1.txt&quot;), Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;3.txt&quot;), StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javac MoveDemo.java</span><br><span class="line">$ java MoveDemo</span><br></pre></td></tr></table></figure><p>查看目录结构，可以看到之前的 1.txt 已经变成了 3.txt </p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以通过 Files 的 delete(Path path) 方法或者 deleteIfExists(Path path) 方法删除文件。</p><h4 id="编程实例-2"><a href="#编程实例-2" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建源代码文件 DeleteDemo.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class DeleteDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;删除文件，文件必须存在，否则抛出异常</span><br><span class="line">            Files.delete(Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;3.txt&quot;));</span><br><span class="line">            &#x2F;&#x2F;删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false</span><br><span class="line">            System.out.println(Files.deleteIfExists(Paths.get(&quot;&#x2F;home&#x2F;project&#x2F;3.txt&quot;)));</span><br><span class="line">            &#x2F;&#x2F;或者使用File类的delete方法</span><br><span class="line">            File file &#x3D; new File(&quot;&#x2F;home&#x2F;project&#x2F;2.txt&quot;);</span><br><span class="line">            System.out.println(file.delete());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac DeleteDemo.java</span><br><span class="line">$ java DeleteDemo</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>再次查看文件目录，2.txt 、3.txt 已经不存在了。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>Java 使用 File 类表示文件或者目录，可以通过 File 类获取文件或者目录的相关属性。</p><h4 id="编程实例-3"><a href="#编程实例-3" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建源代码文件FileInfo.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FileInfo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;&#x2F;home&#x2F;project&quot;);</span><br><span class="line">        System.out.println(&quot;文件或者目录名：&quot; + file.getName());</span><br><span class="line">        System.out.println(&quot;绝对路径：&quot; + file.getAbsolutePath());</span><br><span class="line">        System.out.println(&quot;父目录：&quot; + file.getParent());</span><br><span class="line">        System.out.println(&quot;文件路径：&quot; + file.getPath());</span><br><span class="line">        &#x2F;&#x2F;判断文件是否是目录</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            &#x2F;&#x2F;打印目录中的文件</span><br><span class="line">            Arrays.stream(file.list()).forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;是否隐藏：&quot; + file.isHidden());</span><br><span class="line">        System.out.println(&quot;是否存在：&quot; + file.exists());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，可以根据个人情况更换 File Path 直接获取结果</p><h3 id="目录读取"><a href="#目录读取" class="headerlink" title="目录读取"></a>目录读取</h3><p>Java 中读取目录中的文件可以直接使用 listFiles() 方法读取，但是也只能读取当前目录中的文件，如果当前目录中还有二级目录如何解决呢？三级目录呢？接下来将使用 Java 读取当前目录和子目录中的所有文件。</p><h4 id="编程实例-4"><a href="#编程实例-4" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建源代码文件 ReadDir.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">public class ReadDir &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        readDir(new File(&quot;&#x2F;home&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void readDir(File file) &#123;</span><br><span class="line">        if (file &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果当前file是目录</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            File[] files;</span><br><span class="line">            &#x2F;&#x2F;如果目录不为空</span><br><span class="line">            if ((files &#x3D; file.listFiles()) !&#x3D; null) &#123;</span><br><span class="line">                for (File file1 : files) &#123;</span><br><span class="line">                    &#x2F;&#x2F;递归读取目录内容</span><br><span class="line">                    readDir(file1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果不是目录 直接输出文件名</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，可以根据个人情况更换 File Path （注意 为了更好的效果最好是三级目录读取)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java File </tag>
            
            <tag> java nio </tag>
            
            <tag> java Files </tag>
            
            <tag> java StandardCopyOption </tag>
            
            <tag> java Paths </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 泛型和集合</title>
      <link href="2020/03/16/java-%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88-2020-03016/"/>
      <url>2020/03/16/java-%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88-2020-03016/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型和集合"><a href="#泛型和集合" class="headerlink" title="泛型和集合"></a>泛型和集合</h2><blockquote><p>泛型即参数化类型，也就是说数据类型变成了一个可变的参数，在不使用泛型的情况下，参数的数据类型都是写死了的，使用泛型之后，可以根据程序的需要进行改变。</p></blockquote><h3 id="定义泛型的规则："><a href="#定义泛型的规则：" class="headerlink" title="定义泛型的规则："></a>定义泛型的规则：</h3><p>只能是引用类型，不能是简单数据类型。<br>泛型参数可以有多个。<br>可以用使用 extends 语句或者 super 语句 如 <T extends superClass> 表示类型的上界，T 只能是 superClass 或其子类， <K super childClass> 表示类型的下界，K 只能是 childClass 或其父类。<br>可以是通配符类型，比如常见的 Class&lt;?&gt;。单独使用 ? 可以表示任意类型。也可以结合 extends 和 super 来进行限制。  </p><p>接下来我们来定义一个泛型类，它有一个成员，成员的类型待定。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">使用T代表类型，无论何时都没有比这更具体的类型来区分它。如果有多个类型参数，我们可能使用字母表中T的临近的字母，比如S。</span><br><span class="line">*&#x2F;</span><br><span class="line">class Test&lt;T&gt; &#123;</span><br><span class="line">    private T ob;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    定义泛型成员变量，定义完类型参数后，可以在定义位置之后的方法的任意地方使用类型参数，就像使用普通的类型一样。</span><br><span class="line">    注意，父类定义的类型参数不能被子类继承。</span><br><span class="line">    *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    public Test(T ob) &#123;</span><br><span class="line">        this.ob &#x3D; ob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;getter 方法</span><br><span class="line">    public T getOb() &#123;</span><br><span class="line">        return ob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;setter 方法</span><br><span class="line">    public void setOb(T ob) &#123;</span><br><span class="line">        this.ob &#x3D; ob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showType() &#123;</span><br><span class="line">        System.out.println(&quot;T的实际类型是: &quot; + ob.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 定义泛型类 Test 的一个Integer版本</span><br><span class="line">        Test&lt;Integer&gt; intOb &#x3D; new Test&lt;Integer&gt;(88);</span><br><span class="line">        intOb.showType();</span><br><span class="line">        int i &#x3D; intOb.getOb();</span><br><span class="line">        System.out.println(&quot;value&#x3D; &quot; + i);</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        &#x2F;&#x2F; 定义泛型类Test的一个String版本</span><br><span class="line">        Test&lt;String&gt; strOb &#x3D; new Test&lt;String&gt;(&quot;Hello Gen!&quot;);</span><br><span class="line">        strOb.showType();</span><br><span class="line">        String s &#x3D; strOb.getOb();</span><br><span class="line">        System.out.println(&quot;value&#x3D; &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型使用操作例子"><a href="#泛型使用操作例子" class="headerlink" title="泛型使用操作例子"></a>泛型使用操作例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Animal.java</span><br><span class="line">public class Animal &#123;</span><br><span class="line">    public Animal()&#123;</span><br><span class="line">        System.out.println(&quot;我是动物&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Dog.java</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public Dog()&#123;</span><br><span class="line">        System.out.println(&quot;我是狗&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Test.java</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">  注意：定义带类型参数的方法，其主要目的是为了表达多个参数以及返回值之间的关系。例如本例子中T和S的继承关系， 返回值的类型和第一个类型参数的值相同。</span><br><span class="line">  *&#x2F;</span><br><span class="line">    public&lt;T, S extends T&gt; T testDemo(T t, S s)&#123;</span><br><span class="line">        System.out.println(&quot;我是 T 类型，我的类型是&quot; + t.getClass().getName());</span><br><span class="line">        System.out.println(&quot;我是 S 类型，我的类型是&quot; + s.getClass().getName());</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        Test test &#x3D; new Test();</span><br><span class="line">        Dog d &#x3D; new Dog();</span><br><span class="line">        Animal a0 &#x3D; new Animal();</span><br><span class="line">        Animal a1  &#x3D; test.testDemo(a0, d);</span><br><span class="line">        System.out.println(&quot;我是对象 a1，我的类型是&quot; + a1.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac Test.java Dog.java Animal.java</span><br><span class="line">$ java Test</span><br><span class="line">我是动物</span><br><span class="line">我是狗</span><br><span class="line">我是动物</span><br><span class="line">我是 T 类型，我的类型是Animal</span><br><span class="line">我是 S 类型，我的类型是Dog</span><br><span class="line">我是对象 a1，我的类型是Animal</span><br></pre></td></tr></table></figure><p>上面的例子中我们对类型参数赋予了具体的类型，当然我们有时候也无法确定类型参数的类型，这个时候我们便可以使用通配符。如果仅仅是想实现多态，请优先使用通配符解决</p><p>修改 Test 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; List&lt;?&gt; 表示接受一个元素为任意类型的列表 List。</span><br><span class="line">    public void testDemo(List&lt;?&gt; s)&#123;</span><br><span class="line">        for(Object obj:s)&#123;</span><br><span class="line">            System.out.println(&quot;我的类型是&quot; + obj.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        Test test &#x3D; new Test();</span><br><span class="line">        Dog a0 &#x3D; new Dog();</span><br><span class="line">        Animal a1 &#x3D; new Animal();</span><br><span class="line">    &#x2F;&#x2F; 声明一个接收元素类型是 Animal 的列表 List s。</span><br><span class="line">    &#x2F;&#x2F; 然后创建一个元素类型是 Animal 的 ArrayList 赋值给 s。</span><br><span class="line">        List&lt;Animal&gt; s &#x3D; new ArrayList&lt;Animal&gt;();</span><br><span class="line">    &#x2F;&#x2F; Dog a0 是 Animal 的子类，可以向上转型为 Animal 类型</span><br><span class="line">        s.add(a0);</span><br><span class="line">        s.add(a1);</span><br><span class="line">        test.testDemo(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac Test.java Dog.java Animal.java</span><br><span class="line">$ java Test</span><br><span class="line">我是动物</span><br><span class="line">我是狗</span><br><span class="line">我是动物</span><br><span class="line">我的类型是Dog</span><br><span class="line">我的类型是Animal</span><br></pre></td></tr></table></figure><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><blockquote><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。  </p></blockquote><p>因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。Collection 接口是 Java 集合框架里的一个根接口。它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(E e)</td><td>boolean</td><td>向 collection 的尾部追加指定的元素（可选操作）</td></tr><tr><td>addAll(Collection&lt;? extend E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都添加到此 collection 中（可选操作）</td></tr><tr><td>clear()</td><td>void</td><td>移除此 collection 中的所有元素（可选操作）</td></tr><tr><td>contains(Object o)</td><td>boolean</td><td>如果此 collection 包含指定的元素，则返回 true</td></tr><tr><td>containsAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>如果此 collection 包含指定 collection 的所有元素，则返回 true</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较此 collection 与指定对象是否相等</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此 collection 的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此 collection 不包含元素，则返回 true</td></tr><tr><td>iterator()</td><td>Iterator<E></td><td>返回在此 collection 的元素上进行迭代的迭代器</td></tr><tr><td>remove(Object o)</td><td>boolean</td><td>移除此 collection 中出现的首个指定元素（可选操作）</td></tr><tr><td>removeAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td></tr><tr><td>retainAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td></tr><tr><td>size()</td><td>int</td><td>返回此 collection 中的元素数</td></tr><tr><td>toArray()</td><td>Object[]</td><td>返回包含此 collection 中所有元素的数组</td></tr><tr><td>toArray(T[] a)</td><td><T> T[]</td><td>返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</td></tr></tbody></table><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 是一个接口，不能实例化，需要一个具体类来实现实例化。</p><p>List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 List 接口实现的类有：ArrayList（实现动态数组），Vector（实现动态数组），LinkedList（实现链表），Stack（实现堆栈）。</p><p>List 在 Collection 基础上增加的方法：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(int index, E element)</td><td>void</td><td>在列表的指定位置插入指定元素（可选操作）</td></tr><tr><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td></tr><tr><td>get(int index)</td><td>E</td><td>返回列表中指定位置的元素</td></tr><tr><td>indexOf(Object o)</td><td>int</td><td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td></tr><tr><td>lastIndexOf(Object o)</td><td>int</td><td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td></tr><tr><td>listIterator()</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序）</td></tr><tr><td>listIterator(int index)</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始</td></tr><tr><td>remove(int index)</td><td>E</td><td>移除列表中指定位置的元素（可选操作）</td></tr><tr><td>set(int index, E element)</td><td>E</td><td>用指定元素替换列表中指定位置的元素（可选操作）</td></tr><tr><td>subList(int fromIndex, int toIndex)</td><td>List<E></td><td>返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图</td></tr></tbody></table><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList　类实现一个可增长的动态数组，位于 java.util.ArrayList。实现了 List 接口，它可以存储不同类型的对象（包括 null 在内），而数组则只能存放特定数据类型的值。</p><h4 id="ArrayList-编程实例"><a href="#ArrayList-编程实例" class="headerlink" title="ArrayList 编程实例"></a>ArrayList 编程实例</h4><p>学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作。</p><p>创建一个学生类 Student.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Student(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&#39;&quot; + id + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 ListTest.java，其中包含了一个学生列表，通过操作学生列表来管理学生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ListTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于存放学生的List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ListTest() &#123;</span><br><span class="line">        this.students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于往students中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个学生对象，并通过调用add方法，添加到学生管理List中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取出 List中的Student对象 索引为0 也就是第一个</span><br><span class="line">        Student temp &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name);</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;, &quot;李四&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加到list中，插入到索引为0的位置，也就是第一个</span><br><span class="line">        students.add(0, st2);</span><br><span class="line">        Student temp2 &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对象数组的形式添加</span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line">        Student temp3 &#x3D; students.get(2);</span><br><span class="line">        Student temp4 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name);</span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(2, Arrays.asList(student2));</span><br><span class="line">        Student temp5 &#x3D; students.get(2);</span><br><span class="line">        Student temp6 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取得List中的元素的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testGet() &#123;</span><br><span class="line">        int size &#x3D; students.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">            Student st &#x3D; students.get(i);</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过迭代器来遍历</span><br><span class="line">     * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testIterator() &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过集合的iterator方法，取得迭代器实例</span><br><span class="line">        Iterator&lt;Student&gt; it &#x3D; students.iterator();</span><br><span class="line">        System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;);</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Student st &#x3D; it.next();</span><br><span class="line">            System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过for each 方法访问集合元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过for each）：&quot;);</span><br><span class="line">        for (Student obj : students) &#123;</span><br><span class="line">            Student st &#x3D; obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用java8 Steam将学生排序后输出</span><br><span class="line">        students.stream()&#x2F;&#x2F;创建Stream</span><br><span class="line">                &#x2F;&#x2F;通过学生id排序</span><br><span class="line">                .sorted(Comparator.comparing(x -&gt; x.id))</span><br><span class="line">                &#x2F;&#x2F;输出</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改List中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify() &#123;</span><br><span class="line">        students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除List中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        Student st &#x3D; students.get(4);</span><br><span class="line">        System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;);</span><br><span class="line">        students.remove(st);</span><br><span class="line">        System.out.println(&quot;成功删除学生！&quot;);</span><br><span class="line">        testForEach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListTest lt &#x3D; new ListTest();</span><br><span class="line">        lt.testAdd();</span><br><span class="line">        lt.testGet();</span><br><span class="line">        lt.testIterator();</span><br><span class="line">        lt.testModify();</span><br><span class="line">        lt.testForEach();</span><br><span class="line">        lt.testRemove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ javac Student.java ListTest.java</span><br><span class="line">$ java ListTest</span><br><span class="line"></span><br><span class="line">添加了学生：1:张三</span><br><span class="line">添加了学生：2:李四</span><br><span class="line">添加了学生：3:王五</span><br><span class="line">添加了学生：4:马六</span><br><span class="line">添加了学生：5:周七</span><br><span class="line">添加了学生：6:赵八</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：3:王五</span><br><span class="line">学生：4:马六</span><br><span class="line">有如下学生（通过迭代器访问）：</span><br><span class="line">学生2:李四</span><br><span class="line">学生1:张三</span><br><span class="line">学生5:周七</span><br><span class="line">学生6:赵八</span><br><span class="line">学生3:王五</span><br><span class="line">学生4:马六</span><br><span class="line">有如下学生（通过for each）：</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：3:吴酒</span><br><span class="line">学生：4:马六</span><br><span class="line">Student&#123;id&#x3D;&#39;1&#39;, name&#x3D;&#39;张三&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;2&#39;, name&#x3D;&#39;李四&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;3&#39;, name&#x3D;&#39;吴酒&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;4&#39;, name&#x3D;&#39;马六&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;5&#39;, name&#x3D;&#39;周七&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;6&#39;, name&#x3D;&#39;赵八&#39;&#125;</span><br><span class="line">我是学生：3:吴酒，我即将被删除</span><br><span class="line">成功删除学生！</span><br><span class="line">有如下学生（通过for each）：</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：4:马六</span><br><span class="line">Student&#123;id&#x3D;&#39;1&#39;, name&#x3D;&#39;张三&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;2&#39;, name&#x3D;&#39;李四&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;4&#39;, name&#x3D;&#39;马六&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;5&#39;, name&#x3D;&#39;周七&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;6&#39;, name&#x3D;&#39;赵八&#39;&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 接口也是一个非常重要的集合接口，用于存储键 / 值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。</p><p>value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键 / 值对以 Entry 类型的对象实例形式存在。</p><p>看一看 Map 中的方法吧：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>clear()</td><td>void</td><td>从此映射中移除所用映射关系（可选操作）</td></tr><tr><td>containsKey(Object key)</td><td>boolean</td><td>如果此映射包含指定键的映射关系，则返回 true</td></tr><tr><td>containsValue(Object value)</td><td>boolean</td><td>如果此映射将一个或多个键映射到指定值，则返回 true</td></tr><tr><td>entrySet()</td><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;</td><td>返回此映射中包含的映射关系的 Set 视图</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较指定的对象与此映射是否相等</td></tr><tr><td>get(Object key)</td><td>V</td><td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此映射的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此映射未包含键 - 值映射关系，则返回 true</td></tr><tr><td>keySet()</td><td>Set<K></td><td>返回此映射中包含的键的 Set 视图</td></tr><tr><td>put(K key, V value)</td><td>V</td><td>将指定的值与此映射中的指定键关联（可选操作）</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>void</td><td>从指定映射中将所有映射关系复制到此映射中（可选操作）</td></tr><tr><td>remove(Object key)</td><td>V</td><td>如果存在一个键的映射关系，则将其从此映射中移除（可选操作）</td></tr><tr><td>size</td><td>int</td><td>返回此映射中的键 - 值映射关系数</td></tr><tr><td>values()</td><td>Collection<V></td><td>返回此映射中包含的值的 Collection 视图</td></tr></tbody></table><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是 无序 排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。</p><p>下面我们通过代码来学习 Map 中的方法吧。同学们都有过选课经历吧，我们就用 Map 来管理课程吧。</p><p>创建一个 Course 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Course.java</span><br><span class="line">public class Course &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Course(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 MapTest 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MapTest.java</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来承装课程类型对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Map&lt;String, Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在构造器中初始化 courses 属性</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MapTest() &#123;</span><br><span class="line">        this.courses &#x3D; new HashMap&lt;String, Course&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试添加：输入课程 ID，判断是否被占用</span><br><span class="line">     * 若未被占用，输入课程名称，创建新课程对象</span><br><span class="line">     * 并且添加到 courses 中</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testPut() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来获取输入的课程 ID 和名称</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入课程 ID：&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否被占用</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null)&#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入课程名称</span><br><span class="line">                System.out.println(&quot;请输入课程名称：&quot;);</span><br><span class="line">                String name &#x3D; console.next();</span><br><span class="line">                &#x2F;&#x2F;创建新的课程对象</span><br><span class="line">                Course newCourse &#x3D; new Course(ID,name);</span><br><span class="line">                &#x2F;&#x2F;通过调用 courses 的 put 方法，添加 ID-课程映射</span><br><span class="line">                courses.put(ID, newCourse);</span><br><span class="line">                System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;该课程 ID 已被占用&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试 Map 的 keySet 方法</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void testKeySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 keySet 方法，返回 Map 中的所有键的 Set 集合</span><br><span class="line">        Set&lt;String&gt; keySet &#x3D; courses.keySet();</span><br><span class="line">        &#x2F;&#x2F;遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value</span><br><span class="line">        for(String crID: keySet) &#123;</span><br><span class="line">            Course cr &#x3D; courses.get(crID);</span><br><span class="line">            if(cr !&#x3D; null)&#123;</span><br><span class="line">                System.out.println(&quot;课程：&quot; + cr.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试删除 Map 中的映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取从键盘输入的待删除课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;提示输出待删除的课程 ID</span><br><span class="line">            System.out.println(&quot;请输入要删除的课程 ID！&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否对应的课程对象</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入的 ID 并不存在</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            courses.remove(ID);</span><br><span class="line">            System.out.println(&quot;成功删除课程&quot; + cr.name);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过 entrySet 方法来遍历 Map</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testEntrySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 entrySet 方法，返回 Map 中的所有键值对</span><br><span class="line">        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet &#x3D; courses.entrySet();</span><br><span class="line">        for(Entry&lt;String,Course&gt; entry: entrySet) &#123;</span><br><span class="line">            System.out.println(&quot;取得键：&quot; + entry.getKey());</span><br><span class="line">            System.out.println(&quot;对应的值为：&quot; + entry.getValue().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 利用 put 方法修改Map 中的已有映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify()&#123;</span><br><span class="line">        &#x2F;&#x2F;提示输入要修改的课程 ID</span><br><span class="line">        System.out.println(&quot;请输入要修改的课程 ID：&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            &#x2F;&#x2F;取得从键盘输入的课程 ID</span><br><span class="line">            String crID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;从 courses 中查找该课程 ID 对应的对象</span><br><span class="line">            Course course &#x3D; courses.get(crID);</span><br><span class="line">            if(course &#x3D;&#x3D; null) &#123;</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！请重新输入！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;提示当前对应的课程对象的名称</span><br><span class="line">            System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name);</span><br><span class="line">            &#x2F;&#x2F;提示输入新的课程名称，来修改已有的映射</span><br><span class="line">            System.out.println(&quot;请输入新的课程名称：&quot;);</span><br><span class="line">            String name &#x3D; console.next();</span><br><span class="line">            Course newCourse &#x3D; new Course(crID,name);</span><br><span class="line">            courses.put(crID, newCourse);</span><br><span class="line">            System.out.println(&quot;修改成功！&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MapTest mt &#x3D; new MapTest();</span><br><span class="line">        mt.testPut();</span><br><span class="line">        mt.testKeySet();</span><br><span class="line">        mt.testRemove();</span><br><span class="line">        mt.testModify();</span><br><span class="line">        mt.testEntrySet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-amp-amp-HashSet"><a href="#Set-amp-amp-HashSet" class="headerlink" title="Set &amp;&amp; HashSet"></a>Set &amp;&amp; HashSet</h3><p>Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。</p><p>HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。</p><p>接下来我们通过代码的形式来详细看一看吧！</p><p>假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧。</p><p>因为项目组的组长由一个老师担任 创建一个 PD 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PD.java</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 项目组长类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PD &#123;</span><br><span class="line"></span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    public Set&lt;Student&gt; students;</span><br><span class="line">    public PD(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.students &#x3D; new HashSet&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个学生类 Student.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; Student.java</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Student(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&#39;&quot; + id + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们便创建一个 SetTest 类，用来管理项目成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SetTest.java</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    public SetTest() &#123;</span><br><span class="line">        students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 用于往students中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个学生对象，并通过调用add方法，添加到学生管理List中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;添加到List中的类型均为Object，所以取出时还需要强转</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;,&quot;李四&quot;);</span><br><span class="line">        students.add(st2);</span><br><span class="line"></span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line"></span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过for each 方法访问集合元素</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过for each）：&quot;);</span><br><span class="line">        for(Object obj:students)&#123;</span><br><span class="line">            Student st &#x3D; (Student)obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SetTest st &#x3D; new SetTest();</span><br><span class="line">        st.testAdd();</span><br><span class="line">        st.testForEach();</span><br><span class="line">        PD pd &#x3D; new PD(&quot;1&quot;,&quot;张老师&quot;);</span><br><span class="line">        System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来接收从键盘输入的学生 ID</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i &lt; 3; i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入学生 ID&quot;);</span><br><span class="line">            String studentID &#x3D; console.next();</span><br><span class="line">            for(Student s:st.students)&#123;</span><br><span class="line">                if(s.id.equals(studentID))&#123;</span><br><span class="line">                    pd.students.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.testForEachForSer(pd);</span><br><span class="line">        &#x2F;&#x2F; 关闭 Scanner 对象</span><br><span class="line">        console.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator</span><br><span class="line">    &#x2F;&#x2F;不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素</span><br><span class="line">    public void testForEachForSer(PD pd)&#123;</span><br><span class="line">        for(Student s: pd.students) &#123;</span><br><span class="line">        System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 泛型和集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Throwable 抛出异常</title>
      <link href="2020/03/16/java-Throwable-2020-03-16/"/>
      <url>2020/03/16/java-Throwable-2020-03-16/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-关于抛出异常"><a href="#Java-关于抛出异常" class="headerlink" title="Java 关于抛出异常"></a>Java 关于抛出异常</h2><blockquote><p>异常指不期而至的各种状况，它在程序运行的过程中发生。作为开发者，我们都希望自己写的代码永远都不会出现 bug，然而现实告诉我们并没有这样的情景。如果用户在程序的使用过程中因为一些原因造成他的数据丢失，这个用户就可能不会再使用该程序了。所以，对于程序的错误以及外部环境能够对用户造成的影响，我们应当及时报告并且以适当的方式来处理这个错误。</p></blockquote><blockquote><p>之所以要处理异常，也是为了增强程序的<a href="http://baike.baidu.com/view/45520.htm">鲁棒性</a>。</p></blockquote><p>异常都是从 Throwable 类派生出来的，而 Throwable 类是直接从 Object 类继承而来。你可以在 Java SE 官方 API 文档中获取更多关于它们的知识。</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>异常通常有四类：</p><ul><li>Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理。</li><li>Exception：可以处理的异常。</li><li>RuntimeException：可以捕获，也可以不捕获的异常。</li><li>继承 Exception 的其他类：必须捕获，通常在 API 文档中会说明这些方法抛出哪些异常。</li></ul><p>平时主要关注的异常是 Exception 下的异常，而 Exception 异常下又主要分为两大类异常，一个是派生于 RuntimeExcption 的异常，一个是除了 RuntimeExcption 体系之外的其他异常。</p><p>RuntimeExcption 异常（运行时异常）通常有以下几种：</p><ul><li>错误的类型转换</li><li>数组访问越界</li><li>访问 null 指针</li><li>算术异常</li></ul><p>一般来说，RuntimeException 都是代码逻辑出现问题。</p><p>非 RuntimeException（受检异常，Checked Exception）一般有：</p><ul><li>打开一个不存在的文件</li><li>没有找到具有指定名称的类</li><li>操作文件异常</li></ul><p>受检异常是编译器要求必须处理的异常，必须使用 <strong><em>try catch</em></strong> 处理，或者使用 <strong><em>throw</em></strong> 抛出，交给上层调用者处理。</p><h3 id="声明及抛出"><a href="#声明及抛出" class="headerlink" title="声明及抛出"></a>声明及抛出</h3><h4 id="throw-抛出异常"><a href="#throw-抛出异常" class="headerlink" title="throw 抛出异常"></a>throw 抛出异常</h4><p>当程序运行时数据出现错误或者我们不希望发生的情况出现的话，可以通过抛出异常来处理。</p><p>异常抛出语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new 异常类();</span><br></pre></td></tr></table></figure><p>下面新建 ThrowsTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThrowsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer a &#x3D; 1;</span><br><span class="line">        Integer b &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;当a或者b为null时，抛出异常</span><br><span class="line">        if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac ThrowsTest.java</span><br><span class="line">$ java ThrowsTest</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at ThrowTest.main(ThrowTest.java:8)</span><br></pre></td></tr></table></figure><h4 id="throws-声明异常"><a href="#throws-声明异常" class="headerlink" title="throws 声明异常"></a>throws 声明异常</h4><p>throws 用于声明异常，表示该方法可能会抛出的异常。如果声明的异常中包括 checked 异常（受检异常），那么调用者必须捕获处理该异常或者使用 <strong>throws</strong> 继续向上抛出。<strong>throws</strong> 位于方法体前，多个异常之间使用 <strong>,</strong> 分割。</p><p>修改 ThrowsTest.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class ThrowsTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F;由方法的调用者捕获异常或者继续向上抛出</span><br><span class="line">        throwsTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void throwsTest() throws FileNotFoundException &#123;</span><br><span class="line">        new FileInputStream(&quot;&#x2F;home&#x2F;project&#x2F;xxx.file&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javac ThrowsTest.java</span><br><span class="line">$ java ThrowsTest</span><br><span class="line">Exception in thread &quot;main&quot; java.io.FileNotFoundException: &#x2F;home&#x2F;project&#x2F;xxx.file (系统找不到指定的路径。)</span><br><span class="line">    at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">    at java.io.FileInputStream.open(FileInputStream.java:195)</span><br><span class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)</span><br><span class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</span><br><span class="line">    at ThrowsTest.throwsTest(ThrowsTest.java:13)</span><br><span class="line">    at ThrowsTest.main(ThrowsTest.java:8)</span><br></pre></td></tr></table></figure><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>通常抛出异常后，还需要将异常捕获。使用 try 和 catch 语句块来捕获异常，有时候还会用到 finally。</p><p>对于上述三个关键词所构成的语句块，try 语句块是必不可少的，catch 和 finally 语句块可以根据情况选择其一或者全选。你可以把可能发生错误或出现问题的语句放到 try 语句块中，将异常发生后要执行的语句放到 catch 语句块中，而 finally 语句块里面放置的语句，不管异常是否发生，它们都会被执行。</p><p>你可能想说，那我把所有有关的代码都放到 try 语句块中不就妥当了吗？可是你需要知道，捕获异常对于系统而言，其开销非常大，所以应尽量减少该语句块中放置的语句。</p><p>新建 CatchException.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CatchException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 下面定义了一个try语句块</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;I am try block.&quot;);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; tempClass &#x3D; Class.forName(&quot;&quot;);</span><br><span class="line">            &#x2F;&#x2F; 声明一个空的Class对象用于引发“类未发现异常”</span><br><span class="line">            System.out.println(&quot;Bye! Try block.&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 下面定义了一个catch语句块</span><br><span class="line">            System.out.println(&quot;I am catch block.&quot;);</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            &#x2F;&#x2F;printStackTrace()的意义在于在命令行打印异常信息在程序中出错的位置及原因</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Goodbye! Catch block.&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 下面定义了一个finally语句块</span><br><span class="line">            System.out.println(&quot;I am finally block.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ javac CatchException.java</span><br><span class="line">$ java CatchException</span><br><span class="line">I am try block.</span><br><span class="line">I am catch block.</span><br><span class="line">java.lang.ClassNotFoundException:</span><br><span class="line">        at java.lang.Class.forName0(Native Method)</span><br><span class="line">        at java.lang.Class.forName(Unknown Source)</span><br><span class="line">        at CatchException.main(CatchException.java:8)</span><br><span class="line">Goodbye! Catch block.</span><br><span class="line">I am finally block.</span><br></pre></td></tr></table></figure><p>请你结合这些输出语句在源代码中的位置，再来体会一下三个语句块的作用。</p><h3 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h3><p>在一段代码中，可能会由于各种原因抛出多种不同的异常，而对于不同的异常，我们希望用不同的方式来处理它们，而不是笼统的使用同一个方式处理，在这种情况下，可以使用异常匹配，当匹配到对应的异常后，后面的异常将不再进行匹配。</p><h4 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h4><p>新建源代码文件 MultipleCapturesDemo.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">public class MultipleCapturesDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new FileInputStream(&quot;&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(&quot;IO 异常&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发生异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac MultipleCapturesDemo.java</span><br><span class="line">$ java MultipleCapturesDemo</span><br><span class="line">IO 异常</span><br></pre></td></tr></table></figure><p>在处理异常时，并不要求抛出的异常同 catch 所声明的异常完全匹配，子类的对象也可以匹配父类的处理程序。比如异常 A 继承于异常 B，那么在处理多个异常时，一定要将异常 A 放在异常 B 之前捕获，如果将异常 B 放在异常 A 之前，那么将永远匹配到异常 B，异常 A 将永远不可能执行，并且编译器将会报错。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>尽管 Java SE 的 API 已经为我们提供了数十种异常类，然而在实际的开发过程中，你仍然可能遇到未知的异常情况。此时，你就需要对异常类进行自定义。</p><p>自定义一个异常类非常简单，只需要让它继承 Exception 或其子类就行。在自定义异常类的时候，建议同时提供无参构造方法和带字符串参数的构造方法，后者可以为你在调试时提供更加详细的信息。</p><p>百闻不如一见，下面我们尝试自定义一个算术异常类。</p><p>创建一个 MyAriException 类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MyAriException.java</span><br><span class="line">public class MyAriException extends ArithmeticException &#123;</span><br><span class="line">    &#x2F;&#x2F;自定义异常类，该类继承自ArithmeticException</span><br><span class="line"></span><br><span class="line">    public MyAriException() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实现默认的无参构造方法</span><br><span class="line"></span><br><span class="line">    public MyAriException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实现可以自定义输出信息的构造方法，将待输出信息作为参数传入即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个 ExceptionTest 类作为测试用，在该类的 main() 方法中，可以尝试使用 throw 抛出自定义的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ExceptionTest.java</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; new int[5];</span><br><span class="line">        &#x2F;&#x2F;声明一个长度为5的数组</span><br><span class="line"></span><br><span class="line">        Arrays.fill(array, 5);</span><br><span class="line">        &#x2F;&#x2F;将数组中的所有元素赋值为5</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 4; i &gt; -1; i--) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用for循环逆序遍历整个数组，i每次递减</span><br><span class="line"></span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果i除以了0，就使用带异常信息的构造方法抛出异常</span><br><span class="line"></span><br><span class="line">                throw new MyAriException(&quot;There is an exception occured.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;array[&quot; + i + &quot;] &#x2F; &quot; + i + &quot; &#x3D; &quot; + array[i] &#x2F; i);</span><br><span class="line">            &#x2F;&#x2F; 如果i没有除以0，就输出此结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下代码，编译并运行，期待中的自定义错误信息就展现在控制台中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac ExceptionTest.java MyAriException.java</span><br><span class="line">$ java ExceptionTest</span><br><span class="line">array[4] &#x2F; 4 &#x3D; 1</span><br><span class="line">array[3] &#x2F; 3 &#x3D; 1</span><br><span class="line">array[2] &#x2F; 2 &#x3D; 2</span><br><span class="line">array[1] &#x2F; 1 &#x3D; 5</span><br><span class="line">Exception in thread &quot;main&quot; MyAriException: There is an exception occured.</span><br><span class="line">    at ExceptionTest.main(ExceptionTest.java:17)</span><br></pre></td></tr></table></figure><h3 id="异常堆栈"><a href="#异常堆栈" class="headerlink" title="异常堆栈"></a>异常堆栈</h3><p>当异常抛出后，我们可以通过异常堆栈追踪程序的运行轨迹，以便我们更好的 DEBUG。</p><p>新建一个 ExceptionStackTrace.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionStackTrace &#123;</span><br><span class="line">    private static void method1() &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method2() &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;打印堆栈轨迹</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac ExceptionStackTrace.java</span><br><span class="line">$ java ExceptionStackTrace</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">    at ExceptionStackTrace.method2(ExceptionStackTrace.java:7)</span><br><span class="line">    at ExceptionStackTrace.method1(ExceptionStackTrace.java:3)</span><br><span class="line">    at ExceptionStackTrace.main(ExceptionStackTrace.java:11)</span><br></pre></td></tr></table></figure><p>通过上面的异常堆栈轨迹，在对比我们方法的调用过程，可以得出异常信息中首先打印的是距离抛出异常最近的语句，接着是调用该方法的方法，一直到最开始被调用的方法。从下往上看，就可以得出程序运行的轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Throwable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 伪分布式配置部署</title>
      <link href="2020/01/13/hadoop-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2-2020-01-13/"/>
      <url>2020/01/13/hadoop-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2-2020-01-13/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop-伪分布式配置部署"><a href="#Hadoop-伪分布式配置部署" class="headerlink" title="Hadoop 伪分布式配置部署"></a>Hadoop 伪分布式配置部署</h2><blockquote><p>在阅读本章节之前，请确定你已经阅读过，<a href="/2020/01/13/hadoop-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2-2020-01-13/">Hadoop 单机版部署</a> 并存在环境  </p></blockquote><h3 id="Hadoop-伪分布式模式配置"><a href="#Hadoop-伪分布式模式配置" class="headerlink" title="Hadoop 伪分布式模式配置"></a>Hadoop 伪分布式模式配置</h3><blockquote><p>再次提醒 当前环境 必须是 您在阅读 <strong><em>Hadoop 单机版部署</em></strong> 后部署的环境  </p></blockquote><h3 id="修改-core-site-xml"><a href="#修改-core-site-xml" class="headerlink" title="修改 core-site.xml"></a>修改 core-site.xml</h3><p>这里我们需要修改 <strong><em>core-site.xml</em></strong>, 使用下面的命令调用 Vim 编辑器来编辑文件。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop</span><br><span class="line"></span><br><span class="line">$vim .&#x2F;core-site.xml</span><br></pre></td></tr></table></figure><p>先说一下常用配置项：  </p><ul><li><strong><em>fs.defaultFS</em></strong></li></ul><p><strong><em>fs.defaultFS</em></strong> 是默认的HDFS 路径。 当有多个 HDFS 集群同时工作时，用户在这里指定默认HDFS 集群， 该值来自于 <strong><em>hdfs-site.xml</em></strong> 中的配置。  </p><ul><li><strong><em>fs.default.name</em></strong> </li></ul><p><strong><em>fs.default.name</em></strong> 是一个描述集群中 NameNode 节点的 URI(包括协议、主机名称、端口号)， 集群里面的每一台机器都需要知道 NameNode 的地址。 DataNode 节点会现在 NameNode 上注册， 这样他们的数据才可以被使用。 独立的客户端程序通过这个 URI 跟 DataNode 交互， 以取得文件的块列表。  </p><ul><li><strong><em>hadoop.tmp.dir</em></strong>  </li></ul><p><strong><em>hadoop.tmp.dir</em></strong> 是hadoop 文件系统依赖的基础配置，很多路径都依赖它。如果 <strong><em>hdfs-site.xml</em></strong> 中不配置namenode 和 datanode 的存放位置，默认就放在 <strong><em>/tmp/hadoop-${user.name}</em></strong> 这个路径中。  </p><p>更多说明请参考 <a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/core-default.xml">core-default.xml</a>, 包含配置文件所有配置项的说明和默认值。  </p><p>配置好以后的文件内容如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;home&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="修改-hdfs-site-xml"><a href="#修改-hdfs-site-xml" class="headerlink" title="修改 hdfs-site.xml"></a>修改 hdfs-site.xml</h3><p>这里我们要修改的是 <strong><em>hdfs-site.xml</em></strong>, 使用下面的命令调用 Vim 编辑器来编辑文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop&#x2F;</span><br><span class="line"></span><br><span class="line">$ vim .&#x2F;hdfs-site.xml</span><br></pre></td></tr></table></figure><p>常用配置项说明：  </p><ul><li><strong><em>dfs.replication</em></strong></li></ul><p><strong><em>dfs.replication</em></strong> 决定着系统里面的文件块的数据备份个数。对于一个实际的应用，它应该被设为 3 (这个数字并没有上限,但更多的备份可能并没有作用,而且会占用更多的空间)。 少于三个备份，可能会影响到数据的可靠性（系统故障时，也许会造成数据丢失）  </p><ul><li><strong><em>dfs.data.dir</em></strong>  </li></ul><p><strong><em>dfs.data.dir</em></strong> 这是 DataNode 节点被指定要存储数据的本地文件系统路径。 DataNode 节点上的这个路径没有必要完全相同，因为每台机器的环境很可能是不一样的。但如果每台机器上的这个路径都是统一配置的话，会使工作变得简单一些。 默认的情况下，它的值为 <strong><em>file://${hadoop.tmp.dir}/dfs/data</em></strong> 这个路径只能用于测试的目的， 因为它很可能会丢失掉一些数据。所以这个值最好还是被覆盖。  </p><ul><li><strong><em>dfs.name.dir</em></strong>  </li></ul><p><strong><em>dfs.name.dir</em></strong> 是NameNode节点存储 hadoop 文件系统信息的本地系统路径。 这个值只对 NameNode 有效， DataNode 并不需要使用 到它。上面对于 <strong><em>/temp</em></strong> 类型的警告， 同样也适用于这里。 在实际应用中，它最好被覆盖掉。  </p><p>更多说明请参考 <a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hdfs-default.xml</a>, 包含配置文件所有配置项的说明和默认值  </p><p>配置好以后的文件内容如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="修改-mapred-site-xml"><a href="#修改-mapred-site-xml" class="headerlink" title="修改 mapred-site.xml"></a>修改 mapred-site.xml</h3><p>使用下面的命令先将默认文件复制一份过来，然后调用 Vim 编辑器进行编辑。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop&#x2F;</span><br><span class="line"></span><br><span class="line">$ cp .&#x2F;mapred-site.xml.template .&#x2F;mapred-site.xml</span><br><span class="line"></span><br><span class="line">$ vim .&#x2F;mapred-site.xml</span><br></pre></td></tr></table></figure><p>常用配置项说明：  </p><ul><li><strong><em>mapred.job.tracker</em></strong>：JobTracker 的主机（或者 IP）和端口。<br>更多说明请参考<a href="http://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml">mapred-default.xml</a>，包含配置文件所有配置项的说明和默认值  </li></ul><p>配置好以后的文件内容如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;xsl&quot; href&#x3D;&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="修改-yarn-site-xml"><a href="#修改-yarn-site-xml" class="headerlink" title="修改 yarn-site.xml"></a>修改 yarn-site.xml</h3><p>编辑 <strong><em>yarn-site.xml</em></strong> 文件   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop</span><br><span class="line"></span><br><span class="line">$ vim .&#x2F;yarn-site.xml</span><br></pre></td></tr></table></figure><p>常用配置项说明：  </p><ul><li><strong><em>yarn.nodemanager.aux-services</em></strong> 通过该配置，用户可以自定义一些服务  </li></ul><p>更多说明请参考<a href="http://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-common/yarn-default.xml">yarn-default.xml</a>，包含配置文件所有配置项的说明和默认值  </p><p>配置好以后的文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h3 id="修改-hadoop-env-sh"><a href="#修改-hadoop-env-sh" class="headerlink" title="修改 hadoop-env.sh"></a>修改 hadoop-env.sh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop&#x2F;</span><br><span class="line"></span><br><span class="line">$ sudo vim .&#x2F;hadoop-env.sh</span><br></pre></td></tr></table></figure><p>修改 JAVA_HOME 如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-oracle</span><br><span class="line">export HADOOP_CONF_DIR&#x3D;&#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;etc&#x2F;hadoop</span><br></pre></td></tr></table></figure><p>这样简单的伪分布式就配置好了。  </p><h3 id="格式化-HDFS-文件系统"><a href="#格式化-HDFS-文件系统" class="headerlink" title="格式化 HDFS 文件系统"></a>格式化 HDFS 文件系统</h3><p>在使用 hadoop 前，必须格式化一个全新的 HDFS 安装，通过创建存储目录和 NameNode 持久化数据结构的初始版本，格式化过程创建了一个空的文件系统。  </p><p>由于 NameNode 管理文件系统的元数据，而 DataNode 可以动态的加入或离开集群，因此这个格式化过程并不涉及 DataNode。同理，用户也无需关注文件系统的规模。  </p><p>集群中 DataNode 的数量决定着文件系统的规模。DataNode 可以在文件系统格式化之后的很长一段时间内按需增加。  </p><p>使用下面的命令进行给格式化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">$ hadoop namenode -format</span><br></pre></td></tr></table></figure><h3 id="Hadoop-集群启动"><a href="#Hadoop-集群启动" class="headerlink" title="Hadoop 集群启动"></a>Hadoop 集群启动</h3><h4 id="启动-hdfs-守护进程"><a href="#启动-hdfs-守护进程" class="headerlink" title="启动 hdfs 守护进程"></a>启动 hdfs 守护进程</h4><p>启动 HDFS 守护进程： 分别启动 NameNode 和 DataNode  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ start-dfs.sh</span><br></pre></td></tr></table></figure><p>输出如下（可以看出分别启动了 namenode,datanode,secondarynamenode,因为我们没有配置 secondarynamenode,所以地址为 0.0.0.0）：  </p><h4 id="启动-yarn"><a href="#启动-yarn" class="headerlink" title="启动 yarn"></a>启动 yarn</h4><p>使用如下命令启动 ResourceManager 和 NodeManager：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ start-yarn.sh</span><br></pre></td></tr></table></figure><h4 id="检查是否运行成功"><a href="#检查是否运行成功" class="headerlink" title="检查是否运行成功"></a>检查是否运行成功</h4><p>打开浏览器  </p><ul><li><p>输入： <strong><em><a href="http://localhost:8088/">http://localhost:8088</a></em></strong> 进入 ResourceManager 管理页面 </p></li><li><p>输入： <strong><em><a href="http://localhost:50070/">http://localhost:50070</a></em></strong> 进入 HDFS 页面</p></li></ul><h4 id="可能出现的问题及调试方法"><a href="#可能出现的问题及调试方法" class="headerlink" title="可能出现的问题及调试方法"></a>可能出现的问题及调试方法</h4><p>启动伪分布式之后， 如果活跃节点显示为零，说明伪分布没有真正的启动。  </p><p>原因时有的时候数据结构出现问题会造成无法启动 datanode。 如果使用 <strong><em>hadoop namenode -format</em></strong> 重新格式化仍然无法正常启动，原因时 <strong><em>/tmp</em></strong> 中的文件没有清楚，则需要先清除 <strong><em>/tmp/hadoop/*</em></strong> 再执行格式化，即可解决 hadoop datanode 无法启动的问题。  </p><p>具体步骤如下所示：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 删除 hadoop:&#x2F;tmp</span><br><span class="line">$ hadoop fs -rmr &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># 停止 hadoop</span><br><span class="line">$ stop-all.sh</span><br><span class="line"></span><br><span class="line"># 删除 &#x2F;tmp&#x2F;hadoop*</span><br><span class="line">$ rm -rf &#x2F;tmp&#x2F;hadoop*</span><br><span class="line"></span><br><span class="line"># 格式化</span><br><span class="line">$ hadoop namenode -format</span><br><span class="line"></span><br><span class="line"># 启动 hadoop</span><br><span class="line">$ start-all.sh</span><br></pre></td></tr></table></figure><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>测试验证还是使用 之前的 WordCount。  </p><p>不同的是 ，这次使用了伪分布式模式。  使用了 hdfs ， 因此我们需要把文件拷贝到 hdfs 上去。  </p><p>首先创建相关文件夹  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hdfs dfs -mkdir -p &#x2F;user&#x2F;hadoop&#x2F;input</span><br></pre></td></tr></table></figure><h4 id="创建输入的数据"><a href="#创建输入的数据" class="headerlink" title="创建输入的数据"></a>创建输入的数据</h4><p>这里我们采用 <strong><em>/etc/protocols</em></strong> 文件作为输入的数据进行测试、现将文件拷贝到 hdfs 上：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 上传</span><br><span class="line">$ hdfs dfs -put &#x2F;etc&#x2F;protocols &#x2F;user&#x2F;hadoop&#x2F;input</span><br><span class="line"></span><br><span class="line"># 查看是否上传成功</span><br><span class="line">$ hdfs dfs -ls &#x2F;user&#x2F;hadoop&#x2F;input</span><br></pre></td></tr></table></figure><h4 id="执行-Hadoop-WordCount-应用（词频统计）"><a href="#执行-Hadoop-WordCount-应用（词频统计）" class="headerlink" title="执行 Hadoop WordCount 应用（词频统计）"></a>执行 Hadoop WordCount 应用（词频统计）</h4><p>如果存在上一次测试生成的output，由于hadoop 的安全机制，直接运行可能会报错，所以请手动删除上一次生成的 output 文件夹  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;output&#x2F;</span><br></pre></td></tr></table></figure><p>然后运行词频统计程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop jar   \</span><br><span class="line">  &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;sources&#x2F;hadoop-mapreduce-examples-2.6.0-sources.jar   \</span><br><span class="line">  org.apache.hadoop.examples.WordCount   \</span><br><span class="line">  &#x2F;user&#x2F;hadoop&#x2F;input output</span><br></pre></td></tr></table></figure><h4 id="查看生成的单词统计数据"><a href="#查看生成的单词统计数据" class="headerlink" title="查看生成的单词统计数据"></a>查看生成的单词统计数据</h4><p>耐心等待前面的词频统计命令结束后，输入下面的命令查看结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hdfs dfs -cat &#x2F;user&#x2F;hadoop&#x2F;output&#x2F;*</span><br></pre></td></tr></table></figure><h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><ul><li>关闭 HDFS 守护进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stop-dfs.sh</span><br></pre></td></tr></table></figure><ul><li>关闭 yarn </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stop-yarn.sh</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.cnblogs.com/kinglau/p/3796164.html">http://www.cnblogs.com/kinglau/p/3796164.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> 部署和管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 伪分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 单机安装</title>
      <link href="2020/01/13/hadoop-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2-2020-01-13/"/>
      <url>2020/01/13/hadoop-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2-2020-01-13/</url>
      
        <content type="html"><![CDATA[<h2 id="Hadoop-单机安装"><a href="#Hadoop-单机安装" class="headerlink" title="Hadoop 单机安装"></a>Hadoop 单机安装</h2><h3 id="Hadoop-启动模式"><a href="#Hadoop-启动模式" class="headerlink" title="Hadoop 启动模式"></a>Hadoop 启动模式</h3><p>Hadoop 集群有三种启动模式：</p><ul><li>单机模式：默认情况下运行为一个单独机器上的独立 Java 进程，主要用于调试环境</li><li>伪分布模式：在单个机器上模拟成分布式多节点环境，每一个 Hadoop 守护进程都作为一个独立的 Java 进程运行</li><li>完全分布式模式：真实的生产环境，搭建在完全分布式的集群环境</li></ul><h3 id="用户及用户组"><a href="#用户及用户组" class="headerlink" title="用户及用户组"></a>用户及用户组</h3><p>需要添加用来运行Hadoop 进程的用户组 Hadoop 及用户 Hadoop  </p><p><strong><em>注意：没有linux 环境可以使用docker</em></strong>  </p><p>可以使用下面的命令来查看已经创建好的 hadoop 用户和 uid 与 gid  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hadoop</span><br></pre></td></tr></table></figure><p>另外在 <strong><em>/etc/passwd</em></strong> 文件中也记录了用户的信息，使用下面的命令查看：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -5 &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>添加用户及用户组的步骤如下：  </p><p>创建用户 Hadoop   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser hadoop</span><br></pre></td></tr></table></figure><p>请按照提示输入 hadoop 用户的密码，例如密码设定为 <strong><em>hadoop</em></strong> 。  </p><p>将 hadoop 用户添加进 sudo 用户组  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -G sudo hadoop</span><br></pre></td></tr></table></figure><h3 id="安装及配置以来的软件包"><a href="#安装及配置以来的软件包" class="headerlink" title="安装及配置以来的软件包"></a>安装及配置以来的软件包</h3><p>Hadoop 的 运行需要JDK， 同时还应配置 SSH 免密码登录  </p><blockquote><p>关于配置Java的环境变量，请自行搜索教程  </p></blockquote><h3 id="配置SSH免密码登录"><a href="#配置SSH免密码登录" class="headerlink" title="配置SSH免密码登录"></a>配置SSH免密码登录</h3><p>切换到 hadoop 用户， hadoop 用户时密码为 hadoop。 后续步骤都将在 hadoop 用户的环境中执行。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 切换 hadoop 用户</span><br><span class="line">su hadoop</span><br></pre></td></tr></table></figure><p>配置 ssh 环境免密码登录。  </p><p>在 <strong><em>/home/hadoop</em></strong> 目录下执行下面的命令  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 切换到根目录</span><br><span class="line">$ cd ~ </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成秘钥对</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一路回车保持默认配置即可</span><br></pre></td></tr></table></figure><p>对于秘钥对的设置，保持迷人，等到执行完成后，秘钥对就生成好了（一般存放于 <strong><em>~/.ssh/</em></strong> 目录中）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将公钥写入验证文件中</span><br><span class="line">$ cat .ssh&#x2F;id&#x2F;rsa.pub &gt;&gt; .ssh&#x2F;authorized_keys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改文件的权限为 600 </span><br><span class="line">$ chmod 600 .ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>验证登录本机是否还需要密码，第一次需要密码以后不需要密码就可以登录  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 仅需输入一次 hadoop 密码， 以后不需要输入  </span><br><span class="line">$ ssh localhost</span><br></pre></td></tr></table></figure><h3 id="下载并安装-Hadoop"><a href="#下载并安装-Hadoop" class="headerlink" title="下载并安装 Hadoop"></a>下载并安装 Hadoop</h3><p>注意，本部分的操作都是在 hadoop 用户登录的环境中进行的。  </p><p>切换用户使用下面的命令。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 切换为 hadoop 用户  </span><br><span class="line">$ su hadoop </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 密码为 hadoop</span><br></pre></td></tr></table></figure><h4 id="下载-Hadoop-2-6-0"><a href="#下载-Hadoop-2-6-0" class="headerlink" title="下载 Hadoop 2.6.0"></a>下载 Hadoop 2.6.0</h4><blockquote><p>本次演示为 hadoop 2.6.0 学习者可以安装其他版本 具体安装步骤请参考官网  </p></blockquote><p>Hadoop 的下载比较缓慢，为了方便大家下载，推荐大家搜索如何 使用 阿里云的镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入家目录 &#x2F;home&#x2F;hadoop</span><br><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">$ wget 阿里云镜像地址  </span><br></pre></td></tr></table></figure><h4 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf hadoop-2.6.0.tar.gz</span><br></pre></td></tr></table></figure><p>请耐心等待解压完成  </p><p>安装之前还需要删除之前的遗留文件，如果出现无此文件夹的提示， 说明没有遗留文件。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除原本遗留的 hdfs 文件夹</span><br><span class="line">$ rm -r &#x2F;home&#x2F;hadoop&#x2F;hdfs</span><br></pre></td></tr></table></figure><p>然后再进行安装工作。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复制所需文件  </span><br><span class="line">$ mv hadoop-2.6.0 &#x2F;home&#x2F;hadoop&#x2F;hdfs</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件夹权限设置为 777</span><br><span class="line">$ chmod 777 &#x2F;home&#x2F;hadoop&#x2F;hdfs</span><br></pre></td></tr></table></figure><h4 id="配置-Hadoop"><a href="#配置-Hadoop" class="headerlink" title="配置 Hadoop"></a>配置 Hadoop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;home&#x2F;hadoop&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>在 <strong><em>/home/hadoop/.bashrc</em></strong> 文件末尾添加下列内容：   </p><blockquote><p>下面配置中 以 <strong><em>#</em></strong> 开头的是注释，无需输入  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#HADOOP START</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;hadoop&#x2F;hdfs</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-oracle</span><br><span class="line">#HADOOP END</span><br></pre></td></tr></table></figure><p>在 <strong><em>/home/hadoop/.bashrc</em></strong> 文件中 PATH 路径更改 HADOOP 相关内容：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;bin:&#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;bin:&#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;sbin</span><br></pre></td></tr></table></figure><p>保存退出后，激活新加的环境变量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>至此，Hadoop 单机模式安装完成，可以通过下述步骤的测试来验证安装是否成功。  </p><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><p>创建输入的数据，暂时采用 <strong><em>/etc/protocols</em></strong> 文件作为测试  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 进入到 Hadoop 的目录</span><br><span class="line">$ cd &#x2F;home&#x2F;hadoop&#x2F;hdfs</span><br><span class="line"></span><br><span class="line"># 新建一个 input 文件夹</span><br><span class="line">$ mkdir input</span><br><span class="line"></span><br><span class="line"># 复制文件到 input 中</span><br><span class="line">$ cp &#x2F;etc&#x2F;protocols .&#x2F;input&#x2F;</span><br></pre></td></tr></table></figure><p>执行 Hadoop WordCount 应用（词频统计）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hadoop jar \</span><br><span class="line">  &#x2F;home&#x2F;hadoop&#x2F;hdfs&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;sources&#x2F;hadoop-mapreduce-examples-2.6.0-sources.jar   \</span><br><span class="line">  org.apache.hadoop.examples.WordCount input output</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/SingleCluster.html">http://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p></li><li><p><a href="http://www.cnblogs.com/kinglau/p/3794433.html">http://www.cnblogs.com/kinglau/p/3794433.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> 部署和管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 单机模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop-了解什么是hadoop</title>
      <link href="2020/01/13/hadoop-%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFhadoop-2020-01-13/"/>
      <url>2020/01/13/hadoop-%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFhadoop-2020-01-13/</url>
      
        <content type="html"><![CDATA[<h2 id="了解Hadoop"><a href="#了解Hadoop" class="headerlink" title="了解Hadoop"></a>了解Hadoop</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLViCt.png" alt="https://s2.ax1x.com/2020/01/14/lLViCt.png">  </p><h3 id="Hadoop-简介"><a href="#Hadoop-简介" class="headerlink" title="Hadoop 简介"></a>Hadoop 简介</h3><ul><li>开源</li></ul><p>Apache Hadoop 是一款支持数据密集型分布式应用并以 Apache 2.0 许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。  </p><ul><li><p>源于 MapReduce<br>Hadoop 是根据 Google 公司发表的 MapReduce 和 Google 档案系统的论文自行实作而成。  </p></li><li><p>提供可靠性和数据移动<br>Hadoop 框架透明地为应用提供可靠性和数据移动。它实现了名为 MapReduce 的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。  </p></li><li><p>分布式文件系统<br>此外，Hadoop 还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce 和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和 PB 级的数据。  </p></li><li><p>Hadoop 平台<br>现在普遍认为整个 Apache Hadoop “平台” 包括 Hadoop 内核、MapReduce、Hadoop 分布式文件系统（HDFS）以及一些相关项目，有 Apache Hive 和 Apache HBase 等等。  </p></li></ul><p>Hadoop 的框架最核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，则 MapReduce 为海量的数据提供了计算。  </p><h3 id="Hadoop-历史"><a href="#Hadoop-历史" class="headerlink" title="Hadoop 历史"></a>Hadoop 历史</h3><p>Hadoop 由 Apache Software Foundation 公司于 2005 年秋天作为 Lucene 的子项目 Nutch 的一部分正式引入。它受到最先由 Google Lab 开发的 Map/Reduce 和 Google File System(GFS) 的启发。  </p><p>2006 年 3 月份，Map/Reduce 和 Nutch Distributed File System (NDFS) 分别被纳入称为 Hadoop 的项目中。  </p><p>Hadoop 是最受欢迎的在 Internet 上对搜索关键字进行内容分类的工具，但它也可以解决许多要求极大伸缩性的问题。例如，如果您要 grep 一个 10TB 的巨型文件，会出现什么情况？在传统的系统上，这将需要很长的时间。但是 Hadoop 在设计时就考虑到这些问题，采用并行执行机制，因此能大大提高效率。  </p><p>目前有很多公司开始提供基于 Hadoop 的商业软件、支持、服务以及培训。  </p><ol><li>Cloudera 是一家美国的企业软件公司，该公司在 2008 年开始提供基于 Hadoop 的软件和服务。</li><li>GoGrid 是一家云计算基础设施公司，在 2012 年，该公司与 Cloudera 合作加速了企业采纳基于 Hadoop 应用的步伐。</li><li>Dataguise 公司是一家数据安全公司，同样在 2012 年该公司推出了一款针对 Hadoop 的数据保护和风险评估。  </li></ol><h3 id="Hadoop-相关项目"><a href="#Hadoop-相关项目" class="headerlink" title="Hadoop 相关项目"></a>Hadoop 相关项目</h3><ul><li><p>Hadoop Common<br>在 0.20 及以前的版本中，包含 HDFS、MapReduce 和其他项目公共内容，从 0.21 开始 HDFS 和 MapReduce 被分离为独立的子项目，其余内容为 Hadoop Common。</p></li><li><p>HDFS<br>HDFS 是指 Hadoop 分布式文件系统（Distributed File System）－HDFS（Hadoop Distributed File System）</p></li><li><p>MapReduce<br>MapReduce 是一个并行计算框架，0.20 前使用 org.apache.hadoop.mapred 旧接口，0.20 版本开始引入 org.apache.hadoop.mapreduce 的新 API。</p></li><li><p>Apache HBase<br>HBase 是一个分布式 NoSQL 列数据库，类似谷歌公司的 BigTable。</p></li><li><p>Apache Hive<br>Hive 是构建于 Hadoop 之上的数据仓库，通过一种类 SQL 语言 HiveQL 为用户提供数据的归纳、查询和分析等功能。</p></li><li><p>Apache Mahout<br>机器学习算法软件包。</p></li><li><p>Apache Sqoop<br>结构化数据（如关系数据库）与 Apache Hadoop 之间的数据转换工具。</p></li><li><p>Apache ZooKeeper<br>分布式锁设施，提供类似 Google Chubby 的功能。</p></li><li><p>Apache Avro<br>新的数据序列化格式与传输工具，将逐步取代 Hadoop 原有的 IPC 机制。  </p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://static.oschina.net/uploads/space/2017/0331/174019_l1PS_3362322.jpg" alt="https://static.oschina.net/uploads/space/2017/0331/174019_l1PS_3362322.jpg"></p><h3 id="Hadoop-优点"><a href="#Hadoop-优点" class="headerlink" title="Hadoop 优点"></a>Hadoop 优点</h3><ul><li><p>高可靠性<br>Hadoop 按位存储和处理数据的能力值得人们信赖。</p></li><li><p>高扩展性<br>Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。</p></li><li><p>高效性<br>Hadoop 能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</p></li><li><p>高容错性<br>Hadoop 能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。</p></li><li><p>低成本<br>与一体机、商用数据仓库以及 QlikView、Yonghong Z-Suite 等数据集市相比，hadoop 是开源的，项目的软件成本因此会大大降低。</p></li><li><p>支持 Java、C/C++<br>Hadoop 带有用 Java 语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。  </p></li></ul><h3 id="Hadoop-应用场景"><a href="#Hadoop-应用场景" class="headerlink" title="Hadoop 应用场景"></a>Hadoop 应用场景</h3><p>美国著名科技博客 GigaOM 的专栏作家 Derrick Harris 在一篇文章中总结了 10 个 Hadoop 的应用场景：  </p><ul><li><p>在线旅游<br>全球 80% 的在线旅游网站都是在使用 Cloudera 公司提供的 Hadoop 发行版，其中 SearchBI 网站曾经报道过的 Expedia 也在其中。  </p></li><li><p>移动数据<br>Cloudera 运营总监称，美国有 70% 的智能手机数据服务背后都是由 Hadoop 来支撑的，也就是说，包括数据的存储以及无线运营商的数据处理等，都是在利用 Hadoop 技术。  </p></li><li><p>电子商务<br>这一场景应该是非常确定的，eBay 就是最大的实践者之一。国内的电商在 Hadoop 技术上也是储备颇为雄厚的。</p></li><li><p>能源开采<br>美国 Chevron 公司是全美第二大石油公司，他们的 IT 部门主管介绍了 Chevron 使用 Hadoop 的经验，他们利用 Hadoop 进行数据的收集和处理，其中这些数据是海洋的地震数据，以便于他们找到油矿的位置。</p></li><li><p>节能<br>另外一家能源服务商 Opower 也在使用 Hadoop,为消费者提供节约电费的服务，其中对用户电费单进行了预测分析。</p></li><li><p>基础架构管理<br>这是一个非常基础的应用场景，用户可以用 Hadoop 从服务器、交换机以及其他的设备中收集并分析数据。</p></li><li><p>图像处理<br>创业公司 Skybox Imaging 使用 Hadoop 来存储并处理图片数据，从卫星中拍摄的高清图像中探测地理变化。</p></li><li><p>诈骗检测：这个场景用户接触的比较少，一般金融服务或者政府机构会用到。利用 Hadoop 来存储所有的客户交易数据，包括一些非结构化的数据，能够帮助机构发现客户的异常活动，预防欺诈行为。</p></li><li><p>IT 安全</p></li></ul><p>除企业 IT 基础机构的管理之外，Hadoop 还可以用来处理机器生成数据以便甄别来自恶意软件或者网络中的攻击。</p><ul><li>医疗保健</li></ul><p>医疗行业也会用到 Hadoop，像 IBM 的 Watson 就会使用 Hadoop 集群作为其服务的基础，包括语义分析等高级分析技术等。医疗机构可以利用语义分析为患者提供医护人员，并协助医生更好地为患者进行诊断。</p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
          <category> 部署和管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 初始hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国外VPS搭建SSR多用户教程[中文一键安装管理]</title>
      <link href="2020/01/10/server-%E8%87%AA%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%88%E6%A2%AF%E5%AD%90%EF%BC%89-2020-01-10/"/>
      <url>2020/01/10/server-%E8%87%AA%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%88%E6%A2%AF%E5%AD%90%EF%BC%89-2020-01-10/</url>
      
        <content type="html"><![CDATA[<h2 id="国外VPS搭建SSR多用户教程-中文一键安装管理"><a href="#国外VPS搭建SSR多用户教程-中文一键安装管理" class="headerlink" title="国外VPS搭建SSR多用户教程[中文一键安装管理]"></a>国外VPS搭建SSR多用户教程[中文一键安装管理]</h2><blockquote><p>首先一切的基础都建立在你有一台 [非大陆]的 VPS ，拥有基础服务器知识（例如连接服务器）  </p></blockquote><p>如果你想多用户使用，可以使用不同的端口来控制。所以，本文的SSR多用户搭建就是在一个VPS下面分别设置多个SSR账号，相同的IP地址，不同的端口和SSR密码。  </p><p><strong><em>本文也适用任何可用的国外VPS搭建SS/SSR,可以搭建SS多用户也可以搭建SSR多用户。</em></strong>  </p><h3 id="第一步-连接服务器"><a href="#第一步-连接服务器" class="headerlink" title="第一步 连接服务器"></a>第一步 连接服务器</h3><p>登录服务器，远程连接你的服务器（或者VPS）  </p><h3 id="第二步-安装管理"><a href="#第二步-安装管理" class="headerlink" title="第二步  安装管理"></a>第二步  安装管理</h3><p>在命令行内输入下列命令  ：（该脚本适用于Centos。其他系统没有测试，如果你的系统非Centos，可以使用Docker 具体使用方法，本文不作任何阐述）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CecilWu&#x2F;SSR-Chinese&#x2F;master&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>此时服务器会自动安装脚本，**<em>如果脚本执行过程中没有反映，你直接回车确认即可**</em>  </p><p>这个脚本是中文版的，非常简单，直接根据数字选择即可  </p><h3 id="第三步-配置管理"><a href="#第三步-配置管理" class="headerlink" title="第三步 配置管理"></a>第三步 配置管理</h3><p>输入数字1 之后回车开始安装 <strong><em>ShadowsocksR</em></strong> ,安装完毕之后会要求你自定义端口和密码。然后回车确认，他会要求你选择加密方式，此时一般选择 <strong><em>10:aes-256-cfb</em></strong>  </p><blockquote><p>具体请参考不同的加密方法 不以本文推荐为主</p></blockquote><p>然后设置协议插件、混淆插件（这些都是为了防止封锁） 具体直接根据你的选择进行适当搭配  </p><h3 id="第四步-用户管理"><a href="#第四步-用户管理" class="headerlink" title="第四步 用户管理"></a>第四步 用户管理</h3><p>这一步没什么好讲的，基本上都是中文介绍  </p><h3 id="最后-完成"><a href="#最后-完成" class="headerlink" title="最后 完成"></a>最后 完成</h3><p>上述步骤都使用完毕之后，我们输入 <strong><em>“Y”</em></strong> 确认上述部署  </p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>过段时间之后，系统会提示安装完成，同时显示SS账号的配置信息，自己保存好即可  </p><h4 id="关于多账号使用管理"><a href="#关于多账号使用管理" class="headerlink" title="关于多账号使用管理"></a>关于多账号使用管理</h4><p>如果你想返回主界面继续安装第二个账号，可以输入下面命令调出，然后选择 “9” 切换到多端口模式即可  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该操作 处于 你下载 当前脚本文件夹位置</span><br><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><h4 id="食用说明"><a href="#食用说明" class="headerlink" title="食用说明"></a>食用说明</h4><p>一切都准备好了之后，下载Shadowsocks的客户端：  </p><ul><li><a href="https://img.5xiaobo.com/soft/Shadowsocks.zip">windows</a></li><li><a href="https://img.5xiaobo.com/soft/Shadowsocks%20for%20Mac.dmg">mac</a>  </li></ul><p>请点击上述两个版本进行下载，下载完成之后按照账号信息进行连接配置。配置完毕之后即可愉快的玩耍了！！  </p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>上述操作已经可以满足大部分需求了，但是因为是 <strong><em>vpn</em></strong> 所以网速方面还是很感人的，我们可以对应开启谷歌的 <strong><em>BBR</em></strong> 加速 <strong><em>（ps:现在很多厂商都会自己在服务器内部安装 BBR加速，但是有的也没有，请根据自己的情况选择安装）</em></strong>  </p><p>请直接复制下列命令 一路回车即可  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br><span class="line">chmod +x bbr.sh</span><br><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><blockquote><p>如果安装 <strong><em>BBR</em></strong> 之后 发生故障，推荐 <strong><em>万能重装大法</em></strong>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
            <tag> SSR </tag>
            
            <tag> vps </tag>
            
            <tag> 中文VPN脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 类和对象（二）</title>
      <link href="2020/01/10/scala-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89-2020-01-10/"/>
      <url>2020/01/10/scala-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89-2020-01-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-类和对象（二）"><a href="#Scala-类和对象（二）" class="headerlink" title="Scala 类和对象（二）"></a>Scala 类和对象（二）</h2><h3 id="本章知识点概括"><a href="#本章知识点概括" class="headerlink" title="本章知识点概括"></a>本章知识点概括</h3><ul><li>类的定义规范  </li><li>定义类  </li><li>前提条件检查  </li><li>添加成员变量  </li><li>自身引用  </li><li>辅助构造函数  </li><li>私有成员变量和方法  </li><li>定义运算符  </li><li>标识符  </li><li>方法重载  </li><li>隐式类型转换  </li></ul><h3 id="Rational-类的定义规范"><a href="#Rational-类的定义规范" class="headerlink" title="Rational 类的定义规范"></a>Rational 类的定义规范</h3><p>首先，我们回忆下有理数的定义：一个有理数(rational)可以表示成分数形式： <strong><em>n/d</em></strong> , 其中 <strong><em>n</em></strong> 和 <strong><em>d</em></strong> 都是整数（ <strong><em>d</em></strong> 不可以为 <strong><em>0</em></strong> ），*<strong>n*** 称为分子(numerator)，*</strong>d*** 为分母(denominator)。和浮点数相比，有理数可以精确表达一个分数，而不会有误差。  </p><p>因此我们定义的 <strong><em>Rational</em></strong> 类支持上面的有理数的定义。支持有理数的加减乘除，并支持有理数的规范表示，比如 <strong><em>2/10</em></strong> ，其规范表示为 <strong><em>1/5</em></strong> 。分子和分母的最小公倍数为 <strong><em>1</em></strong> 。  </p><p>有了有理数定义的实现规范，我们可以开始设计类 <strong><em>Rational</em></strong> 。一个好的起点是考虑用户如何使用这个类，我们已经决定使用 “Immutable” 方式来使用 <strong><em>Rational</em></strong> 对象，我们需要用户在定义 <strong><em>Rational</em></strong> 对象时提供分子和分母。因此我们可以开始定义 <strong><em>Rational</em></strong> 类如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Rational( n:Int, d:Int)</span><br></pre></td></tr></table></figure><p>可以看到，和Java不同的是，Scala的类定义可以有参数，称为 <strong><em>类参数</em></strong> , 如上面的 <strong><em>n</em></strong>、**<em>d**</em>。Scala使用类参数，并把类定义和主构造函数合并在一起，在定义类的同事也定义了累的主构造函数。因此Scala的类定义相对要简洁一些  </p><p>Scala 编译器会编译Scala类定义包含的任何不属于类成员和类定义的其他代码，这些代码将作为类的主构造函数。比如，我们定义一条打印消息作为类定义的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Rational (n:Int, d:Int) &#123;</span><br><span class="line">     |    println(&quot;Created &quot; + n + &quot;&#x2F;&quot; +d)</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Rational</span><br><span class="line"></span><br><span class="line">scala&gt; new Rational(1,2)</span><br><span class="line">Created 1&#x2F;2</span><br><span class="line">res0: Rational &#x3D; Rational@22f34036</span><br></pre></td></tr></table></figure><p>可以看到创建 <strong><em>Ratiaonal</em></strong> 对象时，自动执行类定义的代码（主构造函数）  </p><h3 id="重新定义类的-toString-方法"><a href="#重新定义类的-toString-方法" class="headerlink" title="重新定义类的 toString 方法"></a>重新定义类的 toString 方法</h3><p>上面的代码创建 <strong><em>Rational(1,2)</em></strong>，Scala 编译器打印出 <strong><em>Rational@22f34036</em></strong>，这是因为使用了缺省的类的 <strong><em>toString() 定义</em></strong> ( <strong><em>Object</em></strong> 对象的)， 缺省实现是打印出对象的类名称+ @ + 16进制数（对象的地址），显示结果不是很直观，因此我们可以重新定义类的 <strong><em>toString()</em></strong> 方法以显示更有意义的字符。  </p><p>在Scala中，你也可以使用 <strong><em>override</em></strong> 来重载基类定义的方法，而且必须使用 <strong><em>override</em></strong> 关键字表示重新定义基类中的成员。比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Rational (n:Int, d:Int) &#123;</span><br><span class="line">     |    override def toString &#x3D; n + &quot;&#x2F;&quot; +d</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Rational</span><br><span class="line"></span><br><span class="line">scala&gt; val x&#x3D; new Rational(1,3)</span><br><span class="line">x: Rational &#x3D; 1&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; val y&#x3D;new Rational(5,7)</span><br><span class="line">y: Rational &#x3D; 5&#x2F;7</span><br></pre></td></tr></table></figure><h3 id="前提条件检查"><a href="#前提条件检查" class="headerlink" title="前提条件检查"></a>前提条件检查</h3><p>前面说过有理数可以表示为 <strong><em>n/d</em></strong> (其中 <strong><em>d</em></strong> 、*<strong>n*** 、为整数，而 *</strong>d*** 不能为 0)。对于前面的 <strong><em>Rational</em></strong> 定义，我们如果使用 <strong><em>0</em></strong> 也是可以的。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; new Rational(5,0)</span><br><span class="line">res0: Rational &#x3D; 5&#x2F;0</span><br></pre></td></tr></table></figure><p>怎么解决分母不能为0的问题？面向对象编程的一个优点是实现了数据的封装，你可以确保再起声明周期过程中是有效的。对于有理数的一个前提条件是分母不可以为0，Scala中定义为传入构造函数和方法的参数的限制范围，也就是调用这些函数或方法的调用者需要满足的条件。Scala中解决这个问题的一个方法时使用 <strong><em>require</em></strong> 方法 （ <strong><em>require</em></strong> 方法为 <strong><em>Predef</em></strong> 对象定义的一个方法，Scala环境自动载入这个类的定义，因此无需使用 <strong><em>import</em></strong> 引入这个对象），因此修改 <strong><em>Rational</em></strong> 定义如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; class Rational (n:Int, d:Int) &#123;</span><br><span class="line">     |    require(d!&#x3D;0)</span><br><span class="line">     |    override def toString &#x3D; n + &quot;&#x2F;&quot; +d</span><br><span class="line">     | &#125;</span><br><span class="line">defined class Rational</span><br><span class="line"></span><br><span class="line">scala&gt; new Rational(5,0)</span><br><span class="line">java.lang.IllegalArgumentException: requirement failed</span><br><span class="line">  at scala.Predef$.require(Predef.scala:211)</span><br><span class="line">  ... 33 elided</span><br></pre></td></tr></table></figure><p>可以看到，如果再使用 <strong><em>0</em></strong> 作为分母，系统将抛出 <strong><em>IllegalArgumentException</em></strong> 异常  </p><h3 id="添加成员变量"><a href="#添加成员变量" class="headerlink" title="添加成员变量"></a>添加成员变量</h3><p>前面我们定义了 <strong><em>Rational</em></strong> 的主构造函数，并检查了输入不允许分母为 <strong><em>0</em></strong> 。 下面我们就可以开始实现两个 <strong><em>Rational</em></strong> 对象相加的操作。我们需要实现的是 函数化对象，因此 <strong><em>Rational</em></strong> 的加法操作应该是返回一个新的 <strong><em>Rational</em></strong> 对象，而不是返回被相加的对象本身。我们很可能写出如下的实现：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Rational (n:Int, d:Int) &#123;</span><br><span class="line">   require(d!&#x3D;0)</span><br><span class="line">   override def toString &#x3D; n + &quot;&#x2F;&quot; +d</span><br><span class="line">   def add(that:Rational) : Rational &#x3D;</span><br><span class="line">     new Rational(n*that.d + that.n*d,d*that.d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上编译器会给出如下编译错误:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;console&gt;:11: error: value d is not a member of Rational</span><br><span class="line">            new Rational(n*that.d + that.n*d,d*that.d)</span><br><span class="line">                                ^</span><br><span class="line">&lt;console&gt;:11: error: value d is not a member of Rational</span><br><span class="line">            new Rational(n*that.d + that.n*d,d*that.d)</span><br></pre></td></tr></table></figure><p>这是为什么呢？尽管类参数在新定义的函数的访问范围之内，但仅限于定义类的方法本身(比如之前定义的 <strong><em>toString</em></strong> 方法，可以直接访问类参数），但对于 <strong><em>that</em></strong> 来说，无法使用 <strong><em>that.d</em></strong> 来访问 <strong><em>d</em></strong> 。因为 <strong><em>that</em></strong> 不在定义的类可以访问的范围之内。此时需要定义为类的成员变量。（注：后面定义的 <strong><em>case class</em></strong> 类型编译器自动把类参数定义为类的属性，这时可以使用 <strong><em>that.d</em></strong> 等来访问类参数）。  </p><p>修改 Rational 定义，使用成员变量定义如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Rational (n:Int, d:Int) &#123;</span><br><span class="line">   require(d!&#x3D;0)</span><br><span class="line">   val number &#x3D;n</span><br><span class="line">   val denom &#x3D;d </span><br><span class="line">   override def toString &#x3D; number + &quot;&#x2F;&quot; +denom </span><br><span class="line">   def add(that:Rational)  &#x3D;</span><br><span class="line">     new Rational(</span><br><span class="line">       number * that.denom + that.number* denom,</span><br><span class="line">       denom * that.denom</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，我们这里定义成员变量都使用了 <strong><em>val</em></strong> , 因为我们实现的是“immutable”类型的类定义。 <strong><em>number</em></strong> 和 <strong><em>denom</em></strong> 以及 <strong><em>add</em></strong> 都可以不定义类型，Scala 编译器能够根据上下文推算出它们的类型。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val oneHalf&#x3D;new Rational(1,2)</span><br><span class="line">oneHalf: Rational &#x3D; 1&#x2F;2</span><br><span class="line"></span><br><span class="line">scala&gt; val twoThirds&#x3D;new Rational(2,3)</span><br><span class="line">twoThirds: Rational &#x3D; 2&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; oneHalf add twoThirds</span><br><span class="line">res0: Rational &#x3D; 7&#x2F;6</span><br><span class="line"></span><br><span class="line">scala&gt; oneHalf.number</span><br><span class="line">res1: Int &#x3D; 1</span><br></pre></td></tr></table></figure><p>可以看到，这时就可以使用 <strong><em>.number</em></strong> 等来访问类的成员变量。  </p><h3 id="自身引用"><a href="#自身引用" class="headerlink" title="自身引用"></a>自身引用</h3><p>Scala 也适用 <strong><em>this</em></strong> 来引用当前对象本身，一般来说访问类成员时无需使用 <strong><em>this</em></strong>，比如实现一个 <strong><em>lessThan</em></strong> 方法，下面两种实现是等效的。  </p><p>第一种：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def lessThan(that:Rational) &#x3D; </span><br><span class="line">    this.number * that.denom &lt; that.number * this.denom</span><br></pre></td></tr></table></figure><p>第二种：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def lessThan(that:Rational) &#x3D; </span><br><span class="line">    number * that.denom &lt; that.number * denom</span><br></pre></td></tr></table></figure><p>但如果需要引入对象自身，*<strong>this*** 就无法省略，比如下面实现一个返回两个 *</strong>Rational*** 中比较大的一个值：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def max(that:Rational) &#x3D; </span><br><span class="line">    if(lessThan(that)) that else this</span><br></pre></td></tr></table></figure><p>其中的 <strong><em>this</em></strong> 就无法省略  </p><h3 id="辅助构造函数"><a href="#辅助构造函数" class="headerlink" title="辅助构造函数"></a>辅助构造函数</h3><p>在定义类时，很多时候需要定义多个构造函数，在Scala中，除主构造函数之外的构造函数都成为辅助构造函数（或是从构造函数），比如对于 <strong><em>Rational</em></strong> 类来说，如果定义一个整数，就没有必要指明分母，此时只要整数本身就可以定义这个有理数。 我们可以为 Rational 定义一个辅助构造函数， <strong><em>Scala</em></strong> 定义辅助构造函数使用 <strong><em>this(……)</em></strong> 的语法，所有辅助构造函数名称为 <strong><em>this</em></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def this(n:Int) &#x3D; this(n,1)</span><br></pre></td></tr></table></figure><p>所有Scala的辅助构造函数的第一个语句都为调用其他构造函数，也就是 <strong><em>this(……)</em></strong>。被调用的构造函数可以是主构造函数或是其他构造函数（最终会调用柱构造函数）。 这样使得每个构造函数最终都会调用主构造函数，从而使得柱构造函数称为创建类单一入口点。在Scala中也只有柱构造函数才能调用基类的构造函数，这种限制有它的有点，使得Scala构造函数更加简洁以及提高一致性  </p><h3 id="私有成员变量和方法"><a href="#私有成员变量和方法" class="headerlink" title="私有成员变量和方法"></a>私有成员变量和方法</h3><p>Scala类定义私有成员的方法也是使用 <strong><em>private</em></strong> 修饰符，为了实现 <strong><em>Rational</em></strong> 的规范化显示，我们需要使用一个求分子和分母的最大公约数的私有方法 <strong><em>gcd</em></strong>. 同时我们使用一个私有变量 <strong><em>g</em></strong> 来保存最大公约数，修改 <strong><em>Rational</em></strong> 的定义：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Rational (n:Int, d:Int) &#123;</span><br><span class="line">    require(d!&#x3D;0)</span><br><span class="line">    private val g &#x3D;gcd (n.abs,d.abs) </span><br><span class="line">    val number &#x3D;n&#x2F;g </span><br><span class="line">    val denom &#x3D;d&#x2F;g </span><br><span class="line">    override def toString &#x3D; number + &quot;&#x2F;&quot; +denom</span><br><span class="line">    def add(that:Rational)  &#x3D; </span><br><span class="line">      new Rational( </span><br><span class="line">        number * that.denom + that.number* denom,</span><br><span class="line">        denom * that.denom </span><br><span class="line">      ) </span><br><span class="line">    def this(n:Int) &#x3D; this(n,1) </span><br><span class="line">    private def gcd(a:Int,b:Int):Int &#x3D;</span><br><span class="line">      if(b&#x3D;&#x3D;0) a else gcd(b, a % b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; new Rational ( 66,42)</span><br><span class="line">res0: Rational &#x3D; 11&#x2F;7</span><br></pre></td></tr></table></figure><p>注意gcd的定义，因为他是个 <strong><em>回溯</em></strong> 函数，必须定义返回值类型。<br>Scala 会根据成员变量出现的顺序依次初始化他们，因此 <strong><em>g</em></strong> 必须出现在 <strong><em>number</em></strong> 和 <strong><em>denom</em></strong> 之前  </p><h3 id="定义运算符"><a href="#定义运算符" class="headerlink" title="定义运算符"></a>定义运算符</h3><p>我们使用 <strong><em>add</em></strong> 定义两个 <strong><em>Rational</em></strong> 对象的加法。两个 <strong><em>Rational</em></strong> 加法可以写成 <strong><em>x.add(y)</em></strong> 或者 <strong><em>x add y</em></strong>。  </p><p>即使使用 <strong><em>x add y</em></strong> 还是没有 <strong><em>x + y</em></strong> 来得简洁  </p><p>我们在前面说过，在Scala中，运算符（操作符）和普通的方法没有什么区别，任何方法都可以写成操作符的语法。比如上面的 <strong><em>x add y</em></strong>   </p><p>而在 Scala 中对方法的名称也没有什么特别的限制，你可以使用符号作为类方法的名称，比如使用 <strong><em>+</em></strong>、*<strong>-*** 和 *</strong>*<strong>*等符号。因此我们可以重新定义 *</strong>Rational*** 如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Rational (n:Int, d:Int) &#123;</span><br><span class="line">   require(d!&#x3D;0)</span><br><span class="line">   private val g &#x3D;gcd (n.abs,d.abs) </span><br><span class="line">   val numer &#x3D;n&#x2F;g </span><br><span class="line">   val denom &#x3D;d&#x2F;g </span><br><span class="line">   override def toString &#x3D; numer + &quot;&#x2F;&quot; +denom</span><br><span class="line">   def +(that:Rational)  &#x3D;</span><br><span class="line">     new Rational( </span><br><span class="line">       numer * that.denom + that.numer* denom,</span><br><span class="line">       denom * that.denom </span><br><span class="line">     ) </span><br><span class="line">   def * (that:Rational) &#x3D;</span><br><span class="line">     new Rational( numer * that.numer, denom * that.denom)</span><br><span class="line">   def this(n:Int) &#x3D; this(n,1) </span><br><span class="line">   private def gcd(a:Int,b:Int):Int &#x3D;</span><br><span class="line">     if(b&#x3D;&#x3D;0) a else gcd(b, a % b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用 <strong><em>+</em></strong> 、 <strong><em>*</em></strong> 号来实现Rational的加法和乘法。 <strong><em>+</em></strong>、*<strong>**</strong>的优先级是 Scala 预设的，和整数的 <strong><em>+</em></strong>、*<strong>-**<em>、</em></strong>*<strong>* 和 *</strong>/*** 的优先级一样。 下面为使用 Rational 的例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x&#x3D; new Rational(1,2)</span><br><span class="line">x: Rational &#x3D; 1&#x2F;2</span><br><span class="line"></span><br><span class="line">scala&gt; val y&#x3D;new Rational(2,3)</span><br><span class="line">y: Rational &#x3D; 2&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; x+y</span><br><span class="line">res0: Rational &#x3D; 7&#x2F;6</span><br><span class="line"></span><br><span class="line">scala&gt; x+ x*y</span><br><span class="line">res1: Rational &#x3D; 5&#x2F;6</span><br></pre></td></tr></table></figure><p>从这个例子也可以看出 Scala 语言的扩展性， 你使用 <strong><em>Rational</em></strong> 对象就像 <strong><em>Scala</em></strong> 内置的数据类型一样。  </p><h3 id="Scala-中的标识符"><a href="#Scala-中的标识符" class="headerlink" title="Scala 中的标识符"></a>Scala 中的标识符</h3><p>从前面的例子我们可以看到Scala可以使用两种形式的标志符， 字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号 <strong><em>$</em></strong> 在Scala 中也看做字母。然而以 <strong><em>$</em></strong> 开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用 <strong><em>$</em></strong> 开始的标识符，以免造成冲突  </p><p>Scala 的命名规则采用和 Java 类似的 <strong><em>camel</em></strong> 命名规则（驼峰命名法），首字符小写，比如 <strong><em>toString</em></strong> 。类名的首字符还是使用大写。此外也应该避免使用以下划线结尾的标志符以避免冲突  </p><p>符号标志符包含一个或多个符号，如 <strong><em>+</em></strong> 、*<strong>:*** 和 *</strong>?<strong>*。对于 *</strong>+<strong><em>、</em></strong>++<strong><em>、</em></strong>:::<strong><em>、</em></strong>:-&gt;<strong>*之类的符号，Scala内部实现时会使用转义的标志符。例如对 *</strong>:-&gt;<strong>* 使用 *</strong>$colon$minus$greater*** 来表示这个符号。因此，如果你需要在Java代码中访问 <strong><em>:-&gt;</em></strong> 方法，你需要使用 Scala 的内部名称 <strong><em>$colon$minus$greater</em></strong>。  </p><p>混合标志符由字符数字标志符后面跟着一个或多个符号组成，比如 <strong><em>unary_+</em></strong> 为Scala 对 <strong><em>+</em></strong> 方法的内部实现时的名称。  </p><p>字面量标志符为 使用 <strong><em>“</em></strong> 定义的字符串，比如 <strong><em>“x”</em></strong> 、 <strong><em>“yield”</em></strong>。 你可以在 <strong><em>“</em></strong> 之间使用任何有效的Scala标志符，Scala将他们解释为一个Scala标志符，一个典型的使用是 <strong><em>Thread</em></strong> 的 <strong><em>yield</em></strong> 方法，在Scala中你不能使用 <strong><em>Thread.yield()</em></strong> 是因为 yield 为 Scala 中的关键字，你必须使用 <strong><em>Thread.”yield”()</em></strong> 来使用这个方法  </p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>和 Java 一样， Scala也支持方法重载，重载的方法参数类型不同却使用同样的方法名称， 比如对于 <strong><em>Ratioinal</em></strong> 对象， <strong><em>+</em></strong> 的对象可以为另一个 <strong><em>Rational</em></strong> 对象，也可以为一个 <strong><em>Int</em></strong> 对象，此时你可以重载 <strong><em>+</em></strong> 方法以支持和 <strong><em>Int</em></strong> 相加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def + (i:Int) &#x3D; </span><br><span class="line">    new Rational (numer + i * denom, denom)</span><br></pre></td></tr></table></figure><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>上面我们定义 <strong><em>Rational</em></strong> 的加法，并重载 <strong><em>+</em></strong> 以支持整数， <strong><em>r+2</em></strong>, 但如果我们需要 <strong><em>2+r</em></strong> 如何呢？下面例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x &#x3D;new Rational(2,3)</span><br><span class="line">x: Rational &#x3D; 2&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; val y &#x3D; new Rational(3,7)</span><br><span class="line">y: Rational &#x3D; 3&#x2F;7</span><br><span class="line"></span><br><span class="line">scala&gt; val z &#x3D; 4</span><br><span class="line">z: Int &#x3D; 4</span><br><span class="line"></span><br><span class="line">scala&gt; x + z</span><br><span class="line">res0: Rational &#x3D; 14&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; x + 3</span><br><span class="line">res1: Rational &#x3D; 11&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; 3 + x</span><br><span class="line">&lt;console&gt;:10: error: overloaded method value + with alternatives:</span><br><span class="line">  (x: Double)Double &lt;and&gt;</span><br><span class="line">  (x: Float)Float &lt;and&gt;</span><br><span class="line">  (x: Long)Long &lt;and&gt;</span><br><span class="line">  (x: Int)Int &lt;and&gt;</span><br><span class="line">  (x: Char)Int &lt;and&gt;</span><br><span class="line">  (x: Short)Int &lt;and&gt;</span><br><span class="line">  (x: Byte)Int &lt;and&gt;</span><br><span class="line">  (x: String)String</span><br><span class="line"> cannot be applied to (Rational)</span><br><span class="line">              3 + x</span><br><span class="line">                ^</span><br></pre></td></tr></table></figure><p>可以看到 <strong><em>x+3</em></strong> 没有问题， <strong><em>3+x</em></strong>就报错了，这是因为整数类型不支持和 <strong><em>Rational</em></strong> 相加。 我们不可能去修改 <strong><em>Int</em></strong> 的定义（除非你重写Scala的 <strong><em>Int</em></strong> 定义） 以支持 <strong><em>Int</em></strong> 和 <strong><em>Rational</em></strong> 相加。 如果你写过 .net 代码，这可以通过静态扩展方法来实现， Scala 提供了类似的机制来解决这种问题。  </p><p>如果 <strong><em>Int</em></strong> 类型能够根据需要自动转换为 <strong><em>Rational</em></strong> 类型， 那么 <strong><em>3 + x</em></strong> 就可以相加。 Scala 通过 <strong><em>implicit def</em></strong> 定义一个隐含类型转换，比如定义由整数到 <strong><em>Rational</em></strong> 类型的转换如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implicit def intToRational(x:Int) &#x3D; new Rational(x)</span><br></pre></td></tr></table></figure><p>再次重新计算 <strong><em>r + 2</em></strong> 和 <strong><em>2 + r</em></strong> 的例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val r &#x3D; new Rational(2,3)</span><br><span class="line">r: Rational &#x3D; 2&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; r + 2</span><br><span class="line">res0: Rational &#x3D; 8&#x2F;3</span><br><span class="line"></span><br><span class="line">scala&gt; 2 + r</span><br><span class="line">res1: Rational &#x3D; 8&#x2F;3</span><br></pre></td></tr></table></figure><p>其实此时 <strong><em>Rational</em></strong> 的一个 <strong><em>+</em></strong> 重载方法时多余的，当Scala计算 <strong><em>2 + r</em></strong>，发现 <strong><em>2(Int)</em></strong> 类型没有可以和 <strong><em>Rational</em></strong> 对象相加的方法， 类型转换后的类型支持 <strong><em>+r</em></strong> , 一检查发现定义了由 <strong><em>Int</em></strong> 到 <strong><em>Rational</em></strong> 的隐含转换方法，就自动调用该方法，把整数转换为 <strong><em>Rational</em></strong> 数据类型， 然后调用 <strong><em>Rational</em></strong> 对象的 <strong><em>+</em></strong> 方法。  从而实现了 <strong><em>Rational</em></strong> 类或是 <strong><em>Int</em></strong> 类的扩展。 关于 <strong><em>implicit def</em></strong> 的详细介绍将由后面的文章来说明，隐含类型转换在设计Scala库时非常有用。  </p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 类和对象 （一）</title>
      <link href="2020/01/10/scala-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89-2020-01-10/"/>
      <url>2020/01/10/scala-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89-2020-01-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-类和对象-（一）"><a href="#Scala-类和对象-（一）" class="headerlink" title="Scala 类和对象 （一）"></a>Scala 类和对象 （一）</h2><h3 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h3><p>首先介绍Scala的类定义，我们以一个简单的例子开始，创建一个计算整数累计校验和类 <strong><em>ChecksumAccumulator</em></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ChecksumAccumulator &#123;</span><br><span class="line">    private var sum&#x3D;0;</span><br><span class="line">    def add(b:Byte) :Unit &#x3D; sum+&#x3D;b</span><br><span class="line">    def Checksum() : Int &#x3D; ~ (sum &amp; 0xFF) + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Scala类定义和Java非常类似，也是以 <strong><em>class</em></strong> 开始，和Java 不同的，Scala的缺省修饰符为 <strong><em>public</em></strong>， 也就是如果不带有访问范围的修饰符 <strong><em>public、protected、private</em></strong>等，Scala将默认定义为 <strong><em>public</em></strong>。 类的方法以 <strong><em>def</em></strong>定义开始，要注意的是Scala的方法的参数都是 <strong><em>val</em></strong> 类型，而不是 <strong><em>var</em></strong> 类型， 因此在函数体内不可以修改参数的值，比如：如果你修改 <strong><em>add</em></strong> 方法如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add(b:Byte) :Unit &#x3D; &#123;</span><br><span class="line">    b&#x3D;1;</span><br><span class="line">    sum+&#x3D;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时编译器会报错：  </p><p>类的方法分两种，一种是有返回值的，一种是不包含返回值的，没有返回值的主要是利用代码的”副作用”,比如修改类的成员变量的值或者读写文件等。Scala内部其实将这种函数的返回值定位 <strong><em>Unit</em></strong>（类同Java的void类型），对于这种类型的方法，可以省略掉 <strong><em>=</em></strong> 号，因此如果你希望函数返回某个值，淡忘了方法定义中的 <strong><em>=</em></strong> ，Scala会忽略方法的返回值，而返回 <strong><em>Unit</em></strong>   </p><p>再强调一下，Scala 代码无需使用 ； 结尾，也不需要使用 return 返回值，函数的最后一行的值就作为函数的返回值   </p><p>但如果你需要在一行中书写多个语句，此时需要使用 ； 隔开，不过不建议这么做。你也可以把一条语句分成几行书写，Scala 编译器大部分情况下会推算出语句的结尾，不过这样也不是一个好的编码习惯。  </p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Scala 比 Java 更加面向对象，这是因为Scala不允许类保护静态元素（静态变量或者静态方法）。在Scala中提供类似功能的是称为“*<strong>Singleton***（单例对象）”的对象。在Scala中定义 *</strong>Singleton*** 对象的方法，除了使用 <strong><em>object</em></strong> 而非 <strong><em>class</em></strong> 关键字外，其他方式和类定义非常类似。下面例子创建一个 <strong><em>ChecksumAccumulator</em></strong> 对象：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object ChecksumAccumulator &#123;</span><br><span class="line">   private val cache &#x3D; Map [String, Int] ()</span><br><span class="line">   def calculate(s:String) : Int &#x3D;</span><br><span class="line">      if(cache.contains(s))</span><br><span class="line">         cache(s)</span><br><span class="line">      else &#123;</span><br><span class="line">         val acc&#x3D;new ChecksumAccumulator</span><br><span class="line">         for( c &lt;- s)</span><br><span class="line">            acc.add(c.toByte)</span><br><span class="line">         val cs&#x3D;acc.checksum()</span><br><span class="line">         cache +&#x3D; ( s -&gt; cs)</span><br><span class="line">         cs</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象和上一个创建的类 <strong><em>ChecksumAccumulator</em></strong> 同名， 这在Scala中把这个对象称为其同名的类的“伴侣”对象（Companion object)。如果你需要定义类的 <strong><em>companion</em></strong> 对象，Scala 要求你把这两个定义放在同一个文件中。类和其 companion 对象可以互相访问对方的私有成员。  </p><p>如果你是 Java 程序员，可以把 <strong><em>Singleton</em></strong> 对象看成以前 Java 定义静态成员的地方。你可以使用类似 Java 静态方法的方式调用 <strong><em>Singleton</em></strong> 对象的方法，比如下面为这个例子完整的代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import scala.collection.mutable.Map</span><br><span class="line"></span><br><span class="line">class ChecksumAccumulator&#123;</span><br><span class="line">   private var sum&#x3D;0</span><br><span class="line">   def add(b:Byte) :Unit &#x3D; sum +&#x3D;b</span><br><span class="line">   def checksum() : Int &#x3D; ~ (sum &amp; 0xFF) +1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object ChecksumAccumulator &#123;</span><br><span class="line">   private val cache &#x3D; Map [String, Int] ()</span><br><span class="line">   def calculate(s:String) : Int &#x3D;</span><br><span class="line">      if(cache.contains(s))</span><br><span class="line">         cache(s)</span><br><span class="line">      else &#123;</span><br><span class="line">         val acc&#x3D;new ChecksumAccumulator</span><br><span class="line">         for( c &lt;- s)</span><br><span class="line">            acc.add(c.toByte)</span><br><span class="line">         val cs&#x3D;acc.checksum()</span><br><span class="line">         cache +&#x3D; ( s -&gt; cs)</span><br><span class="line">         cs</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println ( ChecksumAccumulator.calculate(&quot;Welcome to Scala Chinese community&quot;))</span><br></pre></td></tr></table></figure><p>Scala 的 singleton 对象不仅仅局限于作为静态对象的容器，它在 Scala 中也是头等公民，但仅仅定义 Singleton 对象本身不会创建一个新的类型，你不可以使用 new 再创建一个新的 Singleton 对象（这也是 Singleton 名字的由来），此外和类定义不同的是，singleton 对象不可以带参数（类定义参数将在后面的内容中介绍）。  </p><p>回过头来看看我们的第一个例子“Hello World”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld &#123;</span><br><span class="line">    def main(args: Array[String])&#123;</span><br><span class="line">        println(&quot;Hello, world!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个最简单的 Scala 程序，*<strong>HelloWorld*** 是一个 *</strong>Singleton*** 对象，它包含一个 <strong><em>main</em></strong> 方法（ 可以支持命令行参数）。和Java类似，Scala中任何 <strong><em>Singleton</em></strong> 对象，如果包含 <strong><em>main</em></strong> 方法 ， 都可以作为应用的入口点。  </p><p>在这里要说明一点的是，在 Scala 中不要求 <strong><em>public</em></strong> 类定义和其文件名同名，不过使用 <strong><em>public</em></strong> 类和文件同名还是有它的有点的，你可以根据个人喜好决定是否遵循Java文件命名风格。  </p><p>最后提一下Scala的 <strong><em>Trait</em></strong> 功能， Scala的 <strong><em>Trait</em></strong> 和 Java 的 <strong><em>Interface</em></strong> 相比，可以有方法的实现（这点有点像抽象类，但如果是抽象类，就不会允许继承多个抽象类）。 Scala的 <strong><em>Trait</em></strong> 支持类和 <strong><em>Singleton</em></strong> 对象以及多个 <strong><em>Trait</em></strong> 混合 （使用来自这些 <strong><em>Trait</em></strong> 中的方法，而不是不违反单一继承的原则）。  </p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 基本数据类型</title>
      <link href="2020/01/09/scala-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2020-01-09/"/>
      <url>2020/01/09/scala-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2020-01-09/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-基本数据类型"><a href="#Scala-基本数据类型" class="headerlink" title="Scala 基本数据类型"></a>Scala 基本数据类型</h2><h3 id="基本数据类型简介"><a href="#基本数据类型简介" class="headerlink" title="基本数据类型简介"></a>基本数据类型简介</h3><p>如果你是个Java 程序员，你会发现 Java 支持的基本数据类型，Scala都有对应的支持，不过Scala的数据类型都是对象（比如整数），这些基本类型都可以通过隐式自动转换的形式支持比 Java 基本数据类型更多的方法。  </p><p>隐式自动转换的概念将在后面介绍，简单的说就是可以为基本类型提供扩展，比如如果调用 <strong><em>(-1).abs()</em></strong> , Scala 发现基本类型Int没有提供 <strong><em>abs()</em></strong> 方法，但可以发现系统提供了从 <strong><em>Int</em></strong> 类型转换为 <strong><em>RichInt</em></strong> 的隐式自动转换，而 <strong><em>RichInt</em></strong> 具有 <strong><em>abs()</em></strong> 方法, 那么Scala就自动将 <strong><em>1</em></strong> 转换为 <strong><em>RichInt</em></strong> 类型， 然后调用 <strong><em>RichInt</em></strong> 的 <strong><em>abs</em></strong> 方法。  </p><p>Scala 的基本数据类型有： <strong><em>Byte、Short、Int、Long</em></strong> 和 <strong><em>char</em></strong> （这些称为整数类型）。 整数类型加上 <strong><em>Float</em></strong> 和 <strong><em>Double</em></strong> 称为数值类型。 此外还有 <strong><em>String</em></strong> 类型，除 <strong><em>String</em></strong> 类型在 <strong><em>java.lang</em></strong> 包中定义，其他的类型都定义在包 scala 中。 比如 <strong><em>Int</em></strong> 的全名为 <strong><em>scala.Int</em></strong> 。实际上 Scala 运行环境自动会载入包 <strong><em>scala</em></strong> 和 <strong><em>java.lang</em></strong> 中定义的数据类型，你可以直接使用 <strong><em>Int、Short、String</em></strong> 而无需再引入包或是使用全称。  </p><p>下面的例子给出了这些基本数据类型的字面量用法，由于Scala支持数据类型推断，你在定义变量时多数可以不指明数据类型，而是由 Scala 运行环境自动给出变量的数据类型：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_171).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; var hex&#x3D;0x5</span><br><span class="line">hex: Int &#x3D; 5</span><br><span class="line"></span><br><span class="line">scala&gt; var hex2&#x3D;0x00ff</span><br><span class="line">hex2: Int &#x3D; 255</span><br><span class="line"></span><br><span class="line">scala&gt; val prog&#x3D;0xcafebabel</span><br><span class="line">prog: Long &#x3D; 3405691582</span><br><span class="line"></span><br><span class="line">scala&gt; val littler:Byte&#x3D; 38</span><br><span class="line">littler: Byte &#x3D; 38</span><br><span class="line"></span><br><span class="line">scala&gt; val big&#x3D;1.23232</span><br><span class="line">big: Double &#x3D; 1.23232</span><br><span class="line"></span><br><span class="line">scala&gt; val a&#x3D;&#39;A&#39;</span><br><span class="line">a: Char &#x3D; A</span><br><span class="line"></span><br><span class="line">scala&gt; val f &#x3D;&#39;\u0041&#39;</span><br><span class="line">f: Char &#x3D; A</span><br><span class="line"></span><br><span class="line">scala&gt; val hello&#x3D;&quot;hello&quot;</span><br><span class="line">hello: String &#x3D; hello</span><br><span class="line"></span><br><span class="line">scala&gt; val longString&#x3D;&quot;&quot;&quot; Welcome to Ultamix 3000. Type &quot;Help&quot; for help.&quot;&quot;&quot;</span><br><span class="line">longString: String &#x3D; &quot; Welcome to Ultamix 3000. Type &quot;Help&quot; for help.&quot;</span><br><span class="line"></span><br><span class="line">scala&gt; val bool&#x3D;true</span><br><span class="line">bool: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p>Scala 的基本数据类型的字面量也支持方法（这点和Java不同，Scala中所有的数值字面量也是对象）,比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (-2.7).abs</span><br><span class="line">res3: Double &#x3D; 2.7</span><br><span class="line"></span><br><span class="line">scala&gt; -2.7 abs</span><br><span class="line">warning: there were 1 feature warning(s); re-run with -feature for details</span><br><span class="line">res4: Double &#x3D; 2.7</span><br><span class="line"></span><br><span class="line">scala&gt; 0 max 5</span><br><span class="line">res5: Int &#x3D; 5</span><br><span class="line"></span><br><span class="line">scala&gt; 4 to 6</span><br><span class="line">res6: scala.collection.immutable.Range.Inclusive &#x3D; Range(4, 5, 6)</span><br></pre></td></tr></table></figure><p>这些方法其实是对于数据类型的 <strong><em>Rich</em></strong> 类型的方法，**<em>Rich**</em> 类型将在后面再做详细介绍  </p><h3 id="操作基本数据类型"><a href="#操作基本数据类型" class="headerlink" title="操作基本数据类型"></a>操作基本数据类型</h3><p>Scala 提供了 丰富的运算符用来操作前面介绍的基本数据类型。前面说过，这些运算符（操作符）实际为普通类方法的简化（或者称为美化）表示。比如 <strong><em>1+2</em></strong> ，实际为 <strong><em>(1).+(2)</em></strong> , 也就是调用 <strong><em>Int</em></strong> 类型的 <strong><em>+</em></strong> 方法  </p><p>例如 ：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val sumMore &#x3D; (1).+(2)</span><br><span class="line">sumMore: Int &#x3D; 3</span><br></pre></td></tr></table></figure><p>实际上类 <strong><em>Int</em></strong> 定义了多个 <strong><em>+</em></strong> 方法的重载方法(以支持不同的数据类型)，比如： 和 <strong><em>Long</em></strong> 类型相加。  </p><p><strong><em>+</em></strong> 符号是一个运算符，并且是一个中缀运算符。在 Scala中你可以定义任何方法为一操作符。比如 <strong><em>String</em></strong> 的 <strong><em>IndexOf</em></strong> 方法也可以使用操作符的语法来书写。 例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s &#x3D;&quot;Hello, World&quot;</span><br><span class="line">s: String &#x3D; Hello, World</span><br><span class="line"></span><br><span class="line">scala&gt; s indexOf &#39;o&#39;</span><br><span class="line">res0: Int &#x3D; 4</span><br></pre></td></tr></table></figure><p>由此可以看出，运算符在Scala 中并不是什么特殊的语法，任何Scala方法都可以作为操作符来使用。是否是操作符取决于你使用这个方法， 当你使用 <strong><em>s.indexOf(‘o’)</em></strong> 时， <strong><em>indexOf</em></strong> 不是一个运算符。而你写成 <strong><em>s indexOf ‘o’</em></strong> , <strong><em>indexOf</em></strong> 就是一个操作符，因为你使用了操作符的语法。  </p><p>除了类似 + 的中缀运算符（操作符在两个操作符之间），还可以有前缀运算符和后缀运算符。顾名思义，前缀运算符的操作符在操作数前面，比如 <strong><em>-7</em></strong> 前面的 <strong><em>-</em></strong> 。后缀运算符的运算符在操作数的后面，比如 <strong><em>7 toLong</em></strong> 中的 <strong><em>toLong</em></strong> 。 前缀和后缀操作符都使用一个操作数，而中缀运算符使用前后两个操作数。Scala 在实现前缀和后缀操作符的方法，其方法名都以 <strong><em>unary_-</em></strong> 开头。  </p><p>比如，表达式 <strong><em>-2.0</em></strong> 实际上调用 <strong><em>(2.0).unary_-</em></strong> 方法。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; -2.0</span><br><span class="line">res1: Double &#x3D; -2.0</span><br><span class="line"></span><br><span class="line">scala&gt; (2.0).unary_-</span><br><span class="line">res2: Double &#x3D; -2.0</span><br></pre></td></tr></table></figure><p>如果你需要定义前缀方法，你只能使用 <strong><em>+</em></strong>、*<strong>-**<em>、</em></strong>!<strong>* 和 *</strong>~***四个符号作为前缀操作符。  </p><p>后缀操作符在不使用 <strong><em>.</em></strong> 和括号调用时不带任何参数。在 Scala 中，你可以省略掉没有参数的方法调用的空括号。 按照惯例，如果你调用方法是为了利用方法的“副作用”， 此时写上空括号，如果方法没有任何副作用（没有修改其他程序状态），你可以省略掉括号。  </p><p>比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s &#x3D; &quot;Hello, World&quot;</span><br><span class="line">s: String &#x3D; Hello,World</span><br><span class="line"></span><br><span class="line">scala&gt; s toLowerCase</span><br><span class="line">warning: there was one feature warning; re-run with -feature for details</span><br><span class="line">res0: String &#x3D; hello,world </span><br></pre></td></tr></table></figure><p>具体 Scala 的基本数据类型支持的操作符，可以参考Scala API 文档。  </p><p>下面以示例介绍一些常用的操作符  </p><h4 id="算数运算符（包括-、-、x-和-）"><a href="#算数运算符（包括-、-、x-和-）" class="headerlink" title="算数运算符（包括+、-、x 和 /）"></a>算数运算符（包括+、-、x 和 /）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1.2 + 2.3</span><br><span class="line">res0: Double &#x3D; 3.5</span><br><span class="line"></span><br><span class="line">scala&gt; &#39;b&#39; -&#39;a&#39;</span><br><span class="line">res1: Int &#x3D; 1</span><br><span class="line"></span><br><span class="line">scala&gt; 11 % 4   #取余</span><br><span class="line">res2: Int &#x3D; 3</span><br><span class="line"></span><br><span class="line">scala&gt; 11.0f &#x2F; 4.0f</span><br><span class="line">res3: Float &#x3D; 2.75</span><br><span class="line"></span><br><span class="line">scala&gt; 2L * 3L</span><br><span class="line">res4: Long &#x3D; 6</span><br></pre></td></tr></table></figure><h4 id="关系和逻辑运算符（包括-gt-、-lt-、-gt-和-等）"><a href="#关系和逻辑运算符（包括-gt-、-lt-、-gt-和-等）" class="headerlink" title="关系和逻辑运算符（包括 &gt; 、&lt; 、&gt;= 和 ! 等）"></a>关系和逻辑运算符（包括 &gt; 、&lt; 、&gt;= 和 ! 等）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 &gt;2</span><br><span class="line">res5: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">scala&gt; 1.0 &lt;&#x3D; 1.0</span><br><span class="line">res6: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; val thisIsBoring &#x3D; !true</span><br><span class="line">thisIsBoring: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">scala&gt; !thisIsBoring</span><br><span class="line">res7: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; val toBe&#x3D;true</span><br><span class="line">toBe: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; val question &#x3D; toBe || ! toBe  #表示逻辑或</span><br><span class="line">question: Boolean &#x3D; true</span><br></pre></td></tr></table></figure><p>要注意的是，逻辑运算支持“短路运算”,比如 <strong><em>op1 || op2</em></strong> ,当 <strong><em>op1=true</em></strong>， <strong><em>op2</em></strong> 无需再计算，就可以知道结果为 <strong><em>true</em></strong>。 这时 <strong><em>op2</em></strong> 表达式不会执行。例如  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def salt()&#x3D; &#123; println(&quot;salt&quot;);false&#125;</span><br><span class="line">salt: ()Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; def pepper() &#x3D;&#123;println(&quot;pepper&quot;);true&#125;</span><br><span class="line">pepper: ()Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; pepper() &amp;&amp; salt()   #表示逻辑与</span><br><span class="line">pepper</span><br><span class="line">salt</span><br><span class="line">res0: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">scala&gt; salt() &amp;&amp; pepper()</span><br><span class="line">salt</span><br><span class="line">res1: Boolean &#x3D; false</span><br></pre></td></tr></table></figure><h4 id="位操作符（包括-amp-、-、-、-）"><a href="#位操作符（包括-amp-、-、-、-）" class="headerlink" title="位操作符（包括&amp;、|、^、~）"></a>位操作符（包括&amp;、|、^、~）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 &amp; 2</span><br><span class="line">res2: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">scala&gt; 1 | 2</span><br><span class="line">res3: Int &#x3D; 3</span><br><span class="line"></span><br><span class="line">scala&gt; 1 ^ 2</span><br><span class="line">res4: Int &#x3D; 3</span><br><span class="line"></span><br><span class="line">scala&gt; ~1</span><br><span class="line">res5: Int &#x3D; -2</span><br></pre></td></tr></table></figure><h4 id="对象恒等比较"><a href="#对象恒等比较" class="headerlink" title="对象恒等比较"></a>对象恒等比较</h4><p>如果需要比较两个对象是否相等，可以使用 <strong><em>==</em></strong> 和 <strong><em>!=</em></strong> 操作符  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1 &#x3D;&#x3D; 2</span><br><span class="line">res6: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">scala&gt; 1 !&#x3D;2</span><br><span class="line">res7: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; List(1,2,3) &#x3D;&#x3D; List (1,2,3)</span><br><span class="line">res8: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; (&quot;he&quot;+&quot;llo&quot;) &#x3D;&#x3D; &quot;hello&quot;</span><br><span class="line">res9: Boolean &#x3D; true</span><br></pre></td></tr></table></figure><p>Scala 的 <strong><em>==</em></strong> 和 Java不同，Scala的 <strong><em>==</em></strong> 只用于比较两个对象的值是否相同。而对于引用类型的比较使用另外的操作符 <strong><em>eq</em></strong> 和 <strong><em>ne</em></strong></p><h4 id="操作符的优先级和左右结合性"><a href="#操作符的优先级和左右结合性" class="headerlink" title="操作符的优先级和左右结合性"></a>操作符的优先级和左右结合性</h4><p>Scala 的 操作符的优先级和 Java基本相同，如果有困惑时，可以使用 <strong><em>()</em></strong> 改变操作符的优先级。操作符一般为左结合，Scala规定了操作符的结合性由操作符的最后一个字符定义。对于以 <strong><em>:</em></strong> 结尾的操作符都是右结合，其他的操作符多是左结合。  </p><p>例如： <strong><em>a\</em>b*</strong> 为 <strong><em>a.\</em>(b)*</strong>,而 <strong><em>a:::b</em></strong> 为 <strong><em>b.:::(a)</em></strong>， 而 <strong><em>a:::b:::c</em></strong> 等价于 <strong><em>a:::(b:::c)</em></strong> , <strong><em>a\</em>b*c*</strong> 等价于 <strong><em>(a\</em>b)*c*</strong>  </p><h3 id="基本数据类型的实现方法"><a href="#基本数据类型的实现方法" class="headerlink" title="基本数据类型的实现方法"></a>基本数据类型的实现方法</h3><blockquote><p>当前内容可能需要部分后面章节的知识作为基础。若理解有困难，可以尝试学习后续课程后在返回查看  </p></blockquote><p>Scala 的基本数据类型是如何实现的呢？实际上，Scala 以和 Java 同样的方式存储整数：把它当作 32 位的字类型。这对于有效使用 JVM 平台和与 Java 库的互操作性方面来说都很重要。  </p><p>标准的操作，如加法或乘法，都被实现为数据类型基本运算操作。然而，当整数需要被当作（Java）对象看待的时候， Scala 使用了“备份”类 <strong><em>java.lang.Integer</em></strong> 。如在整数上调用 <strong><em>toString</em></strong> 方法或者把整数赋值给 <strong><em>Any</em></strong> 类型的变量时，就会这么做。当需要的时候， Int 类型的整数能自动转换为 <strong><em>java.lang.Integer</em></strong> 类型的“装箱整数( boxed integer )”。</p><p>这些听上去和 Java 的 <strong><em>box</em></strong> 操作很像，实际上它们也很像，但这里有一个重要的差异，Scala 使用 <strong><em>box</em></strong> 操作比在 Java 中要少的多：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java 代码</span><br><span class="line">boolean isEqual(int x, int y) &#123;</span><br><span class="line">    return x &#x3D;&#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(isEqual(421,421));</span><br></pre></td></tr></table></figure><p>你当然会得到 <strong><em>true</em></strong> 。 现在， 把isEqual 的参数类型变为 <strong><em>java.lang.Integer</em></strong> （或 <strong><em>Object</em></strong> , 结果都一样）:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java代码 </span><br><span class="line">boolean isEqual(Integer x, Integer y) &#123; </span><br><span class="line">  return x &#x3D;&#x3D; y; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(isEqual(421,421));</span><br></pre></td></tr></table></figure><p>你会发现你得到了 false 的原因是，数 421 使用 box 操作了两次，因此参数 x 和 y 是两个不同的对象。因为在引用类型上，== 表示引用相等，而 Integer 是引用类型，所以结果是 false 。这是展示了 Java 不是纯面向对象语言的一个方面。我们能清楚观察到基本数据值类型和引用类型之间的差别。  </p><p>现在在 Scala 里尝试同样的实验：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def isEqual(x:Int,y:Int) &#x3D; x &#x3D;&#x3D; y</span><br><span class="line">isEqual: (x: Int, y: Int)Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; isEqual(421,421)</span><br><span class="line">res0: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; def isEqual(x:Any,y:Any) &#x3D; x &#x3D;&#x3D; y</span><br><span class="line">isEqual: (x: Any, y: Any)Boolean</span><br><span class="line"></span><br><span class="line">scala&gt; isEqual(421,421)</span><br><span class="line">res1: Boolean &#x3D; true</span><br></pre></td></tr></table></figure><p>Scala 的 == 设计出自动适应变量类型的操作，对值类型来说，就是自然的（数学或布尔）相等。对于引用类型，== 被视为继承自 Object 的 equals 方法的别名。比如对于字符串比较：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x &#x3D; &quot;abcd&quot;.substring(2)</span><br><span class="line">x: String &#x3D; cd</span><br><span class="line"></span><br><span class="line">scala&gt; val y &#x3D; &quot;abcd&quot;.substring(2)</span><br><span class="line">y: String &#x3D; cd</span><br><span class="line"></span><br><span class="line">scala&gt; x&#x3D;&#x3D;y</span><br><span class="line">res0: Boolean &#x3D; true</span><br></pre></td></tr></table></figure><p>而在 Java 里，x 与 y 的比较结果将是 false。程序员在这种情况应该用 equals，不过它容易被忘记。  </p><p>然而，有些情况下，你可能需要使用引用相等代替用户定义的相等。例如，某些时候效率是首要因素，你想要把某些类进行哈希合并（ hash cons ），然后通过引用相等比较它们的实例。为了满足这种情况，类 AnyRef 定义了附加的 eq 方法，它不能被重载并且实现为引用相等（也就是说，它表现得就像Java里对于引用类型的 == 那样）。同样也有一个 eq 的反义词，被称为 ne 。例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val x &#x3D;new String(&quot;abc&quot;)</span><br><span class="line">x: String &#x3D; abc</span><br><span class="line"></span><br><span class="line">scala&gt; val y &#x3D; new String(&quot;abc&quot;)</span><br><span class="line">y: String &#x3D; abc</span><br><span class="line"></span><br><span class="line">scala&gt; x &#x3D;&#x3D; y</span><br><span class="line">res0: Boolean &#x3D; true</span><br><span class="line"></span><br><span class="line">scala&gt; x eq y</span><br><span class="line">res1: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">scala&gt; x ne y</span><br><span class="line">res2: Boolean &#x3D; true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习Scala</title>
      <link href="2020/01/09/scala-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Scala-2020-01-09/"/>
      <url>2020/01/09/scala-%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0Scala-2020-01-09/</url>
      
        <content type="html"><![CDATA[<h2 id="开始学习Scala"><a href="#开始学习Scala" class="headerlink" title="开始学习Scala"></a>开始学习Scala</h2><blockquote><p>老规矩，请您先自行安装 Scala</p></blockquote><p>开始使用 Scala 的最简单的方式是使用交互式 Scala 解释器，只要输入 Scala 表达式， Scala 解释器会立即解释执行该语句并输出结果。当然你也可以使用如 Scala IDE 或 IntelliJ IDEA 集成开发环境。不过本教程开始还是以这种交互式 Scala 解释器为主。  </p><p>开始使用 Scala 的最简单的方式是使用交互式 Scala 解释器，只要输入 Scala 表达式， Scala 解释器会立即解释执行该语句并输出结果。当然你也可以使用如 Scala IDE 或 IntelliJ IDEA 集成开发环境。不过本教程开始还是以这种交互式 Scala 解释器为主。  </p><p>你可以使用 <strong><em>:help</em></strong> 命令列出一些常用的 Scala 解释器命令  </p><p>退出Scala解释器，输入:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure><h3 id="使用表达式"><a href="#使用表达式" class="headerlink" title="使用表达式"></a>使用表达式</h3><p>在 <strong><em>scala &gt;</em></strong> 提示符下，你可以输入任意的Scala表达式，比如输入 <strong><em>1+2</em></strong> ,解释器显示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+2</span><br></pre></td></tr></table></figure><p>输入上面的表达式 结果显示包括：</p><ul><li>一个由Scala解释器自动生成的变量名或者由你指定的变量名用来指向计算出来的结果（比如 <strong><em>res0</em></strong> 代表 <strong><em>result0</em></strong> 变量）</li><li>一个冒号，后来紧跟个变量类型比如 <strong><em>Int</em></strong>  </li><li>一个等于号 <strong><em>=</em></strong></li><li>计算结果，本例为 <strong><em>1+2</em></strong>的结果 <strong><em>3</em></strong>  </li></ul><p><strong><em>resX</em></strong> 变量名会用在之后得到表达式中, 比如: 此时 <strong><em>res0=3</em></strong>, 如果输入 <strong>*res0 <em>3**</em>, 则显示 *</strong>res1: Int =9*** 。  </p><h3 id="定义一些变量"><a href="#定义一些变量" class="headerlink" title="定义一些变量"></a>定义一些变量</h3><p>Scala 定义了两种类型的变量 <strong><em>val</em></strong> 和 <strong><em>var</em></strong>, <strong><em>val</em></strong> 类似于Java中的 <strong><em>final</em></strong> 变量，一旦初始化之后，不可以重新复制（我们可以称它为 <strong><em>常变量</em></strong>）.而 <strong><em>var</em></strong> 类似于一般的非 <strong><em>final</em></strong> 变量。 可以任意重新赋值。  </p><p>比如定义一个字符串常变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val msg &#x3D; &quot;Hello,World&quot;</span><br><span class="line">msg：String &#x3D; Hello,World</span><br></pre></td></tr></table></figure><p>这个表达式定义了一个msg变量，为字符串常量。它的类型为 <strong><em>string</em></strong>(<strong><em>java.lang.string</em></strong>). 可以看到我们在定义这个变量是并不需要像Java一样定义其类型，Scala可以根据赋值的内容推算出变量的类型。这在Scala语言中称为”type inference”(类型推断)。 当然如果你愿意，你也可以采用和Java一样的方法，明确指定变量的类型，如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val msg2:String &#x3D;&quot;Hello again,world&quot;</span><br><span class="line">msg2: String &#x3D; Hello again,world</span><br></pre></td></tr></table></figure><p>不过这样写就显得不像 Scala 风格了。此外 Scala 语句也不需要以分号结尾。 如果在命令行中需要分多行输入， Scala 解释器在新行前面显示 |，表示该行接着上一行。比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val msg3&#x3D;</span><br><span class="line">     | &quot;Hello world 3rd time&quot;</span><br><span class="line">msg3: String &#x3D; Hello world 3rd time</span><br></pre></td></tr></table></figure><h3 id="定义一些函数"><a href="#定义一些函数" class="headerlink" title="定义一些函数"></a>定义一些函数</h3><p>Scala 既是面向对象的编程语言，也是面向函数的编程语言，因此函数在 Scala 语言中的地位和类是同等的。下面的代码定义了一个简单的函数求两个值的最大值：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def max(x:Int,y:Int) : Int &#x3D;&#123;</span><br><span class="line">     | if (x &gt;y) x</span><br><span class="line">     | else</span><br><span class="line">     | y</span><br><span class="line">     | &#125;</span><br><span class="line">max: (x: Int, y: Int)Int</span><br></pre></td></tr></table></figure><p>Scala 函数以 def 定义，之后是函数的名称（如 max )，然后是以逗号分隔的参数。Scala 中变量类型是放在参数和变量的后面，以 ： 隔开。这样做的一个好处是便于“ type inference ”。刚开始有些不习惯（如果你是 Pascal 程序员可能会觉得很亲切）。同样如果函数需要返回值，它的类型也是定义在参数的后面（实际上每个Scala函数都有返回值，只是有些返回值类型为 Unit ，类似于 void 类型）。  </p><p>此外每个 Scala 表达式都有返回结果（这一点和 Java，C# 等语言不同），比如 Scala 的 if else 语句也是有返回值的，因此函数返回结果无需使用 return 语句。实际上在Scala代码中应当尽量避免使用 return 语句。函数的最后一个表达式的值就可以作为函数的结果进行返回。  </p><p>同样由于 Scala 的“ type inference ”特点，本例其实无需指定返回值的类型。对于大多数函数 Scala 都可以推测出函数返回值的类型，但目前来说回溯函数（函数调用自身）还是需要指明返回结果类型的。  </p><p>下面再定义个“没有”返回结果的函数（其它语言可能称这种无返回值的函数为程式）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def greet() &#x3D; println(&quot;hello,world&quot;)</span><br><span class="line">greet: ()Unit</span><br></pre></td></tr></table></figure><p>greet 函数的返回值类型为 Unit ，表示该函数不返回任何有意义的值，Unit 类似于 Java 中的 void 类型。这种类型的函数主要用来获得函数的“副作用”，比如本函数的副作用是打印招呼语。  </p><h3 id="使用while-实现循环"><a href="#使用while-实现循环" class="headerlink" title="使用while 实现循环"></a>使用while 实现循环</h3><p>下面的代码使用 <strong><em>while</em></strong> 实现一个循环：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val args &#x3D; Array(&quot;I&quot;,&quot;like&quot;,&quot;scala&quot;)</span><br><span class="line">var i&#x3D;0</span><br><span class="line">while (i &lt; args.length) &#123;</span><br><span class="line">  println (args(i))</span><br><span class="line">  i+&#x3D;1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是Scala不支持++i和i++的运算符，因此需要使用 <strong><em>i += 1</em></strong> 来加一。这段代码看起来和Java代码差不多，实际上 <strong><em>while</em></strong> 也是一个函数，你自然可以利用Scala语言的扩展性，实现while语句，使它看起来和Scala语言自带的关键字一样调用。   </p><p>Scala 访问数组的语法是使用 <strong><em>()</em></strong> 来实现循环，但这种实现循环的方法并不是最好的 Scala 风格，在下一步介绍使用一种更好的方法来避免通过索引来枚举数组元素。  </p><h3 id="使用-foreach-和-for-来实现迭代"><a href="#使用-foreach-和-for-来实现迭代" class="headerlink" title="使用 foreach 和 for 来实现迭代"></a>使用 foreach 和 for 来实现迭代</h3><p>在实验3.4中使用 <strong><em>while</em></strong> 来实现循环， 和使用Java实现无太大差异，而 Scala 是面向函数的语言，更好的方法时采用”函数式” 风格来编写代码。比如上面的循环，使用foreach方法如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args.foreach(arg &#x3D;&gt; println(arg))</span><br></pre></td></tr></table></figure><p>该表达式，调用 <strong><em>args</em></strong> 的 <strong><em>foreach</em></strong> 方法，传入一个参数，这个参数类型也是一个函数( <strong><em>lambad</em></strong> 表达式，和C#中的概念类似)。这段代码可以再写的精简些，你可以利用Scala支持的缩写形式，如果一个函数只有一个参数并且只包含一个表达式，那么你无需明确指明参数。因此上面的代码可以写成：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args.foreach(println)</span><br></pre></td></tr></table></figure><p>Scala 中也提供了一个称为” for comprehension” 的功能，它比Java中的 <strong><em>for</em></strong> 功能更强大。 “for comprehension” (可称之为 for 表达式) 将在后面介绍，这里先试用 for 来实现前面的例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(arg &lt;-args)</span><br><span class="line">    println(arg)</span><br></pre></td></tr></table></figure><h3 id="使用类型参数化数组"><a href="#使用类型参数化数组" class="headerlink" title="使用类型参数化数组"></a>使用类型参数化数组</h3><p>在Scala 中，你可以使用new 来实例化一个类。当你创建一个对象的实例时，你可以使用数值或类型参数。如果使用类型参数，它的作用类似Java或 .net 的 <strong><em>Generic</em></strong> 类型。所不同的是，Scala使用方括号来指明数据类型参数，而非尖括号。比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val greetStrings &#x3D; new Array[String](3);</span><br><span class="line">greetStrings(0) &#x3D; &quot;hello&quot;</span><br><span class="line">greetStrings(1) &#x3D; &quot;,&quot;</span><br><span class="line">greetStrings(2) &#x3D; &quot;world!\n&quot;</span><br><span class="line">for(i &lt;- 0 to 2)</span><br><span class="line">    print(greetStrings(i))</span><br></pre></td></tr></table></figure><p>可以看到 Scala 使用 [] 来为数组指明类型化参数，本例使用 String 类型，数组使用 () 而非 [] 来指明数组的索引。其中的 for 表达式中使用到 0 to 2 ，这个表达式演示了 Scala 的一个基本规则，如果一个方法只有一个参数，你可以不用括号和 . 来调用这个方法。  </p><p>因此这里的 0 to 2， 其实为 (0).to(2) 调用的为整数类型的 to 方法，to 方法使用一个参数。Scala 中所有的基本数据类型也是对象（和 Java 不同），因此 0 可以有方法（实际上调用的是 RichInt 的方法），这种只有一个参数的方法可以使用操作符的写法（不用 . 和括号），实际上 Scala 中表达式 1+2 ，最终解释为 (1).+(2)+，这也是 Int 的一个方法，和 Java 不同的是，Scala 对方法的名称没有太多的限制，你可以使用符号作为方法的名称。  </p><p>这里也说明为什么 Scala 中使用 () 来访问数组元素，在 Scala 中，数组和其它普遍的类定义一样，没有什么特别之处，当你在某个值后面使用 () 时，Scala 将其翻译成对应对象的 apply 方法。因此本例中 greetStrings(1) 其实是调用 greetString.apply(1) 方法。这种表达方法不仅仅只限于数组，对于任何对象，如果在其后面使用 () ，都将调用该对象的 apply 方法。同样的如果对某个使用 () 的对象赋值，比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greetStrings(0) &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure><p>Scala 将这种赋值转换为该对象的 update 方法， 也就是 greetStrings.update(0,”hello”) 。因此上面的例子，使用传统的方法调用可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val greetStrings &#x3D;new Array[String](3)</span><br><span class="line">greetStrings.update(0,&quot;Hello&quot;)</span><br><span class="line">greetStrings.update(1,&quot;,&quot;)</span><br><span class="line">greetStrings.update(2,&quot;world!\n&quot;)</span><br><span class="line">for(i &lt;- 0 to 2)</span><br><span class="line">  print(greetStrings.apply(i))</span><br></pre></td></tr></table></figure><p>从这点来说，数组在 Scala 中并不是某种特殊的数据类型，和普通的类没有什么不同。  </p><p>不过 Scala 还是提供了初始化数组的简单方法，比如上面的例子数组可以使用如下代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val greetStrings &#x3D;Array(&quot;Hello&quot;,&quot;,&quot;,&quot;World\n&quot;)</span><br></pre></td></tr></table></figure><p>这里使用 () 其实还是调用 Array 类的关联对象 Array 的 apply 方法，也就是：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val greetStrings &#x3D;Array.apply(&quot;Hello&quot;,&quot;,&quot;,&quot;World\n&quot;)</span><br></pre></td></tr></table></figure><h3 id="使用Lists"><a href="#使用Lists" class="headerlink" title="使用Lists"></a>使用Lists</h3><p>Scala 也是一个面向函数的编程语言，面向函数的编程语言的一个特点是，调用某个方法不应该有任何副作用，参数一定，调用该方法后，返回一定的结果，而不会去修改程序的其他状态（副作用）。这样做的一个好处是方法和方法之间关联性较小，从而方法变得更加可靠和重用性高。使用这个原则也就意味着需要把变量设为不可修改的，这也就避免访问的互锁问题。  </p><p>前面介绍的数组，它的元素是可以被修改的。如果需要使用不可以修改的序列，Scala中提供了 <strong><em>Lists</em></strong> 类。和Java的 <strong><em>List</em></strong> 不同，Scala的 <strong><em>Lists</em></strong> 对象是不可修改的。它被设计用来满足函数编程风格的代码。它有点像Java 的 <strong><em>String</em></strong>，*<strong>String*** 也是不可以修改的，如果需要可以修改的 *</strong>String*** 对象，可以使用 <strong><em>StringBUlider</em></strong> 类  </p><p>比如下面的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val oneTwo &#x3D; List(1,2)</span><br><span class="line">val threeFour &#x3D; List(3,4)</span><br><span class="line">val oneTwoThreeFour &#x3D; oneTwo ::: threeFour</span><br><span class="line">println (oneTwo + &quot; and &quot; + threeFour + &quot; were not mutated. &quot;)</span><br><span class="line">println (&quot;Thus,&quot; + oneTwoThreeFour + &quot; is a new list&quot;)</span><br></pre></td></tr></table></figure><p>定义了两个 <strong><em>List</em></strong> 对象 <strong><em>oneTwo</em></strong> 和 <strong><em>threeFour</em></strong>，然后通过 <strong><em>:::</em></strong> 操作符 （其实为 <strong><em>:::</em></strong> 方法） 将两个列表连接起来。实际上由于 <strong><em>List</em></strong> 的不可修改特性，Scala创建了一个新的 <strong><em>List</em></strong> 对象 <strong><em>oneTwoThreeFour</em></strong> 来保存两个列表连接后的值。  </p><p><strong><em>List</em></strong> 也提供了一个 <strong><em>::</em></strong> 方法用来像 <strong><em>list</em></strong> 中添加一个元素， <strong><em>::</em></strong> 方法（操作符）是右操作符，也就是使用 <strong><em>::</em></strong> 右边的对象来调用它的 <strong><em>::</em></strong> 方法，Scala 中的规定所有以 <strong><em>:</em></strong> 开头的操作符都是右操作符，因此如果你自己定义以 <strong><em>:</em></strong> 开头的方法（操作符）也是右操作符。   </p><p>如下面使用常量创建一个列表：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val oneTwoThree &#x3D; 1 :: 2 :: 3 :: Nil</span><br><span class="line">println(oneTwoThree)</span><br></pre></td></tr></table></figure><p>调用空列表兑现 <strong><em>Nil</em></strong> 的 <strong><em>::</em></strong> 方法也就是：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val oneTwoThree &#x3D; Nil.::(3).::(2).::(1)</span><br></pre></td></tr></table></figure><p>Scala 的 <strong><em>List</em></strong> 类还定义了其他很多很有用的方法，比如 <strong><em>head</em></strong>、*<strong>last**<em>、</em></strong>length*<strong>、**<em>reverse</em></strong>、*<strong>tail***等。这里就不一一说明了，具体可以参考 *</strong>List*** 文档。  </p><h3 id="使用元组-Tuples"><a href="#使用元组-Tuples" class="headerlink" title="使用元组(Tuples)"></a>使用元组(Tuples)</h3><p>Scala 中另外一个很有用的容器类为 <strong><em>Tuples</em></strong> ，和 <strong><em>List</em></strong> 不同的是， <strong><em>Tuples</em></strong> 可以包含不同类型的数据，而 <strong><em>List</em></strong> 只能包含同类型的数据， <strong><em>Tuples</em></strong> 在方法需要返回多个结果时非常有用。（ <strong><em>Tuple</em></strong> 对应到数字的 <strong><em>矢量</em></strong> 的概念）。  </p><p>一旦定义了一个元组，可以使用 <strong><em>._</em></strong> 和 <strong><em>索引</em></strong> 来访问元组的元素（矢量的分量，主义和数组不听的是，元组的索引从1开始）。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val pair &#x3D; (99,&quot;Luftballons&quot;)</span><br><span class="line">println(pair._1)</span><br><span class="line">println(pair._2)</span><br></pre></td></tr></table></figure><p>元组的实际类型取决于它的分量的类型，比如上面的 <strong><em>pair</em></strong> 的类型实际为 <strong><em>Tuple2[Int,String]</em></strong> , 而 <strong><em>(‘u’,’r’,’the’,1,4,’me’)</em></strong> 的类型为 <strong><em>Tuple6[Char,Char,String,Int,Int,String]</em></strong>   </p><p>目前Scala支持的元组的最大长度为22。如果有需要，你可以自己扩展更长的元组  </p><h3 id="使用Sets-和-Maps"><a href="#使用Sets-和-Maps" class="headerlink" title="使用Sets 和 Maps"></a>使用Sets 和 Maps</h3><p>Scala Set(集合)是没有重复对象的集合，所有的元素都是唯一的。  </p><p>Scala 语言的一个设计目标是让程序员可以同时利用面向对象和面向函数的方法编写代码，因此它提供的集合类分成了可以修改的集合类和不可以修改的集合类两大类型。比如 <strong><em>Array</em></strong> 总是可以修改内容的，而 <strong><em>List</em></strong> 总是不可以修改内容的。类似的情况，*<strong>Scala*** 也提供了两种 *</strong>Sets*** 和 <strong><em>Maps</em></strong> 集合类。  </p><p>比如 Scala API 定义了 <strong><em>set</em></strong> 的 <strong><em>基Trait</em></strong> 类型 <strong><em>Set</em></strong> ( <strong><em>Trait</em></strong> 的概念类似于Java中的 <strong><em>Interface</em></strong> ), 所不同的是Scala中的 <strong><em>Trait</em></strong> 可以有方法的实现，分两个包定义 <strong><em>Mutable</em></strong> (可变) 和 <strong><em>Immutable</em></strong> (不可变)， 使用同样名称的子 <strong><em>Trait</em></strong>。   </p><p>使用 <strong><em>Set</em></strong> 的基本方法如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jetSet &#x3D; Set(&quot;Boeing&quot;,&quot;Airbus&quot;)</span><br><span class="line">jetSet +&#x3D; &quot;Lear&quot;</span><br><span class="line">println(jetSet.contains(&quot;Cessna&quot;))</span><br></pre></td></tr></table></figure><p>缺省情况 <strong><em>Set</em></strong> 为 <strong><em>Immutable Set</em></strong>, 如果你需要使用可修改的集合类（*<strong>Set*** 类型）,你可以使用全路径来指明 *</strong>Set*** 比如 <strong><em>scala.collection.mutable.Set</em></strong>。  </p><p>Scala 提供的另一个类型为 <strong><em>Map</em></strong> 类型，Map(映射)是一种可迭代的key/value结构，所有的值都可以通过键来获取。Scala也提供了 <strong><em>Mutable</em></strong> 和 <strong><em>Immutable</em></strong> 两种Map类型。  </p><p>Map的基本用法如下（Map类似其他语言中的关联数组，如PHP）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val romanNumeral &#x3D; Map( 1 -&gt; &quot;I&quot;, 2 -&gt; &quot;II&quot;, 3 -&gt; &quot;III&quot;, 4 -&gt; &quot;IV&quot;, 5 -&gt; &quot;V&quot;)</span><br><span class="line">println(romanNumeral(4))</span><br></pre></td></tr></table></figure><h3 id="学习识别函数编程风格"><a href="#学习识别函数编程风格" class="headerlink" title="学习识别函数编程风格"></a>学习识别函数编程风格</h3><p>Scala语言的一个特点是支持面向函数编程，因此学习Scala的一个重要方面是改变之前的指令时编程思想（尤其是来自Java或C#背景的程序员），观念要向函数式编程转变。首先在看代码上要认识哪种是指令编程，哪种是函数式编程，实现这种思想上的转变，不仅仅会使你成为一个更好的Scala程序员，同时也会扩展你的视野，使你成为一个更好的程序员。  </p><p>一个简单的原则，如果代码中含有 <strong><em>var</em></strong> 类型的变量，这段代码就是传统的指令式编程，如果代码只有 <strong><em>val</em></strong> 变量，这段代码就很有可能是函数式代码，因此学会函数式编程关键是不适用 <strong><em>vars</em></strong> 来编写代码。  </p><p>来看一看简单的例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def printArgs ( args: Array[String]) : Unit &#x3D; &#123;</span><br><span class="line">    var i&#x3D;0;</span><br><span class="line">    while(i &lt; args.length)&#123;</span><br><span class="line">        println (args(i));</span><br><span class="line">        i+&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来自Java 背景的程序员开始写Scala代码很有可能写成上面的实现。我们试着去除vars变量，可以写成更符合函数式编程的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def printArgs(args: Array[String]) : Unit &#x3D; &#123;</span><br><span class="line">    for(arg &lt;- args)</span><br><span class="line">        println(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者更简化为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def printArgs (args:Array[String]) : Unit &#x3D; &#123;</span><br><span class="line">    args.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子也说明了尽量少用 <strong><em>vars</em></strong> 的好处，代码更简洁明了，从而也可以减少错误的发生。因此Scala编程的一个基本原则是，能不用 <strong><em>vars</em></strong> ，尽量不用 <strong><em>vars</em></strong>， 能不用 <strong><em>mutable</em></strong>变量，尽量不用 <strong><em>mutable</em></strong> 变量，能避免函数的副作用，就尽量不产生副作用。  </p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>使用脚本实现某个人物，通常需要读取文件，本节介绍Scala读写文件的基本方法。比如下面的例子读取文件的每行，把该行字符长度添加到行首：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import scala.io.Source</span><br><span class="line"></span><br><span class="line">var args&#x3D;Source.fromFile(&quot;&#x2F;home&#x2F;hadoop&#x2F;test.text&quot;) # 记得在对应位置创建文件，并写入内容</span><br><span class="line"></span><br><span class="line">for( line &lt;- args.getLines)</span><br><span class="line">    println(line.length + &quot;&quot; + line)</span><br></pre></td></tr></table></figure><p>可以看到Scala引入包的方式和Java类似，也是通过 <strong><em>import</em></strong> 语句。文件相关的类定义在 <strong><em>scala.io</em></strong> 包中。如果需要引入多个类，Scala 使用 <strong><em>_</em></strong>而非 <strong><em>*</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 控制语句</title>
      <link href="2020/01/09/scala-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-2020-01-10/"/>
      <url>2020/01/09/scala-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-2020-01-10/</url>
      
        <content type="html"><![CDATA[<h2 id="Scala-控制语句"><a href="#Scala-控制语句" class="headerlink" title="Scala 控制语句"></a>Scala 控制语句</h2><p>Scala 的所有控制结构都有返回结果，如果你使用过 Java 或 C#， 就可能了解 Java 提供的三元运算符 <strong><em>?:</em></strong> ,它的基本功能和 <strong><em>if</em></strong> 一样，都可以返回结果。 Scala在此基础上所有控制结构（ <strong><em>while</em></strong>、*<strong>try**<em>、</em></strong>if***等） 都可以返回结果。这样做的一个好处是，可以简化代码，如果没有这种特点，程序员常常需要创建一个临时变量用来保存结果  </p><p>总的来说，Scala提供的基本程序控制结构，”麻雀虽小，五脏俱全”,虽然少，但足够满足其他指令式语言（如 Java，C++）所支持的程序控制功能。而且，由于这些指令都有返回结果，可以使得代码更为精简。  </p><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><p>Scala 语言的 <strong><em>if</em></strong> 的基本功能和其他语言没有什么不同，它根据条件执行两个不同的分支。比如，使用Java风格编写下面Scala的if语句的一个例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var age &#x3D; 25</span><br><span class="line">var result &#x3D; &quot;&quot;</span><br><span class="line">if (age &gt; 20)</span><br><span class="line">&#123;</span><br><span class="line">    result &#x3D; &quot;worker&quot;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    result &#x3D; &quot;Student&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>上面代码和使用 Java实现没有太多区别，看起来不怎么像 Scala 风格，我们重新改写一下，利用 <strong><em>if</em></strong> 可以返回结果这个特点。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var age&#x3D;25</span><br><span class="line">val result &#x3D; if (age &gt; 20) &quot;Worker&quot; else &quot;Student&quot;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>首先这种代码比前段代码短，更重要的是这段代码使用 val 而无需使用 <strong><em>var</em></strong> 类型的变量。 使用 <strong><em>val</em></strong> 为函数式编程风格  </p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>Scala 的 <strong><em>while</em></strong> 循环和 其他语言（如 Java）功能一样，它含有一个条件和循环体。只要条件满足，就一直执行循环体的代码。 比如，下面的计算最大公约数的一个实现  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def gcdLoop (x: Long, y:Long) : Long &#x3D;&#123;</span><br><span class="line">   var a&#x3D;x</span><br><span class="line">   var b&#x3D;y</span><br><span class="line">   while( a!&#x3D;0) &#123;</span><br><span class="line">      var temp&#x3D;a</span><br><span class="line">      a&#x3D;b % a</span><br><span class="line">      b &#x3D; temp</span><br><span class="line">  &#125;</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala 也有 <strong><em>do-while</em></strong> 循环，它和 <strong><em>while</em></strong> 循环类似，只是检查条件是否满足实在循环体执行之后检查。  </p><p>例如 ：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var line&#x3D;&quot;&quot;</span><br><span class="line">do &#123;</span><br><span class="line">   line &#x3D; readLine()</span><br><span class="line">   println(&quot;Read: &quot; + line)</span><br><span class="line">&#125; while (line !&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure><p>Scala 的 <strong><em>while</em></strong> 和 <strong><em>do-while</em></strong> 称为“循环”而不是表达式，是因为它不产生有用的返回值（或是返回值为 <strong><em>Unit</em></strong>），可以写成 <strong><em>()</em></strong> 。*<strong>()*** 的存在使得Scala的 *</strong>Unit*** 和 Java 的 <strong><em>void</em></strong> 类型有所不同。   </p><p>比如，下面的语句在 Scala 的解释器中执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def greet() &#123; println(&quot;hi&quot;)&#125;</span><br><span class="line">greet: ()Unit</span><br><span class="line"></span><br><span class="line">scala&gt; greet() &#x3D;&#x3D; ()</span><br><span class="line">&lt;console&gt;:9: warning: comparing values of types Unit and Unit using &#96;&#x3D;&#x3D;&#39; will always yield true</span><br><span class="line">              greet() &#x3D;&#x3D; ()</span><br><span class="line">                      ^</span><br><span class="line">hi</span><br><span class="line">res0: Boolean &#x3D; true</span><br></pre></td></tr></table></figure><p>可以看到（或者看到警告） <strong><em>greet()</em></strong> 的返回值 和 <strong><em>()</em></strong> 比较结果为 <strong><em>true</em></strong>  </p><p>注意另外一种可以返回 <strong><em>Unit</em></strong> 结果的语句为 <strong><em>var</em></strong> 类型赋值语句。如果你使用如下 Java 风格的语句将碰到麻烦：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while((line&#x3D;readLine())!&#x3D;&quot;&quot;)</span><br><span class="line">  println(&quot;Read: &quot; + line)</span><br></pre></td></tr></table></figure><p>上述代码当你运行的时候，会出现 错误  </p><p>错误的代码意思是 <strong><em>Unit</em></strong> （赋值语句返回值）和 <strong><em>String</em></strong> 做不等比较永远为 <strong><em>true</em></strong> 上面的代码会是一个死循环。  </p><p>正因为 <strong><em>while</em></strong> 循环没有值，因此在纯函数化编程中应该避免使用 <strong><em>while</em></strong> 循环。 Scala 保留 <strong><em>while</em></strong> ，是因为在某些时候使用循环代码比较容易理解。 而如果使用纯函数化编程，需要执行一些重复运行的代码时，通常就需要使用回溯函数来实现，回溯函数通常看起来不是很直观。  </p><p>比如前面计算最大公约数的函数使用纯函数化编程借助回溯函数实现如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def gcd (x :Long, y:Long) :Long &#x3D;</span><br><span class="line">   if (y &#x3D;&#x3D;0) x else gcd (y, x % y)</span><br></pre></td></tr></table></figure><p>总的来说，推荐尽量避免在代码中使用 <strong><em>while</em></strong> 循环， 正如函数化编程要避免使用 <strong><em>var</em></strong> 变量一样。而使用 <strong><em>while</em></strong> 循环时通常也会使用到 <strong><em>var</em></strong> 变量，因此在你打算使用 <strong><em>while</em></strong> 循环时需要特别小心，看是否可以避免使用它们  </p><h3 id="for-表达式"><a href="#for-表达式" class="headerlink" title="for 表达式"></a>for 表达式</h3><p>Scala 中的 <strong><em>for</em></strong> 表达式有如一把完成迭代任务的瑞士军刀，它允许你使用一些简单的不见以不同的方法组合完成许多复杂的迭代任务。简单的应用，比如枚举一个整数列表，较复杂的应用可以同时枚举多个不同类型的列表，根据条件过滤元素，并可以生成新的集合。  </p><h4 id="枚举集合元素"><a href="#枚举集合元素" class="headerlink" title="枚举集合元素"></a>枚举集合元素</h4><p>这是使用 <strong><em>for</em></strong> 表示式的一个基本用法，和 Java 的 <strong><em>for</em></strong> 非常类似， 比如下面的代码可以枚举当前目录下所有文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">for(file &lt;-filesHere)</span><br><span class="line">  println(file)</span><br></pre></td></tr></table></figure><p>其中如 file &lt;– filesHere 的语法结构，在 Scala 中称为“生成器 (generator)”。 本例中，filesHere 的类型为 Array[File]。每次迭代中，变量 file 会初始化为该数组中一个元素， file 的 toString() 为文件的文件名，因此 println(file) 打印出文件名。  </p><p>Scala 的 for 表达式支持所有类型的集合，而不仅仅是数组，比如下面使用 for 表达式来枚举一个 Range 类型。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> scala&gt; for(i &lt;- 1 to 4) println(&quot;Interation&quot; +i)</span><br><span class="line">Interation 1</span><br><span class="line">Interation 2</span><br><span class="line">Interation 3</span><br><span class="line">Interation 4</span><br></pre></td></tr></table></figure><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>某些时候，你可能不想枚举集合中的每一个元素，而是只想迭代某些符合条件的元素。在 Scala 中，你可以为 for 表达式添加一个过滤器——在 for 的括号内添加一个 if 语句，例如：  </p><p>修改前面枚举文件的例子，改成只列出 .scala 文件，示例如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">for( file &lt;-filesHere</span><br><span class="line">   if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">)  println(file)</span><br></pre></td></tr></table></figure><p>如果有必要的话，你可以使用多个过滤器，只要添加多个 if 语句即可。比如，为保证前面列出的文件不是目录，可以添加一个 if，如下面代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">for( file &lt;-filesHere</span><br><span class="line">   if file.isFile</span><br><span class="line">   if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">)  println(file)</span><br></pre></td></tr></table></figure><h4 id="嵌套迭代"><a href="#嵌套迭代" class="headerlink" title="嵌套迭代"></a>嵌套迭代</h4><p>for 表达式支持多重迭代。下面的例子使用两重迭代，外面的循环枚举 filesHere ，而内部循环枚举该文件的每一行文字。实现了类似 Unix 中的 grep 命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">def fileLines (file : java.io.File) &#x3D;</span><br><span class="line">   scala.io.Source.fromFile(file).getLines().toList</span><br><span class="line"></span><br><span class="line">def grep (pattern: String) &#x3D;</span><br><span class="line">  for (</span><br><span class="line">    file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;);</span><br><span class="line">    line &lt;- fileLines(file)</span><br><span class="line">    if line.trim.matches(pattern)</span><br><span class="line">  ) println(file + &quot;:&quot; + line.trim)</span><br><span class="line"></span><br><span class="line">grep (&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure><p>注意上面代码中，两个迭代之间使用了 ; ，如果你使用 {} 替代 for 的 () 括号，你可以不使用 ； 分隔这两个“生成器”。这是因为，Scala 编译器不推算包含在花括号内的省掉的 ; 。使用 {} 改写的代码如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">def fileLines (file : java.io.File) &#x3D;</span><br><span class="line">   scala.io.Source.fromFile(file).getLines().toList</span><br><span class="line"></span><br><span class="line">def grep (pattern: String) &#x3D;</span><br><span class="line">  for &#123;</span><br><span class="line">    file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">    line &lt;- fileLines(file)</span><br><span class="line">    if line.trim.matches(pattern)</span><br><span class="line">  &#125; println(file + &quot;:&quot; + line.trim)</span><br><span class="line"></span><br><span class="line">grep (&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure><p>这两段代码是等效的。  </p><h4 id="绑定中间变量"><a href="#绑定中间变量" class="headerlink" title="绑定中间变量"></a>绑定中间变量</h4><p>你可能注意到，前面代码使用了多次 <strong><em>line.trim</em></strong> 如果 trim 是个耗时的操作，你可能希望 trim 只计算一次。Scala 允许你使用 = 号来绑定计算结果到一个新变量。绑定的作用和 val 类似，只是不需要使用 val 关键字。例如，修改前面的例子，只计算一次 trim，把结果保存在 trimmed 变量中。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val filesHere &#x3D; (new java.io.File(&quot;.&quot;)).listFiles</span><br><span class="line"></span><br><span class="line">def fileLines (file : java.io.File) &#x3D;</span><br><span class="line">   scala.io.Source.fromFile(file).getLines().toList</span><br><span class="line"></span><br><span class="line">def grep (pattern: String) &#x3D;</span><br><span class="line">  for &#123;</span><br><span class="line">    file &lt;- filesHere if file.getName.endsWith(&quot;.scala&quot;)</span><br><span class="line">    line &lt;- fileLines(file)</span><br><span class="line">    trimmed&#x3D;line.trim</span><br><span class="line">    if trimmed.matches(pattern)</span><br><span class="line">  &#125; println(file + &quot;:&quot; + trimmed)</span><br><span class="line"></span><br><span class="line">grep (&quot;.*gcd.*&quot;)</span><br></pre></td></tr></table></figure><h4 id="生成新集合"><a href="#生成新集合" class="headerlink" title="生成新集合"></a>生成新集合</h4><p>for 表达式也可以用来生产新的集合，这是 Scala 的 for表达式比 Java 的 for 语句功能强大的地方。它的基本语法如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for clauses yield body</span><br></pre></td></tr></table></figure><p>关键字 yield 放在 body 的前面，for 每迭代一次，就产生一个 body 。yield 收集所有的 body 结果，返回一个 body 类型的集合。  </p><h3 id="用-try-表达式处理异常"><a href="#用-try-表达式处理异常" class="headerlink" title="用 try 表达式处理异常"></a>用 try 表达式处理异常</h3><p>Scala 的异常处理和其它语言比如Java类似，一个方法可以通过抛出异常而不返回值的方式来终止相关代码的运行。调用函数，可以捕获这个异常作出相应的处理，或者直接退出。在这种情况下，异常会传递给调用函数的调用者，依次向上传递，直到有方法处理这个异常。  </p><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>Scala 抛出异常的方法和 Java 一样，使用 throw 方法。例如，抛出一个新的参数异常： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new IllegalArgumentException</span><br></pre></td></tr></table></figure><p>尽管看起来似乎有些自相矛盾，Scala 中，throw 也是一个表达式，也是有返回值的。比如下面的例子：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val half &#x3D;</span><br><span class="line">  if (n % 2 &#x3D;&#x3D; 0)</span><br><span class="line">    n&#x2F;2</span><br><span class="line">  else</span><br><span class="line">    throw new RuntimeException(&quot;n must be even&quot;)</span><br></pre></td></tr></table></figure><p>当 n 为偶数时，n 初始化为 n 的一半；而如果 n 为奇数，将在初始化 half 之前就抛出异常。正因为如此，可以把 throw 的返回值视作任意类型。技术上来说，抛出异常的类型为 Nothing 。对于上面的例子，整个 if 表达式的类型为可以计算出值的那个分支的类型。如果 n 为 Int ，那么 if 表示式的类型也是 Int 类型，而不需要考虑 throw 表达式的类型。  </p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>Scala 捕获异常的方法和后面介绍的“模式匹配”的使用方法是一致的。比如：  </p><p><strong><em>注意，这个地方的文件需要自己创建，并将文件目录写到FileReader中</em></strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi input.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileReader</span><br><span class="line">import java.io.FileNotFoundException</span><br><span class="line">import java.io.IOException</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  val f &#x3D; new FileReader(&quot;&#x2F;home&#x2F;hadoop&#x2F;input.txt&quot;)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  case ex: FileNotFoundException &#x3D;&gt; &#x2F;&#x2F;handle missing file</span><br><span class="line">  case ex: IOException &#x3D;&gt; &#x2F;&#x2F;handle other I&#x2F;O error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配将在后面介绍，try-catch 表达式的基本用法和 Java 一样。如果 try 块中代码在执行过程中出现异常，将逐个检测每个 catch 块。在上面的例子，如果打开文件出现异常，将先检查是否是 FileNotFoundException 异常。如果不是，再检查是否是 IOException 。如果还不是，再终止 try-catch 块的运行，而向上传递这个异常。  </p><p>注意： 和Java异常处理不同的一点是，Scala 不需要你捕获 checked 的异常。这点和 C# 一样，也不需要使用 throw 来声明某个异常。当然，如果有需要，还是可以通过 @throw 来声明一个异常，但这不是必须的。  </p><h4 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h4><p>Scala 也支持 finally 语句，你可以在 finally 块中添加一些代码。这些代码不管 try 块是否抛出异常，都会执行。比如，你可以在 finally 块中添加代码保证关闭已经打开的文件，而不管前面代码中是否出现异常。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileReader</span><br><span class="line"></span><br><span class="line">val file &#x3D; new FileReader(&quot;&#x2F;home&#x2F;hadoop&#x2F;input.txt&quot;)</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  &#x2F;&#x2F;use the file</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  file.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成返回值"><a href="#生成返回值" class="headerlink" title="生成返回值"></a>生成返回值</h4><p>和大部分 Scala 控制结构一样，Scala 的 try-catch-finally 也生成某个值。比如下面的例子尝试分析一个 URL ，如果输入的 URL 无效，则使用缺省的 URL 链接地址：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL</span><br><span class="line">import java.net.MalformedURLException</span><br><span class="line"></span><br><span class="line">def urlFor(path:String) &#x3D;</span><br><span class="line">  try &#123;</span><br><span class="line">    new URL(path)</span><br><span class="line">  &#125; catch &#123;</span><br><span class="line">    case e: MalformedURLException &#x3D;&gt;</span><br><span class="line">      new URL(&quot;http:&#x2F;&#x2F;www.scala-lang.org&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通常情况下，finally 块用来做些清理工作，而不应该产生结果，但如果在 finally 块中使用 return 来返回某个值，这个值将覆盖 try-catch 产生的结果，比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def f(): Int &#x3D; try &#123; return 1 &#125; finally &#123; return 2&#125;</span><br><span class="line">f: ()Int</span><br><span class="line"></span><br><span class="line">scala&gt; f</span><br><span class="line">res0: Int &#x3D; 2</span><br></pre></td></tr></table></figure><p>而下面的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def g() :Int &#x3D; try 1 finally 2</span><br><span class="line">&lt;console&gt;:21: warning: a pure expression does nothing in statement position; you may be omitting necessary parentheses</span><br><span class="line">       def g() : Int &#x3D; try 1 finally 2</span><br><span class="line">                                     ^</span><br><span class="line"></span><br><span class="line">g: ()Int</span><br><span class="line"></span><br><span class="line">scala&gt; g</span><br><span class="line">res0: Int &#x3D; 1</span><br></pre></td></tr></table></figure><p>结果却是 1 ，上面两种情况常常使得程序员产生困惑，因此关键的一点是避免在 finally 生成返回值，而只用来做些清理工作，比如关闭文件。  </p><h4 id="Match-表达式"><a href="#Match-表达式" class="headerlink" title="Match 表达式"></a>Match 表达式</h4><p>Scala 的 Match 表达式支持从多个选择中选取其一，类似其它语言中的 switch 语句。通常来说，Scala 的 match 表达式支持任意的匹配模式，这种基本模式将在后面介绍。  </p><p>接下来，为你介绍类似 switch 用法的 match 表达式，它也是在多个选项中选择其一。  </p><p>例如，下面的例子从参数中读取食品的名称，然后根据食品的名称，打印出和该食品搭配的食品。比如，输入 salt，与之对应的食品为 pepper 。如果是 chips ，那么搭配的就是 salsa等等。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val args &#x3D; Array(&quot;chips&quot;)</span><br><span class="line">val firstArg &#x3D; if (args.length &gt;0 ) args(0) else &quot;&quot;</span><br><span class="line">firstArg match &#123;</span><br><span class="line">  case &quot;salt&quot; &#x3D;&gt; println(&quot;pepper&quot;)</span><br><span class="line">  case &quot;chips&quot; &#x3D;&gt; println(&quot;salsa&quot;)</span><br><span class="line">  case &quot;eggs&quot; &#x3D;&gt; println(&quot;bacon&quot;)</span><br><span class="line">  case _ &#x3D;&gt; println(&quot;huh?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和 Java 的 switch 相比有几点不同：  </p><ul><li>一是任何类型的常量都可以用在 case 语句中，而不仅仅是 int 或是枚举类型。</li><li>二是每个 case 语句无需使用 break ，Scala不支持“fall through”。</li><li>三是Scala的缺省匹配为 _ ，其作用类似 java 中的 default。</li></ul><p>而最关键的一点，是 scala 的 match 表达式有返回值。上面的代码使用的是 println 打印，而实际上你可以使用表达式，比如修改上面的代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val firstArg &#x3D; if (args.length &gt;0 ) args(0) else &quot;&quot;</span><br><span class="line">val friend &#x3D; firstArg match &#123;</span><br><span class="line">  case &quot;salt&quot; &#x3D;&gt; &quot;pepper&quot; </span><br><span class="line">  case &quot;chips&quot; &#x3D;&gt; &quot;salsa&quot; </span><br><span class="line">  case &quot;eggs&quot; &#x3D;&gt; &quot;bacon&quot; </span><br><span class="line">  case _ &#x3D;&gt; &quot;huh?&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(friend)</span><br></pre></td></tr></table></figure><p>这段代码和前面的代码是等效的，不同的是后面这段代码 match 表达式返回结果。</p><h3 id="没有-break-和-continue-的日子"><a href="#没有-break-和-continue-的日子" class="headerlink" title="没有 break 和 continue 的日子"></a>没有 break 和 continue 的日子</h3><p>你也许注意到：到目前为止，我们介绍 Scala 的内置控制结构时，没有提到使用 break 和 continue 。 Scala 特地没有在内置控制结构中包含 break 和 continue ，这是因为这两个控制结构和函数字面量有点格格不入，函数字面量我们将在后面介绍。函数字面量和其它类型字面量，比如数值字面量 4、5.6 相比，他们在 Scala 的地位相同。  </p><p>我们很清楚 break 和 continue 在循环控制结构中的作用。Scala内置控制结构特地去掉了 break 和 continue ，这是为了更好的适应函数化编程。不过，你不用担心，Scala 提供了多种方法来替代 break 和 continue 的作用。  </p><p>一个简单的方法，是使用一个 if 语句来代替一个 continue，使用一个布尔控制量来去除一个 break 。比如下面的 Java 代码在循环结构中使用 continue 和 break：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int i&#x3D;0;</span><br><span class="line">boolean foundIt&#x3D;false;</span><br><span class="line">while(i &lt;args.length) &#123;</span><br><span class="line">    if (args[i].startWith(&quot;-&quot;)) &#123;</span><br><span class="line">        i&#x3D;i+1;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(args[i].endsWith(&quot;.scala&quot;))&#123;</span><br><span class="line">        foundIt&#x3D;true;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    i&#x3D;i+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 Java 代码实现的功能，是从一组字符串中寻找以 .scala 结尾的字符串，但跳过以 - 开头的字符串。  </p><p>下面我们使用 if 和 boolean 变量，逐句将这段使用Scala来实现（不使用break和continue)如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var i&#x3D;0</span><br><span class="line">var foundIt&#x3D;false</span><br><span class="line">while (i &lt; args.length &amp;&amp; !foundIt) &#123;</span><br><span class="line">    if (!args(i).startsWith(&quot;-&quot;)) &#123;</span><br><span class="line">    if(args(i).endsWith(&quot;.scala&quot;))</span><br><span class="line">        foundIt&#x3D;true</span><br><span class="line">    &#125;</span><br><span class="line">    i&#x3D;i+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们使用 if（与前面的 continue 条件相反）去掉了 continue，而重用了 foundIt 布尔变量，去掉了 break 。  </p><p>这段代码和前面 Java 实现非常类似，并且使用了两个 var 变量。使用纯函数化编程的一个方法是去掉 var 变量的使用，而递归函数（回溯函数）是用于去除循环结构中使用 var 变量时，通常使用的一个方法。  </p><p>使用递归函数重新实现上面代码的查询功能：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def searchFrom(i:Int) : Int &#x3D;&#123;</span><br><span class="line">    if( i &gt;&#x3D; args.length) -1</span><br><span class="line">    else if (args(i).startsWith(&quot;-&quot;)) searchFrom (i+1)</span><br><span class="line">    else if (args(i).endsWith(&quot;.scala&quot;)) i</span><br><span class="line">    else searchFrom(i+1)</span><br><span class="line">&#125;</span><br><span class="line">     val i &#x3D; searchFrom(0)</span><br></pre></td></tr></table></figure><p>在函数化编程中，使用递归函数来实现循环是非常常见的一种方法，我们应该熟悉递归函数的用法。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们学习了 Scala 中的主要控制语句的用法。如果你之前学习了 Java ，那么在此处有一点需要特别注意：Scala 是一门“函数式”编程语言。结合这一点，多与之前学过的编程语言作比较，相信你能获得更多。  </p>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启Scala编程</title>
      <link href="2020/01/08/scala-%E5%BC%80%E5%A7%8B%E7%BC%96%E7%A8%8B-2020-01-08/"/>
      <url>2020/01/08/scala-%E5%BC%80%E5%A7%8B%E7%BC%96%E7%A8%8B-2020-01-08/</url>
      
        <content type="html"><![CDATA[<h2 id="开启Scala编程"><a href="#开启Scala编程" class="headerlink" title="开启Scala编程"></a>开启Scala编程</h2><blockquote><p>首先 需要安装 Scala 软件  进入scale 终端  </p></blockquote><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>每次使用开发的时候 必定输出 Hello World  </p><p>代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld &#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    println(&quot;Hello, world!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一行中的代码太长，可以在该行最后以 Shift键+Enter键 进行换行即可。输入上述代码后，显示如下图所示：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/08/l2pRtU.png" alt="运行示例-1">  </p><p>如果一行中的代码太长，可以在该行最后以 Shift键+Enter键 进行换行即可。输入上述代码后，显示如下图所示：</p><p>这段代码，你可以使用命令行交互式执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld.main(null)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://doc.shiyanlou.com/document-uid702660labid6307timestamp1525417639151.png/wm" alt="运行示例-2">  </p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://baike.baidu.com/view/1588150.htm">百度百科 - Scala</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
          <category> 基础开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化机制</title>
      <link href="2020/01/06/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-2020-01-06/"/>
      <url>2020/01/06/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-2020-01-06/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h2><p>内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。  </p><p>Redis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。  </p><p>Redis 支持两种持久化方式：  </p><ol><li>snapshotting（快照）：将数据存放到文件里，默认方式。  </li></ol><p>是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如：  </p><p>save 900 1：900 秒内如果超过 1 个 key 被修改，则发起快照保存。  </p><p>save 300 10：300 秒内如果超过 10 个 key 被修改，则快照保存。  </p><ol start="2"><li>Append-only file（缩写为 aof）：将读写操作存放到文件中。  </li></ol><p>由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。  </p><p>aof 比快照方式有更好的持久化性，是由于使用 aof 时，redis 会将每一个收到的写命令都通过 write 函数写入到文件中，当 redis 启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。  </p><p>由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。  </p><p>配置文件中的可配置参数：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes &#x2F;&#x2F;启用 aof 持久化方式</span><br><span class="line"></span><br><span class="line"># appendfsync always &#x2F;&#x2F;收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化</span><br><span class="line"></span><br><span class="line">appendfsync everysec &#x2F;&#x2F;每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</span><br><span class="line"></span><br><span class="line"># appendfsync no &#x2F;&#x2F;完全依赖 os，性能最好，持久化没有保证</span><br></pre></td></tr></table></figure><p>在 redis-cli 的命令中，save 命令是将数据写入磁盘中。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; help save</span><br><span class="line">&gt; save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 持久化机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制</title>
      <link href="2020/01/05/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-2020-01-05/"/>
      <url>2020/01/05/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-2020-01-05/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><p>为了分担服务器压力，会在特定情况下部署多台服务器分别用于缓存的读和写操作，用于写操作的服务器称为主服务器，用于读操作的服务器称为从服务器。  </p><p>从服务器通过 psync 操作同步主服务器的写操作，并按照一定的时间间隔更新主服务器上新写入的内容。  </p><p>Redis 主从复制的过程：  </p><ol><li>Slave 与 Master 建立连接，发送 psync 同步命令。</li><li>Master 会启动一个后台进程，将数据库快照保存到文件中，同时 Master 主进程会开始收集新的写命令并缓存。</li><li>后台完成保存后，就将此文件发送给 Slave。</li><li>Slave 将此文件保存到磁盘上。  </li></ol><p>Redis 主从复制特点  </p><ol><li>可以拥有多个 Slave。</li><li>多个 Slave 可以连接同一个 Master 外，还可以连接到其它的 Slave。（当 Master 宕机后，相连的 Slave 转变为 Master）。</li><li>主从复制不会阻塞 Master，在同步数据时， Master 可以继续处理 Client 请求。</li><li>提高了系统的可伸缩性。</li></ol><p>从服务器的主要作用是响应客户端的数据请求，比如返回一篇博客信息。  </p><p>上面说到了主从复制是不会阻塞 Master 的，就是说 Slave 在从 Master 复制数据时，Master 的删改插入等操作继续进行不受影响。  </p><p>如果在同步过程中，主服务器修改了一篇博客，而同步到从服务器上的博客是修改前的。这时候就会出现时间差，即修改了博客过后，在访问网站的时候还是原来的数据，这是因为从服务器还未同步最新的更改，这也就意味着非阻塞式的同步只能应用于对读数据延迟接受度较高的场景。  </p><p>要建立这样一个主从关系的缓存服务器，只需要在 Slave 端执行命令:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># SLAVEOF IPADDRESS:PORT</span><br><span class="line">&gt; SLAVEOF 127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>如果主服务器设置了连接密码，就需要在从服务器中事先设置好：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure><p>这样，当前服务器就作为 127.0.0.1:6379 下的一个从服务器，它将定期从该服务器复制数据到自身。<br>在以前的版本中（2.8 以前），你应该慎用 redis 的主从复制功能，因为它的同步机制效率低下，可以想象每一次短线重连都要复制主服务器上的全部数据，算上网络通讯所耗费的时间，反而可能达不到通过 redis 缓存来提升应用响应速度的效果。但是幸运的是，官方在 2.8 以后推出了解决方案，通过部分同步来解决大量的重复操作。  </p><p>这需要主服务器和从服务器都至少达到 2.8 的版本要求。  </p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 事务处理</title>
      <link href="2020/01/05/redis-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-2020-01-05/"/>
      <url>2020/01/05/redis-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-2020-01-05/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-事务处理"><a href="#Redis-事务处理" class="headerlink" title="Redis 事务处理"></a>Redis 事务处理</h2><p>Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 multi 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 exec 命令时，redis 会顺序的执行队列中的所有命令。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">&gt; set name a</span><br><span class="line">&gt; set name b</span><br><span class="line">&gt; exec</span><br><span class="line">&gt; get name</span><br></pre></td></tr></table></figure><p>需要注意的是，redis 对于事务的处理方式比较特殊，它不会在事务过程中出错时恢复到之前的状态，这在实际应用中导致我们不能依赖 redis 的事务来保证数据一致性。  </p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 事务处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 虚拟内存的使用</title>
      <link href="2020/01/05/redis-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8-2020-01-05/"/>
      <url>2020/01/05/redis-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8-2020-01-05/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-虚拟内存的使用"><a href="#Redis-虚拟内存的使用" class="headerlink" title="Redis 虚拟内存的使用"></a>Redis 虚拟内存的使用</h2><p>虚拟内存管理在 2.6 及之上版本取消了，取消了是指这部分内容在后面的版本会由 redis 软件自身管理，在本实验中，选择的是 4.0.9 版本的 redis，所以实验中的配置文件没有虚拟内存管理功能的配置选项，此处仅为讲解。  </p><p>Redis 的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据，尤其对于 redis 这样的内存数据库，内存总是不够用的。除了分隔到多个 redis server 外，提高数据库容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。  </p><p>通过配置 vm 相关的 redis.config 配置：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 开启 vm 功能</span><br><span class="line">vm-enable yes</span><br><span class="line"></span><br><span class="line"># 交换出来的 value 保存的文件路径</span><br><span class="line">vm-swap-file &#x2F;tmp&#x2F;redis.swap</span><br><span class="line"></span><br><span class="line"># redis 使用的最大内存上限</span><br><span class="line">vm-max-memory 10000000</span><br><span class="line"></span><br><span class="line"># 每个页面的大小 32 字节</span><br><span class="line">vm-page-size 32</span><br><span class="line"></span><br><span class="line"># 最多使用多少个页面</span><br><span class="line">vm-pages 123217729</span><br><span class="line"></span><br><span class="line"># 用于执行 value 对象换入的工作线程数量</span><br><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 虚拟内存的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 简介与安装</title>
      <link href="2020/01/05/redis-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85-2020-01-05/"/>
      <url>2020/01/05/redis-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85-2020-01-05/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-简介与安装"><a href="#Redis-简介与安装" class="headerlink" title="Redis 简介与安装"></a>Redis 简介与安装</h2><h3 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h3><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。Redis 提供了一些丰富的数据结构，包括 lists、sets、ordered sets 以及 hashes ，当然还有和 Memcached 一样的 strings 结构。Redis 当然还包括了对这些数据结构的丰富操作。  </p><p>Redis 常被称作是一款数据结构服务器（data structure server）。Redis 的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。  </p><p>对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。  </p><h4 id="Redis-的优点"><a href="#Redis-的优点" class="headerlink" title="Redis 的优点"></a>Redis 的优点</h4><ul><li>性能极高：Redis 能支持超过 100K+ 每秒的读写频率。</li><li>丰富的数据类型：Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。</li><li>原子：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。</li><li>丰富的特性：Redis 还支持 publish/subscribe，通知，key 过期等等特性。</li></ul><h3 id="Redis-的安装步骤"><a href="#Redis-的安装步骤" class="headerlink" title="Redis 的安装步骤"></a>Redis 的安装步骤</h3><p><strong><em>下面的安装步骤仅为示例大家不需要在环境中进行操作。</em></strong>  </p><p>redis 手动安装的话非常简单，以 redis-4.0.9 版本为例。  </p><p>首先进入 root 目录并下载 Redis 的程序包：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;labfile.oss.aliyuncs.com&#x2F;courses&#x2F;106&#x2F;redis-4.0.9.tar.gz</span><br></pre></td></tr></table></figure><p>在目录下，解压安装包，生成新的目录 redis-4.0.9：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf redis-4.0.9.tar.gz</span><br></pre></td></tr></table></figure><p>进入解压之后的目录，进行编译  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-4.0.9</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>说明：如果没有明显的错误，则表示编译成功。  </p><h4 id="查看重要文件"><a href="#查看重要文件" class="headerlink" title="查看重要文件"></a>查看重要文件</h4><p>在Readis 安装完成之后，注意一些重要的文件，可用ls命令查看。  </p><ul><li>服务端：src/readis-server</li><li>客户端： src/redis-cli</li><li>默认配置文件：redis.conf</li></ul><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>为了今后能更方便地打开 Redis 服务器和客户端，可以将 src 目录下的 redis-server 和 redis-cli 添加进环境变量所属目录里面。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp redis-server &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">cp redis-cli &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><p>添加完成后在任何目录下输入 redis-server 可启动服务器，输入 redis-cli 可启动客户端  </p><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>在前面的步骤设置完成后可以运行测试（非必须），确认 Redis 的功能是否正常  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;redis-4.0.9</span><br><span class="line">make test</span><br></pre></td></tr></table></figure><p>如果提示 <strong><em>You need tcl 8.5 or newer in order to run the Redis test</em></strong>  </p><p>可以安装tcl，然后再进行测试   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tcl -y</span><br></pre></td></tr></table></figure><p>Redis 是一个服务端和客户端配合的程序，和 Mysql 类似，因此要使用 Redis 需要先启动服务端，客户端有多种形式，比如在 Java 中连接 Redis 服务器也是扮演了一个客户端的角色，本节实验中采用终端的形式来对 Redis 的各项操作进行练习。  </p><h3 id="启动-Readis-server"><a href="#启动-Readis-server" class="headerlink" title="启动 Readis-server"></a>启动 Readis-server</h3><p>添加完 <a href="#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量之后</a>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>开启之后 会出现redis 的 界面 此时要使用 Redis-Client 需要保持此终端的运行，重开一个终端标签。  </p><h4 id="查看-Redis"><a href="#查看-Redis" class="headerlink" title="查看 Redis"></a>查看 Redis</h4><p>在命令行终端执行如下命令查看Redis：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis  </span><br></pre></td></tr></table></figure><p>通过端口号检查Redis服务器状态：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nlt| grep 6379</span><br></pre></td></tr></table></figure><h4 id="启动-Redis-client"><a href="#启动-Redis-client" class="headerlink" title="启动 Redis-client"></a>启动 Redis-client</h4><p>在命令行终端执行如下命令启动 Redis-client:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>至此，redis 启动完成。  </p><p>在有的环境下，redis 交互环境可能出现中文乱码的情况，解决办法是用下列命令启动 redis 客户端：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --raw</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 简介与安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io 数据流</title>
      <link href="2020/01/03/java-io-%E6%95%B0%E6%8D%AE%E6%B5%81-2020-01-03/"/>
      <url>2020/01/03/java-io-%E6%95%B0%E6%8D%AE%E6%B5%81-2020-01-03/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-数据流"><a href="#Java-数据流" class="headerlink" title="Java 数据流"></a>Java 数据流</h2><p>接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()…; write(), writeChar(), writeBoolean()… 此外，还可以用 readLine() 方法读取一行信息。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>readBoolean()</td><td>boolean</td><td></td></tr><tr><td>readByte()</td><td>byte</td><td></td></tr><tr><td>readShort()</td><td>short</td><td></td></tr><tr><td>readChar()</td><td>char</td><td></td></tr><tr><td>readInt()</td><td>int</td><td></td></tr><tr><td>readLong()</td><td>long</td><td></td></tr><tr><td>readDouble()</td><td>double</td><td></td></tr><tr><td>readFloat()</td><td>float</td><td></td></tr><tr><td>readUnsignedByte()</td><td>int</td><td></td></tr><tr><td>readUnsignedShort()</td><td>int</td><td></td></tr><tr><td>readFully(byte[] b)</td><td>void</td><td>从输入流中读取一些字节，并将它们存储在缓冲区数组 b 中</td></tr><tr><td>reaFully(byte[] b, int off,int len)</td><td>void</td><td>从输入流中读取 len 个字节</td></tr><tr><td>skipBytes(int n)</td><td>int</td><td>与 InputStream.skip 等价</td></tr><tr><td>readUTF()</td><td>String</td><td>按照 UTF-8 形式从输入中读取字符串</td></tr><tr><td>readLine()</td><td>String</td><td>按回车 (\r) 换行 (\n) 为分割符读取一行字符串，不完全支持 UNICODE</td></tr><tr><td>writeBoolean(boolean v)</td><td>void</td><td></td></tr><tr><td>writeByte(int v)</td><td>void</td><td></td></tr><tr><td>writeShort(int v)</td><td>void</td><td></td></tr><tr><td>writeChar(int v)</td><td>void</td><td></td></tr><tr><td>writeInt(int v)</td><td>void</td><td></td></tr><tr><td>writeLong(long v)</td><td>void</td><td></td></tr><tr><td>writeFloat(float v)</td><td>void</td><td></td></tr><tr><td>writeDouble(double v)</td><td>void</td><td></td></tr><tr><td>write(byte[] b)</td><td>void</td><td>与 OutputStream.write 同义</td></tr><tr><td>write(byte[] b, int off, int len)</td><td>void</td><td>与 OutputStream.write 同义</td></tr><tr><td>write(int b)</td><td>void</td><td>与 OutputStream.write 同义</td></tr><tr><td>writeBytes(String s)</td><td>void</td><td>只输出每个字符的低 8 位；不完全支持 UNICODE</td></tr><tr><td>writeChars(String s)</td><td>void</td><td>每个字符在输出中都占两个字节</td></tr></tbody></table><p>数据流类 DataInputStream 和 DataOutputStream 的处理对象除了是字节或字节数组外，还可以实现对文件的不同数据类型的读写：</p><ol><li>分别实现了 DataInput 和 DataOutput 接口。</li><li>在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来。</li><li>提供了字符串读写的手段。</li></ol><p>数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis &#x3D; new FileInputStream(&quot;file1.txt&quot;);</span><br><span class="line">FileOutputStream fos &#x3D; new FileOutputStream(&quot;file2.txt&quot;);</span><br><span class="line">DataInputStream dis &#x3D; new DataInputStream(fis);</span><br><span class="line">DataOutputStream dos &#x3D; new DataOutputStream(fos);</span><br></pre></td></tr></table></figure><p>新建源代码文件 DataStream.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class DataStream &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException&#123;</span><br><span class="line">        &#x2F;&#x2F;向文件 a.txt 写入</span><br><span class="line">        FileOutputStream fos &#x3D; new FileOutputStream(&quot;a.txt&quot;);</span><br><span class="line">        DataOutputStream dos &#x3D; new DataOutputStream(fos);</span><br><span class="line">        try &#123;</span><br><span class="line">            dos.writeBoolean(true);</span><br><span class="line">            dos.writeByte((byte)123);</span><br><span class="line">            dos.writeChar(&#39;J&#39;);</span><br><span class="line">            dos.writeDouble(3.1415926);</span><br><span class="line">            dos.writeFloat(2.122f);</span><br><span class="line">            dos.writeInt(123);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            dos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;从文件 a.txt 读出</span><br><span class="line">        FileInputStream fis &#x3D; new FileInputStream(&quot;a.txt&quot;);</span><br><span class="line">        DataInputStream dis &#x3D; new DataInputStream(fis);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readBoolean());</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readByte());</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readChar());</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readDouble());</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readFloat());</span><br><span class="line">            System.out.println(&quot;\t&quot; + dis.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac DataStream.java</span><br><span class="line">$ java DataStream</span><br><span class="line">        true</span><br><span class="line">        123</span><br><span class="line">        J</span><br><span class="line">        3.1415926</span><br><span class="line">        2.122</span><br><span class="line">        123</span><br></pre></td></tr></table></figure><h3 id="读写对象"><a href="#读写对象" class="headerlink" title="读写对象"></a>读写对象</h3><p>我们知道实例化的对象存在于内存中，如果我们想传输实例化的对象怎么办呢？可以通过 ObjectOutputStream 和 ObjectInputStream 将对象输入输出。 将对象的状态信息转换为可以存储或者传输的形式的过程又叫序列化。</p><p>新建一个源代码文件 ReadWriteObject.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class ReadWriteObject &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file &#x3D; new File(&quot;&#x2F;home&#x2F;project&#x2F;user.file&quot;);</span><br><span class="line">        try (ObjectOutputStream objectOutputStream &#x3D; new ObjectOutputStream(new FileOutputStream(file))) &#123;</span><br><span class="line">            &#x2F;&#x2F;将匿名对象 写入到file中，注意：被写入的对象必须实现了Serializable接口</span><br><span class="line">            objectOutputStream.writeObject(new User(&quot;admin&quot;, &quot;adminpwd&quot;));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;读取文件 打开输入流</span><br><span class="line">        try (ObjectInputStream objectInputStream &#x3D; new ObjectInputStream(new FileInputStream(file))) &#123;</span><br><span class="line">&#x2F;&#x2F;            将信息还原为user实例</span><br><span class="line">            User user &#x3D; (User) objectInputStream.readObject();</span><br><span class="line">            &#x2F;&#x2F;打印user信息  和上面创建的匿名对象的信息一致</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态内部类 必须实现Serializable</span><br><span class="line">    static class User implements Serializable &#123;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line"></span><br><span class="line">        public User(String username, String password) &#123;</span><br><span class="line">            this.username &#x3D; username;</span><br><span class="line">            this.password &#x3D; password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;User&#123;&quot; +</span><br><span class="line">                    &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                    &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                    &#39;&#125;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ javac ReadWriteObject.java</span><br><span class="line">$ java ReadWriteObject</span><br><span class="line">User&#123;username&#x3D;&#39;admin&#39;, password&#x3D;&#39;adminpwd&#39;&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Java NIO(New IO) 发布于 JDK1.4，用于代替 Java 标准 IO 。Java NIO 是面向缓存的、非阻塞的 IO，而标准 IO 是面向流的，阻塞的 IO。</p><p>首先理解 NIO 的重要概念：Buffer（缓冲区）</p><ul><li><p>NIO 读取或者写入数据都要通过 Buffer</p></li><li><p>通过 allocate() 方法分配 Buffer，Buffer 不可实例化，Buffer 是抽象类，需要使用具体的子类，比如 ByteBuffer。</p></li><li><p>Buffer 的参数</p><ul><li>capacity ：缓冲区的容量</li><li>position ：当前指针位置，没读取一次缓冲区数据或者写入缓冲区一个数据那么指针将会后移一位</li><li>limit ：限制指针的移动，指针不能读取 limit 之后的位置</li><li>mark ：如果设置该值，那么指针将移动到 0 - position 的位置</li><li>最后可以这几个参数的关系如下：mark &lt;= position &lt;= limit &lt;= capacity</li></ul><p>新建源代码文件 NioDemo.java：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.nio.charset.CharsetDecoder;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class NioDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File file &#x3D; new File(&quot;&#x2F;home&#x2F;project&#x2F;nio.txt&quot;);</span><br><span class="line">            if (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;创建channel  nio通过channel来连接文件 相当于桥梁</span><br><span class="line">            FileChannel writeChannel &#x3D; new RandomAccessFile(file, &quot;rw&quot;).getChannel();</span><br><span class="line">            &#x2F;&#x2F;创建一个ByteBuffer 容量为100</span><br><span class="line">            ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(100);</span><br><span class="line">            System.out.println(&quot;请输入字符串&quot;);</span><br><span class="line">            Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">            String s &#x3D; in.nextLine();</span><br><span class="line">            &#x2F;&#x2F;将字符串写入到缓冲区</span><br><span class="line">            byteBuffer.put(s.getBytes());</span><br><span class="line">            System.out.println(&quot;写入数据后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());</span><br><span class="line">            &#x2F;&#x2F;为输出数据做准备 将limit移动到position位置，position置0</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(&quot;flip后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());</span><br><span class="line">            &#x2F;&#x2F;将缓冲区写入channel</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">            &#x2F;&#x2F;清除缓冲区 为下次写入或者读取数据做准备 恢复到初始状态 position&#x3D;0 limit&#x3D;capacity&#x3D;100  因为我们这里分配的容量大小为100</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            System.out.println(&quot;clear后指针变化-position:&quot; + byteBuffer.position() + &quot; limit：&quot; + byteBuffer.limit() + &quot; capacity :&quot; + byteBuffer.capacity());</span><br><span class="line">            &#x2F;&#x2F;关闭channel</span><br><span class="line">            writeChannel.close();</span><br><span class="line">            FileChannel readChannel &#x3D; new RandomAccessFile(file, &quot;r&quot;).getChannel();</span><br><span class="line">            &#x2F;&#x2F;从channel中将数据读取到缓冲区</span><br><span class="line">            while (readChannel.read(byteBuffer) !&#x3D; -1) &#123;</span><br><span class="line">                &#x2F;&#x2F;为读取数据做准备</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                &#x2F;&#x2F;输出数据 设置解码器</span><br><span class="line">                Charset charset &#x3D; Charset.forName(&quot;UTF-8&quot;);</span><br><span class="line">                CharsetDecoder decoder &#x3D; charset.newDecoder();</span><br><span class="line">                System.out.println(&quot;读取结果：&quot; + decoder.decode(byteBuffer));</span><br><span class="line">                &#x2F;&#x2F;清除缓冲区</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            readChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac NioDemo.java</span><br><span class="line">$ java NioDemo</span><br><span class="line">请输入字符串</span><br><span class="line">hellojava</span><br><span class="line">写入数据后指针变化-position:9 limit：100 capacity :100</span><br><span class="line">flip后指针变化-position:0 limit：9 capacity :100</span><br><span class="line">clear后指针变化-position:0 limit：100 capacity :100</span><br><span class="line">shiyanlou</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java IO </tag>
            
            <tag> 数据流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java.lang 包装类</title>
      <link href="2020/01/03/java-lang-%E5%8C%85%E8%A3%85%E7%B1%BB-2020-01-03/"/>
      <url>2020/01/03/java-lang-%E5%8C%85%E8%A3%85%E7%B1%BB-2020-01-03/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-lang-包装类"><a href="#Java-lang-包装类" class="headerlink" title="Java.lang 包装类"></a>Java.lang 包装类</h2><table><thead><tr><th>原始数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte(字节)</td><td>Byte</td></tr><tr><td>char(字符)</td><td>character</td></tr><tr><td>int(整型)</td><td>Integer</td></tr><tr><td>long(长整型)</td><td>Long</td></tr><tr><td>float(浮点型)</td><td>Float</td></tr><tr><td>double(双精度)</td><td>Double</td></tr><tr><td>boolean(布尔型)</td><td>Boolean</td></tr><tr><td>short(短整型)</td><td>Short</td></tr></tbody></table><p>在这八个类名中，除了Integer和Character类以后，其他六个类的类名和基本数据类型一致，只是类名的第一个字母大写  </p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>java.lang 包中的 Integer 类、Long类和Short类都是Number类的子类，他们的区别在于不同子类里面封装着不同的数据类型，比如Integer类包装了一个基本类型int。其包含的方法基本相同。  </p><p>我们以 Integer 类为例。 Integer 构造方法有两种：  </p><ol><li>Integer(int value) ，以 int 型变量作为参数创建 Integer 对象。例如 <strong><em>Integer a = new Integer(10);</em></strong></li><li>Integer(String s) ，以 String 型变量作为参数创建   <strong><em>Integer 对象，例如Integer a = new Integer(“10”)</em></strong></li></ol><p>下面是Integer的常用方法  </p><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以byte类型返回该Integer的值</td></tr><tr><td>compareTo(Integer anotherInteger)</td><td>int</td><td>在数字上比较Integer对象。如果这两个值相等，则返回0 如果调用对象的值小于anotherInteger的数值，则返回负值 如果调用对象的数值大于anotherInteger的数值，则返回正值</td></tr><tr><td>equals(Object IntegerObj)</td><td>boolean</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>intValue()</td><td>int</td><td>以int型返回此Integer对象</td></tr><tr><td>shortValue()</td><td>short</td><td>以short型返回此Integer对象</td></tr><tr><td>longValue()</td><td>long</td><td>以long 型返回此Integer对象</td></tr><tr><td>floatValue()</td><td>float</td><td>以float型返回此Integer对象</td></tr><tr><td>doubleValue()</td><td>double</td><td>以double型返回此Integer对象</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该Integer值的String对象</td></tr><tr><td>valueOf(String str)</td><td>Integer</td><td>返回保存指定的String值的Integer对象</td></tr><tr><td>parseInt(String str)</td><td>int</td><td>将字符串参数作为有符号的十进制整数进行解析</td></tr></tbody></table><p>代码示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class IntegerTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;初始化一个 Integer 类实例</span><br><span class="line">        Integer a &#x3D; new Integer(&quot;10&quot;);</span><br><span class="line">        &#x2F;&#x2F;初始化一个 Integer 类实例</span><br><span class="line">        Integer b &#x3D; new Integer(11);</span><br><span class="line">        &#x2F;&#x2F;判断两个数的大小</span><br><span class="line">        System.out.println(a.compareTo(b));</span><br><span class="line">        &#x2F;&#x2F; 判断两个实例是否相等</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">        &#x2F;&#x2F;将 a 转换成 float 型数</span><br><span class="line">        float c &#x3D; a.floatValue();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        String d &#x3D; &quot;10101110&quot;;</span><br><span class="line">        &#x2F;&#x2F;将字符串转换为数值</span><br><span class="line">        &#x2F;&#x2F;parseInt(String str) 和 parseInt(String str,int radix) 都是类方法，由类来调用。后一个方法则实现将字符串按照参数 radix 指定的进制转换为 int，</span><br><span class="line">        int e &#x3D; Integer.parseInt(d, 2);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。  </p><p>Character 常用方法  </p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>isDigit(char ch)</td><td>boolean</td><td>确定字符是否为数字</td></tr><tr><td>isLetter(char ch)</td><td>boolean</td><td>确定字符是否为字母</td></tr><tr><td>isLowerCase(char ch)</td><td>boolean</td><td>确定字符是否为小写字母</td></tr><tr><td>isUpperCase(char ch)</td><td>boolean</td><td>确定字符是否为大写字母</td></tr><tr><td>isWhitespace(char ch)</td><td>boolean</td><td>确定字符是否为空白字符</td></tr><tr><td>isUnicodeIdentifierStart(char ch)</td><td>boolean</td><td>确定是否运行将指定字符作为Unicode标识符中的首字符</td></tr></tbody></table><h4 id="示例方法"><a href="#示例方法" class="headerlink" title="示例方法"></a>示例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CharacterTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int count;</span><br><span class="line">        &#x2F;&#x2F;定义了一个字符数组</span><br><span class="line">        char[] values &#x3D; &#123;&#39;*&#39;, &#39;_&#39;, &#39;%&#39;, &#39;8&#39;, &#39;L&#39;, &#39;l&#39;&#125;;</span><br><span class="line">        &#x2F;&#x2F;遍历字符数组</span><br><span class="line">        for (count &#x3D; 0; count &lt; values.length; count++)&#123;</span><br><span class="line">            if(Character.isDigit(values[count]))&#123;</span><br><span class="line">                System.out.println(values[count]+&quot;是一个数字&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(Character.isLetter(values[count]))&#123;</span><br><span class="line">                System.out.println(values[count]+ &quot;是一个字母&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(Character.isUpperCase(values[count]))&#123;</span><br><span class="line">                System.out.println(values[count]+&quot;是大写形式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(Character.isLowerCase(values[count]))&#123;</span><br><span class="line">                System.out.println(values[count]+&quot;是小写形式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(Character.isUnicodeIdentifierStart(values[count]))&#123;</span><br><span class="line">                System.out.println(values[count]+&quot;是 Unicode 标志符的第一个有效字符&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断字符 c 是否是空白字符</span><br><span class="line">        char c &#x3D; &#39; &#39;;</span><br><span class="line">        System.out.println(&quot;字符 c 是空白字符吗？&quot;+Character.isWhitespace(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。  </p><p>Boolean 类的构造方法也有两个：  </p><ol><li><p>Boolean(boolean value)，创建一个表示 value 参数的 Boolean 对象，如Boolean b = new Boolean(true)  </p></li><li><p>Boolean(String s)，如果 String 参数不为 null 且在忽略大小写时等于 “true”, 创建一个表示 true 值的 Boolean 对象，如Boolean b = new Boolean(“ok”)，为 false。  </p></li></ol><p>Boolean 常用方法  </p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>booleanValue()</td><td>boolean</td><td>将Boolean 对象的值以对应的boolean值返回</td></tr><tr><td>equals(Object obj)</td><td>boolean</td><td>判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，而且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td></tr><tr><td>parseBoolean(String s)</td><td>boolean</td><td>将字符串参数解析为 boolean 值</td></tr><tr><td>toString()</td><td>String</td><td>返回表示该 boolean 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Boolean</td><td>返回一个用指定得字符串表示值的 boolean 值</td></tr></tbody></table><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BooleanTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; Boolean(boolean value) 构造方法</span><br><span class="line">        Boolean a &#x3D; new Boolean(true);</span><br><span class="line">        System.out.println(&quot;a 为&quot;+a);</span><br><span class="line">        &#x2F;&#x2F; Boolean(String s) 构造方法</span><br><span class="line">        Boolean b &#x3D; new Boolean(&quot;true&quot;);</span><br><span class="line">        Boolean c &#x3D; new Boolean(&quot;OK&quot;);</span><br><span class="line">        System.out.println(&quot;b 为&quot;+b);</span><br><span class="line">        System.out.println(&quot;c 为&quot;+c);</span><br><span class="line">        System.out.println(&quot;a 的 booleanValue() 为&quot;+a.booleanValue());</span><br><span class="line">        System.out.println(&quot;a 和 b 相等吗？&quot;+a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>我们经常使用 String 类来定义一个字符串。字符串是常量，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。<br>String 对象的初始化格式有如下两种：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s0 &#x3D; &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">String s1 &#x3D; new String(&quot;abd&quot;);</span><br></pre></td></tr></table></figure><p>String 类具有丰富的方法，比如计算字符串的长度、连接字符串、比较字符串、提取字符串等等。  </p><h4 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h4><p>计算字符串长度  </p><p>调用方法： <strong><em>字符串标识符。length();</em></strong>  返回一个 int 类型的整数（字符串中字符数，中文字符也是一个字符）。例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">String s2 &#x3D; &quot;Java 语言&quot;;</span><br><span class="line">int len1 &#x3D; s1.length();</span><br><span class="line">int len2 &#x3D; s2.length();</span><br></pre></td></tr></table></figure><p>则变量 len1 的值是 3，变量 len2 的值是 6。   </p><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。  </p><p>equals() 方法比较是从第一字符开始，一个字符一个字符依次比较。  </p><p>那如果我想忽略掉大小写关系，比如：java 和 Java 是一样的，我们怎么办呢？我们可以调用equalsIgnoreCase()方法，其用法与 equals 一致，不过它会忽视大小写。  </p><p>比如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String s &#x3D; new String(&quot;Java&quot;);</span><br><span class="line">        String m &#x3D; &quot;java&quot;;</span><br><span class="line">        System.out.println(&quot;用 equals() 比较，java 和 Java 结果为&quot;+s.equals(m));</span><br><span class="line">        System.out.println(&quot;用 equalsIgnoreCase() 比较，java 和 Java 结果为&quot;+s.equalsIgnoreCase(m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用”==”比较的是两个对象在内存中存储的地址是否一样。例如： String s1 = “abc”; String s2 = new String(“abc”); boolean b = (s1 == s2); 则变量 b 的值是 false，因为 s1 对象对应的地址是”abc”的地址，而 s2 使用 new 关键字申请新的内存，所以内存地址和 s1 的”abc”的地址不一样，所以获得的值是 false。  </p><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>字符串连接有两种方法：  </p><ol><li>使用 <strong><em>+</em></strong> 比如 String s = “Hello “ + “World!”;</li><li>使用String类的 <strong><em>concat()</em></strong>方法  </li></ol><p>示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s0 &#x3D; new String(&quot;Hello &quot;);</span><br><span class="line">String s1 &#x3D; &quot;World&quot; + &quot;!&quot;;   &#x2F;&#x2F;+号连接</span><br><span class="line">String s2 &#x3D; s0.concat(s1); &#x2F;&#x2F;concat() 方法连接</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure><p>而且使用+进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。  </p><h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h4><p>charAt()方法的作用是按照索引值（规定字符串中第一个字符的索引值是0，第二个字符的索引值是1，依次类推），获得字符串中的指定字符。  </p><p>例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;abc&quot;;</span><br><span class="line">char c &#x3D; s.charAt(1);</span><br></pre></td></tr></table></figure><h4 id="字符串常用提取方法"><a href="#字符串常用提取方法" class="headerlink" title="字符串常用提取方法"></a>字符串常用提取方法</h4><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>indexOf(int ch)</td><td>int</td><td>搜索字符 ch 第一次出现的索引</td></tr><tr><td>indexOf(String value)</td><td>int</td><td>搜索字符串 value 第一次出现的索引</td></tr><tr><td>lastIndexOf(int ch)</td><td>int</td><td>搜索字符 ch 最后一次出现的索引</td></tr><tr><td>lastIndexOf(String value)</td><td>int</td><td>搜索字符串 value 最后一次出现的索引</td></tr><tr><td>substring(int index)</td><td>String</td><td>提取从位置索引开始到结束的字符串</td></tr><tr><td>substring(int beginindex, int endindex)</td><td>String</td><td>提取 beginindex 和 endindex 之间的字符串部分</td></tr><tr><td>trim()</td><td>String</td><td>返回一个前后不含任何空格的调用字符串的副本</td></tr></tbody></table><p>说明：在字符串中，第一个字符的索引为 0，子字符串包含 beginindex 的字符，但不包含 endindex 的字符。  </p><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         String s &#x3D; &quot;abcdefabc&quot;;</span><br><span class="line">         System.out.println(&quot;字符 a 第一次出现的位置为&quot;+s.indexOf(&#39;a&#39;));</span><br><span class="line">         System.out.println(&quot;字符串 bc 第一次出现的位置为&quot;+s.indexOf(&quot;bc&quot;));</span><br><span class="line">         System.out.println(&quot;字符 a 最后一次出现的位置为&quot;+s.lastIndexOf(&#39;a&#39;));</span><br><span class="line">         System.out.println(&quot;从位置 3 开始到结束的字符串&quot;+s.substring(3));</span><br><span class="line">         System.out.println(&quot;从位置 3 开始到 6 之间的字符串&quot;+s.substring(3,6));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>String 类的字符串创建后是不能够改变的。  </p><p>示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s &#x3D; &quot;Hello &quot;;</span><br><span class="line">s.concat(&quot;World!&quot;);   &#x2F;&#x2F;字符串连接</span><br><span class="line">System.out.println(s); &#x2F;&#x2F;输出 s，还是&quot;Hello &quot;</span><br><span class="line">s &#x3D; s.concat(&quot;World!&quot;);  &#x2F;&#x2F;把字符串对象连接的结果赋给了 s 引用</span><br><span class="line">System.out.println(s);  &#x2F;&#x2F;输出 s，变成了&quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">上述三条语句其实产生了 3 个 String 对象，&quot;Hello &quot;，&quot;World!&quot;，&quot;Hello World!&quot;。第 2 条语句确实产生了&quot;Hello World&quot;字符串，但是没有指定把该字符串的引用赋给谁，因此没有改变 s 引用。第 3 条语句根据不变性，并没有改变&quot;Hello &quot;，JVM 创建了一个新的对象，把&quot;Hello &quot;，&quot;World!&quot;的连接赋给了 s 引用，因此引用变了，但是原对象没变。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>String 的不变性的机制显然会在 String 常量内有大量的冗余。比如我创建一个循环，使字符’1’依次连接到’n’，那么系统就得创建 n+(n-1) 个 String 对象。那有没有可变的 String 类呢？  </p><p>StringBuffer 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的，这里建议大家去看一看 String 类与 StringBuffer 类的区别，理解一下他们在内存中的存储情况）  </p><p>构造方法：  </p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer()</td><td>构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符</td></tr><tr><td>StringBuffer(CharSequence seq)</td><td>构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符</td></tr><tr><td>StringBuffer(int capacity)</td><td>构造一个不带字符，但具有指定初始容量的字符串缓冲区</td></tr><tr><td>StringBuffer(String str)</td><td>构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</td></tr></tbody></table><p>常用方法：  </p><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>insert(int offsetm,Object s)</td><td>StringBuffer</td><td>在 offsetm 的位置插入字符串 s</td></tr><tr><td>append(Object s)</td><td>StringBuffer</td><td>在字符串末尾追加字符串 s</td></tr><tr><td>length()</td><td>int</td><td>确定 StringBuffer 对象的长度</td></tr><tr><td>setCharAt(int pos,char ch)</td><td>void</td><td>使用 ch 指定的新值设置 pos 指定的位置上的字符</td></tr><tr><td>toString()</td><td>String</td><td>转换为字符串形式</td></tr><tr><td>reverse()</td><td>StringBuffer</td><td>反转字符串</td></tr><tr><td>delete(int start, int end)</td><td>StringBuffer</td><td>删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列</td></tr><tr><td>replace(int start, int end, String s)</td><td>StringBuffer</td><td>使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</td></tr></tbody></table><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;定义和初始化一个 StringBuffer 类的字串 s</span><br><span class="line">        StringBuffer s &#x3D; new StringBuffer(&quot;I&quot;);</span><br><span class="line">        &#x2F;&#x2F;在 s 后面添加字串&quot; java&quot;</span><br><span class="line">        s.append(&quot; java&quot;);</span><br><span class="line">        &#x2F;&#x2F;在 s[1] 的位置插入字串</span><br><span class="line">        s.insert(1, &quot; love&quot;);</span><br><span class="line">        String t &#x3D; s.toString(); &#x2F;&#x2F;转为字符串</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>我们在编程的过程中，经常对一些数字进行数学操作，比如我们想要求绝对值或余弦什么的。那这些方法是否需要我们自己实现吗？其实在 java.lang 里的 Math 类 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。我们就来学习一下吧！  </p><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>sin(double numvalue)</td><td>double</td><td>计算角 numvalue 的正弦值</td></tr><tr><td>cos(double numvalue)</td><td>double</td><td>计算角 numvalue 的余弦值</td></tr><tr><td>acos(double numvalue)</td><td>double</td><td>计算 numvalue 的反余弦</td></tr><tr><td>asin(double numvalue)</td><td>double</td><td>计算 numvalue 的反正弦</td></tr><tr><td>atan(double numvalue)</td><td>double</td><td>计算 numvalue 的反正切</td></tr><tr><td>pow(double a, double b)</td><td>double</td><td>计算 a 的 b 次方</td></tr><tr><td>sqrt(double numvalue)</td><td>double</td><td>计算给定值的正平方根</td></tr><tr><td>abs(int numvalue)</td><td>int</td><td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>ceil(double numvalue)</td><td>double</td><td>返回大于等于 numvalue 的最小整数值</td></tr><tr><td>floor(double numvalue)</td><td>double</td><td>返回小于等于 numvalue 的最大整数值</td></tr><tr><td>max(int a, int b)</td><td>int</td><td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>min(int a, int b)</td><td>int</td><td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td></tr><tr><td>rint(double numvalue)</td><td>double</td><td>返回最接近 numvalue 的整数值</td></tr><tr><td>round(T arg)</td><td>arg 为 double 时返回 long，为 float 时返回 int</td><td>返回最接近 arg 的整数值</td></tr><tr><td>random()</td><td>double</td><td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td></tr></tbody></table><blockquote><p>更多方法 请参照 官方api  </p></blockquote><p>代码示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Math.abs(-12.7));</span><br><span class="line">        System.out.println(Math.ceil(12.7));</span><br><span class="line">        System.out.println(Math.rint(12.4));</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        System.out.println(&quot;sin30 &#x3D; &quot; + Math.sin(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算 30°的正弦值，参数是用弧度表示的角，即π的六分之一</span><br><span class="line">        System.out.println(&quot;cos30 &#x3D; &quot; + Math.cos(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算 30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为 double</span><br><span class="line">        System.out.println(&quot;tan30 &#x3D; &quot; + Math.tan(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算 30°的正切值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会觉得简单的计算很枯燥，但在合适的地方用到它们可以让你的程序（比如游戏中飞行轨迹的计算）更加精彩。  </p><h4 id="实战小项目-生成彩票号码"><a href="#实战小项目-生成彩票号码" class="headerlink" title="实战小项目-生成彩票号码"></a>实战小项目-生成彩票号码</h4><p>有了之前的基础，我们来做个更好玩的项目——彩票生成器。目前市面上彩票的种类很多，我们就以大乐透为例吧。大乐透的规则是：从 135 中随机选取 5 个不重复的数字，从 112 中随机选取 2 个不重复的数字，这些数字组成了一个七位数。如果你买的号码与摇出来的号码相同，那么你一夜之间可能就不会当程序员了。  </p><p>因为彩票号码是随机生成的，所以这个项目中我们也会带大家认识随机数的使用方法。首先请在先创建一个Lottery类。  </p><p>我们需要用到  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br></pre></td></tr></table></figure><p>由于彩票号码的前半段和后半段的规则和个数略有不同，所以我们分别创建生成它们的方法。  </p><p>首先来创建生成前段号码的方法getHeadNumber()，该方法需要从 1 到 36 中随机选取一个数作为号码（即摇号的过程）。对于个位数，为了显示上更整齐，所以我们在其十位再放一个“0”。再者，为了结果更加易读，我们还需要调用Collections.sort()方法对结果进行排序。  </p><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; getHeadNumber() &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); </span><br><span class="line">        &#x2F;&#x2F; 创建彩票的前半段号码集合</span><br><span class="line">        String lotteryNumber &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 36; i++) &#123; </span><br><span class="line">            &#x2F;&#x2F; 这个循环是为了初始化彩票的前半段号码集合</span><br><span class="line"></span><br><span class="line">            if (i &lt; 10) &#123;</span><br><span class="line">                list.add(&quot;0&quot; + i + &quot;  &quot;);</span><br><span class="line">                &#x2F;&#x2F; 在集合中添加 0~9 的号码，因为是个位数，为了显示上更加人性化，所以需要在十位的地方添加“0”</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                list.add(&quot;&quot; + i + &quot;  &quot;);</span><br><span class="line">                &#x2F;&#x2F; 向集合添加大于 9 的号码，即添加双位数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int roundIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 创建并初始化随机数</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; lotteryList &#x3D; new ArrayList&lt;String&gt;(); </span><br><span class="line">        &#x2F;&#x2F; 保存前段号码的 List 集合</span><br><span class="line"></span><br><span class="line">        for (int j &#x3D; 0; j &lt; 5; j++) &#123;</span><br><span class="line">            int amount &#x3D; list.size(); &#x2F;&#x2F; 获取前半段号码的个数</span><br><span class="line">            Random r &#x3D; new Random(); &#x2F;&#x2F; 创建并实例化 Random 的对象</span><br><span class="line">            roundIndex &#x3D; r.nextInt(amount); &#x2F;&#x2F; 获取一个 0 到 amount-1 的随机数</span><br><span class="line">            lotteryNumber &#x3D; list.get(roundIndex); &#x2F;&#x2F; 获取彩票数字，即摇号的号码</span><br><span class="line">            lotteryList.add(lotteryNumber); &#x2F;&#x2F; 将彩票号码添加 lotteryList 中</span><br><span class="line">            list.remove(roundIndex); &#x2F;&#x2F; 移除刚刚产生的号码</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(lotteryList); </span><br><span class="line">        &#x2F;&#x2F; 对前半段号码进行排序，排序的目的是为了让结果更具可读性</span><br><span class="line">        return lotteryList;</span><br><span class="line">        &#x2F;&#x2F;返回前半段号码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处用到了Random()方法，在创建一个 Random 对象r后，你可以调用该对象的nextInt()方法得到一个随机数。r.nextInt(amount);中的 amount 是随机数的上限，产生的随机数为 0 到 100（不含 100）的整数。 你可以 <a href="http://www.cnblogs.com/ningvsban/p/3590722.html">了解更多 Random 的用法</a>。  </p><p>和前半段号码类似，我们接着来写生成后半段号码的方法getRearNum()，代码片段如下：  </p><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; getRearNumber() &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(); </span><br><span class="line">        &#x2F;&#x2F; 创建后半段号码集合，也就是最后两个球的数字</span><br><span class="line"></span><br><span class="line">        String lotteryNumber &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 13; i++) &#123; </span><br><span class="line">            &#x2F;&#x2F; 初始化后半段号码集合</span><br><span class="line"></span><br><span class="line">            if (i &lt; 10) &#123;</span><br><span class="line">                list.add(&quot;0&quot; + i + &quot;  &quot;);</span><br><span class="line">                &#x2F;&#x2F; 添加 0~9 的号码，原理同前半段</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                list.add(&quot;&quot; + i + &quot;  &quot;);</span><br><span class="line">                &#x2F;&#x2F; 添加大于 9 的号码</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int roundIndex &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;创建并初始化随机数</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; lotteryList &#x3D; new ArrayList&lt;String&gt;(); </span><br><span class="line">        &#x2F;&#x2F; 保存后半段号码的 List 集合</span><br><span class="line"></span><br><span class="line">        for (int j &#x3D; 0; j &lt; 2; j++) &#123;</span><br><span class="line">            int amount &#x3D; list.size(); &#x2F;&#x2F; 获取后半段号码的个数</span><br><span class="line">            Random r &#x3D; new Random(); &#x2F;&#x2F; 创建并实例化 Random 的对象</span><br><span class="line">            roundIndex &#x3D; r.nextInt(amount); &#x2F;&#x2F; 获取一个 0 到 amount-1 的随机数</span><br><span class="line">            lotteryNumber &#x3D; list.get(roundIndex); &#x2F;&#x2F; 摇号</span><br><span class="line">            lotteryList.add(lotteryNumber); &#x2F;&#x2F; 将彩票号码添加 lotteryList 中</span><br><span class="line">            list.remove(roundIndex); &#x2F;&#x2F; 移除刚刚产生的号码</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(lotteryList); </span><br><span class="line">        &#x2F;&#x2F; 对后半段号码进行排序</span><br><span class="line">        return lotteryList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在，根据规则我们已经能够产生对应的数字了。再接再厉，我们再做一个生成最终结果的方法，把这两个号段组装成整体的号码，并且按照用户的要求产生多少组号码，在控制台输出它们。  </p><p>下面给出了这个方法的代码片段：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void generateLottery(String groupNum) &#123;</span><br><span class="line"></span><br><span class="line">        int groupNumber &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;为了避免不必要的错误，一般在创建变量时都要为其赋初始值</span><br><span class="line"></span><br><span class="line">        groupNumber &#x3D; Integer.parseInt(groupNum);</span><br><span class="line">        StringBuilder sbuiler &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F; 创建字符串生成器对象，使用字符串生成器能够较为方便地在字符串中追加内容</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; groupNumber; i++) &#123;</span><br><span class="line">            List&lt;String&gt; startList &#x3D; getHeadNumber();</span><br><span class="line">            &#x2F;&#x2F; 获得彩票前半段号码的集合</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; endList &#x3D; getRearNumber();</span><br><span class="line">            &#x2F;&#x2F; 获得彩票后半段号码的集合</span><br><span class="line"></span><br><span class="line">            for (int m &#x3D; 0; m &lt; startList.size(); m++) &#123;</span><br><span class="line">                sbuiler.append(startList.get(m));</span><br><span class="line">                &#x2F;&#x2F; append() 即为追加方法，用于添加彩票的前半段号码到字符串生成器中</span><br><span class="line">            &#125;</span><br><span class="line">            sbuiler.append(&quot;    &quot;);</span><br><span class="line">            for (int n &#x3D; 0; n &lt; endList.size(); n++) &#123;</span><br><span class="line">                sbuiler.append(endList.get(n));</span><br><span class="line">                &#x2F;&#x2F; 添加彩票的后半段号码到字符串生成器中</span><br><span class="line">            &#125;</span><br><span class="line">            sbuiler.append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sbuiler.toString());</span><br><span class="line">        &#x2F;&#x2F;将每组生成好的彩票号码即时输出</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了验证我们的实现无误，在同一个目录中创建一个名为LotteryTest的测试类，编写其main()方法。在其中创建一个彩票对象并调用其产生号码的方法。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class LotteryTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Lottery l &#x3D; new Lottery();</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);&#x2F;&#x2F; 创建扫描器</span><br><span class="line">        System.out.println(&quot;Please input the number of lottery group(s) that you want to generate : &quot;);</span><br><span class="line">        &#x2F;&#x2F; 获得用户输入的需要生成的中奖号码个数</span><br><span class="line"></span><br><span class="line">        String groupNum &#x3D; scan.nextLine();</span><br><span class="line">        l.generateLottery(groupNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下代码，编译并运行  </p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即每一个类，在生成的.class文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。我们获取 Class 实例有三种方法：  </p><ol><li><p>利用对象调用 getClass()方法获取该对象的 Class 实例</p></li><li><p>使用 Class 类的静态方法 forName(String className)，用类的名字获取一个 Class 实例  </p></li><li><p>运用.class的方式来获取 Class 实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例  </p></li></ol><p>关于Class 示例代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ClassDemo&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        String objString &#x3D; new String();</span><br><span class="line">        @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">        Class objClass;</span><br><span class="line">        objClass &#x3D; objString.getClass();</span><br><span class="line">        System.out.println(&quot;String 对象的类型是:&quot;+objClass.getName());</span><br><span class="line">        objClass &#x3D; Integer.class;</span><br><span class="line">        System.out.println(&quot;Integer 对象的类型是:&quot; + objClass.getName());</span><br><span class="line">        objClass &#x3D; Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">        System.out.println(&quot;Character 对象的类型是:&quot;+ objClass.getName());</span><br><span class="line">        objClass &#x3D; objClass.getSuperclass();</span><br><span class="line">        System.out.println(&quot;Character 对象的父类是:&quot;+ objClass.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class 类没有共有的构造方法,它由JVM自动调用.Class类的方法在这里就不细讲了，有兴趣的可以自己查询一下.  </p><blockquote><p><a href="http://blog.csdn.net/u010858605/article/details/53454830">官方详解</a></p></blockquote><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 类是所有类的父类,所有对象（包括数组）都实现这个类的方法。所以在默认的情况下，我们定义的类扩展自Object类，那我们当然可以调用和重写Object类里面的所有方法.  </p><p>Object 定义方法 :  </p><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>equals(Objectobj)</td><td>boolean</td><td>将当前对象实例与给定的对象进行比较，检查它们是否相等</td></tr><tr><td>finalize() throws Throwable</td><td>void</td><td>当垃圾回收期确定不存在对象的更多引用时，由对象的垃圾回收期调用此方法. 通常被子类重写</td></tr><tr><td>getClass()</td><td>Class</td><td>返回当前对象的Class对象</td></tr><tr><td>toString()</td><td>String</td><td>返回此对象的字符创标识</td></tr><tr><td>wait() throws InterruptedException</td><td>void</td><td>在其他线程调用此对象的notify() 方法或 notifyAll() 方法前，使当前线程进入等待状态</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java lang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 日期和随机数</title>
      <link href="2020/01/03/java-%E6%97%A5%E6%9C%9F%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%95%B0-2020-01-03/"/>
      <url>2020/01/03/java-%E6%97%A5%E6%9C%9F%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%95%B0-2020-01-03/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-日期和随机数"><a href="#Java-日期和随机数" class="headerlink" title="Java 日期和随机数"></a>Java 日期和随机数</h2><blockquote><p>这一章节 我们主要学习 java.util 中的 Date 类、Calendar 类，Random 类以及 java.time 包中的 LocalTime 类。  </p></blockquote><h3 id="java-util-和-java-time-包"><a href="#java-util-和-java-time-包" class="headerlink" title="java.util 和 java.time 包"></a>java.util 和 java.time 包</h3><p>ava.util 包提供了一些实用的方法和数据结构。比如日期类 Date，日历类 Calendar 以及随机数类 Random，同时包里还提供了 collection 框架，像堆栈 Stack、向量 Vector、位集合 Bitset 以及哈希表 Hashtable 等表示数据结构的类。而 java.time 包是 java8 新提供的包，里面对时间和日期提供了新的 api，弥补了 java.util 包对日期和时间操作的不足。  </p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>Date 类表示时间和日期,里面封装了操作日期和时间的方法. Date类经常用来获取系统当前时间。  </p><p>Date中当前未过时的构造方法:   </p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Date()</td><td>构造一个Date对象并对其进行初始化以反映当前时间</td></tr><tr><td>Date(long date)</td><td>构造一个Date对象，并根据相对于GMT1970年1月1日 00:00:00 的毫秒数对其进行初始化</td></tr></tbody></table><p>代码示例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        String strDate, strTime &#x3D; &quot;&quot;;</span><br><span class="line">        Date objDate &#x3D; new Date();</span><br><span class="line">        System.out.println(&quot;今天的日期是：&quot; + objDate);</span><br><span class="line">        long time &#x3D; objDate.getTime();</span><br><span class="line">        System.out.println(&quot;自 1970 年 1 月 1 日起以毫秒为单位的时间（GMT）：&quot; + time);</span><br><span class="line">        strDate &#x3D; objDate.toString();</span><br><span class="line">        &#x2F;&#x2F;提取 GMT 时间</span><br><span class="line">        strTime &#x3D; strDate.substring(11,(strDate.length() - 4));</span><br><span class="line">        &#x2F;&#x2F;按小时、分钟和秒提取时间</span><br><span class="line">        strTime &#x3D; &quot;时间：&quot; + strTime.substring(0,8);</span><br><span class="line">        System.out.println(strTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示 Date 很多方法在JDK1.1开始就已经过时了.想要了解可以去官网查询  </p></blockquote><h4 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h4><p>在早期的JDK版本中，Date类附有两大功能：  </p><ol><li>允许用年、月、日、时、分、秒来解释日期</li><li>允许对表示日期的字符串进行格式化和句法分析  </li></ol><p>在JDK1.1中提供了类Calendar来完成第一种功能，类DateFormat来完成第二项功能。DateFormat是java.text包中的一个类。与Date类有所不同的是，DateFormat类可以接受用各种语言和不同习惯表示的日期字符串。  </p><p>但是Calendar类是一个抽象类，它完成Date类与普通日期表示法之间的转换，而我们更多的是使用Calendar类的子类GregorianCalendar类。它实现了世界上普遍的公历系统。当然我们也可以继承Calendar类，然后自己定义实现日历的方法.  </p><p>GregorianCalendar 构造方法：  </p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>GregorianCalendar</td><td>创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处的时区、地点的当前时间</td></tr><tr><td>GregorianCalendar(TimeZone zone)</td><td>创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间</td></tr><tr><td>GregorianCalendar(Locale aLocale)</td><td>创建的对象中的相关值被设置成缺省的时区，指定地点aLocale的当前时间</td></tr><tr><td>GregorianCalendar(TimeZone zone,Locale aLocale)</td><td>year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间</td></tr></tbody></table><p>TimeZone是java.util包中的一个类，其中封装了有关时区的信息。每一个时区对应一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。  </p><p>例如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 太平洋时区的ID为PST</span><br><span class="line">TimeZone tz0 &#x3D; TimeZone.getTimeZone(&quot;PST&quot;);</span><br><span class="line">&#x2F;&#x2F; getDefault() 可以获取主机所处时区对象</span><br><span class="line">TimeZone tz1 &#x3D; TimeZone.getDefault();</span><br></pre></td></tr></table></figure><p>Locale只是一种机制，它用来标识一个特定的地理、政治或文化区域获取一个Locale对象的构造方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用 Locale 类的构造方法  </span><br><span class="line">Locale 10 &#x3D; new Locale(String language);</span><br><span class="line">Locale 11 &#x3D; new Locale(String language,String country);</span><br><span class="line">Locale 12 &#x3D; new Locale(String language, String country, String variant);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用 Locale 类中定义的常量  </span><br><span class="line">Locale 11 &#x3D; Locale.CHINA;</span><br></pre></td></tr></table></figure><p>一个简单的示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"></span><br><span class="line">public class CalendarDemo</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到日期格式对象</span><br><span class="line">    &#x2F;&#x2F; Date date &#x3D; fmt.parse(strDateMake);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;完整显示日期时间：&quot;);</span><br><span class="line">    &#x2F;&#x2F; 字符串转换日期格式</span><br><span class="line">    DateFormat fdate &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    String str &#x3D;fdate.format(new Date());</span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Calendar 对象</span><br><span class="line">    Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">    &#x2F;&#x2F; 初始化 Calendar 对象，但并不必要，除非需要重置时间</span><br><span class="line">    calendar.setTime(new Date());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 显示年份</span><br><span class="line">    System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 显示月份 （从 0 开始，实际显示要加一）</span><br><span class="line">    System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前分钟数</span><br><span class="line">    System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 今年的第 N 天</span><br><span class="line">    System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 本月第 N 天</span><br><span class="line">    System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3 小时以后</span><br><span class="line">    calendar.add(Calendar.HOUR_OF_DAY, 3);</span><br><span class="line">    System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime());</span><br><span class="line">    &#x2F;&#x2F; 格式化显示</span><br><span class="line">    str &#x3D; (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());</span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重置 Calendar 显示当前时间</span><br><span class="line">    calendar.setTime(new Date());</span><br><span class="line">    str &#x3D; (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());</span><br><span class="line">    System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建一个 Calendar 用于比较时间</span><br><span class="line">    Calendar calendarNew &#x3D; Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设定为 5 小时以前，后者大，显示 -1</span><br><span class="line">    calendarNew.add(Calendar.HOUR, -5);</span><br><span class="line">    System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设定 7 小时以后，前者大，显示 1</span><br><span class="line">    calendarNew.add(Calendar.HOUR, +7);</span><br><span class="line">    System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 退回 2 小时，时间相同，显示 0</span><br><span class="line">    calendarNew.add(Calendar.HOUR, -2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; calendarNew 创建时间点</span><br><span class="line">    System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime()));</span><br><span class="line">    &#x2F;&#x2F; calendar 创建时间点</span><br><span class="line">    System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()));</span><br><span class="line">    System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。  </p><p>有的人可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。</p><h4 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h4><p>因为 java8 之前的日期和时间 api 饱受诟病，比如线程安全问题，比如 Date 的月份是从 0 开始的！而 java.time 包中将月份封装成为了枚举类型。接下来来看看如何使用这个新的时间报  </p><p>首先了解一下 LocalTime 类，LocalTime 类是一个不可变类（也就是用 final 修饰的类），和 String 类一样，所以它是线程安全的。除了 LocalTime 还有 LocalDate（日期）、LocalDateTime（日期和时间）等，他们的使用方式都差不多。下面来实际编写一下。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import java.time.*;</span><br><span class="line">import java.time.temporal.ChronoUnit;</span><br><span class="line"></span><br><span class="line">public class TimeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获得当前的日期和时间</span><br><span class="line">        LocalDateTime currentTime &#x3D; LocalDateTime.now();</span><br><span class="line">        System.out.println(&quot;current date and time: &quot; + currentTime);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出当前时间的本地值（本时区）</span><br><span class="line">        LocalDate date1 &#x3D; currentTime.toLocalDate();</span><br><span class="line">        System.out.println(&quot;local date: &quot; + date1);</span><br><span class="line"></span><br><span class="line">        Month month &#x3D; currentTime.getMonth();</span><br><span class="line">        int day &#x3D; currentTime.getDayOfMonth();</span><br><span class="line">        int seconds &#x3D; currentTime.getSecond();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由当前时间对象获得各个字段，输出结果</span><br><span class="line">        System.out.println(&quot;month: &quot; + month +&quot;day: &quot; + day +&quot;seconds: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 由当前时间附带月份和年再输出</span><br><span class="line">        LocalDateTime date2 &#x3D; currentTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">        System.out.println(&quot;date 2: &quot; + date2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出 2016 年圣诞节的日期</span><br><span class="line">        LocalDate date3 &#x3D; LocalDate.of(2016, Month.DECEMBER, 25);</span><br><span class="line">        System.out.println(&quot;date 3: &quot; + date3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出新闻联播的开始时间</span><br><span class="line">        LocalTime date4 &#x3D; LocalTime.of(19, 00);</span><br><span class="line">        System.out.println(&quot;date 4: &quot; + date4);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 转化为字符串，再输出</span><br><span class="line">        LocalTime date5 &#x3D; LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">        System.out.println(&quot;date 5: &quot; + date5);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将字符串代表的时区信息转化</span><br><span class="line">        ZonedDateTime date6 &#x3D; ZonedDateTime.parse(&quot;2016-04-20T19:22:15+01:30[Europe&#x2F;Paris]&quot;);</span><br><span class="line">        System.out.println(&quot;date1: &quot; + date6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设定地区 ID 为亚洲的加尔各答（位于印度），并输出</span><br><span class="line">        ZoneId id &#x3D; ZoneId.of(&quot;Asia&#x2F;Kolkata&quot;);</span><br><span class="line">        System.out.println(&quot;ZoneId: &quot; + id);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获得系统默认的当前地区并输出</span><br><span class="line">        ZoneId currentZone &#x3D; ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;CurrentZone: &quot; + currentZone);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获得当前的日期并输出</span><br><span class="line">        LocalDate today &#x3D; LocalDate.now();</span><br><span class="line">        System.out.println(&quot;Current date: &quot; + today);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在当前日期的基础上增加两周时间再输出</span><br><span class="line">        LocalDate nextWeek &#x3D; today.plus(2, ChronoUnit.WEEKS);</span><br><span class="line">        System.out.println(&quot;two weeks after now: &quot; + nextWeek);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在当前日期的基础上增加 6 个月的时间再输出</span><br><span class="line">        LocalDate nextMonth &#x3D; today.plus(6, ChronoUnit.MONTHS);</span><br><span class="line">        System.out.println(&quot;6 months after now: &quot; + nextMonth);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在当前日期的基础上增加 5 年的时间再输出</span><br><span class="line">        LocalDate nextYear &#x3D; today.plus(5, ChronoUnit.YEARS);</span><br><span class="line">        System.out.println(&quot;5 years after now: &quot; + nextYear);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在当前日期的基础上增加 20 年的时间再输出（一个 Decade 为 10 年）</span><br><span class="line">        LocalDate nextDecade &#x3D; today.plus(2, ChronoUnit.DECADES);</span><br><span class="line">        System.out.println(&quot;20 years after now: &quot; + nextDecade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>java实用工具类库中的类 java.util.Random 提供了昌盛各种类型随机的方法。它可以产生int、long、float、double 以及Gaussian等类型的随机数。这也是它与java.lang.Math 中的方法Random() 最大的不同之处，后者只产生double型的随机数  </p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Random()</td><td>产生一个随机数需要基数，这里将系统时间作为seed</td></tr><tr><td>Random(long seed)</td><td>使用单个long种子创建一个新的随机数生成器</td></tr></tbody></table><p>普通方法原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;该方法是设定基值 seed</span><br><span class="line">public synchronized void setSeed(long seed)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该方法是产生一个整型随机数</span><br><span class="line">public int nextInt()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该方法是产生一个 long 型随机数</span><br><span class="line">public long nextLong()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该方法是产生一个 Float 型随机数</span><br><span class="line">public float nextFloat()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该方法是产生一个 Double 型随机数</span><br><span class="line">public double nextDouble()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;该方法是产生一个 double 型的 Gaussian 随机数</span><br><span class="line">public synchronized double nextGaussian()</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">synchronized  是 Java 语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>大家可以验证和尝试一下引入上面所讲的所有类，调用一下里面的各种方法</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线文档-jdk-zh</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 日期 </tag>
            
            <tag> java 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 集合框架</title>
      <link href="2020/01/03/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-2020-01-03/"/>
      <url>2020/01/03/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-2020-01-03/</url>
      
        <content type="html"><![CDATA[<h2 id="java-集合框架"><a href="#java-集合框架" class="headerlink" title="java 集合框架"></a>java 集合框架</h2><h3 id="集合框架的介绍"><a href="#集合框架的介绍" class="headerlink" title="集合框架的介绍"></a>集合框架的介绍</h3><p>我们在超市买东西的时候，如果没有购物车是不是会很麻烦呢？Java 中集合类是一种工具类，就是像购物车一样的容器，存储任意数量的具有共同属性的对象。  </p><p>我们为什么要用集合呢？一个类的内部有许多相同类型的属性，并且他们的作用与意义是一样的，我们最好用一个类似容器的东西去盛放他们，在类的内部就变得井然有序。所以集合便是在类的内部，对数据进行组织的作用。这样我们便可以简单而快速地搜索大量的条目。有的集合接口，提供了一系列排列有序的元素，并且可以在序列中快速地插入或者删除有关元素。还有一些集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型。  </p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。  </p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>因为集合框架中的很多类功能是相似的，所以我们用接口来规范类。  </p><p>Collection接口是java集合框架里的一个根接口。他也是List、Set和Queue 接口的父接口。Collection接口中定义了可用于操作List、Set和Queue的方法–增删改查  </p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(E e)</td><td>boolean</td><td>向collection的尾部追加指定的元素（可选操作）</td></tr><tr><td>addAll(Collection&lt;? extend E&gt; c)</td><td>boolean</td><td>将指定collection 中的所有元素都添加此collection中(可选操作)</td></tr><tr><td>clear()</td><td>void</td><td>移除此collection中的所有元素（可选操作）</td></tr><tr><td>contains(Object o)</td><td>boolean</td><td>如果此collection包含指定元素，则返回true</td></tr><tr><td>containsAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>如果此collection包含指定collection的所有元素，则返回true</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较此collection与指定对象是否相等</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此collection的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此collection不包含元素 则返回true</td></tr><tr><td>iterator()</td><td>Iterator<E></td><td>返回在此collection的元素上进行迭代的迭代器</td></tr><tr><td>remove(Object o)</td><td>boolean</td><td>移除此collection中出现的首个指定元素（可选操作）</td></tr><tr><td>removeAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td></tr><tr><td>retainAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td></tr><tr><td>size()</td><td>int</td><td>返回此collection中的元素数</td></tr><tr><td>toArray()</td><td>Object[]</td><td>返回包含此collection中所有元素的数组</td></tr><tr><td>toArray(T[] a)</td><td><T> T[]</td><td>返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</td></tr></tbody></table><h3 id="List-接口-与-ArrayList-类"><a href="#List-接口-与-ArrayList-类" class="headerlink" title="List 接口 与 ArrayList 类"></a>List 接口 与 ArrayList 类</h3><p>List是一个接口，不能实例化，需要一个具体类来实现实例化。List集合中的对象按照一定的顺序排放，里面的内容可以重复。List接口实现的类有：ArrayList(实现动态数组)，Vector(实现动态数组), LinkedList(实现链表)，Stack(实现堆栈).  </p><p>List在Collection 基础上的方法  </p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(int index, E element)</td><td>void</td><td>在列表的指定位置插入指定元素（可选操作）</td></tr><tr><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td></tr><tr><td>get(int index)</td><td>E</td><td>返回列表中指定位置的元素</td></tr><tr><td>indexOf(Object o)</td><td>int</td><td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td></tr><tr><td>lastIndexOf(Object o)</td><td>int</td><td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td></tr><tr><td>listIterator()</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序）</td></tr><tr><td>listIterator(int index)</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始</td></tr><tr><td>remove(int index)</td><td>E</td><td>移除列表中指定位置的元素（可选操作）</td></tr><tr><td>set(int index, E element)</td><td>E</td><td>用指定元素替换列表中指定位置的元素（可选操作）</td></tr><tr><td>subList(int fromIndex, int toIndex)</td><td>List<E></td><td>返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图</td></tr></tbody></table><p>今天我们主要来学习　 java.util.ArrayList，ArrayList 　类实现一个可增长的动态数组，它可以存储不同类型的对象，而数组则只能存放特定数据类型的值。  </p><p>我们通过实际的例子来学习 ArrayList 吧！学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名，我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作。  </p><p>先创建一个学生类：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Student(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&#39;&quot; + id + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理学生类:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class ListTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    &#x2F;&#x2F;我们以后会详细讲到</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于存放学生的 List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    public ListTest() &#123;</span><br><span class="line">        this.students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于往 students 中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个学生对象，并通过调用 add 方法，添加到学生管理 List 中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取出 List 中的 Student 对象</span><br><span class="line">        Student temp &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name);</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;, &quot;李四&quot;);</span><br><span class="line">        students.add(0, st2);</span><br><span class="line">        Student temp2 &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对象数组的形式添加</span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Arrays 类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line">        Student temp3 &#x3D; students.get(2);</span><br><span class="line">        Student temp4 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name);</span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(2, Arrays.asList(student2));</span><br><span class="line">        Student temp5 &#x3D; students.get(2);</span><br><span class="line">        Student temp6 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取得 List 中的元素的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testGet() &#123;</span><br><span class="line">        int size &#x3D; students.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">            Student st &#x3D; students.get(i);</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过迭代器来遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动</span><br><span class="line">    public void testIterator() &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过集合的 iterator 方法，取得迭代器实例</span><br><span class="line">        Iterator&lt;Student&gt; it &#x3D; students.iterator();</span><br><span class="line">        System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;);</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Student st &#x3D; it.next();</span><br><span class="line">            System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过 for each 方法访问集合元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过 for each）：&quot;);</span><br><span class="line">        for (Student obj : students) &#123;</span><br><span class="line">            Student st &#x3D; obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用 java8 Steam 将学生排序后输出</span><br><span class="line">        students.stream()&#x2F;&#x2F;创建 Stream</span><br><span class="line">                &#x2F;&#x2F;通过学生 id 排序</span><br><span class="line">                .sorted(Comparator.comparing(x -&gt; x.id))</span><br><span class="line">                &#x2F;&#x2F;输出</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改 List 中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify() &#123;</span><br><span class="line">        students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除 List 中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        Student st &#x3D; students.get(4);</span><br><span class="line">        System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;);</span><br><span class="line">        students.remove(st);</span><br><span class="line">        System.out.println(&quot;成功删除学生！&quot;);</span><br><span class="line">        testForEach();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListTest lt &#x3D; new ListTest();</span><br><span class="line">        lt.testAdd();</span><br><span class="line">        lt.testGet();</span><br><span class="line">        lt.testIterator();</span><br><span class="line">        lt.testModify();</span><br><span class="line">        lt.testForEach();</span><br><span class="line">        lt.testRemove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，用到了 Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。  </p><p>List 有两种基本的类型，除了ArrayList外，还有LinkedList，LinkedList类用于创建链表数据结构，两者的对比如下：  </p><ul><li>ArrayList:它擅长于随机访问元素，但是插入和移除元素很慢  </li><li>LinkedList： 它通过代价较低的在List中进行插入和删除操作，提供了优化的顺序访问，它在随机访问方面相对较慢，但是它的特性集较ArrayList更大。  </li></ul><h4 id="Set接口-和-HashSet-类"><a href="#Set接口-和-HashSet-类" class="headerlink" title="Set接口 和 HashSet 类"></a>Set接口 和 HashSet 类</h4><p>Set接口也是Collection接口的子接口，它有一个很重要也是很常用的实现类————HashSet,Set是元素无序并且不包含重复元素的collection(List可以重复)，被称为集。  </p><p>HashSet由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。  </p><p>接下来我们同样通过代码的形式来详细看一看吧！  </p><p>在上面我们实现了学生的管理，现在学生要做项目，每一个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理</p><p>因为项目组的组长由一个老师担任，首先我们来创建一个 PD 类  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 项目组长类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PD &#123;</span><br><span class="line"></span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    &#x2F;&#x2F;我们以后会详细讲到</span><br><span class="line">    public Set&lt;Student&gt; students;</span><br><span class="line">    public PD(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.students &#x3D; new HashSet&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们便创建一个 SetTest 类，用来管理项目成员  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    public SetTest() &#123;</span><br><span class="line">        students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 用于往 students 中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个学生对象，并通过调用 add 方法，添加到学生管理 List 中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;添加到 List 中的类型均为 Object，所以取出时还需要强转</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;,&quot;李四&quot;);</span><br><span class="line">        students.add(st2);</span><br><span class="line"></span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line"></span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过 for each 方法访问集合元素</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过 for each）：&quot;);</span><br><span class="line">        for(Object obj:students)&#123;</span><br><span class="line">            Student st &#x3D; (Student)obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SetTest st &#x3D; new SetTest();</span><br><span class="line">        st.testAdd();</span><br><span class="line">        st.testForEach();</span><br><span class="line">        PD pd &#x3D; new PD(&quot;1&quot;,&quot;张老师&quot;);</span><br><span class="line">        System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来接收从键盘输入的学生 ID</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i &lt; 3; i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入学生 ID&quot;);</span><br><span class="line">            String studentID &#x3D; console.next();</span><br><span class="line">            for(Student s:st.students)&#123;</span><br><span class="line">                if(s.id.equals(studentID))&#123;</span><br><span class="line">                    pd.students.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.testForEachForSer(pd);</span><br><span class="line">        &#x2F;&#x2F; 关闭 Scanner 对象</span><br><span class="line">        console.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印输出，老师所选的学生！Set 里遍历元素只能用 foreach 和 iterator</span><br><span class="line">    &#x2F;&#x2F;不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素</span><br><span class="line">    public void testForEachForSer(PD pd)&#123;</span><br><span class="line">        for(Student s: pd.students) &#123;</span><br><span class="line">        System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h4><p>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry 对象是无序排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射（key 值不可重复）。  </p><p>下面我们通过代码来学习 Map 中的方法吧。都有过选课经历吧，我们就用 Map 来管理课程吧  </p><p>创建一个Course类  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Course &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Course(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个MapTest类:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来承装课程类型对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Map&lt;String, Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在构造器中初始化 courses 属性</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MapTest() &#123;</span><br><span class="line">        this.courses &#x3D; new HashMap&lt;String, Course&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试添加：输入课程 ID，判断是否被占用</span><br><span class="line">     * 若未被占用，输入课程名称，创建新课程对象</span><br><span class="line">     * 并且添加到 courses 中</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testPut() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来获取输入的课程 ID 和名称</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入课程 ID：&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否被占用</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null)&#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入课程名称</span><br><span class="line">                System.out.println(&quot;请输入课程名称：&quot;);</span><br><span class="line">                String name &#x3D; console.next();</span><br><span class="line">                &#x2F;&#x2F;创建新的课程对象</span><br><span class="line">                Course newCourse &#x3D; new Course(ID,name);</span><br><span class="line">                &#x2F;&#x2F;通过调用 courses 的 put 方法，添加 ID-课程映射</span><br><span class="line">                courses.put(ID, newCourse);</span><br><span class="line">                System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;该课程 ID 已被占用&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试 Map 的 keySet 方法</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void testKeySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 keySet 方法，返回 Map 中的所有键的 Set 集合</span><br><span class="line">        Set&lt;String&gt; keySet &#x3D; courses.keySet();</span><br><span class="line">        &#x2F;&#x2F;遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value</span><br><span class="line">        for(String crID: keySet) &#123;</span><br><span class="line">            Course cr &#x3D; courses.get(crID);</span><br><span class="line">            if(cr !&#x3D; null)&#123;</span><br><span class="line">                System.out.println(&quot;课程：&quot; + cr.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试删除 Map 中的映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取从键盘输入的待删除课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;提示输出待删除的课程 ID</span><br><span class="line">            System.out.println(&quot;请输入要删除的课程 ID！&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否对应的课程对象</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入的 ID 并不存在</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            courses.remove(ID);</span><br><span class="line">            System.out.println(&quot;成功删除课程&quot; + cr.name);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过 entrySet 方法来遍历 Map</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testEntrySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 entrySet 方法，返回 Map 中的所有键值对</span><br><span class="line">        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet &#x3D; courses.entrySet();</span><br><span class="line">        for(Entry&lt;String,Course&gt; entry: entrySet) &#123;</span><br><span class="line">            System.out.println(&quot;取得键：&quot; + entry.getKey());</span><br><span class="line">            System.out.println(&quot;对应的值为：&quot; + entry.getValue().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 利用 put 方法修改 Map 中的已有映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify()&#123;</span><br><span class="line">        &#x2F;&#x2F;提示输入要修改的课程 ID</span><br><span class="line">        System.out.println(&quot;请输入要修改的课程 ID：&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            &#x2F;&#x2F;取得从键盘输入的课程 ID</span><br><span class="line">            String crID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;从 courses 中查找该课程 ID 对应的对象</span><br><span class="line">            Course course &#x3D; courses.get(crID);</span><br><span class="line">            if(course &#x3D;&#x3D; null) &#123;</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！请重新输入！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;提示当前对应的课程对象的名称</span><br><span class="line">            System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name);</span><br><span class="line">            &#x2F;&#x2F;提示输入新的课程名称，来修改已有的映射</span><br><span class="line">            System.out.println(&quot;请输入新的课程名称：&quot;);</span><br><span class="line">            String name &#x3D; console.next();</span><br><span class="line">            Course newCourse &#x3D; new Course(crID,name);</span><br><span class="line">            courses.put(crID, newCourse);</span><br><span class="line">            System.out.println(&quot;修改成功！&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MapTest mt &#x3D; new MapTest();</span><br><span class="line">        mt.testPut();</span><br><span class="line">        mt.testKeySet();</span><br><span class="line">        mt.testRemove();</span><br><span class="line">        mt.testModify();</span><br><span class="line">        mt.testEntrySet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线文档-jdk-zh</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io 字节流</title>
      <link href="2020/01/02/java-io-%E5%AD%97%E8%8A%82%E6%B5%81-2020-01-02/"/>
      <url>2020/01/02/java-io-%E5%AD%97%E8%8A%82%E6%B5%81-2020-01-02/</url>
      
        <content type="html"><![CDATA[<h2 id="java-io-字节流"><a href="#java-io-字节流" class="headerlink" title="java.io 字节流"></a>java.io 字节流</h2><h3 id="基类-InputStream-和-OutputStream"><a href="#基类-InputStream-和-OutputStream" class="headerlink" title="基类 InputStream 和 OutputStream"></a>基类 InputStream 和 OutputStream</h3><p>字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，他们是抽象类，不能直接使用。字节流能处理所有类型的数据（如图片、avi 等）。  </p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p>InputStream 是所有表示字节输入流的基类，继承它的子类要重新定义其中所有定义的抽象方法.InputStream是从装置来源地读取数据的抽象表示，例如System中的标准输入流in对象就是一个InputStream类型的实例。  </p><p>我们先来看看InputStream类的方法：  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>read()throws IOException</td><td>从输入流中读取数据的下一个字节（抽象方法）</td></tr><tr><td>skip(long n) throws IOException</td><td>跳过和丢弃此输入流中数据的n个字节</td></tr><tr><td>available() throws IOException</td><td>返回流中可用字节数</td></tr><tr><td>mark(int readlimit) throws IOException</td><td>在此输入流中标记当前的位置</td></tr><tr><td>reset() throws IOException</td><td>将此流重新定位到最后一次对此输入流调用mark方法时的位置</td></tr><tr><td>markSupport() throws IOException</td><td>测试此输入流是否支持mark 和 reset 方法</td></tr><tr><td>close() throws IOException</td><td>关闭流</td></tr></tbody></table><p>在InputStream类中，方法read()提供了三种从流中读数据的方法；  </p><ol><li>int read(): 从输入流中读一个字节，形成一个0~255之间的整数返回（是一个抽象方法）  </li><li>int read(byte b[]): 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。  </li><li>int read(byte b[], int off,int len): 从输入流中读取长度为len的数据，写入数组b中从索引off开始的位置，并返回读取的字节数。  </li></ol><p>对于这三个方法，若返回-1，表明流结束，否则，返回实际读取的字符数。  </p><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><p>OutputStream 是所有表示字节输出流类的基类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是 java.io.PrintStream，这个类是 OutputStream 的子类。  </p><p>OutputStream 类方法：  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>write(int b)throws IOException</td><td>将指定的字节写入此输出流（抽象方法）</td></tr><tr><td>write(byte b[])throws IOException</td><td>将字节数组中的数据输出到流中</td></tr><tr><td>write(byte b[], int off, int len)throws IOException</td><td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</td></tr><tr><td>flush()throws IOException</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr><tr><td>close()throws IOException</td><td>关闭流</td></tr></tbody></table><p>看个例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 把输入流中的所有内容赋值到输出流中</span><br><span class="line">     * @param in</span><br><span class="line">     * @param out</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void copy(InputStream in, OutputStream out) throws IOException &#123;</span><br><span class="line">        byte[] buf &#x3D; new  byte[4096];</span><br><span class="line">        int len &#x3D; in.read(buf);</span><br><span class="line">        &#x2F;&#x2F;read 是一个字节一个字节地读，字节流的结尾标志是-1</span><br><span class="line">        while (len !&#x3D; -1)&#123;</span><br><span class="line">            out.write(buf, 0, len);</span><br><span class="line">            len &#x3D; in.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        test t &#x3D; new test();</span><br><span class="line">        System.out.println(&quot;输入字符：&quot;);</span><br><span class="line">        t.copy(System.in, System.out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java IO </tag>
            
            <tag> 字节流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io 字符流</title>
      <link href="2020/01/02/java-io-%E5%AD%97%E7%AC%A6%E6%B5%81-2020-01-02/"/>
      <url>2020/01/02/java-io-%E5%AD%97%E7%AC%A6%E6%B5%81-2020-01-02/</url>
      
        <content type="html"><![CDATA[<h2 id="java-io-字符流"><a href="#java-io-字符流" class="headerlink" title="java.io 字符流"></a>java.io 字符流</h2><h3 id="字符串基类"><a href="#字符串基类" class="headerlink" title="字符串基类"></a>字符串基类</h3><p>java.io 包中专门用于字符流处理的类，是以Reader和Writer为基础派生的一系列类  </p><p><strong><em>字符串以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。</em></strong>  </p><p>同类InputStream 和 OutputStream一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。他们的方法与类InputStream 和 OutputStream类似，只不过其中的参数换成字符或字符数组  </p><p>Reader 是所有的输入字符流的父类，他是一个抽象类  </p><p>我们先来看一看基类 Reader 的方法，其用法与作用都与InputStream 和 OutputStream 类似，就不做过多的说明了  </p><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>mark(int readAheadLimit)</td><td>void</td></tr><tr><td>markSupported()</td><td>boolean</td></tr><tr><td>read()</td><td>int</td></tr><tr><td>rerad(char[] cbuf,int off,int len)</td><td>int</td></tr><tr><td>ready()</td><td>boolean</td></tr><tr><td>reset()</td><td>void</td></tr><tr><td>skip(long n)</td><td>long</td></tr></tbody></table><p>Writer 是所有的输出字符流的父类，它是一个抽象类。Writer的方法：   </p><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>flush()</td><td>void</td></tr><tr><td>write(char[] cbuf)</td><td>void</td></tr><tr><td>write(char[] cbuf, int off,int len)</td><td>void</td></tr><tr><td>write(int c)</td><td>void</td></tr><tr><td>write(String str)</td><td>void</td></tr><tr><td>write(String str, int off, int len)</td><td>void</td></tr></tbody></table><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in); &#x2F;&#x2F;缺省规范说明</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定规范 enc</span><br><span class="line">InputStreamReader(InputStream in, String enc);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter(OutputStream out); &#x2F;&#x2F;缺省规范说明</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定规范 enc</span><br><span class="line">OutputStreamWriter(OutputStream out, String enc);</span><br></pre></td></tr></table></figure><p>如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader ir &#x3D; new InputStreamReader(is,&quot;8859_1&quot;);</span><br></pre></td></tr></table></figure><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率。</p><p>在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用 32 字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍。</p><p>BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read() 方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据。</p><p>BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作写入的动作。</p><p>构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;[ ]里的内容代表可选参数</span><br><span class="line">BufferedInputStream(InputStream in [, int size])</span><br><span class="line">BufferedOutputStream(OutputStream out [, int size])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举个例子，将缓冲流与文件流相接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in &#x3D; new FileInputStream(&quot;file.txt&quot;);</span><br><span class="line">FileOutputStream out &#x3D; new FileOutputStream(&quot;file2.txt&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置输入缓冲区大小为256字节</span><br><span class="line">BufferedInputStream bin &#x3D; new BufferedInputStream(in,256)</span><br><span class="line">BufferedOutputStream bout &#x3D; new BufferedOutputStream(out,256)</span><br><span class="line"></span><br><span class="line">int len;</span><br><span class="line">byte bArray[] &#x3D; new byte[256];</span><br><span class="line">len &#x3D; bin.read(bArray); &#x2F;&#x2F;len 中得到的是实际读取的长度，bArray 中得到的是数据</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/26/8xcSfK.png" alt="缓冲流示例图"></p><p>对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出。</p><p>例如方法 <strong><em>copy()</em></strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void copy(InputStream in, OutputStream out) throws IOException &#123;</span><br><span class="line">    out &#x3D; new BufferedOutputStream(out, 4096);</span><br><span class="line">    byte[] buf &#x3D; new byte[4096];</span><br><span class="line">    int len &#x3D; in.read(buf);</span><br><span class="line">    while (len !&#x3D; -1) &#123;</span><br><span class="line">    out.write(buf, 0, len);</span><br><span class="line">    len &#x3D; in.read(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;最后一次读取得数据可能不到4096字节</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferedReader-和-BufferedWrite"><a href="#BufferedReader-和-BufferedWrite" class="headerlink" title="BufferedReader 和 BufferedWrite"></a>BufferedReader 和 BufferedWrite</h3><p>同样的，为了提高字符流处理的效率，java.io 中也提供了缓冲流 BufferedReader 和 BufferedWrite。其构造方法与 BufferedInputStream 和 BufferedOutPutStream 相类似。另外，除了 read() 和 write() 方法外，它还提供了整行字符处理方法：</p><ol><li>public String readLine() ： BufferedReader 的方法，从输入流中读取一行字符，行结束标志 <strong><em>\n</em></strong> 、**<em>\r**</em> 或者两者在一起（这是根据系统而定的）  </li><li>public void newLine() : BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符 <strong><em>\n</em></strong> 或 <strong><em>\r</em></strong> , 而是系统定义的行隔离标志(line separator)  </li></ol><p>看一看例子:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class FileToUnicode &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream fis &#x3D; new FileInputStream(&quot;file1.txt&quot;);</span><br><span class="line">            InputStreamReader dis &#x3D; new InputStreamReader(fis);</span><br><span class="line">            BufferedReader reader &#x3D; new BufferedReader(dis);</span><br><span class="line">            String s;</span><br><span class="line">            &#x2F;&#x2F;每次读取一行，当改行为空时结束</span><br><span class="line">            while((s &#x3D; reader.readLine()) !&#x3D; null)&#123;</span><br><span class="line">                System.out.println(&quot;read:&quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如file1.txt 的内容如下:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">efg</span><br><span class="line">hij</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ javac FileToUnicode.java</span><br><span class="line">$ java FileToUnicode</span><br><span class="line">read:abc</span><br><span class="line">read:efg</span><br><span class="line">read:hij</span><br></pre></td></tr></table></figure><h3 id="其他字符流类"><a href="#其他字符流类" class="headerlink" title="其他字符流类"></a>其他字符流类</h3><p>在这里我们就列举一下有哪些类，具体的就不仔细列举了。  </p><ol><li>对字符数组进行处理： CharArrayReader、CharArrayWrite</li><li>对文本文件进行处理：FileReader、FileWriter</li><li>对字符串进行处理：StringReader、StringWriter</li><li>过滤字符流：FilterReader、FileterWriter</li><li>管道字符流：PipedReader、PipedWriter</li><li>行处理字符流：LineNumberReader</li><li>打印字符流：PrintWriter</li></ol><p>类有千万，方法更是不计其数，所以没有必要去掌握所有的方法和类，只需要知道常见常用的就行了，而大多数的类和方法，希望大家有一个印象，当我们在实际开放的时间，能够想到，并且借助其他工具去查询我们需要的方法的应用方式就可以了。  </p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线文档-jdk-zh</a></li><li><a href="http://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html">Java IO 流学习总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java IO </tag>
            
            <tag> 字符流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 文件操作（文件流）</title>
      <link href="2020/01/02/java-%E6%96%87%E4%BB%B6%E6%B5%81-javaio-2020-01-04/"/>
      <url>2020/01/02/java-%E6%96%87%E4%BB%B6%E6%B5%81-javaio-2020-01-04/</url>
      
        <content type="html"><![CDATA[<h2 id="java-文件-（Java-io）"><a href="#java-文件-（Java-io）" class="headerlink" title="java 文件 （Java io）"></a>java 文件 （Java io）</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>java.io 定义的大多数类都是流式操作，但 File 类不是。它直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它描述了文件本身的属性。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list( ) 方法检测的文件名列表。  </p><p>先看一看 File 的构造方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</span><br><span class="line">File(File parent, String child)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例</span><br><span class="line">File(String pathname)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例</span><br><span class="line">File(String parent, String child)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例</span><br><span class="line">File(URI uri)</span><br></pre></td></tr></table></figure><p>例如:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个目录路径参数</span><br><span class="line">File f1 &#x3D; new File(&quot;&#x2F;Users&#x2F;mumutongxue&#x2F;&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对象有两个参数——路径和文件名</span><br><span class="line">File f2 &#x3D; new File(&quot;&#x2F;Users&#x2F;mumutongxue&#x2F;&quot;,&quot;a.bat&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向 f1 文件的路径及文件名</span><br><span class="line">File f3 &#x3D; new File(f1,&quot;a.bat&quot;);</span><br></pre></td></tr></table></figure><p>再来看看File的一些方法  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean canExecute()</td><td>测试应用程序是否可以执行此抽象路径名表示的文件</td></tr><tr><td>boolean canRead()</td><td>测试应用程序是否可以读取此抽象路径名表示的文件</td></tr><tr><td>boolean canWrite()</td><td>测试应用程序是否可以修改此抽象路径名表示的文件</td></tr><tr><td>int compareTo(File pathname)</td><td>按字母顺序比较两个抽象路径名</td></tr><tr><td>boolean createNewFile()</td><td>当且仅当不存在具有抽象路径名指定名称的文件时，不可分地创建一个新的空文件</td></tr><tr><td>static File createTempFile(String prefix, String suffix, File directory)</td><td>在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称</td></tr><tr><td>static File createTempFile(String prefix, String suffix, File idrectory)</td><td>在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称</td></tr><tr><td>boolean delete()</td><td>删除此抽象路径名表示的文件或目录</td></tr><tr><td>void deleteOnExit()</td><td>在虚拟机终止时，请求删除此抽象路径名表示的文件或目录</td></tr><tr><td>boolean equals(Object obj)</td><td>测试此抽象路径名与给定对象是否相等</td></tr><tr><td>boolean exists()</td><td>测试此抽象路径名表示的文件或目录是否存在</td></tr><tr><td>File getAbsoluteFile()</td><td>返回此抽象路径名的绝对路径名形式</td></tr><tr><td>String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>File getCanonicalFile()</td><td>返回此抽象路径名的规范形式</td></tr><tr><td>String getCanonicalPath()</td><td>返回此抽象路径名的规范名字符串</td></tr><tr><td>long getFreeSpace()</td><td>返回此抽象路径名指定的分区中为分配的字节数</td></tr><tr><td>String getName()</td><td>返回由此抽象路径名表示的文件或目录的名称</td></tr><tr><td>String getParent()</td><td>返回此抽象路径名父目录的路径字符串；如果此路径名没有指定父目录，则返回 null</td></tr><tr><td>File getParentFile()</td><td>返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回null</td></tr><tr><td>String getPath()</td><td>将此抽象路径名转换为一个路径名字符串</td></tr><tr><td>long getTotalSpace()</td><td>返回此抽象路径名指定的分区大小</td></tr><tr><td>long getUsableSpace()</td><td>返回此抽象路径名指定的分区上可用于此虚拟机的字节数</td></tr><tr><td>int hashCode()</td><td>计算此抽象路径名的哈希码</td></tr><tr><td>boolean isAbsolute()</td><td>测试此抽象路径名是否为绝对路径名</td></tr><tr><td>boolean isDirectory()</td><td>测试此抽象路径名表示的文件是否一个目录</td></tr><tr><td>boolean isFile()</td><td>测试此抽象路径名表示的文件是否是一个标准文件</td></tr><tr><td>boolean isHidden()</td><td>测试此抽象路径名指定的文件是否是一个隐藏文件</td></tr><tr><td>long lastModified()</td><td>返回此抽象路径名表示的文件最后一次被修改的时间</td></tr><tr><td>long length()</td><td>返回由此抽象路径名表示的文件最后一次被修改的时间</td></tr><tr><td>String[] list()</td><td>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录</td></tr><tr><td>String[] list(FilenameFilter filter)</td><td>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录</td></tr><tr><td>File[] listFiles()</td><td>返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件</td></tr><tr><td>File[] listFiles(FileFiter filter)</td><td>返回抽象路径名数组，这是路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录</td></tr><tr><td>File[] listFiles(FilenameFilter filter)</td><td>返回抽象路径名数组， 这些路径名表示此抽象路径名表示的 目录中满足指定过滤器的文件和目录</td></tr><tr><td>static File[] listRoots()</td><td>列出可用的文件系统根</td></tr><tr><td>boolean mkdir()</td><td>创建此抽象路径名指定的目录</td></tr><tr><td>boolean mkdirs()</td><td>创建此抽象路径名指定的目录，包括所有必须但不存在的父目录</td></tr><tr><td>boolean renameTo(File dest)</td><td>重新命名此抽象路径名表示的文件</td></tr><tr><td>boolean setExecutable(boolean executable)</td><td>设置此抽象路径名所有者执行权限的一个便捷方法</td></tr><tr><td>boolean setExecutable(boolean executable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的执行权限</td></tr><tr><td>boolean setLastModified(long time)</td><td>设置此抽象路径名指定的文件或目录的最后一次修改时间</td></tr><tr><td>boolean setReadable(boolean readable)</td><td>设置此抽象路径名所有者读权限的一个便携方法</td></tr><tr><td>boolean setReadable(boolean readable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的读权限</td></tr><tr><td>boolean setReadOnly()</td><td>标记此抽象路径名指定的文件或目录，从而只能对其进行读操作</td></tr><tr><td>boolean setWritable(boolean writable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的写权限</td></tr><tr><td>String toString()</td><td>返回此抽象路径名的路径名字符串</td></tr><tr><td>URI toURI()</td><td>构造一个表示此抽象路径名的file:URI</td></tr></tbody></table><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class  FileDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;同学们可以根据自己的路径进行更改</span><br><span class="line">        File f1 &#x3D;new File(&quot;&#x2F;home&#x2F;project&#x2F;1.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F;File(String parent,String child)</span><br><span class="line">        File f2 &#x3D;new File(&quot;&#x2F;home&#x2F;project&quot;,&quot;2.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F;separator 跨平台分隔符</span><br><span class="line">        File f3 &#x3D;new File(&quot;&#x2F;home&quot;+File.separator+&quot;project&quot;);</span><br><span class="line">        File f4 &#x3D;new File(f3,&quot;3.txt&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">             System.out.println(f1);</span><br><span class="line">                &#x2F;&#x2F;当文件存在时返回 false；不存在时返回 true</span><br><span class="line">                System.out.println(f2.createNewFile());</span><br><span class="line">                &#x2F;&#x2F;当文件不存在时返回 false</span><br><span class="line">                System.out.println(f3.delete());</span><br><span class="line">        &#125;catch(IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;列出磁盘下的文件和文件夹</span><br><span class="line">        File[] files &#x3D;File.listRoots();</span><br><span class="line">        for(File file:files)&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            if(file.length()&gt;0)&#123;</span><br><span class="line">                String[] filenames &#x3D;file.list();</span><br><span class="line">                for(String filename:filenames)&#123;</span><br><span class="line">                    System.out.println(filename);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h3><p>对于 FileInputStream/FileOutputStream、FileReader/FileWriter 来说，它们的实例都是顺序访问流，即只能进行顺序读/写。而类 RandomAccessFile 则允许文件内容同时完成读和写操作，它直接继承 object，并且同时实现了接口 DataInput 和 DataOutput。  </p><p>随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。  </p><p>RandomAccessFile 提供了支持随机文件操作的方法：  </p><ol><li>readXXX() 或者 writeXXX(): 如 ReadInt(),ReadLine(),WriteChar(),WriteDouble() 等</li><li>int skipBytes(int n): 将指针向下移动若干字节</li><li>length(): 返回文件长度</li><li>long getFilePointer(): 返回指针当前位置</li><li>void seek(long pos): 将指针调用所需位置  </li></ol><p>在生成一个随机文件对象时，除了要指定文件对象和文件名之外，还需要指明访问文件的模式。  </p><p>我们来看看RandomAccessFile的构造方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile(File file,String mode)</span><br><span class="line">RandomAccessFile(String name,String mode)</span><br></pre></td></tr></table></figure><h4 id="mode-的取值："><a href="#mode-的取值：" class="headerlink" title="mode 的取值："></a>mode 的取值：</h4><ul><li><strong><em>r</em></strong>: 只读，任何写操作都讲抛出 IOException</li><li><strong><em>rw</em></strong>: 读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容。</li><li><strong><em>rws</em></strong>: 打开以便读取和写入，对于 “rw”，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li><li><strong><em>rwd</em></strong>: 打开以便读取和写入，对于 “rw”，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line">public class  FileDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">            int data_arr[] &#x3D; &#123;12, 32, 43, 45, 1, 5&#125;;</span><br><span class="line">            try &#123;</span><br><span class="line">                RandomAccessFile randf&#x3D;new RandomAccessFile(&quot;temp.dat&quot;,&quot;rw&quot;);</span><br><span class="line">                for(int i &#x3D; 0; i &lt; data_arr.length; i++)&#123;</span><br><span class="line">                    randf.writeInt(data_arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i &#x3D; data_arr.length-1 ; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">                    &#x2F;&#x2F;int 数据占 4 个字节</span><br><span class="line">                    randf.seek(i * 4L);</span><br><span class="line">                    System.out.println(randf.readInt());</span><br><span class="line">                &#125;</span><br><span class="line">                randf.close();</span><br><span class="line">            &#125;catch(IOException e)&#123;</span><br><span class="line">                System.out.println(&quot;File access error&quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh">在线文档-jdk-zh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO 流</title>
      <link href="2020/01/01/java-io-%E6%B5%81-2020-03-24/"/>
      <url>2020/01/01/java-io-%E6%B5%81-2020-03-24/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO 流"></a>Java IO 流</h2><p>在大多数程序中，都需要对输入输出进行处理。例如我们中需要获取用户从键盘上的输入，需要在控制台输出结果等等。除此之外还有从文件中读取数据，向文件中写入数据等等。在 Java 中，我们把这些不同类型的输入输出源抽象地称为 流，也就是 Stream；在里面输入输出的数据则称为数据流（Data Stream），它们通常具有统一的接口。</p><p>于是我们得到了数据流的定义：</p><blockquote><p>一个 Java I/O 对象叫做数据流。读取数据到内存的对象叫做输入流，内存写出数据的对象叫做输出流。</p></blockquote><p>针对其面向的不同角度，我们大致可以将流分为下面几种类型：</p><ul><li>按照数据流的方向不同分为 输入流 和 _输出流_。这种分类不是绝对的，例如在向一个文件写入数据时，它就是输出流；而在读取数据时，它就是输入流。</li><li>按照处理数据的单位不同分为 <a href="https://bawcat.wiki/2020/01/02/java-io-%E5%AD%97%E8%8A%82%E6%B5%81-2020-01-02/">字节流</a> 和 <a href="https://bawcat.wiki/2020/01/02/java-io-%E5%AD%97%E7%AC%A6%E6%B5%81-2020-01-02/"><em>字符流</em></a>。</li><li>按照功能的不同分为 节点流 和 _处理流_。</li></ul><p>需要特别说明，节点流是从特定的数据节点（文件、数据库、内存等）读写数据；处理流是连接在已有的流上，通过对数据的处理为程序提供更多功能。</p><p>在 Java 环境中，java.io 包提供了大多数的类和接口来实现输入输出管理。一些标准的输入输出则来自 java.lang 包中的类，但它们都是继承自 java.io 中的类。我们可以将输入流理解为数据的提供者，而把输出流理解为数据的接收者。在最初的时候，这些派生自抽象类 InputStream 和 OutputStream 的输入输出类是面向 8 位的字节流的。但为了支持国际化，又引入了派生自抽象类 Reader 和 Writer 的类层次，用于读写一些双字节的 Unicode 字符。</p><p><strong><em>因此，在学习 java 的输入输出上，我们希望你以字节流和字符流作为区分来学习。</em></strong></p><p>如果需要概括一下，则可以得到下面的定义：</p><ul><li>字节流：表示以字节为单位从 stream 中读取或往 stream 中写入信息。通常用来读取二进制数据。</li><li>字符流：以 Unicode 字符为单位从 stream 中读取或往 stream 中写入信息。</li></ul><p>按照这样的定义，Java 中流的层级结构可以通过下图来表示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/24/8HOXf1.jpg" alt="java层级结构"></p><p>图中蓝色的部分均为抽象类，而绿色的部分则为派生类，是可以直接使用的。</p><p>而下图简要说明了字节流和字符流的区别，你也可以<a href="http://blog.csdn.net/cynhafa/article/details/6882061">进一步了解字节流与字符流的区别。</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://s1.ax1x.com/2020/03/24/8HXAfI.jpg" alt="java字符流&amp;字节流区别"></p><p>我们知道 Java 是一门面向对象的语言，所以为了能够永久地保存对象的状态，java.io包还以字节流为基础，通过实现 ObjectInput 和 ObjectOutput 接口提供了 _对象流_。在此仅作引入，你可以通过查阅 API 手册来详细了解它们。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambad Streams （流）</title>
      <link href="2020/01/01/java-streams-2020-01-01/"/>
      <url>2020/01/01/java-streams-2020-01-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Streams-（流）"><a href="#Streams-（流）" class="headerlink" title="Streams （流）"></a>Streams （流）</h2><p>Stream 是Java 8中的一个新的抽象层。通过使用Stream，你能以类似于SQL语句的声明式方式处理数据。  </p><p>例如一个典型的SQL语句能够自动地返回某些信息，而不用在开发者这一端做任何的计算工作。同样，通过使用Java的集合框架，开发者能够利用循环做重复的检查。另外一个关注点是效率，就像多核处理器能够提升效率一样，开发者也可以通过并行化编程来改进工作流程，但是这样很容易出错。  </p><p>因此，Stream的引入是为了解决上述痛点。开发者可以通行声明式数据处理，以及简单地利用多核处理体系而不用写特定的代码。  </p><p>说了这么久，Stream究竟是什么呢？Stream代表了来自某个源的对象的序列，这些序列支持聚集操作。下面是Stream的一些特性：  </p><ul><li>元素序列：Stream以序列的形式提供了特定类型的元素的集合。根据需求，它可以获得和计算元素，但不会储存任何元素。</li><li>源：Stream可以将集合、数组和I/O资源作为输入源。</li><li>聚集操作：Stream支持诸如filter、map、limit、reduce等的聚集操作。</li><li>流水技术：许多Stream操作返回了流本身，故它们的返回值可以以流水的行式存在。这些操作称之为中间操作，并且它们的功能就是负责输入、处理和向目标输出。collect()方法是一个终结操作，通常存在于流水线操作的末端，来标记流的结束。</li><li>自动迭代：Stream的操作可以基于已提供的源元素进行内部的迭代，而集合则需要显式的迭代。</li></ul><blockquote><p>扩展阅读：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/">java 8 中的 Streams Api 详解</a> - IBM  </p></blockquote><h3 id="产生流"><a href="#产生流" class="headerlink" title="产生流"></a>产生流</h3><p>集合的接口有两个方法来产生流  </p><ul><li><strong><em>stream()</em></strong> :该方法返回一个将集合视为源的连续流</li><li><strong><em>parallelStream()</em></strong> :该方法返回一个将集合视为源的并行流。  </li></ul><h4 id="相关的方法介绍"><a href="#相关的方法介绍" class="headerlink" title="相关的方法介绍"></a>相关的方法介绍</h4><ul><li><strong><em>forEach</em></strong> :该方法用于对Steam中的每个元素进行迭代操作。下面的代码段演示了如何使用forEach方法输出10个输出数。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li><strong><em>map</em></strong> :该方法用于将每个元素映射到对应的结果上。下面代码段演示了怎样用map方法输出唯一的某个数的平方。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(2,3,3,2,5,2,7);</span><br><span class="line">&#x2F;&#x2F; get list of unique squares</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map( i -&gt; i*i ).distinct().collect(Collectiors.toList());</span><br></pre></td></tr></table></figure><ul><li><strong><em>filter</em></strong> :该方法用于过滤满足条件的元素。下面的代码段演示了怎样输出使用了过滤方法的空字符串数量。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);</span><br><span class="line">&#x2F;&#x2F; get count of empty string</span><br><span class="line">long count &#x3D; strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>limit</em></strong> :该方法用于减少Stream的大小。下面的代码段演示了怎样有限制地输出10个随机数。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p><strong><em>sorted</em></strong> :该方法用于对Stream排序。下面的代码段演示了怎样以有序的形式输出10个随机数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ul><h4 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h4><p>ParallelStream 是 Stream 用于并行处理的一种替代方案。下面的代码段演示了如何使用它来输出字符串的数量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);</span><br><span class="line">long count &#x3D; strings.parallelStream().filter(String::isEmpty).count();</span><br></pre></td></tr></table></figure><p>当然，在连续的Stream与并行的Stream之间切换是很容易的。  </p><h4 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h4><p>Collector 用于合并Stream的元素处理结果。它可以用于返回一个字符串列表  </p><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;efg&quot;,&quot;&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;ghij&quot;,&quot;lmn&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;Filtered List:&quot; + filtered);</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;Merged String: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h4 id="统计工具"><a href="#统计工具" class="headerlink" title="统计工具"></a>统计工具</h4><p>Java 8引入了用于统计的Collector来计算Stream处理完成后的所有统计数据。  </p><p>下面的代码段演示了如何使用它  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(2,3,3,2,5,2,7);</span><br><span class="line"></span><br><span class="line">IntSummaryStatistics stats &#x3D; numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Highest number in List : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;Lowest number in List : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;Sum of all numbers : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;Average of all numbers : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h3 id="一个Stream的例子"><a href="#一个Stream的例子" class="headerlink" title="一个Stream的例子"></a>一个Stream的例子</h3><p>下面我们通过一个例子来演示技巧  </p><p>新建一个类NewFeaturesTester.java，以下是NewFeaturesTester.java 类中应当输入的代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.IntSummaryStatistics;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      System.out.println(&quot;Using Java 7: &quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 统计空字符串的数量</span><br><span class="line">      List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;efg&quot;, &quot;&quot;, &quot;abc&quot;, &quot;bc&quot;, &quot;ghij&quot;,&quot;&quot;, &quot;lmn&quot;);</span><br><span class="line">      System.out.println(&quot;List: &quot; +strings);</span><br><span class="line">      long count &#x3D; getCountEmptyStringUsingJava7(strings);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Empty Strings: &quot; + count);</span><br><span class="line">      count &#x3D; getCountLength3UsingJava7(strings);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Strings of length 3: &quot; + count);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 消除空字符串</span><br><span class="line">      List&lt;String&gt; filtered &#x3D; deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(&quot;Filtered List: &quot; + filtered);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 消除空字符串，同时使用逗号来连接</span><br><span class="line">      String mergedString &#x3D; getMergedStringUsingJava7(strings,&quot;, &quot;);</span><br><span class="line">      System.out.println(&quot;Merged String: &quot; + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers &#x3D; Arrays.asList(2, 3, 3, 2, 5, 2, 7);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 获得不同数字的平方的列表</span><br><span class="line">      List&lt;Integer&gt; squaresList &#x3D; getSquares(numbers);</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers &#x3D; Arrays.asList(1,2,13,4,15,6,17,8,19);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;List: &quot; +integers);</span><br><span class="line">      System.out.println(&quot;Highest number in List : &quot; + getMax(integers));</span><br><span class="line">      System.out.println(&quot;Lowest number in List : &quot; + getMin(integers));</span><br><span class="line">      System.out.println(&quot;Sum of all numbers : &quot; + getSum(integers));</span><br><span class="line">      System.out.println(&quot;Average of all numbers : &quot; + getAverage(integers));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 输出10个随机数</span><br><span class="line">      System.out.println(&quot;Random Numbers: &quot;);</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">      for(int i&#x3D;0; i &lt; 10; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 使用Java 8的新特性</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Using Java 8: &quot;);</span><br><span class="line">      System.out.println(&quot;List: &quot; +strings);</span><br><span class="line"></span><br><span class="line">      count &#x3D; strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;Empty Strings: &quot; + count);</span><br><span class="line"></span><br><span class="line">      count &#x3D; strings.stream().filter(string -&gt; string.length() &#x3D;&#x3D; 3).count();</span><br><span class="line">      System.out.println(&quot;Strings of length 3: &quot; + count);</span><br><span class="line"></span><br><span class="line">      filtered &#x3D; strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Filtered List: &quot; + filtered);</span><br><span class="line"></span><br><span class="line">      mergedString &#x3D; strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">      System.out.println(&quot;Merged String: &quot; + mergedString);</span><br><span class="line"></span><br><span class="line">      squaresList &#x3D; numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      System.out.println(&quot;List: &quot; +integers);</span><br><span class="line"></span><br><span class="line">      IntSummaryStatistics stats &#x3D; integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 输出结果</span><br><span class="line">      System.out.println(&quot;Highest number in List : &quot; + stats.getMax());</span><br><span class="line">      System.out.println(&quot;Lowest number in List : &quot; + stats.getMin());</span><br><span class="line">      System.out.println(&quot;Sum of all numbers : &quot; + stats.getSum());</span><br><span class="line">      System.out.println(&quot;Average of all numbers : &quot; + stats.getAverage());</span><br><span class="line">      System.out.println(&quot;Random Numbers: &quot;);</span><br><span class="line"></span><br><span class="line">      random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 并行处理</span><br><span class="line">      count &#x3D; strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;Empty Strings: &quot; + count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用Java 7版本就提供的API来计算空串数量    </span><br><span class="line">   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">         if(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用Java 7版本就提供的API来计算长度为3字符的字符串数量</span><br><span class="line">   private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">         if(string.length() &#x3D;&#x3D; 3)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用Java 7版本就提供的API来删除空串</span><br><span class="line">   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      List&lt;String&gt; filteredList &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return filteredList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 使用Java 7版本就提供的API来获取合并后的字符串</span><br><span class="line">   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123;</span><br><span class="line">      StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line"></span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString &#x3D; stringBuilder.toString();</span><br><span class="line">      return mergedString.substring(0, mergedString.length()-2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 自定义的用于计算数字的平方的方法</span><br><span class="line">   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">      for(Integer number: numbers)&#123;</span><br><span class="line">         Integer square &#x3D; new Integer(number.intValue() * number.intValue());</span><br><span class="line"></span><br><span class="line">         if(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return squaresList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 自定义的用于获得List中最大值的方法</span><br><span class="line">   private static int getMax(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int max &#x3D; numbers.get(0);</span><br><span class="line"></span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">         Integer number &#x3D; numbers.get(i);</span><br><span class="line"></span><br><span class="line">         if(number.intValue() &gt; max)&#123;</span><br><span class="line">            max &#x3D; number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 自定义的用于获得List中最小值的方法</span><br><span class="line">   private static int getMin(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int min &#x3D; numbers.get(0);</span><br><span class="line"></span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number &#x3D; numbers.get(i);</span><br><span class="line"></span><br><span class="line">         if(number.intValue() &lt; min)&#123;</span><br><span class="line">            min &#x3D; number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return min;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 自定义的用于获得List中各个数字的和的方法</span><br><span class="line">   private static int getSum(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int sum &#x3D; (int)(numbers.get(0));</span><br><span class="line"></span><br><span class="line">      for(int i&#x3D;1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum +&#x3D; (int)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 自定义的用于获得List中各个数字的平均值的方法</span><br><span class="line">   private static int getAverage(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      return getSum(numbers) &#x2F; numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Streams </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口、默认方法和Optional类</title>
      <link href="2020/01/01/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95-optional-2020-01-01/"/>
      <url>2020/01/01/java-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95-optional-2020-01-01/</url>
      
        <content type="html"><![CDATA[<h2 id="函数式接口、默认方法和Optional类"><a href="#函数式接口、默认方法和Optional类" class="headerlink" title="函数式接口、默认方法和Optional类"></a>函数式接口、默认方法和Optional类</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口通过一个单一的功能来表现。例如，带有**<em>单个compareTo**</em>方法的比较接口，被用于比较的场合。Java 8 开始定义了大量的函数式接口来广泛地用于lambda表达式。</p><blockquote><p>Java 8 引入的一个核心概念是函数式接口（Functional Interfaces）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。引用自<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html">IBM - Java 8 新特性概述</a></p></blockquote><h3 id="相关的接口及描述"><a href="#相关的接口及描述" class="headerlink" title="相关的接口及描述"></a>相关的接口及描述</h3><p>下面是部分函数式接口的列表  </p><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>BitConsumer&lt;T,U&gt;</td><td>改接口代表了接收两个输入参数T、U，并且没有返回的操作</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>该接口代表提供接收两个参数T、U，并且产生一个结果R的方法</td></tr><tr><td>BinaryOperator<T></td><td>代表了基于两个相同类型的操作数, 产生任然是相同类型结果的操作</td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>代表了对两个参数的断言操作（基于Boolean值的方法）</td></tr><tr><td>BooleanSupplier</td><td>代表了一个给出Boolean值结果的方法</td></tr><tr><td>Consumer<T></td><td>代表了接受单一输入参数并且没有返回值的操作</td></tr><tr><td>DoubleBinaryOperator</td><td>代表了基于两个Double类型操作数的操作，并且返回一个Double类型的返回值</td></tr><tr><td>DoubleConsumer</td><td>代表了一个接受单个Double类型的参数并且没有返回的操作</td></tr><tr><td>DoubleFunction<R></td><td>代表了一个接受Double类型参数并且返回结果的方法</td></tr><tr><td>DoublePredicate</td><td>代表了对一个Double类型的参数的断言操作</td></tr><tr><td>DoubleSupplier</td><td>代表了一个给出Double类型值的方法</td></tr><tr><td>DoubleToIntFunction</td><td>代表了接受单个Double类型参数但返回Int类型结果的方法</td></tr><tr><td>DoubleToLongFunction</td><td>代表了接受单个Double类型参数但返回Long类型结果的方法</td></tr><tr><td>DoubleUnaryOperator</td><td>代表了基于单个Double类型操作数且产生Double类型结果的操作</td></tr><tr><td>Function&lt;T,R&gt;</td><td>代表了接受一个参数并且产生一个结果的方法</td></tr><tr><td>IntBinaryOperator</td><td>代表了对两个Int类型操作数的操作，并且产生一个Int类型的结果</td></tr><tr><td>IntConsumer</td><td>代表了接受单个Int类型参数的操作，没有返回结果</td></tr><tr><td>IntFunction<R></td><td>代表了接受Int类型参数并且给出返回值的方法</td></tr><tr><td>IntPredicate</td><td>代表了对单个Int类型参数的断言操作</td></tr></tbody></table><p>更多的接口可以参考Java官方API手册：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">java.lang.Annotation Type FunctionalInterface</a>。在实际使用过程中，加有 <strong><em>@FunctionalInterface</em></strong> 注解的方法均是此类接口，位于<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/package-frame.html">java.util.Funtion</a>包中。  </p><h4 id="一个函数式编程的例子"><a href="#一个函数式编程的例子" class="headerlink" title="一个函数式编程的例子"></a>一个函数式编程的例子</h4><p>下面我们通过一个例子学习如何使用这些函数式编程的接口  </p><p>新建一个类 <strong><em>NewFeaturesTester.java</em></strong>，以下是 <strong><em>NewFeaturesTester.java</em></strong> 类中应当输入的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;Integer&gt; list &#x3D; Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;All of the numbers:&quot;);</span><br><span class="line"></span><br><span class="line">      eval(list, n-&gt;true);</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Even numbers:&quot;);</span><br><span class="line">      eval(list, n-&gt; n%2 &#x3D;&#x3D; 0 );</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Numbers that greater than  5:&quot;);</span><br><span class="line">      eval(list, n -&gt; n &gt; 5 );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">      for(Integer n: list) &#123;</span><br><span class="line"></span><br><span class="line">         if(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>Java 8在接口方面引入了一个关于默认方法实现的新概念。它也是作为一种向后兼容能力而出现，旧的接口也能用到Lambda表达式中。例如，*<strong>List***或 *</strong>Collection*** 接口是没有forEach方法的声明的。但是，通过这些默认方法能够就能轻易地打破集合框架实现的限制。Java 8引入默认方式使得 <strong><em>List</em></strong> 和 <strong><em>Collection</em></strong> 接口能够拥有 <strong><em>forEach</em></strong> 方法的默认实现。实现了这些接口的类也不必再实现相同的功能了。  </p><p>语法如下所示:  </p><blockquote><p>本段代码是示例代码,仅供理解使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface boy &#123;</span><br><span class="line">    default void print()&#123;</span><br><span class="line">        System.out.println(&quot;I am a boy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多个默认值"><a href="#多个默认值" class="headerlink" title="多个默认值"></a>多个默认值</h4><p>接口中有了默认方法之后，在同一个类里面实现两个带有相同默认方法的接口就可行了。  </p><p>下面的代码演示了如何解决这种含糊不清的情况。  </p><p>首先是同一个类里面的两个接口  </p><blockquote><p>本段是示例代码，仅供理解</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface younger &#123;</span><br><span class="line">    default void print()&#123;</span><br><span class="line">        System.out.println(&quot;I am a younger.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface learner &#123;</span><br><span class="line">    default void print()&#123;</span><br><span class="line">        System.out.println(&quot;I am a learner.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个解决办法就是创建一个自有的办法，来重写默认的实现。就像这样：  </p><blockquote><p>本段代码是示例代码，仅供理解使用。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class student implements younger, learner &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      System.out.println(&quot;I am a younger and a learner, so I am  a student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决办法就是使用超类 <strong><em>super</em></strong> 来调用特定接口的默认方法。  </p><blockquote><p>本段代码是示例代码，仅供理解使用  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class student implements younger, learner &#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        learner.super.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h4><p>你也可以为这个接口增加静态的辅助方法(helper), 就像下面这样：</p><blockquote><p>本段代码是示例代码，仅供理解使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Younger &#123;</span><br><span class="line">    default void print()&#123;</span><br><span class="line">        System.out.println(&quot;I am a younger.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void sayHi()&#123;</span><br><span class="line">        System.out.println(&quot;Young is the capital.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个默认方法的例子"><a href="#一个默认方法的例子" class="headerlink" title="一个默认方法的例子"></a>一个默认方法的例子</h4><p>下面我们通过一个例子来掌握如何使用默认方法。请看下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Younger younger &#x3D; new Student();</span><br><span class="line">        younger.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Younger &#123;</span><br><span class="line">    default void print() &#123;</span><br><span class="line">        System.out.println(&quot;I am a younger.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void sayHi() &#123;</span><br><span class="line">        System.out.println(&quot;Young is the capital.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Learner &#123;</span><br><span class="line">    default void print() &#123;</span><br><span class="line">        System.out.println(&quot;I am a learner.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Younger, Learner &#123;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        Younger.super.print();</span><br><span class="line">        Learner.super.print();</span><br><span class="line">        Younger.sayHi();</span><br><span class="line">        System.out.println(&quot;I am a student!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h3><p>Optional是一个容器对象，用于容纳非空对象。Optional对象通过缺失值值代表null。这个类有许多实用的方法来促使代码能够处理一些像可用或者不可用的值，而不是检查那些空值（null）。Java 8中引入的这个特性有点像Google Guava里的Optional（Guava 是一个 Google 的基于Java 6的类库集合的扩展项目）。  </p><p>在Java官方文档的解释中，它是一个可以为null的容器对象。如果值存在则 isPresent() 方法会返回 true ，调用 get()方法会返回该对象。  </p><h4 id="类的声明及方法"><a href="#类的声明及方法" class="headerlink" title="类的声明及方法"></a>类的声明及方法</h4><p>下面是java.util.Optional<T>类的声明：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure><p>这个类继承了java.lang.Object类大多数方法。主要有：  </p><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>static <T> Optional<T> empty()</td><td>该方法返回一个空的Optional实例</td></tr><tr><td>boolean equals(Object obj)</td><td>该方法可以指示某个对象是否与当前Optional对象相等</td></tr><tr><td>Optional<T> filter(Predicate&lt;? super <T> predicate)</td><td>如果一个值存在并且这个值满足某个给定的断言，那么该方法将返回一个描述该值的Optional对象；否则，将返回一个空的Optional对象</td></tr><tr><td>Optional flatMap(Function&lt;? super T,Optional&gt; mapper)</td><td>如果一个值存在，该方法会把一个map方法应用于它，并且返回结果；否则，将返回空的Optional对象</td></tr><tr><td>T get()</td><td>如果一个值存在于当前Optional中，则返回这个值；否则将抛出一个NoSuchElementException异常</td></tr><tr><td>int hashCode()</td><td>返回当前值的hash编码值。若这个值不存在，则返回0</td></tr><tr><td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td>如果一个值存在，该方法会通过该值调用指定的consumer。如果不存在，则不调用</td></tr><tr><td>boolean isPresent()</td><td>返回一个值是否存在</td></tr><tr><td>Optional map(Function&lt;? super T,? extends U&gt; mapper</td><td>如果一个值存在，则将某个map方法应用于它。如果这个值是非空的，则返回一个描述结果的Optional对象</td></tr><tr><td>static <T> Optional<T> of(T value)</td><td>返回某个存在的非空值的Optional对象</td></tr></tbody></table><p>更多的你可以访问官方API手册查看：<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a>  </p><h4 id="一个Optional类的例子"><a href="#一个Optional类的例子" class="headerlink" title="一个Optional类的例子"></a>一个Optional类的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line"></span><br><span class="line">      NewFeaturesTester tester &#x3D; new NewFeaturesTester();</span><br><span class="line">      Integer value1 &#x3D; null;</span><br><span class="line">      Integer value2 &#x3D; new Integer(5);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; ofNullable 允许传参时给出 null</span><br><span class="line">      Optional&lt;Integer&gt; a &#x3D; Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果传递的参数为null，那么 of 将抛出空指针异常（NullPointerException）</span><br><span class="line">      Optional&lt;Integer&gt; b &#x3D; Optional.of(value2);</span><br><span class="line">      System.out.println(tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; isPresent 用于检查值是否存在</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;First parameter is present: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;Second parameter is present: &quot; + b.isPresent());</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果当前返回的是传入的默认值，orElse 将返回它</span><br><span class="line">      Integer value1 &#x3D; a.orElse(new Integer(0));</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; get 用于获得值，条件是这个值必须存在</span><br><span class="line">      Integer value2 &#x3D; b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p><a href="http://www.importnew.com/6675.html">Java 8 Optional类深度解析</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">Java SE 8: Lambda Quick Start</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">The Java™ Tutorials - Default Methods</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 函数式接口 </tag>
            
            <tag> java Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java Calendar Date Math 类的使用</title>
      <link href="2019/12/29/java-Calendar-Math-Date-2019-12-29/"/>
      <url>2019/12/29/java-Calendar-Math-Date-2019-12-29/</url>
      
        <content type="html"><![CDATA[<h2 id="java-Calendar、Date、Math-的使用"><a href="#java-Calendar、Date、Math-的使用" class="headerlink" title="java Calendar、Date、Math 的使用"></a>java Calendar、Date、Math 的使用</h2><blockquote><p>记录 Calendar 的使用方法</p></blockquote><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><blockquote><p>这是时间类</p></blockquote><p>在早期的jdk版本中，Date类附有两大功能:</p><ol><li>允许用年、月、日、时、分、秒来解释日期</li><li>允许对表示日期的字符串进行格式化和句法分析</li></ol><p>在JDK1.1中提供了类Calendar来完成第一种功能，类DateFormat来完成第二项功能。DateFormat是java.text包中的一个</p><p>类。与Date类中有所不同的是，DateFormat类可以接受用各种语言和不同习惯表示的日期字符串。</p><p>但是Calendar 类是一个抽象类，他完成Date类与普通日期表示法之间的转换，而我们更多地是使用Calendar类的子类</p><p>GregorianCalendar类。它实现了世界上普遍使用的公历系统。当然我们也可以继承Calendar类，然后自己定义实现日历</p><p>方法。</p><p>先来看一看GregorianCalendar类的构造函数：</p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>GregorianCalendar()</td><td>创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行所处的时区、地点的当前时间</td></tr><tr><td>GregorianCalendar(TimeZone zone)</td><td>创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间</td></tr><tr><td>GregorianCalendar(Locale aLocale)</td><td>创建的对象中的相关值被设置成缺省时区，指定地点aLocale的当前时间</td></tr><tr><td>GregorianCalendar(TimeZone zone,Locale aLocale)</td><td>year - 创建的对象中的相关值被设置成指定时区，指定地点的当前时间</td></tr></tbody></table><p>TimeZone是java.util包中的一个类,其中封装了有关时区的信息。每一个时区对应一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 太平洋时区的ID 为 PST</span><br><span class="line">TimeZone tz0 &#x3D; TimeZone.getTimeZone(&quot;PST&quot;);</span><br><span class="line">&#x2F;&#x2F; getDefault() 可以获取主机所在时区的对象</span><br><span class="line">TimeZone tz1 &#x3D; TimeZone.getDefault();</span><br></pre></td></tr></table></figure><p>Locale只是一种机制，他用来标识一个特定的地理、政治或文化区域取一个Locale对象的构造方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用Locale类的构造方法</span><br><span class="line">Locale 10 &#x3D; new Locale(String language)</span><br><span class="line">Locale 11 &#x3D; new Locale(String language,String country)</span><br><span class="line">Locale 12 &#x3D; new Locale(String language,String country,String variant)</span><br><span class="line">&#x2F;&#x2F; 调用Locale类中定义的常量</span><br><span class="line">Locale 11 - Locale.CHINA</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class CalendarDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;完整显示日期时间：&quot;);</span><br><span class="line">        &#x2F;&#x2F; 字符串转换日期格式</span><br><span class="line">        DateFormat fdate &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String str &#x3D; fdate.format(new Date());</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建 Calendar 对象</span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 初始化 Calendar 对象，但并不必要，除非需要重置时间</span><br><span class="line">        calendar.setTime(new Date());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 显示年份</span><br><span class="line">        System.out.println(&quot;年： &quot; + calendar.get(Calendar.YEAR));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 显示月份 (从0开始, 实际显示要加一)</span><br><span class="line">        System.out.println(&quot;月： &quot; + calendar.get(Calendar.MONTH));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 当前分钟数</span><br><span class="line">        System.out.println(&quot;分钟： &quot; + calendar.get(Calendar.MINUTE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 今年的第 N 天</span><br><span class="line">        System.out.println(&quot;今年的第 &quot; + calendar.get(Calendar.DAY_OF_YEAR) + &quot;天&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 本月第 N 天</span><br><span class="line">        System.out.println(&quot;本月的第 &quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;天&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3小时以后</span><br><span class="line">        calendar.add(Calendar.HOUR_OF_DAY, 3);</span><br><span class="line">        System.out.println(&quot;三小时以后的时间： &quot; + calendar.getTime());</span><br><span class="line">        &#x2F;&#x2F; 格式化显示</span><br><span class="line">        str &#x3D; (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 重置 Calendar 显示当前时间</span><br><span class="line">        calendar.setTime(new Date());</span><br><span class="line">        str &#x3D; (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime());</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个 Calendar 用于比较时间</span><br><span class="line">        Calendar calendarNew &#x3D; Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设定为 5 小时以前，后者大，显示 -1</span><br><span class="line">        calendarNew.add(Calendar.HOUR, -5);</span><br><span class="line">        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设定7小时以后，前者大，显示 1</span><br><span class="line">        calendarNew.add(Calendar.HOUR, +7);</span><br><span class="line">        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 退回 2 小时，时间相同，显示0</span><br><span class="line">        calendarNew.add(Calendar.HOUR, -2);</span><br><span class="line">        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; calendarNew创建时间点</span><br><span class="line">        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendarNew.getTime</span><br><span class="line"></span><br><span class="line">()));</span><br><span class="line">        &#x2F;&#x2F; calendar创建时间点</span><br><span class="line">        System.out.println((new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;)).format(calendar.getTime()));</span><br><span class="line">        System.out.println(&quot;时间比较：&quot; + calendarNew.compareTo(calendar));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">完整显示日期时间：</span><br><span class="line">2019-12-12 06:17:57</span><br><span class="line">年： 2019</span><br><span class="line">月： 11</span><br><span class="line">分钟： 17</span><br><span class="line">今年的第 346天</span><br><span class="line">本月的第 12天</span><br><span class="line">三小时以后的时间： Thu Dec 12 09:17:57 UTC 2019</span><br><span class="line">2019-12-12 09:17:57:108</span><br><span class="line">2019-12-12 06:17:57:122</span><br><span class="line">时间比较：-1</span><br><span class="line">时间比较：1</span><br><span class="line">时间比较：1</span><br><span class="line">2019-12-12 06:17:57:123</span><br><span class="line">2019-12-12 06:17:57:122</span><br><span class="line">时间比较：1</span><br></pre></td></tr></table></figure><p>大家运行上面的代码后，看见控制台上的输出结果会不会有所疑问呢？</p><p>其实 month 的含义与 Date 类相同，0 代表 1 月，11 代表 12 月。</p><p>有的人可能不明白最后一个的输出为什么有时是 0 ，有时是 1，在这里会涉及到 calendarNew 与 calendar 的创建时</p><p>间点， calendarNew 经过增加和减少时间后恢复到原来的时间点，也就是最终比较的是谁先创建好，时间点靠后的大一</p><p>些，而 calendarNew 创建的时间点只有可能是大于等于 calendar 的，需要根据实际的创建时间点进行比较。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><blockquote><p>Date 类表示日期和时间，里面封装了操作日期和时间的方法.Date类经常用来获取系统当前时间</p></blockquote><p>Date 中定义的未过时的构造方法:</p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Date()</td><td>构造一个Date对象并对其进行初始化以反映当前时间</td></tr><tr><td>Date(long date)</td><td>构造一个Date对象，并根据相对于 GMT 1970年1月1日 00:00:00的毫秒数以对其进行初始化</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DateDemo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String strDate, strTime;</span><br><span class="line">        Date objDate &#x3D; new Date();</span><br><span class="line">        System.out.println(&quot;今天的日期是: &quot; + objDate);</span><br><span class="line">        long time &#x3D; objDate.getTime();</span><br><span class="line">        System.out.println(&quot;自1970年1月1日起以毫秒为单位的时间（GMT）&quot; + time);</span><br><span class="line">        strDate &#x3D; objDate.toString();</span><br><span class="line">        &#x2F;&#x2F; 提取GMT时间</span><br><span class="line">        strTime &#x3D; strDate.substring(11, (strDate.length() - 4));</span><br><span class="line">        &#x2F;&#x2F; 按照小时、分钟和秒提取时间</span><br><span class="line">        strTime &#x3D; &quot;时间：&quot; + strTime.substring(0,8);</span><br><span class="line">        System.out.println(strTime);</span><br><span class="line">        &#x2F;&#x2F; 格式化时间</span><br><span class="line">        SimpleDateFormat formatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SS&quot;);</span><br><span class="line">        System.out.println(formatter.format(objDate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac DateDemo.java</span><br><span class="line">$ java DateDemo     </span><br><span class="line">今天的日期是: Thu Dec 12 06:34:45 UTC 2019</span><br><span class="line">自1970年1月1日起以毫秒为单位的时间（GMT）1576132485389</span><br><span class="line">时间：06:34:45</span><br><span class="line">2019-12-12 06:34:45:389</span><br></pre></td></tr></table></figure><blockquote><p>注意 Date类的很多方法自 JDK 1.1 开始就已经过时了。</p></blockquote><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote><p>Math 类在java.lang 包中，包含用于执行基本数学运算的方法,如初等指数、对数、平方根和三角函数</p></blockquote><p>常见方法:</p><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>sin(double numvalue)</td><td>double</td><td>计算角numvalue的正弦值</td></tr><tr><td>cos(double numvalue)</td><td>double</td><td>计算角 numvalue 的余弦值</td></tr><tr><td>acos(double numvalue)</td><td>double</td><td>计算 numvalue 的反余弦</td></tr><tr><td>asin(double numvalue)</td><td>double</td><td>计算 numvalue 的反正弦</td></tr><tr><td>atan(double numvalue)</td><td>double</td><td>计算 numvalue 的反正切</td></tr><tr><td>pow(double a, double b)</td><td>double</td><td>计算 a 的 b 次方</td></tr><tr><td>sqrt(double numvalue)</td><td>double</td><td>计算给定值的正平方根</td></tr><tr><td>abs(int numvalue)</td><td>int</td><td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>ceil(double numvalue)</td><td>double</td><td>返回大于等于 numvalue 的最小整数值</td></tr><tr><td>floor(double numvalue)</td><td>double</td><td>返回小于等于 numvalue 的最大整数值</td></tr><tr><td>max(int a, int b)</td><td>int</td><td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>min(int a, int b)</td><td>int</td><td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td></tr><tr><td>rint(double numvalue)</td><td>double</td><td>返回最接近 numvalue 的整数值</td></tr><tr><td>round(T arg)</td><td>arg 为 double 时返回long,为float 时返回int</td><td>返回最接近arg的整数值</td></tr><tr><td>random()</td><td>double</td><td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td></tr></tbody></table><blockquote><p>上面都是一些常用的方法，如果同学们还会用到极坐标、对数等，就去查一查手册吧。</p></blockquote><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MathDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Math.abs(-12.7));</span><br><span class="line">        System.out.println(Math.ceil(12.7));</span><br><span class="line">        System.out.println(Math.rint(12.4));</span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">        System.out.println(&quot;sin30 &#x3D; &quot; + Math.sin(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算30°的正弦值，参数是用弧度表示的角，即π的六分之一</span><br><span class="line">        System.out.println(&quot;cos30 &#x3D; &quot; + Math.cos(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算30°的余弦值，这些计算三角函数的方法，其参数和返回值的类型都为double</span><br><span class="line">        System.out.println(&quot;tan30 &#x3D; &quot; + Math.tan(Math.PI &#x2F; 6));</span><br><span class="line">        &#x2F;&#x2F; 计算30°的正切值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javac MathDemo.java</span><br><span class="line">$ java MathDemo</span><br><span class="line">12.7</span><br><span class="line">13.0</span><br><span class="line">12.0</span><br><span class="line">0.4548881782067914</span><br><span class="line">sin30 &#x3D; 0.49999999999999994</span><br><span class="line">cos30 &#x3D; 0.8660254037844387</span><br><span class="line">tan30 &#x3D; 0.5773502691896257</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Calendar </tag>
            
            <tag> java Math </tag>
            
            <tag> java Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java Collections 类的使用</title>
      <link href="2019/12/29/java-collections-2019-12-29/"/>
      <url>2019/12/29/java-collections-2019-12-29/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Collections"><a href="#Java-Collections" class="headerlink" title="Java Collections"></a>Java Collections</h2><blockquote><p>java.util.Collections 是一个工具类,他包含了大量对集合进行操作的静态方法.</p></blockquote><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void sort(List list)</td><td>按自然升序排序</td></tr><tr><td>void sort(List list,Comparator c)</td><td>自定义排序规则排序</td></tr><tr><td>void shuffle(List list)</td><td>随机排序,用于打乱顺序</td></tr><tr><td>void reverse(List list)</td><td>反转,将列表元素顺序反转</td></tr><tr><td>void swap(List list,int i,int j)</td><td>交换处于索引 i 和 j 位置的元素</td></tr><tr><td>int binarySearch(List list,Object key)</td><td>二分查找,列表必须有序,返回找到的元素索引位置</td></tr><tr><td>int max(Collection coll)</td><td>查找最大值</td></tr><tr><td>int min(Collection coll)</td><td>查找最小值</td></tr><tr><td>void fill(List list,Object obj)</td><td>使用obj填充list所有元素</td></tr><tr><td>boolean replaceAll(List list,Object oldVal,Object newVal)</td><td>使用用newVal替换所有的oldVal</td></tr><tr><td>&lt;K,V&gt;Map&lt;K,V&gt; synchronizedList(List<T> list)</td><td>将list包装为线程安全的List</td></tr><tr><td><T>List<T> synchronizedList(List<T> list)</td><td>将list包装为线程安全的List</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CollectionsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        创建一个空List</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;赋值</span><br><span class="line">        list.add(3);</span><br><span class="line">        list.add(5);</span><br><span class="line">        list.add(7);</span><br><span class="line">        list.add(9);</span><br><span class="line">        list.add(12);</span><br><span class="line">        System.out.print(&quot;初始顺序：&quot;);</span><br><span class="line">        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;打乱顺序</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.print(&quot;\n打乱顺序：&quot;);</span><br><span class="line">        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;反转</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.print(&quot;\n反转集合：&quot;);</span><br><span class="line">        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;第一个位和最后一位交换</span><br><span class="line">        Collections.swap(list,0,list.size()-1);</span><br><span class="line">        System.out.print(&quot;\n交换第一位和最后一位：&quot;);</span><br><span class="line">        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;按自然升序排序</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.print(&quot;\nSort排序后：&quot;);</span><br><span class="line">        list.forEach(v -&gt; System.out.print(v + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;二分查找 必须排序后</span><br><span class="line">        System.out.print(&quot;\n二分查找数值7的位置：&quot;+Collections.binarySearch(list, 7));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回线程安全的list</span><br><span class="line">        List&lt;Integer&gt; synchronizedList &#x3D; Collections.synchronizedList(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac CollectionsDemo.java</span><br><span class="line">$ java CollectionsDemo</span><br><span class="line">初始顺序：3    5    7    9    12    </span><br><span class="line">打乱顺序：5    7    3    12    9    </span><br><span class="line">反转集合：9    12    3    7    5    </span><br><span class="line">交换第一位和最后一位：5    12    3    7    9    </span><br><span class="line">Sort排序后：3    5    7    9    12    </span><br><span class="line">二分查找数值7的位置：2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambad 表达式的含义及使用方法、引用</title>
      <link href="2019/12/27/java-lambad-%E8%A1%A8%E8%BE%BE%E5%BC%8F-2019-12-27/"/>
      <url>2019/12/27/java-lambad-%E8%A1%A8%E8%BE%BE%E5%BC%8F-2019-12-27/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambad-表达式的含义及使用方法、引用"><a href="#Lambad-表达式的含义及使用方法、引用" class="headerlink" title="Lambad 表达式的含义及使用方法、引用"></a>Lambad 表达式的含义及使用方法、引用</h2><h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。<br>函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p><h3 id="Lambad-表达式"><a href="#Lambad-表达式" class="headerlink" title="Lambad 表达式"></a>Lambad 表达式</h3><p>Lambad 表达式是在Java 8 中引入的。并且成为了Java 8最大的特点。<br>它使得功能性编程变得非常便利，极大地简化了开发工作。  </p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>一个Lambad表达式具有下面这样的语法特征。它由三个部分组成；<br>第一部分为一个括号内用都好分割的参数列表，参数即函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;; 第三部分为方法体，可以使表达式和代码块。语法如下  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter -&gt; expression body</span><br></pre></td></tr></table></figure><p>下面列举了Lambad表达式的几个最重要的特征；  </p><ul><li>可选的类型声明：你不用去声明参数的类型。编译器可以从参数的值来推断它是什么类型。  </li><li>可选的参数周围的括号：你可以不用在括号内声明单个参数。但是对于很多参数的情况，括号是必需的  </li><li>可选的大括号：如果表达式体里面只有一个语句，那么你不必用大括号括起来。  </li><li>可选的返回关键字：如果表达式体只有单个表达式用于值的返回，那么编译器会自动完成这一步。若要指示表达式来返回某个值，则需要使用大括号。  </li></ul><p>语言的设计者们思考了很多如何让现有的功能和lambda表达式友好兼容。于是就有了函数接口这个概念。函数接口是一种只有一个方法的接口，函数接口可以隐式地转换成 Lambda 表达式。  </p><blockquote><p>函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码。引用自<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html">IBM - Java 8 新特性概述。</a>  </p></blockquote><h4 id="一个Lambad-表达式的例子"><a href="#一个Lambad-表达式的例子" class="headerlink" title="一个Lambad 表达式的例子"></a>一个Lambad 表达式的例子</h4><p>下面尝试写一些代码来理解Lambda表达式。新建一个类NewFeaturesTester.java，请在NewFeaturesTester.java中输入下面这些代码，对于它们的解释在注释中给出。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        NewFeaturesTester tester &#x3D; new NewFeaturesTester();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 带有类型声明的表达式</span><br><span class="line">          MathOperation addition &#x3D; (int a, int b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 没有类型声明的表达式</span><br><span class="line">          MathOperation subtraction &#x3D; (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 带有大括号、带有返回语句的表达式</span><br><span class="line">          MathOperation multiplication &#x3D; (int a, int b) -&gt; &#123; return a * b; &#125;;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 没有大括号和return语句的表达式</span><br><span class="line">          MathOperation division &#x3D; (int a, int b) -&gt; a &#x2F; b;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 输出结果</span><br><span class="line">          System.out.println(&quot;10 + 5 &#x3D; &quot; + tester.operate(10, 5, addition));</span><br><span class="line">          System.out.println(&quot;10 - 5 &#x3D; &quot; + tester.operate(10, 5, subtraction));</span><br><span class="line">          System.out.println(&quot;10 x 5 &#x3D; &quot; + tester.operate(10, 5, multiplication));</span><br><span class="line">          System.out.println(&quot;10 &#x2F; 5 &#x3D; &quot; + tester.operate(10, 5, division));</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 没有括号的表达式            </span><br><span class="line">          GreetingService greetService1 &#x3D; message -&gt;</span><br><span class="line">          System.out.println(&quot;Hello &quot; + message);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 有括号的表达式            </span><br><span class="line">          GreetingService greetService2 &#x3D; (message) -&gt;</span><br><span class="line">          System.out.println(&quot;Hello &quot; + message);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 调用sayMessage方法输出结果</span><br><span class="line">          greetService1.sayMessage(&quot;Java&quot;);</span><br><span class="line">          greetService2.sayMessage(&quot;Classmate&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 下面是定义的一些接口和方法</span><br><span class="line"></span><br><span class="line">       interface MathOperation &#123;</span><br><span class="line">          int operation(int a, int b);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       interface GreetingService &#123;</span><br><span class="line">          void sayMessage(String message);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private int operate(int a, int b, MathOperation mathOperation)&#123;</span><br><span class="line">          return mathOperation.operation(a, b);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：  </p><ul><li>Lambda表达式优先用于定义功能接口在行内的实现，即单个方法只有一个接口。在上面的例子中，我们用了多个类型的Lambda表达式来定义MathOperation接口的操作方法。然后我们定义了GreetingService的sayMessage的实现  </li><li>Lambda表达式让匿名类不再需要，这为Java增添了简洁但实用的函数式编程能力。  </li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>我们可以通过下面这段代码来学习Lambda的作用域。请将代码修改至如下这些：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line">        final static String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;正确，不可再次赋值</span><br><span class="line">        &#x2F;&#x2F;static String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;正确，可再次赋值</span><br><span class="line">        &#x2F;&#x2F;String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;报错</span><br><span class="line">        &#x2F;&#x2F;final String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;报错</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        &#x2F;&#x2F;final String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;正确，不可再次赋值</span><br><span class="line">        &#x2F;&#x2F;String salutation &#x3D; &quot;Hello &quot;; &#x2F;&#x2F;正确，隐性为 final , 不可再次赋值</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; salution &#x3D; &quot;welcome to &quot;  </span><br><span class="line">        GreetingService greetService1 &#x3D; message -&gt; </span><br><span class="line">        System.out.println(salutation + message);</span><br><span class="line">        greetService1.sayMessage(&quot;Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">       void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到以下结论：  </p><ul><li>可访问static修饰的成员变量,如果是final static 修饰，不可再次赋值，只有static修饰可再次赋值；  </li><li>可访问表达式外层的final局部变量（不用声明为final，隐性具有final语义），不可再次赋值  </li></ul><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><blockquote><p>方法也是一种对象，可以通过名字来引用，不过方法引用的唯一用途是支持Lambad的简写，使用方法名称来表示Lambad。不能通过方法引用来获得诸如方法签名的相关信息。引用自<a href="http://blog.csdn.net/kimylrong/article/details/47255123">永无止境，上下求索</a> 的博客  </p></blockquote><p>方法引用提供了一个很有用的语义来直接访问类或者实例的已经存在的方法或者构造方法。  </p><p>方法引用可以通过方法的名字来引用其本身。方法引用是通过::符号（双冒号）来描述的。  </p><p>它可以用来引用下列类型的方法：  </p><ul><li>构造器引用。语法是Class::new,或者更一般的Class<T>::new,要求构造器方法是没有参数；  </li><li>静态方法引用。语法是Class::static_method,要求接受一个Class类型的参数;  </li><li>特定类的任意对象方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入；  </li></ul><p>更多对于方法引用的介绍，可以参考这一篇博文–<a href="http://blog.csdn.net/wwwsssaaaddd/article/details/37573517">java8 - 方法引用(method referrance)</a> </p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class NewFeaturesTester &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        names.add(&quot;Peter&quot;);</span><br><span class="line">        names.add(&quot;Linda&quot;);</span><br><span class="line">        names.add(&quot;Smith&quot;);</span><br><span class="line">        names.add(&quot;Zack&quot;);</span><br><span class="line">        names.add(&quot;Bob&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;     通过System.out::println引用了输出的方法</span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">The Java™ Tutorials - Lambda Expressions</a></li><li><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">The Java™ Tutorials - Method References</a></li><li><a href="http://blog.csdn.net/wwwsssaaaddd/article/details/37573517">java8 - 方法引用(method referrance)</a></li><li><a href="http://www.importnew.com/19345.html">Java 8 特性 – 终极手册</a></li><li><a href="http://www.jb51.net/article/48304.htm">JAVA8 十大新特性详解</a></li><li><a href="http://www.cnblogs.com/pkufork/p/java_8.html">Java9都快发布了，Java8的十大新特性你了解多少呢？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Lambad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 正则表达式 (regular)</title>
      <link href="2019/12/26/java-regular-2019-12-27/"/>
      <url>2019/12/26/java-regular-2019-12-27/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-的-正则表达式使用"><a href="#Java-的-正则表达式使用" class="headerlink" title="Java 的 正则表达式使用"></a>Java 的 正则表达式使用</h2><blockquote><p>正则表达式，又称规则表达式.（英语：Regular Expression ,在代码中常简写 regex 、 regexp 或 RE）, 计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本。</p></blockquote><p>Java 通过 <strong><em>java.util.regex</em></strong> 包提供正则表达式的功能</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>Java 使用正则表达式匹配非常简单，我们以邮箱地址为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;       Pattern类 正则表达式的编译表示。</span><br><span class="line">        Pattern pattern &#x3D; Pattern.compile(&quot;^[a-zA-Z0-9_!#$%&amp;&#39;*+&#x2F;&#x3D;?&#96;&#123;|&#125;~^.-]+@[a-zA-Z0-9.-]+$&quot;);</span><br><span class="line">        String[] emails &#x3D; &#123;&quot;shiyanlou@shiyanlou.com&quot;, &quot;shiyanlou&quot;&#125;;</span><br><span class="line">        for (String email :</span><br><span class="line">                emails) &#123;</span><br><span class="line">&#x2F;&#x2F;Matcher 通过解释Pattern对字符序列执行匹配操作的引擎</span><br><span class="line">            Matcher matcher &#x3D; pattern.matcher(email);</span><br><span class="line">            System.out.println(email + &quot;匹配结果：&quot; + matcher.matches());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 正则 </tag>
            
            <tag> java regular </tag>
            
            <tag> regular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-反射</title>
      <link href="2019/12/24/java-%E5%8F%8D%E5%B0%84-2019-12-25/"/>
      <url>2019/12/24/java-%E5%8F%8D%E5%B0%84-2019-12-25/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><p>Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用，我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。  </p><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射是Java 编程语言的一个腾讯，它提供了在运行时检查和动态调用类、方法、属性的能力。  </p><h3 id="反射能做什么？"><a href="#反射能做什么？" class="headerlink" title="反射能做什么？"></a>反射能做什么？</h3><p>反射可以在运行时检查类，接口，方法和变量。还可以实例化对象、调用方法、获取和设置变量值。比如当我们不知道一个类中是否拥有某个方法时，我们就可以使用反射来检查是否拥有这个方法。  </p><h3 id="反射常用类"><a href="#反射常用类" class="headerlink" title="反射常用类"></a>反射常用类</h3><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><ul><li>Class：Class 类标识正在运行的Java程序中的类和接口  </li><li>Field： 提供有关类或接口的单个域的信息和动态访问。如数据类型，访问修饰符，域的名称和值  </li><li>Method ：提供有关类或接口上的单个构造函数的信息和访问权限。如访问修饰符，返回类型，名称，参数类型和方法的异常类型。</li><li>Constructor ：提供有关类的单个构造函数的信息和访问权限。例如构造函数的访问修饰符，名称和参数类型。  </li><li>Modifier：提供了有关访问修饰符的信息。  </li></ul><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Class 类没有公共构造方法，可以通过其他方法获取Class类。  </p><ul><li>Object 提供的 getClass() 方法  </li><li>类名.Class  </li><li>Class.forName(String className) 方法。className为类的全限定名  </li></ul><h4 id="Class-类常用方法："><a href="#Class-类常用方法：" class="headerlink" title="Class 类常用方法："></a>Class 类常用方法：</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Field getField(String name)</td><td>获取指定的域对象</td></tr><tr><td>field[] getFields()</td><td>返回所有的公有域对象数组</td></tr><tr><td>Method getDeclaredMethod(String name,Class&lt;?&gt;……parameterTypes)</td><td>返回指定的方法对象</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有方法对象数组</td></tr><tr><td>String getNmae()</td><td>获取全限定名</td></tr></tbody></table><blockquote><p>更多方法请参阅<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">官方文档</a>  </p></blockquote><h4 id="反射方法示例"><a href="#反射方法示例" class="headerlink" title="反射方法示例"></a>反射方法示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public int a;</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;ReflectDemo&gt; reflectDemoClass &#x3D; ReflectDemo.class;</span><br><span class="line">        &#x2F;&#x2F;输出所有的域名称</span><br><span class="line">        for (Field declaredField : reflectDemoClass.getDeclaredFields()) &#123;</span><br><span class="line">            &#x2F;&#x2F;可以通过Modifier将具体的权限信息输出，否则只会显示代表权限的数值</span><br><span class="line">            System.out.println(&quot;域：&quot; + declaredField.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredField.getModifiers()));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;输出所有的公有域名称</span><br><span class="line">        for (Field field : reflectDemoClass.getFields()) &#123;</span><br><span class="line">            System.out.println(&quot;公有域：&quot; + field.getName() + &quot; 修饰符：&quot; + Modifier.toString(field.getModifiers()));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;输出类的所有方法名</span><br><span class="line">        for (Method declaredMethod : reflectDemoClass.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(&quot;方法：&quot; + declaredMethod.getName() + &quot; 修饰符：&quot; + Modifier.toString(declaredMethod.getModifiers()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fun1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void fun2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>反射虽然提供了强大的能力，但是也会带来很多问题，如性能降低，权限漏洞以及权限问题。所以能不用劲量不用  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-设计模式</title>
      <link href="2019/12/23/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2019-12-24/"/>
      <url>2019/12/23/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2019-12-24/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-常见设计模式"><a href="#Java-常见设计模式" class="headerlink" title="Java 常见设计模式"></a>Java 常见设计模式</h2><blockquote><p>设计模式(Design pattern) 代表了最佳实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p></blockquote><h3 id="设计模式简要说明"><a href="#设计模式简要说明" class="headerlink" title="设计模式简要说明"></a>设计模式简要说明</h3><blockquote><p>本次示例 主要介绍一下模式</p></blockquote><ul><li>中介模式</li><li>代理模式</li><li>责任链模式</li></ul><h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><blockquote><p>定义一个对象，该对象封装了一组对象的交互方式。对象之间的通信将封装在中介对象中。对象不再直接相互通信而是通过中介进行通信。这减少了通信对象之间的依赖性，从而减少了耦合。</p></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>避免一组交互对象之间的紧密耦合</li><li>可以独立地改变一组对象之间的交互</li></ol><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jackie8tao/Images/raw/master/Mediator.jpg" alt="中介模式"></p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>比如 我们要实现一个聊天室 聊天室就是中介，聊天的人就是一个同事类，发送的消息都由聊天室转发给别人</p><p>首先我们新建一个聊天室文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractChatRoom &#123;</span><br><span class="line">    public abstract void notice(String message, User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们新建一个聊天室  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ChatRoom extends AbstractChatRoom &#123;</span><br><span class="line">    private List&lt;User&gt; users &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void register(User user) &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void notice(String message, User user) &#123;</span><br><span class="line">        for (User u : users) &#123;</span><br><span class="line">            if (u !&#x3D; user) &#123;</span><br><span class="line">                u.getMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们新建一个用户基类  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class User &#123;</span><br><span class="line">    protected AbstractChatRoom chatRoom;</span><br><span class="line"></span><br><span class="line">    public User(AbstractChatRoom chatRoom) &#123;</span><br><span class="line">        this.chatRoom &#x3D; chatRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息</span><br><span class="line">     *</span><br><span class="line">     * @param msg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void sendMessage(String msg);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接受消息</span><br><span class="line">     *</span><br><span class="line">     * @param msg</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void getMessage(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟用户A  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class UserA extends User &#123;</span><br><span class="line">    public UserA(AbstractChatRoom chatRoom) &#123;</span><br><span class="line">        super(chatRoom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;用户A发送 &quot; + msg);</span><br><span class="line">        chatRoom.notice(msg, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getMessage(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;用户A收到 &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟用户B  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class UserB extends User &#123;</span><br><span class="line">    public UserB(AbstractChatRoom chatRoom) &#123;</span><br><span class="line">        super(chatRoom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;用户B发送 &quot; + msg);</span><br><span class="line">        chatRoom.notice(msg, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getMessage(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;用户B收到 &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChatRoom chatRoom &#x3D; new ChatRoom();</span><br><span class="line">        UserA userA &#x3D; new UserA(chatRoom);</span><br><span class="line">        UserB userB &#x3D; new UserB(chatRoom);</span><br><span class="line">        chatRoom.register(userA);</span><br><span class="line">        chatRoom.register(userB);</span><br><span class="line">        userA.sendMessage(&quot;你好！&quot;);</span><br><span class="line">        userB.sendMessage(&quot;再见！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己编译运行 查看效果  </p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><blockquote><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不合适或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用  </p></blockquote><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol><li>隐藏原始对象并控制对象的访问  </li><li>访问对象时提供其他的功能  </li></ol><h5 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/jackie8tao/Images/raw/master/Proxy.jpg" alt="代理模式"></p><p>说明：  </p><ul><li>Subject : 一个客户端可用的公开的功能接口</li><li>RealSubject: 实现Subject接口的类，提供了接口方法的具体实现</li><li>Proxy: 实现Subject接口的代理类，通过RealSubject类的业务逻辑方法来实现抽象方法，可以附加自己的操作  </li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><blockquote><p>假设我们需要建设一栋楼房，但是建设之前我们需要购买原材料（如水泥……)接着才能开始建设，楼房主体建设完成后，还需要封顶  </p></blockquote><p>首先建立一个 构建接口  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LouSubject&#123;</span><br><span class="line">    void build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建设大楼主程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LouRealSubject implements LouSubject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void build()&#123;</span><br><span class="line">        System.out.println(&quot;建设实验楼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建设大楼需要购买材料方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LouProxy implements LouSubject&#123;</span><br><span class="line">    private LouSubject target;</span><br><span class="line">    public LouProxy()&#123;</span><br><span class="line">        this.target &#x3D; new LouRealSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void build()&#123;</span><br><span class="line">        System.out.println(&quot;购买材料&quot;);</span><br><span class="line">        target.build();</span><br><span class="line">        System.out.println(&quot;封顶&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用主客户端执行程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LouClient&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        LouSubject proxy &#x3D; new LouProxy();</span><br><span class="line">        proxy.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><blockquote><p>责任链模式是一种由命令对象源和一系列处理对象组成的设计模式。每个处理对象都包含它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。还存在一种机制，用于将新处理对象添加到该链的末尾。责任链模式还在结构上与装饰器模式几乎相同不同之处在于对于装饰器。所有类都处理请求，而对于责任链，链中的一个类恰好处理请求。  </p></blockquote><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol><li>避免将请求的发送方与其接收方耦合  </li><li>可以使用多个接收器处理请求  </li></ol><h5 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h5><p><img src= "/img/loading.gif" data-lazy-src="https://image-static.segmentfault.com/420/495/4204951507-5a17e5d460f64_articlex" alt="责任链模式">  </p><p>handler : 抽象处理者<br>ConcreteHandler：具体处理者，接受到请求后，可以选择处理请求或者传递给下一个处理者  </p><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><p>假设我们有一个 OA 系统 不同的职位可以处理不同的审批流  </p><p>组长： 可以处理两天以内的审批<br>厂长： 可以处理七天以内的审批<br>老板： 可以处理十五天以内的审批<br>如果组长可以处理，那么久直接处理了，如果组长不可以处理，那么我们再继续往下传递  </p><p>处理程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 下个处理者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Handler successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(Handler successor) &#123;</span><br><span class="line">        this.successor &#x3D; successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handlerRequest(int heaven);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组长处理程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GroupLeaderHandler extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRequest(int heaven) &#123;</span><br><span class="line">        if (heaven &lt;&#x3D; 2) &#123;</span><br><span class="line">            System.out.println(&quot;组长处理&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (super.successor !&#x3D; null) &#123;</span><br><span class="line">                super.successor.handlerRequest(heaven);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>厂长处理程序  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryManagerHandler extends Handler&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRequest(int heaven) &#123;</span><br><span class="line">        if (heaven &lt;&#x3D; 7) &#123;</span><br><span class="line">            System.out.println(&quot;厂长处理&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (super.successor !&#x3D; null) &#123;</span><br><span class="line">                super.successor.handlerRequest(heaven);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老板处理  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BossHandler extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRequest(int heaven) &#123;</span><br><span class="line">        if (heaven &lt;&#x3D; 15) &#123;</span><br><span class="line">            System.out.println(&quot;老板处理&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if (super.successor !&#x3D; null) &#123;</span><br><span class="line">                super.successor.handlerRequest(heaven);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟发起请求  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Handler groupLeaderHandler &#x3D; new GroupLeaderHandler();</span><br><span class="line">        Handler factoryManagerHandler &#x3D; new FactoryManagerHandler();</span><br><span class="line">        Handler bossHandler &#x3D; new BossHandler();</span><br><span class="line">        groupLeaderHandler.setSuccessor(factoryManagerHandler);</span><br><span class="line">        factoryManagerHandler.setSuccessor(bossHandler);</span><br><span class="line">        &#x2F;&#x2F;请假一天</span><br><span class="line">        groupLeaderHandler.handlerRequest(1);</span><br><span class="line">        &#x2F;&#x2F;请假6天</span><br><span class="line">        groupLeaderHandler.handlerRequest(6);</span><br><span class="line">        &#x2F;&#x2F;请假10天</span><br><span class="line">        groupLeaderHandler.handlerRequest(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java 多线程</title>
      <link href="2019/12/23/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-2019-12-23/"/>
      <url>2019/12/23/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-2019-12-23/</url>
      
        <content type="html"><![CDATA[<h2 id="java-多线程"><a href="#java-多线程" class="headerlink" title="java 多线程"></a>java 多线程</h2><p> Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。本节主要讲解 Java 多线程的一些概念以及其实现。</p><ul><li>多线程</li><li>线程变量</li><li>线程同步 </li><li>Lock 与 Unlock</li><li>死锁</li><li>线程生命周期 </li><li>ArrayBlockingQueue</li><li>生产者消费者模式</li><li>线程池</li></ul><blockquote><p>线程：程序执行流的最小单元。它是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派 CPU 的基本单位。</p></blockquote><p>如同大自然中的万物，线程也有“生老病死”的过程，下图表示了一个线程从创建到消亡的过程，以及过程中的状态。  </p><p>结合线程的生命周期来看看多线程的定义：</p><blockquote><p>多线程：从软件或者硬件上实现多个线程并发执行的技术。在单个程序中同时运行多个线程完成不同的工作。  </p></blockquote><p>在 Java 中，<a href="http://baike.baidu.com/view/159846.htm">垃圾回收机制</a>就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。反映到我们现实生活中，在浏览网页时，浏览器能够同时下载多张图片；实验楼的服务器能够容纳多个用户同时进行在线实验，这些都是多线程带来的好处。  </p><p>从专业的角度来看，多线程编程是为了最大限度地利用 CPU 资源——当处理某个线程不需要占用 CPU 而只需要利用 IO 资源时，允许其他的那些需要 CPU 资源的线程有机会利用 CPU。这或许就是多线程编程的最终目的。当然，你也可以进一步了解。  </p><p>对于多线程和线程之间的关系，你可以这样理解：一个使用了多线程技术的程序，包含了两条或两条以上并发运行的线程（**<em>Thread**</em>）  </p><p>Java 中的**<em>Thread**</em>类就是专门用来创建线程和操作线程的类。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>创建线程的方法：  </p><ol><li>继承 Thread 类并重写它的run()方法，然后用这个子类来创建对象并调用start()方法。  </li><li>定义一个类并实现 Runnable 接口，实现run()方法</li></ol><p>总的来说就是线程通过 start()方法启动而不是 run()方法，run()方法的内容为我们要实现的业务逻辑  </p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CreateThread &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread1 thread1 &#x3D; new Thread1();</span><br><span class="line">        &#x2F;&#x2F;声明一个Thread1对象，这个Thread1类继承自Thread类的</span><br><span class="line"></span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Thread2());</span><br><span class="line">        &#x2F;&#x2F;传递一个匿名对象作为参数</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        &#x2F;&#x2F;启动线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Thread1 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;在run()方法中放入线程要完成的工作</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里我们把两个线程各自的工作设置为打印100次信息</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; ++i) &#123;</span><br><span class="line">            System.out.println(&quot;Hello! This is &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在这个循环结束后，线程便会自动结束</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Thread2 implements Runnable &#123;</span><br><span class="line">    &#x2F;&#x2F;与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; ++i) &#123;</span><br><span class="line">            System.out.println(&quot;Thanks. There is &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在控制台就可以看到两个线程近似交替地在输出信息。受到系统调度的影响，两个线程输出信息的先后顺序可能不同。  </p><h3 id="线程变量"><a href="#线程变量" class="headerlink" title="线程变量"></a>线程变量</h3><blockquote><p>ThreadLocal，即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值。<br>可以通过 set(T)方法来设置一个值，在当前线程下再通过 get()方法获取到原先设置的值。</p></blockquote><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo threadDemo &#x3D; new ThreadDemo();</span><br><span class="line">        &#x2F;&#x2F;启动2个线程</span><br><span class="line">        new Thread(threadDemo).start();</span><br><span class="line">        new Thread(threadDemo).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable &#123;</span><br><span class="line">    &#x2F;&#x2F;使用ThreadLocal提供的静态方法创建一个线程变量 并且初始化值为0</span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal &#x3D; ThreadLocal.withInitial(() -&gt; 0);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;get方法获取线程变量值</span><br><span class="line">            Integer integer &#x3D; threadLocal.get();</span><br><span class="line">            integer +&#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;set方法设置线程变量值</span><br><span class="line">            threadLocal.set(integer);</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过输出控制台的结果我们可以看到，两个线程之间的变量互不干涉  </p><h3 id="线程共享变量"><a href="#线程共享变量" class="headerlink" title="线程共享变量"></a>线程共享变量</h3><p>如果我们去掉了ThreadLocal,其他的流程都不改变,已经使用2个线程自增变量会如何呢？  </p><p>修改ThreadLoacalDemo.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo threadDemo &#x3D; new ThreadDemo();</span><br><span class="line">        new Thread(threadDemo).start();</span><br><span class="line">        new Thread(threadDemo).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable &#123;</span><br><span class="line">    private Integer integer &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            integer++;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有加入 ThreadLocal 的情况下，发现 integer 变量的值增加到了 20，那是因为这个时候两个线程都是使用同一对象threadDemo的变量，这个时候的 integer 就变成了线程共享变量，如果同学们多运行几次，还有可能出现最后结果是 18 19 的情况，那是因为如果不做任何处理，线程共享变量都不是线程安全的，也就是说在多线程的情况下，共享变量有可能会出错  </p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当多个线程操作同一个对象时，就会出现线程安全问题，被多个线程同时操作的对象数据可能会发生错误。线程同步可以保证在同一个时刻该对象只被一个线程访问。  </p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。它有三种使用方法：  </p><ul><li>对普通方式使用,将会锁住当前实例对象  </li><li>对静态方法使用,将会锁住当前类的Class对象  </li><li>对代码块使用,将会锁住代码块中的对象  </li></ul><p>使用示例  </p><p>在下面的代码中, 演示了三种加锁方式.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedDemo &#123;</span><br><span class="line">    private static Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;同步代码块 锁住lock</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            &#x2F;&#x2F;doSomething</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;静态同步方法  锁住当前类class对象</span><br><span class="line">    public synchronized static void staticMethod()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;普通同步方法  锁住当前实例对象</span><br><span class="line">    public synchronized void memberMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><p>java.util.concurrent 包是 java5 开始引入的并发类库，提供了多种在并发编程中的适用工具类。包括原子操作类，线程池，阻塞队列，Fork/Join 框架，并发集合，线程同步锁等。  </p><h3 id="Lock-与-Unlock"><a href="#Lock-与-Unlock" class="headerlink" title="Lock 与 Unlock"></a>Lock 与 Unlock</h3><p>JUC 中的 ReentrantLock 是多线程编程中常用的加锁方式，ReentrantLock 加锁比 synchronized 加锁更加的灵活，提供了更加丰富的功能。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class LockDemo &#123;</span><br><span class="line">    private static ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;需要同步的代码块</span><br><span class="line">                System.out.println(&quot;线程1加锁&quot;);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">&#x2F;&#x2F;                一定要在finally中解锁，否则可能造成死锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(&quot;线程1解锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;线程2加锁&quot;);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(&quot;线程2解锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的编程实例中，线程 1 获取了 lockA 的锁后再去获取 lockB 的锁，而此时 lockB 已经被线程 2 获取，同时线程 2 也想获取 lockA，两个线程进这样僵持了下去，谁也不让，造成了死锁。在编程时，应该避免死锁的出现。  </p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况<br>比如当前线程处于一个低优先级的情况下，操作系统每次都调用高优先级的线程运行，就会导致当前线程虽然可以运行，但是一直不能被运行的情况。  </p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>线程的声明周期共有 6 种状态，分别是：新建New、运行（可运行）Runnable、阻塞Blocked、计时等待Timed Waiting、等待Waiting和终止Terminate。  </p><blockquote><p>当你声明一个线程对象时，线程处于新建状态，系统不会为它分配资源，它只是一个空的线程对象<br>调用start()方法时，线程就成为了可运行状态，至于是否是运行状态，则要看系统的调度了<br>调用了sleep()方法、调用wait()方法和 IO 阻塞时，线程处于等待、计时等待或阻塞状态。<br>当run()方法执行结束后，线程也就终止了。  </p></blockquote><p>示例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadState implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void waitForAMoment() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        wait(500);</span><br><span class="line">        &#x2F;&#x2F;使用wait()方法使当前线程等待500毫秒</span><br><span class="line">        &#x2F;&#x2F;或者等待其他线程调用notify()或notifyAll()方法来唤醒</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void waitForever() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        wait();</span><br><span class="line">        &#x2F;&#x2F;不填入时间就意味着使当前线程永久等待，</span><br><span class="line">        &#x2F;&#x2F;只能等到其他线程调用notify()或notifyAll()方法才能唤醒</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void notifyNow() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        notify();</span><br><span class="line">        &#x2F;&#x2F;使用notify()方法来唤醒那些因为调用了wait()方法而进入等待状态的线程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里用异常处理是为了防止可能的中断异常</span><br><span class="line">        &#x2F;&#x2F;如果任何线程中断了当前线程，则抛出该异常</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            waitForAMoment();</span><br><span class="line">            &#x2F;&#x2F; 在新线程中运行waitMoment()方法</span><br><span class="line"></span><br><span class="line">            waitForever();</span><br><span class="line">            &#x2F;&#x2F; 在新线程中运行waitForever()方法</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadState state &#x3D; new ThreadState();</span><br><span class="line">        &#x2F;&#x2F;声明并实例化一个ThreadState对象</span><br><span class="line"></span><br><span class="line">        Thread thread &#x3D; new Thread(state);</span><br><span class="line">        &#x2F;&#x2F;利用这个名为state的ThreadState对象来创建Thread对象</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Create new thread: &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;使用getState()方法来获得线程的状态，并进行输出</span><br><span class="line"></span><br><span class="line">        thread.start(); </span><br><span class="line">        &#x2F;&#x2F;使用thread对象的start()方法来启动新的线程</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Start the thread: &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;输出线程的状态</span><br><span class="line"></span><br><span class="line">        Thread.sleep(100); </span><br><span class="line">        &#x2F;&#x2F;通过调用sleep()方法使当前这个线程休眠100毫秒，从而使新的线程运行waitForAMoment()方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Waiting for a moment (time): &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;输出线程的状态</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000); </span><br><span class="line">        &#x2F;&#x2F;使当前这个线程休眠1000毫秒，从而使新的线程运行waitForever()方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Waiting for a moment: &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;输出线程的状态</span><br><span class="line"></span><br><span class="line">        state.notifyNow(); </span><br><span class="line">        &#x2F;&#x2F; 调用state的notifyNow()方法</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Wake up the thread: &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;输出线程的状态</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000); </span><br><span class="line">        &#x2F;&#x2F;使当前线程休眠1000毫秒，使新线程结束</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Terminate the thread: &quot; + thread.getState());</span><br><span class="line">        &#x2F;&#x2F;输出线程的状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><blockquote><p>ArrayBlockingQueue 是由数组支持的有界阻塞队列.位于java.util.concurrent包下</p></blockquote><p>首先看看其构造方法:  </p><table><thead><tr><th>构造方法</th><th>描述</th></tr></thead><tbody><tr><td>public ArrayBlockingQueue(int capacity)</td><td>构造大小为capacity的队列</td></tr><tr><td>public ArrayBlockingQueue(int capacity, boolean fair)</td><td>指定队列大小，以及内部实现是公平锁还是非公平锁</td></tr><tr><td>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</td><td>指定队列大小, 以及锁实现, 并且在初始化是加入集合c</td></tr></tbody></table><p>入队常用方法:  </p><table><thead><tr><th>入队方法</th><th>队列已满</th><th>队列未满</th></tr></thead><tbody><tr><td>add</td><td>抛出异常</td><td>返回true</td></tr><tr><td>offer</td><td>返回false</td><td>返回true</td></tr><tr><td>put</td><td>阻塞直到插入</td><td>没有返回值</td></tr></tbody></table><p>出队常用方法:  </p><table><thead><tr><th>出队方法</th><th>队列为空</th><th>队列不为空</th></tr></thead><tbody><tr><td>remove</td><td>抛出异常</td><td>移出并返回队首</td></tr><tr><td>poll</td><td>返回null</td><td>移出并返回队首</td></tr><tr><td>take</td><td>阻塞直到返回</td><td>移出并返回队首</td></tr></tbody></table><p>示例源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class ABQDemo &#123;</span><br><span class="line">    &#x2F;&#x2F;构建大小为10的阻塞队列</span><br><span class="line">    private static ArrayBlockingQueue&lt;Integer&gt; arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(10);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;</span><br><span class="line">                arrayBlockingQueue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;等待线程1执行完毕</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;如果插入失败</span><br><span class="line">            if (!arrayBlockingQueue.offer(11)) &#123;</span><br><span class="line">                System.out.println(&quot;插入元素11失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;一直阻塞直到插入元素11，注意这里阻塞的不是主线程，main方法还是继续运行</span><br><span class="line">                arrayBlockingQueue.put(11);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread thread2&#x3D;new Thread(() -&gt; &#123;</span><br><span class="line">            Integer element;</span><br><span class="line">            System.out.println(&quot;开始出队:&quot;);</span><br><span class="line">            &#x2F;&#x2F;打印队列中的元素</span><br><span class="line">            while ((element &#x3D; arrayBlockingQueue.poll()) !&#x3D; null) &#123;</span><br><span class="line">                System.out.print(&quot;\t&quot;+element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><blockquote><p>生产者消费者模式是多线程编程中非常重要的设计模式，生产者负责生产数据，消费者负责消费数据。生产者消费者模式中间通常还有一个缓冲区，用于存放生产者生产的数据，而消费者则从缓冲区中获取，这样可以降低生产者和消费者之间的耦合度。举个例子来说吧，比如有厂家，代理商，顾客，厂家就是生产者，顾客就是消费者，代理商就是缓冲区，顾客从代理商这里买东西，代理商负责从厂家处拿货，并且销售给顾客，顾客不用直接和厂家打交道，并且通过代理商，就可以直接获取商品，或者从代理商处知道货物不足，需要等待。</p></blockquote><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class PCModel &#123;</span><br><span class="line">    private static LinkedBlockingQueue&lt;Integer&gt; queue &#x3D; new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F; 生产者</span><br><span class="line">        Thread provider &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 执行代码块</span><br><span class="line">            Random random &#x3D; new Random();</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 5; j++)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    int i &#x3D; random.nextInt();</span><br><span class="line">                    &#x2F;&#x2F; 直到插入数据</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(&quot;生产数据：&quot;+ i);</span><br><span class="line">                    Thread.sleep(1000);&#x2F;&#x2F; 睡眠程序</span><br><span class="line">                &#125; catch(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();&#x2F;&#x2F; 抛出异常</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 消费者</span><br><span class="line">        Thread consumer &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            Integer data;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    &#x2F;&#x2F; 阻塞直到取出数据</span><br><span class="line">                    data &#x3D; queue.take();</span><br><span class="line">                    System.out.println(&quot;消费数据:&quot;+data);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动线程</span><br><span class="line">        provider.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p></blockquote><p>由于Java创建和销毁线程都会带来资源上的销毁,所以线程池可以帮助我们复用线程，减少资源消耗  </p><p>Java 线程池可以通过 Executors 工具类创建，Executors 常用方法：  </p><ul><li>newFixedThreeadPoo(int nThreads); 创建一个固定大小为n的线程池</li><li>newSingleThreadExecutor(); 创建只有一个线程的线程池  </li><li>newCachedThreadPool(); 创建一个根据需要创建新线程的线程池</li></ul><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    &#x2F;&#x2F;使用Executors 创建一个固定大小为5的线程池</span><br><span class="line">    private static ExecutorService executorService &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        提交任务</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;停止线程池 并不会立即关闭 ，而是在线程池中的任务执行完毕后才关闭</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用**<em>Executors**</em>工具类帮助我们创建之外，也可以直接创建线程池  </p><p>示例代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo2 &#123;</span><br><span class="line">    private static ExecutorService executorService &#x3D; new ThreadPoolExecutor(</span><br><span class="line">            5, &#x2F;&#x2F;核心线程数为5</span><br><span class="line">            10,&#x2F;&#x2F;最大线程数为10</span><br><span class="line">            0L, TimeUnit.MILLISECONDS,&#x2F;&#x2F;非核心线程存活时间</span><br><span class="line">            new LinkedBlockingQueue&lt;&gt;());&#x2F;&#x2F;任务队列 </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;提交任务</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;关闭线程池</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java Socket 的使用</title>
      <link href="2019/12/23/java-Socket-2019-12-23/"/>
      <url>2019/12/23/java-Socket-2019-12-23/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Socket"><a href="#Java-Socket" class="headerlink" title="Java Socket"></a>Java Socket</h2><blockquote><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节</p></blockquote><ul><li>TCP  </li><li>UDP  </li><li>HttpURLConnection</li><li>InetAddress  </li><li>Socket</li><li>ServerSocket</li></ul><h3 id="Socket-简介-摘抄网络"><a href="#Socket-简介-摘抄网络" class="headerlink" title="Socket 简介(摘抄网络)"></a>Socket 简介(摘抄网络)</h3><blockquote><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket<br> 建立网络通信连接至少要一对端口号(socket)。socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口<br>HTTP 是轿车，提供了封装或者显示数据的具体形式<br>Socket 是发动机，提供了网络通信的能力<br>Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信<br>在 Internet 上的主机一般运行了多个服务软件，同时提供几种服务<br>每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务<br>Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目<br> 客户软件将插头插到不同编号的插座，就可以得到不同的服务  </p></blockquote><h3 id="TCP-摘抄网络"><a href="#TCP-摘抄网络" class="headerlink" title="TCP (摘抄网络)"></a>TCP (摘抄网络)</h3><blockquote><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议<br>在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层<br>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换<br>应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）<br>之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收<br>然后接收端实体对已成功收到的包发回一个相应的确认（ACK）<br>如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传<br>TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和  </p></blockquote><h3 id="UDP-摘抄网络"><a href="#UDP-摘抄网络" class="headerlink" title="UDP (摘抄网络)"></a>UDP (摘抄网络)</h3><blockquote><p>UDP 是 User Datagram Protocol 的简称， 中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768 是 UDP 的正式规范。UDP 在 IP 报文的协议号是 17。<br>UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层<br>UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的<br>UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议<br>UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天 UDP 仍然不失为一项非常实用和可行的网络传输层协议<br>与所熟知的 TCP（传输控制协议）协议一样，UDP 协议直接位于 IP（网际协议）协议的顶层。根据 OSI（开放系统互连）参考模型，UDP 和 TCP 都属于传输层协议<br>UDP 协议的主要作用是将网络数据流量压缩成数据包的形式<br>一个典型的数据包就是一个二进制数据的传输单位。每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据  </p></blockquote><h3 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h3><blockquote><p>HttpURLConnection 位于 java.net 包中，支持 HTTP 特定功能。我们可以使用它来发起网络请求，获取服务器的相关资源。</p></blockquote><p>HttpURLConnection 提供了很多方法用于使用 Http，这里只演示了使用<br>HttpURLConnection 类的基本流程，想要了解更多方法的同学可以查询<a href="https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html">API 文档</a>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.HttpURLConnection;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class HttpUrlTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;设置url</span><br><span class="line">            URL shiyanlou &#x3D; new URL(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;);</span><br><span class="line">            &#x2F;&#x2F;打开连接</span><br><span class="line">            HttpURLConnection urlConnection &#x3D; (HttpURLConnection)shiyanlou.openConnection();</span><br><span class="line">            &#x2F;&#x2F;设置请求方法</span><br><span class="line">            urlConnection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">            &#x2F;&#x2F;设置连接超时时间</span><br><span class="line">            urlConnection.setConnectTimeout(1000);</span><br><span class="line">            &#x2F;&#x2F;获取输入流</span><br><span class="line">            InputStream inputStream &#x3D; urlConnection.getInputStream();</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">            &#x2F;&#x2F;打印结果</span><br><span class="line">            bufferedReader.lines().forEach(System.out::println);</span><br><span class="line">            &#x2F;&#x2F;关闭连接</span><br><span class="line">            inputStream.close();</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面对baidu发起请求抓取  获取首页源代码  </p></blockquote><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><blockquote><p>InetAddress类用于表示 IP 地址，比如在进行 Socket 编程时，就会使用到该类。  </p></blockquote><p>InetAddress没有公共构造方法，我们只能使用它提供的静态方法来构建一个InetAddress类实例  </p><ul><li>getLocalHost(): 返回本地主机地址</li><li>getAllByName（String host）：从指定的主机名返回 InetAddress 对象的数组，因为主机名可以与多个 IP 地址相关联。  </li><li>getByAddress（byte [] addr）：从原始 IP 地址的字节数组中返回一个 InetAddress 对象。  </li><li>getByName（String host）：根据提供的主机名创建一个 InetAddress 对象。  </li><li>getHostAddress（）：返回文本表示的 IP 地址字符串。  </li><li>getHostname（）：获取主机名。  </li></ul><p>代码实例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class InetAddressDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InetAddress shiyanlou &#x3D; InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            &#x2F;&#x2F;toString 方法将输出主机名和ip地址</span><br><span class="line">            System.out.println(shiyanlou.toString());</span><br><span class="line">            &#x2F;&#x2F;获取ip地址</span><br><span class="line">            String ip &#x3D; shiyanlou.toString().split(&quot;&#x2F;&quot;)[1];</span><br><span class="line">            &#x2F;&#x2F;根据IP地址获取主机名</span><br><span class="line">            InetAddress byAddress &#x3D; InetAddress.getByName(ip);</span><br><span class="line">            System.out.println(&quot;get hostname by IP address:&quot; + byAddress.getHostName());</span><br><span class="line">            System.out.println(&quot;localhost: &quot;+InetAddress.getLocalHost());</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码 获取baidu的主机名和ip地址 并输出  </p></blockquote><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket类代表一个客户端套接字，可以使用该类想服务器发送和接受数据。一般需要通过下面几个步骤：  </p><ol><li>建立与服务器的连接</li><li>使用输出流将数据发送到服务器</li><li>使用输入流读取服务器返回的数据</li><li>关闭连接</li></ol><h4 id="Socket-常用构造方法"><a href="#Socket-常用构造方法" class="headerlink" title="Socket 常用构造方法"></a>Socket 常用构造方法</h4><ul><li><strong><em>Socket(InetAddress address, int port)</em></strong>：创建一个套接字，连接到指定 IP 地址和端口的服务器</li><li><strong><em>Socket(String host, int port)</em></strong>：创建一个套接字，连接到指定的主机名和端口的服务器</li><li><strong><em>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</em></strong>：创建一个套接字连接到指定的 IP 地址和端口的服务器，并且显示的指定客户端地址和端口。</li></ul><p>在创建Socket时，需要捕获异常  </p><h4 id="getOutputStream"><a href="#getOutputStream" class="headerlink" title="getOutputStream()"></a>getOutputStream()</h4><p>该方法可以获取输出流，在建立连接后，可以使用该方法获取输出流，发送数据到服务器。发送数据的方式和使用 IO 流是相同的，使用 write 方法发送指定的数据即可。</p><h4 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream()"></a>getInputStream()</h4><p>用户获取输入流，通过该方法获取输入流之后可以读取服务器发送来的数据。使用方法和 IO 流相同，使用 read 方法即可。</p><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>关闭 Socket，可能抛出 IO 异常，所以我们同样需要捕获异常。</p><h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><p><strong><em>ServerSocket</em></strong>类用于实现服务器套接字，服务器套接字会等待客户端网络连接，与客户端连接之后，会进行一系列操作，然后将结果返回给客户端。  </p><p>创建一个**<em>ServerSocket**</em>一般需要以下几个步骤:  </p><ol><li>创建服务器套接字并将其绑定到特定的接口  </li><li>等待客户端连接  </li><li>通过客户端套接字获取输入流，从客户端读取数据  </li><li>通过客户端套接字获取输出流，发送数据到客户端  </li><li>关闭套接字  </li></ol><p>常用构造方法:  </p><ul><li><strong><em>ServerSocket()</em></strong>:创建一个未绑定端口的服务器器套接字  </li><li><strong><em>ServerSocket(int port)</em></strong>：创建绑定到指定端口号的服务器套接字.</li><li><strong><em>ServerSocket(int port, int backlog)</em></strong>：创建一个绑定到指定端口号的服务器套接字，并且**<em>backlog**</em> 参数指定了最大排队连接数</li><li><strong><em>ServerSocket(int port,int backlog,InetAddress bindAddr)</em></strong>：创建服务器套接字并将其绑定到指定的端口号和本地 IP 地址。</li></ul><p>示例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket &#x3D; new ServerSocket(8888);</span><br></pre></td></tr></table></figure><h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>用于监听客户端连接请求，当调用该方法时，会阻塞当前线程，直到有客户端发起请求与其建立连接，否则将一直等待。当连接成功后，将返回一个**<em>Socket**</em>对象。</p><h4 id="close-1"><a href="#close-1" class="headerlink" title="close()"></a>close()</h4><p>用于关闭服务器套接字，服务器停止后，将断开所有连接。  </p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>可以查阅<a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html">官方文档</a></p><h3 id="网络编程实例"><a href="#网络编程实例" class="headerlink" title="网络编程实例"></a>网络编程实例</h3><blockquote><p>java.net 包提供了两个类Socket和ServerSocket，分别实现 Socket 连接的客户端和服务器端。  </p></blockquote><p>我们编译一个简单的 Socket 应用，实现客户端发送信息给服务端，服务端再将信息发送回客户端的回显的功能。  </p><p>服务端：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class EchoServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;服务端需要使用ServerSocket类</span><br><span class="line">            ServerSocket serverSocket &#x3D; new ServerSocket(1080);</span><br><span class="line">            &#x2F;&#x2F;阻塞 等待客户端连接</span><br><span class="line">            Socket client &#x3D; serverSocket.accept();</span><br><span class="line">            PrintWriter out &#x3D; new PrintWriter(client.getOutputStream(), true);</span><br><span class="line">            BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            String userIn;</span><br><span class="line">            while ((userIn &#x3D; in.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                System.out.println(&quot;收到客户端消息：&quot; + userIn);</span><br><span class="line">                &#x2F;&#x2F;发回客户端</span><br><span class="line">                out.println(userIn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class EchoClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String hostname &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">        &#x2F;&#x2F;socket端口</span><br><span class="line">        int port &#x3D; 1080;</span><br><span class="line">        Scanner userIn &#x3D; new Scanner(System.in);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;建立socket连接</span><br><span class="line">            Socket socket &#x3D; new Socket(hostname, port);</span><br><span class="line">            &#x2F;&#x2F;获取socket输出流</span><br><span class="line">            PrintWriter out &#x3D; new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">            &#x2F;&#x2F;获取输入流</span><br><span class="line">            BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String userInput;</span><br><span class="line">            System.out.println(&quot;请输入信息：&quot;);</span><br><span class="line">            &#x2F;&#x2F;当用户输入exit时退出</span><br><span class="line">            while (!&quot;exit&quot;.equals(userInput &#x3D; userIn.nextLine())) &#123;</span><br><span class="line">                out.println(userInput);</span><br><span class="line">                System.out.println(&quot;收到服务端回应:&quot; + in.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;关闭socket</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java Set、HashSet 的使用</title>
      <link href="2019/12/22/java-Set-HashSet-2019-12-22/"/>
      <url>2019/12/22/java-Set-HashSet-2019-12-22/</url>
      
        <content type="html"><![CDATA[<h2 id="Set-和-HashSet"><a href="#Set-和-HashSet" class="headerlink" title="Set 和 HashSet"></a>Set 和 HashSet</h2><p>Set 接口也是 Collection 接口的子接口, 它有一个很重要也是很常用的实现类—-HashSet.<br>Set 是元素无需并且不包含重复元素的Collection(List可以重复), 被称为集  </p><p>HashSet 由哈希表(实际上是一个HashMap实例)支持. 它不保证set的迭代顺序; 特别是它不保证该顺序恒久不变  </p><p>示例代码:</p><blockquote><p>假设现在学生们要做项目，每个项目有一个组长，由组长来组织组员，我们便来实现项目组的管理吧。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PD.java</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 项目组长类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PD &#123;</span><br><span class="line"></span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    public Set&lt;Student&gt; students;</span><br><span class="line">    public PD(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.students &#x3D; new HashSet&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;&#x2F; Student.java</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Student(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&#39;&quot; + id + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理成员类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SetTest.java</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class SetTest &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line">    public SetTest() &#123;</span><br><span class="line">        students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 用于往students中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个学生对象，并通过调用add方法，添加到学生管理List中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;添加到List中的类型均为Object，所以取出时还需要强转</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;,&quot;李四&quot;);</span><br><span class="line">        students.add(st2);</span><br><span class="line"></span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;),new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line"></span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;),new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(Arrays.asList(student2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过for each 方法访问集合元素</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过for each）：&quot;);</span><br><span class="line">        for(Object obj:students)&#123;</span><br><span class="line">            Student st &#x3D; (Student)obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SetTest st &#x3D; new SetTest();</span><br><span class="line">        st.testAdd();</span><br><span class="line">        st.testForEach();</span><br><span class="line">        PD pd &#x3D; new PD(&quot;1&quot;,&quot;张老师&quot;);</span><br><span class="line">        System.out.println(&quot;请：&quot; + pd.name + &quot;选择小组成员！&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来接收从键盘输入的学生 ID</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i &lt; 3; i++)&#123;</span><br><span class="line">            System.out.println(&quot;请输入学生 ID&quot;);</span><br><span class="line">            String studentID &#x3D; console.next();</span><br><span class="line">            for(Student s:st.students)&#123;</span><br><span class="line">                if(s.id.equals(studentID))&#123;</span><br><span class="line">                    pd.students.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.testForEachForSer(pd);</span><br><span class="line">        &#x2F;&#x2F; 关闭 Scanner 对象</span><br><span class="line">        console.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印输出，老师所选的学生！Set里遍历元素只能用foreach 和 iterator </span><br><span class="line">    &#x2F;&#x2F;不能使用 get() 方法，因为它是无序的，不能想 List 一样查询具体索引的元素</span><br><span class="line">    public void testForEachForSer(PD pd)&#123;</span><br><span class="line">        for(Student s: pd.students) &#123;</span><br><span class="line">        System.out.println(&quot;选择了学生：&quot; + s.id + &quot;:&quot; + s.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ javac PD.java SetTest.java Student.java</span><br><span class="line">$ java SetTest</span><br><span class="line">有如下学生（通过for each）：</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：3:王五</span><br><span class="line">学生：4:马六</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">请：张老师选择小组成员！</span><br><span class="line">请输入学生 ID</span><br><span class="line">4</span><br><span class="line">请输入学生 ID</span><br><span class="line">5</span><br><span class="line">请输入学生 ID</span><br><span class="line">6</span><br><span class="line">选择了学生：4:马六</span><br><span class="line">选择了学生：5:周七</span><br><span class="line">选择了学生：6:赵八</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Set </tag>
            
            <tag> java HashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java Map 的使用</title>
      <link href="2019/12/21/java-map-2019-12-21/"/>
      <url>2019/12/21/java-map-2019-12-21/</url>
      
        <content type="html"><![CDATA[<h2 id="java-Map"><a href="#java-Map" class="headerlink" title="java Map"></a>java Map</h2><p>Map 接口也是一个非常重要的集合接口, 用于存储键/值对.<br>Map 中的元素都是成对出现的,键值对就想数组的索引与数组的内容关系一样, 将一个键映射到一个值的对象.<br>一个映射不能包含重复的键；每个键最多只能映射到一个值.<br>我们可以通过键去找到相应的值.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D;&gt;(映射) value</span><br></pre></td></tr></table></figure><p>value 可以存储任意类型的对象,我们可以根据key键快速查找value.<br>Map 中的键/值对以Entry类型的对象实例形式存在.  </p><p>Map 方法:</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>clear()</td><td>void</td><td>从此映射中一处所用映射关系(可选操作)</td></tr><tr><td>containsKey(Object key)</td><td>boolean</td><td>如果此映射包含指定键的映射关系,则返回 true</td></tr><tr><td>containsValue(Object value)</td><td>boolean</td><td>如果此映射将一个或多个映射到指定值,则返回true</td></tr><tr><td>entrySet()</td><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;</td><td>返回此映射中包含的映射关系的Set视图</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较指定的对象与此映射是否相等</td></tr><tr><td>get(Object key)</td><td>V</td><td>返回指定键所映射的值;如果此映射不包含该键的映射关系,则返回null</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此映射的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此映射为包含键-值映射关系,则返回true</td></tr><tr><td>keySet()</td><td>Set<K></td><td>返回此映射中包含的键的Set视图</td></tr><tr><td>put(K key,Vvalue)</td><td>V</td><td>将指定的值与此映射中的指定键关联（可选操作）</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt;m)</td><td>void</td><td>从指定映射中将所有映射关系复制到此映射中（可选操作）</td></tr><tr><td>remove(Object key)</td><td>V</td><td>如果存在一个键的映射关系,则将其从此映射中移除（可选操作）</td></tr><tr><td>size</td><td>int</td><td>返回此映射中的键-值映射关系数</td></tr><tr><td>values()</td><td>Collection<V></td><td>返回此映射中包含的值的Collection 视图</td></tr></tbody></table><p>HashMap 是基于哈希表的Map接口的一个重要实现类. HashMap 中的Entry对象是无需排列的,key值和value值都可以为null,但是一个HashMap 只能有一个key值为null的映射(key值不可重复)  </p><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Course.java</span><br><span class="line">public class Course &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Course(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MapTest.java</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来承装课程类型对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Map&lt;String, Course&gt; courses;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在构造器中初始化 courses 属性</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public MapTest() &#123;</span><br><span class="line">        this.courses &#x3D; new HashMap&lt;String, Course&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试添加：输入课程 ID，判断是否被占用</span><br><span class="line">     * 若未被占用，输入课程名称，创建新课程对象</span><br><span class="line">     * 并且添加到 courses 中</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testPut() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，用来获取输入的课程 ID 和名称</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.println(&quot;请输入课程 ID：&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否被占用</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null)&#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入课程名称</span><br><span class="line">                System.out.println(&quot;请输入课程名称：&quot;);</span><br><span class="line">                String name &#x3D; console.next();</span><br><span class="line">                &#x2F;&#x2F;创建新的课程对象</span><br><span class="line">                Course newCourse &#x3D; new Course(ID,name);</span><br><span class="line">                &#x2F;&#x2F;通过调用 courses 的 put 方法，添加 ID-课程映射</span><br><span class="line">                courses.put(ID, newCourse);</span><br><span class="line">                System.out.println(&quot;成功添加课程：&quot; + courses.get(ID).name);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;该课程 ID 已被占用&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试 Map 的 keySet 方法</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void testKeySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 keySet 方法，返回 Map 中的所有键的 Set 集合</span><br><span class="line">        Set&lt;String&gt; keySet &#x3D; courses.keySet();</span><br><span class="line">        &#x2F;&#x2F;遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value</span><br><span class="line">        for(String crID: keySet) &#123;</span><br><span class="line">            Course cr &#x3D; courses.get(crID);</span><br><span class="line">            if(cr !&#x3D; null)&#123;</span><br><span class="line">                System.out.println(&quot;课程：&quot; + cr.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试删除 Map 中的映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        &#x2F;&#x2F;获取从键盘输入的待删除课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            &#x2F;&#x2F;提示输出待删除的课程 ID</span><br><span class="line">            System.out.println(&quot;请输入要删除的课程 ID！&quot;);</span><br><span class="line">            String ID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;判断该 ID 是否对应的课程对象</span><br><span class="line">            Course cr &#x3D; courses.get(ID);</span><br><span class="line">            if(cr &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;提示输入的 ID 并不存在</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            courses.remove(ID);</span><br><span class="line">            System.out.println(&quot;成功删除课程&quot; + cr.name);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过 entrySet 方法来遍历 Map</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testEntrySet() &#123;</span><br><span class="line">        &#x2F;&#x2F;通过 entrySet 方法，返回 Map 中的所有键值对</span><br><span class="line">        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet &#x3D; courses.entrySet();</span><br><span class="line">        for(Entry&lt;String,Course&gt; entry: entrySet) &#123;</span><br><span class="line">            System.out.println(&quot;取得键：&quot; + entry.getKey());</span><br><span class="line">            System.out.println(&quot;对应的值为：&quot; + entry.getValue().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 利用 put 方法修改Map 中的已有映射</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify()&#123;</span><br><span class="line">        &#x2F;&#x2F;提示输入要修改的课程 ID</span><br><span class="line">        System.out.println(&quot;请输入要修改的课程 ID：&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串</span><br><span class="line">        Scanner console &#x3D; new Scanner(System.in);</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            &#x2F;&#x2F;取得从键盘输入的课程 ID</span><br><span class="line">            String crID &#x3D; console.next();</span><br><span class="line">            &#x2F;&#x2F;从 courses 中查找该课程 ID 对应的对象</span><br><span class="line">            Course course &#x3D; courses.get(crID);</span><br><span class="line">            if(course &#x3D;&#x3D; null) &#123;</span><br><span class="line">                System.out.println(&quot;该 ID 不存在！请重新输入！&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;提示当前对应的课程对象的名称</span><br><span class="line">            System.out.println(&quot;当前该课程 ID，所对应的课程为：&quot; + course.name);</span><br><span class="line">            &#x2F;&#x2F;提示输入新的课程名称，来修改已有的映射</span><br><span class="line">            System.out.println(&quot;请输入新的课程名称：&quot;);</span><br><span class="line">            String name &#x3D; console.next();</span><br><span class="line">            Course newCourse &#x3D; new Course(crID,name);</span><br><span class="line">            courses.put(crID, newCourse);</span><br><span class="line">            System.out.println(&quot;修改成功！&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MapTest mt &#x3D; new MapTest();</span><br><span class="line">        mt.testPut();</span><br><span class="line">        mt.testKeySet();</span><br><span class="line">        mt.testRemove();</span><br><span class="line">        mt.testModify();</span><br><span class="line">        mt.testEntrySet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ javac Course.java MapTest.java</span><br><span class="line">$ java MapTest</span><br><span class="line">请输入课程 ID：</span><br><span class="line">1</span><br><span class="line">请输入课程名称：</span><br><span class="line">语文</span><br><span class="line">成功添加课程：语文</span><br><span class="line">请输入课程 ID：</span><br><span class="line">1</span><br><span class="line">该课程 ID 已被占用</span><br><span class="line">请输入课程 ID：</span><br><span class="line">2</span><br><span class="line">请输入课程名称：</span><br><span class="line">数学</span><br><span class="line">成功添加课程：数学</span><br><span class="line">课程：语文</span><br><span class="line">课程：数学</span><br><span class="line">请输入要删除的课程 ID！</span><br><span class="line">1</span><br><span class="line">成功删除课程语文</span><br><span class="line">请输入要修改的课程 ID：</span><br><span class="line">2</span><br><span class="line">当前该课程 ID，所对应的课程为：数学</span><br><span class="line">请输入新的课程名称：</span><br><span class="line">英语</span><br><span class="line">修改成功！</span><br><span class="line">取得键：2</span><br><span class="line">对应的值为：英语</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java JDBC 的使用</title>
      <link href="2019/12/20/java-JDBC-2019-12-20/"/>
      <url>2019/12/20/java-JDBC-2019-12-20/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-JDBC"><a href="#Java-JDBC" class="headerlink" title="Java JDBC"></a>Java JDBC</h2><blockquote><p>JDBC 是连接数据库和Java程序的桥梁，通过JDBC API 可以方便地实现对各种主流数据库的操作. 本节将重点讲解JDBC的内容  </p></blockquote><p>本章概括:  </p><ul><li>SQL 简介  </li><li>JDBC  </li><li>创建数据库  </li><li>数据库操作  </li><li>JDBC 结果集</li><li>插入数据</li></ul><blockquote><p>小提示 在已经掌握了 关系数据库 和 非关系数据库的小伙伴 可以进行适当跳章</p></blockquote><h3 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h3><p>数据库，简而言之可以理解成电子化的文件柜–存储点子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作  </p><p>所谓”数据库”系以一定方式存储在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成.  </p><p>常见的关系型数据库有以下几种:  </p><ul><li>Mysql  <ul><li>MariaDB  </li><li>Percona Server  </li></ul></li><li>PostgreSQL</li><li>Microsoft Access</li><li>Microsoft SQL Server</li><li>Google Fusion Tables</li><li>FileMaker  </li><li>Oracle    </li><li>Sybase</li><li>dBASE</li><li>Clipper  </li><li>FoxPro  </li><li>foshub  </li></ul><p>常见的非关系型数据库  </p><ul><li>Redis  </li><li>BigTable  </li><li>Cassandra  </li><li>MongoDB  </li><li>CouchDB  </li></ul><h3 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h3><blockquote><p>结构化查询语言(Structured Query Language)简称 SQL(发音：/ˈes kjuː ˈel/ “S-Q-L”)，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</p></blockquote><p>SQL语句不是本章节主要内容 想要了解 <a href="https://www.runoob.com/sql/sql-tutorial.html">请戳这里</a>  </p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><blockquote><p>JDBC 的全称是 Java Database Connectivity，叫做 Java 数据库连接。它包括了一组与数据库交互的api，还有与数据库进行通信的驱动程序。  </p></blockquote><p>我们要写设计到数据库的程序，是通过C语言或者C++语言直接访问数据库的接口  </p><p>对于不同的数据库，我们需要知道不同数据库对外提供的系统API，这就影响了我们程序扩展和跨平台的实现.  </p><p>那么有没有一种方法来对不同的数据库接口进行统一呢？ 当然有. 我们只需要和最上层接口进行交互，剩下的部分就交给其它层去处理,我们的任务就变得轻松简单许多 .  </p><p>JDBC 为数据库开发人员提供了一个标准的API，据此可以构建更高级的工具和接口使数据库开发人员能够用纯Java API 编写数据库应用程序  </p><h4 id="JDBC-连接数据库"><a href="#JDBC-连接数据库" class="headerlink" title="JDBC 连接数据库"></a>JDBC 连接数据库</h4><p>设计到建立一个JDBC连接的编程主要有四个步骤:  </p><ol><li>导入JDBC驱动：只有拥有了驱动程序我们才可以注册驱动程序完成连接的其他步骤.  </li><li>注册 JDBC 驱动程序：这一步会导致 JVM 加载所需的驱动类实现到内存中，然后才可以实现 JDBC 请求。</li><li>数据库 URL 指定：创建具有正确格式的地址，指向到要连接的数据库。</li><li>创建连接对象：最后，代码调用 DriverManager 对象的 getConnection() 方法来建立实际的数据库连接。</li></ol><h5 id="导入JDBC-驱动程序"><a href="#导入JDBC-驱动程序" class="headerlink" title="导入JDBC 驱动程序"></a>导入JDBC 驱动程序</h5><p>需要下载对应的数据库的JDBC驱动，将其导入到项目中,具体的导入方式根据个人的IDE确定，当前我们直接通过命令行导入 <strong><em>javac -cp</em></strong> </p><h5 id="注册JDBC驱动程序"><a href="#注册JDBC驱动程序" class="headerlink" title="注册JDBC驱动程序"></a>注册JDBC驱动程序</h5><p>我们在使用驱动程序之前，必须注册你的驱动程序。注册驱动程序的本质就是将我们将要使用的数据库的驱动类文件动态的加载到内存中，然后才能进行数据库。比如我们使用的 Mysql 数据库。我们可以通过以下两种方式来注册我们的驱动程序。</p><ol><li>方法一 —- Class.forName();  </li></ol><p>动态加载一个类最常用的方法时使用Java的Class.forName()方法,通过使用这个方法来将数据库的驱动类动态加载到内存中,然后我们就可以使用.  </p><p>使用Class.forName()来注册Mysql驱动程序;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125; catch(ClassNotFoundException ex)&#123;</span><br><span class="line">    System.out.println(&quot;Error: unable to load driver class!&quot;);</span><br><span class="line">    System.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法2 —- DriverManager.registerDriver();  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Driver driver &#x3D; new com.mysql.jdbc.Driver();</span><br><span class="line">DriverManager.registerDriver(driver);</span><br></pre></td></tr></table></figure><p>指定数据库连接 URL  </p><p>当加载了驱动程序,便可以使用 <strong><em>DriverManager.getConnection()</em></strong> 方法连接到数据库了<br>这里给出 <strong><em>DriverManager.getConnection()</em></strong> 三个重载方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getConnection(String url)</span><br><span class="line"></span><br><span class="line">getConnection(String url, Properties prop)</span><br><span class="line"></span><br><span class="line">getConnection(String url, String user, String password)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库的URL是指定数据库地址.下表列出了下来流行的JDBC驱动程序名和数据库的URL。  </p><table><thead><tr><th>RDBMS</th><th>JDBC 驱动程序的名称</th><th>URL</th></tr></thead><tbody><tr><td>Mysql</td><td>com.mysql.jdbc.Driver</td><td>jdbc:mysql://hostname/databaseName</td></tr><tr><td>Oracle</td><td>oracle.jdbc.driver.OracleDriver</td><td>jdbc:oracle:thin:@hostname:port Number:databaseName</td></tr><tr><td>DB2</td><td>COM.ibm.db2.jdbc.net.DB2Driver</td><td>jdbc:db2:hostname:port Number/databaseName</td></tr><tr><td>Sybase</td><td>com.sybase.jdbc.SybDriver</td><td>jdbc:sybase:Tds:hostname: port Number/databaseName</td></tr></tbody></table><h5 id="创建连接对象"><a href="#创建连接对象" class="headerlink" title="创建连接对象"></a>创建连接对象</h5><p>下面三种形式 DriverManager.getConnection() 方法来创建一个连接对象，以 Mysql 为例。getConnection()最常用形式要求传递一个数据库 URL，用户名 username 和密码 password。</p><ol><li>使用数据库 <strong><em>URL</em></strong> 的 <strong><em>用户名</em></strong> 和 <strong><em>密码</em></strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;EXAMPLE&quot;;</span><br><span class="line">String USER &#x3D; &quot;username&quot;;</span><br><span class="line">String PASS &#x3D; &quot;password&quot;;</span><br><span class="line">Connection conn &#x3D; DriverManager.gegtConnection(URL, USER, PASS);</span><br></pre></td></tr></table></figure><ol start="2"><li>只使用一个数据库 <strong><em>URL</em></strong> </li></ol><p>然而在这种情况下，数据库的URL，包括用户名和密码。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;EXAMPLE?user&#x3D;root&amp;password&#x3D;0909&quot;;&#x2F;&#x2F; 密码为示例</span><br><span class="line">&#x2F;&#x2F; Mysql URL 的参数设置详细可以查阅相关资料</span><br><span class="line">Connection conn &#x3D; DriverManager.getConnection(URL);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用数据库的 <strong><em>URL</em></strong> 和 一个 <strong><em>Properties</em></strong> 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">String URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;EXAMPLE&quot;;</span><br><span class="line">Properties pro &#x3D; new Properties();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Properties 对象 保存一组关键词-值对</span><br><span class="line">pro.put(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">pro.put(&quot;password&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">Connection conn &#x3D; DriverManager.getConnection(URL, pro);</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭JDBC连接</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><blockquote><p>在使用数据库之前第一件事情就是创建数据库，这里我们将使用JDBC来创建数据库</p></blockquote><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.*;</span><br><span class="line"></span><br><span class="line">public class CreateDatabase &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;加载数据库驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;打开数据库连接 第一个参数为数据库地址  后面2个参数分别为数据库用户名和密码</span><br><span class="line">            connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;&quot;,&quot;root&quot;,&quot;&quot;);</span><br><span class="line">            &#x2F;&#x2F;创建Statement</span><br><span class="line">            Statement statement &#x3D; connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;执行sql</span><br><span class="line">            statement.execute(&quot;create database EXAMPLE&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;关闭连接</span><br><span class="line">                if (connection !&#x3D; null) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动mysql 服务</p><p>单文件编译运行需要使用mysql的 jar 包  </p><p>运行示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;labfile.oss.aliyuncs.com&#x2F;courses&#x2F;1230&#x2F;mysql-connector-java-5.1.47.jar</span><br><span class="line">$ javac -cp mysql-connector-java-5.1.47.jar CreateDatabase.java</span><br><span class="line">$ java -cp .:mysql-connector-java-5.1.47.jar CreateDatabase</span><br></pre></td></tr></table></figure><h5 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h5><p>当连接上了数据库后，就需要通过SQL语句对数据库进行操作. 随着java语言应用面的逐步扩宽，Sun公司开发了一个标准的SQL数据库访问接口—-JDBC API. 它可以使Java编程人员通过一个一致的接口，访问多种关系数据库.而今天我们简单示例一遍，如何利用JDBC的一些核心API与数据库进行交互  </p><p>通过使用JDBC Statement, CallableStatement 和 PreparedStatement 接口定义的方法和属性,使可以使用SQL或者PL/SQL 命令和从数据库接收数据. 他们还定义了许多方法,帮助消除Java和数据库之间数据类型的差异  </p><table><thead><tr><th>接口</th><th>应用场景</th></tr></thead><tbody><tr><td>Statement</td><td>当在运行时使用静态SQL语句时（Statement接口不能接收参数)</td></tr><tr><td>CallableStatement</td><td>当要访问数据库中的存储过程时（CallableStatement对象的接口还可以接收运行时输入参数）</td></tr><tr><td>PreparedStatement</td><td>当计划多次使用SQL语句时（PreparedStatement接口接收在运行时输入参数）</td></tr></tbody></table><h5 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h5><p>我们要使用 <strong><em>Statement</em></strong> 接口，第一步肯定是创建一个 <strong><em>Statement</em></strong> 对象了。我们需要使用 <strong><em>Connection</em></strong> 对象的 <strong><em>createStatement()</em></strong> 方法进行创建.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    stmt &#x3D; conn.createStatement();</span><br><span class="line">    ……</span><br><span class="line">&#125; catch(SQLException e)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦创建了一个 <strong><em>Statement</em></strong> 对象，我们就可以用它来执行SQL 语句了， 首先我们先来看看Statement 里面有哪些方法吧!  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean execute(String SQL)</td><td>如果 ResultSet 对象可以被检索返回布尔值true，否则返回false。使用这个方法来执行SQL DDL 语句，或当需要使用真正的动态SQL</td></tr><tr><td>int executeUpdate(String SQL)</td><td>用于执行 INSERT、UPDATE或DELETE语句以及SQLDDL（数据定义语言）语句。返回值是一个整数, 指示受影响的行数（即更新计数）</td></tr><tr><td>ResultSet executeQuery(String SQL)</td><td>返回ResultSet对象。用于产生单个结果集的语句,例如SELECT 语句</td></tr></tbody></table><p>正如关闭一个Connection 对象来释放数据库连接资源，出于同样的原因，也应该关闭Statement对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt &#x3D; null;</span><br><span class="line">try&#123;</span><br><span class="line">    stmt &#x3D; conn.createStatement();</span><br><span class="line">    ……</span><br><span class="line">&#125; catch (SQLException e)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    stmt.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果关闭了 <strong><em>Connection</em></strong> 对象首先它会关闭 <strong><em>Statement</em></strong> 对象，然而应该始终明确关闭Statement对象，以确保正确的清除。  </p></blockquote><h5 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h5><p>PreparedStatement 接口扩展了 Statement 接口，有利于高效地执行多次使用的 SQL 语句。我们先来创建一个 PreparedStatement 对象。 Statement 为一条 SQL 语句生成执行计划。如果要执行两条 SQL 语句，会生成两个执行计划。一万个查询就生成一万个执行计划！ 　</p><p>PreparedStatement 用于使用绑定变量重用执行计划  </p><p>通过 set 不同数据，只需要生成一次执行计划，并且可以重用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在JDBC中所有的参数都被代表？符号，这是已知的参数标记。在执行SQL语句之前 必须提供值的每一个参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String SQL &#x3D; &quot;Update Students SET age &#x3D; ? WHERE id &#x3D; ?&quot;;</span><br><span class="line">    pstmt &#x3D; conn.prepareStatement(SQL);</span><br><span class="line">    . . .</span><br><span class="line">&#125; catch (SQLException e)&#123;</span><br><span class="line">    pstmt.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CallableStatement"><a href="#CallableStatement" class="headerlink" title="CallableStatement"></a>CallableStatement</h5><p>CallableStatement 对象为所有的 DBMS 提供了一种以标准形式调用存储过程的方法。存储过程储存在数据库中。对储存过程的调用是 CallableStatement 对象所含的内容。三种类型的参数有：IN，OUT 和 INOUT。PreparedStatement 对象只使用IN参数。 CallableStatement 对象可以使用所有三个  </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>它的值实在创建SQL语句时未知的参数，将IN参数传给CallableStatement对象是通过 setXXX() 方法完成的</td></tr><tr><td>OUT</td><td>其值由它返回的SQL语句提供的参数。从OUT参数的getXXX() 方法检索值</td></tr><tr><td>INOUT</td><td>同时提供输入和输出值的参数，绑定的setXXX() 方法的变量，并使用getXXX() 方法检索值</td></tr></tbody></table><p>在JDBC中调用存储过程的语法如下所示. 注意，方括号标识其间的内容是可选项; 方括号本身并不是语法的组成部分.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;call 存储过程名[(?,?,……)]&#125;</span><br></pre></td></tr></table></figure><p>返回结果参数的过程的语法为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;? &#x3D; call 存储过程名[(?,?,……)]&#125;</span><br></pre></td></tr></table></figure><p>不带参数的存储过程的语法类似：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;call 存储过程名&#125;</span><br></pre></td></tr></table></figure><p>CallableStatement 对象是用Connection方法prepareCall 创建的。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CallableStatement cstmt &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">   String SQL &#x3D; &quot;&#123;call getEXAMPLEName (?, ?)&#125;&quot;;</span><br><span class="line">   cstmt &#x3D; conn.prepareCall (SQL);</span><br><span class="line">   . . .</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e) &#123;</span><br><span class="line">   . . .</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">   cstmt.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于CallableStatement接口更多的可以查询java JDBC api</p></blockquote><h5 id="JDBC-结果集"><a href="#JDBC-结果集" class="headerlink" title="JDBC 结果集"></a>JDBC 结果集</h5><blockquote><p>结果集通常是通过执行查询数据库的语句生成，表示数据库查询结果的数据表  </p></blockquote><h5 id="ResultSet-介绍"><a href="#ResultSet-介绍" class="headerlink" title="ResultSet 介绍"></a>ResultSet 介绍</h5><p>ResultSet 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。next 方法将光标移动到下一行；因为该方法在 ResultSet 对象没有下一行时返回 false，所以可以在 while 循环中使用它来迭代结果集。光标可以方便我们对结果集进行遍历。默认的 ResultSet 对象不可更新，仅有一个向前移动的光标。因此，只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。    </p><p>ResultSet 接口的方法可分为三类:  </p><ul><li>导航方法: 用于移动光标  </li><li>获取方法：用于查看当前行的光标所指向的列中的数据  </li><li>更新方法：用于更新当前行的列中的数据  </li></ul><p>JDBC 提供下列连接方法来创建所需的 ResultSet 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createStatement(int RSType, int RSConcurrency);</span><br><span class="line"></span><br><span class="line">prepareStatement(String SQL, int RSType, int RSConcurrency);</span><br><span class="line"></span><br><span class="line">prepareCall(String sql, int RSType, int RSConcurrency);</span><br></pre></td></tr></table></figure><p>Rstype 表示 ResultSet 对象的类型，RsConcurrency 是 ResultSet 常量，用于指定一个结果集是否为只读或可更新.  </p><p>ResultSet 的类型，如果不指定ResultSet类型 将自动获取一个是 TYPE_FORWARD_ONLY；  </p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ResultSet.TYPE_FORWARD_ONLY</td><td>游标只能向前移动的结果集</td></tr><tr><td>ResultSet.TYPE_SCROLL_INSENSITIVE</td><td>游标可以向前和向后滚动，但不及时更新，就是如果数据库里的数据修改过，并不在ResultSet中反应出来</td></tr><tr><td>ResultSet.TYPE_SCROLL_SENSITIVE</td><td>游标可以向前和向后滚动，并及时跟踪数据库的更新，以便更改ResultSet中的数据</td></tr></tbody></table><p>并发性的ResultSet，如果不指定任何并发类型，将自动获得一个为CONCUR_READ_ONLY  </p><table><thead><tr><th>并发</th><th>描述</th></tr></thead><tbody><tr><td>ResultSet.CONCUR_READ_ONLY</td><td>创建结果集只读。这是默认的</td></tr><tr><td>ResultSet.CONCUR_UPDATABLE</td><td>创建一个可更新的结果集</td></tr></tbody></table><p>示例创建了一个双向、可更新的ResultSet对象；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Statement stmt &#x3D; conn.createStatement(</span><br><span class="line">        ResultSet.TYPE_SCROLL_INSENSITIVE,</span><br><span class="line">        ResultSet.CONCUR_UPDATABLE</span><br><span class="line">    );</span><br><span class="line">&#125; catch(Exception ex)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h6><p>我们在上面已经知道了，导航方法时用于移动光标.我们先来看一看，在ResultSet接口中有哪些方法会涉及光标的移动.  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void beforeFirst() throws SQLException</td><td>将光标移动到正好位于第一行之前</td></tr><tr><td>public void afterLast() throws SQLException</td><td>将光标移动到刚刚结束的最后一行</td></tr><tr><td>public boolean first() throws SQLException</td><td>将光标移动到第一行</td></tr><tr><td>public void last() throws SQLException</td><td>将光标移动到最后一行</td></tr><tr><td>public boolean absolute(int row) throws SQLException</td><td>将光标移动到指定的行</td></tr><tr><td>public boolean relative(int row) throws SQLException</td><td>从它目前所指向向前或向后移动光标行的给定数量</td></tr><tr><td>public boolean previous() throws SQLException</td><td>将光标移动到上一行。上一行关闭的结果集此方法返回false</td></tr><tr><td>public boolean next() throws SQLException</td><td>将光标移动到下一行。如果没有更多的行结果集中的此方法返回false</td></tr><tr><td>public int getRow() throws SQLException</td><td>返回的行号，改光标指向的行</td></tr><tr><td>public void moveToInsertRow() throws SQLException</td><td>将光标移动到一个特殊的行，可以用来插入新行插入到数据库中的结果集。当前光标位置被记住</td></tr><tr><td>public void moveToCurrentRow() throws SQLException</td><td>移动光标返回到当前行，如果光标在当前插入行，否则，这个方法不执行任何操作</td></tr></tbody></table><h6 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h6><p>ResultSet 接口中 我们经常使用get方法来查看结果集  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public int getInt(String columnName) throws SQLException</td><td>当前行中名为ColumnName列的值</td></tr><tr><td>public int getInt(int columnIndex) throws SQLException</td><td>当前行中指定列的索引的值。 列索引从1开始，意味着一个行的第一列是1，行的第二列是2，依次类推</td></tr></tbody></table><p>当然还有 getString() 等等</p><h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><p>更新的方法如下：  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void updateString(int columnIndex, String s) throws SQLException</td><td>指定列中的字符串更改为s的值</td></tr><tr><td>public void updateString(String columnName, String s) throws SQLException</td><td>类似于前面的方法，不同之处在于由它的名称。而不是它的索引指定的列</td></tr></tbody></table><p>类似的还有updateDouble() 等等  </p><p>我们在更新了结果集中的内容，当然需要更新一下数据库了。 我们可以调用下面的方法更新数据库<br>| 方法 | 说明 |<br>| —- | —- |<br>| public void updateRow() | 通过更新数据库中响应的行更新当前行 |<br>| public void deleteRow() | 从数据库中删除当前行 |<br>| public void refreshRow() | 刷新在结果集的数据，以反映最新变化在数据库中 |<br>| public void cancelRowUpdates() | 取消所做的当前行的任何更新 |<br>| public void insertRow() | 插入一行到数据库中。当光标指向插入行此方法只能被调用 |  </p><p>我们这里对上面的方法做一个小小的举例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt &#x3D; conn.createStatement(</span><br><span class="line">                           ResultSet.TYPE_SCROLL_INSENSITIVE,</span><br><span class="line">                           ResultSet.CONCUR_UPDATABLE</span><br><span class="line">                           );</span><br><span class="line"></span><br><span class="line">String sql &#x3D; &quot;SELECT id, name, age FROM Students&quot;;</span><br><span class="line">ResultSet rs &#x3D; stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果集中插入新行</span><br><span class="line">rs.moveToInsertRow();</span><br><span class="line">rs.updateInt(&quot;id&quot;,5);</span><br><span class="line">rs.updateString(&quot;name&quot;,&quot;John&quot;);</span><br><span class="line">rs.updateInt(&quot;age&quot;,21);</span><br><span class="line">&#x2F;&#x2F;更新数据库</span><br><span class="line">rs.insertRow();</span><br></pre></td></tr></table></figure><h3 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h3><p>我们在编写 java 程序的时候，在默认情况下，JDBC 连接是在自动提交模式下，即每个 SQL 语句都是在其完成时提交到数据库。但有时候我们为了提高程序运行的性能或者保持业务流程的完整性，以及使用了分布式事务管理方式，这个时候我们可能想关闭自动提交而自己管理和控制自己的事务。<br>让多条 SQL 在一个事务中执行，并且保证这些语句是在同一时间共同执行的时候，我们就应该为这多条语句定义一个事务。一个事务是把单个 SQL 语句或一组 SQL 语句作为一个逻辑单元，并且如果事务中任何语句失败，则整个事务失败。  </p><p>如果我们要启动一个事务，而不是让 JDBC 驱动程序默认使用 auto-commit 模式支持。这个时候我们就要使用 Connection 对象的 setAutoCommit() 方法。我们传递一个布尔值 false 到 setAutoCommit() 中，就可以关闭自动提交。反之我们传入一个 true 便将其重新打开。  </p><p>例如:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn &#x3D; null;</span><br><span class="line">conn &#x3D; DriverManager.getConnection(URL);</span><br><span class="line">&#x2F;&#x2F; 关闭自动提交</span><br><span class="line">conn.setAutoCommit(false);</span><br></pre></td></tr></table></figure><p>我们关闭了自动提交后，如果我们要提交数据库更改怎么办呢？这时候就要用到我们的提交和回滚了。我们要提交更改，可以调用commit() 方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.commit();</span><br></pre></td></tr></table></figure><p>尤其不要忘记，在catch块内添加回滚事务，表示操作出现异常，撤销事务;  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java System、Random 的使用</title>
      <link href="2019/12/19/java-System-Random-2019-12-19/"/>
      <url>2019/12/19/java-System-Random-2019-12-19/</url>
      
        <content type="html"><![CDATA[<h2 id="java-关于-System、Random-的使用"><a href="#java-关于-System、Random-的使用" class="headerlink" title="java 关于 System、Random  的使用"></a>java 关于 System、Random  的使用</h2><blockquote><p>记录java的System、Random  类的使用</p></blockquote><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>System 类提供一下的功能:</p><ul><li>标准输入，标准输出和错误输出流</li><li>访问外部定义的属性和环境变量</li><li>加载文件和库的方法</li><li>以及用于快速复制数组的实用方法。</li></ul><p>System 不可以被实例化，只能使用其静态方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从指定的源数组中复制一个数组，从源数组指定的位置开始，到目标数组指定的位置</span><br><span class="line">public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length) </span><br><span class="line">&#x2F;&#x2F;返回以毫秒为单位的当前时间(从1970年到现在的毫秒数)</span><br><span class="line">public static long currentTimeMillis()  </span><br><span class="line">&#x2F;&#x2F;终止当前正在运行的Java虚拟机，status为 0时退出</span><br><span class="line">public static void exit(int status)  </span><br><span class="line">&#x2F;&#x2F;  运行垃圾收集器</span><br><span class="line">public static void gc() </span><br><span class="line">&#x2F;&#x2F; 取得当前系统的全部属性</span><br><span class="line">public static Properties getProperties()</span><br><span class="line">&#x2F;&#x2F;获取指定键的系统属性</span><br><span class="line">public static String  getProperty(String key) </span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class SystemDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; &#123;7, 8, 9, 10, 11&#125;;</span><br><span class="line">        int[] b &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">        &#x2F;&#x2F;从数组a的第二个元素开始，复制到b数组的第三个位置 复制的元素长度为3</span><br><span class="line">        System.arraycopy(a, 1, b, 2, 3);</span><br><span class="line">        &#x2F;&#x2F;输出结果</span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line">        System.out.println(&quot;当前时间：&quot; + System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;java版本信息：&quot; + System.getProperty(&quot;java.version&quot;));</span><br><span class="line">        &#x2F;&#x2F;运行垃圾收集器</span><br><span class="line">        System.gc();</span><br><span class="line">        &#x2F;&#x2F;退出</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 8, 9, 10, 6]</span><br><span class="line">当前时间：1576139050573</span><br><span class="line">java版本信息：1.8.0_131</span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><blockquote><p>Random 类用于生产伪随机数流，在java.util包下。</p></blockquote><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class RandomDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        &#x2F;&#x2F;随机生成一个整数 int范围</span><br><span class="line">        System.out.println(random.nextInt());</span><br><span class="line">        &#x2F;&#x2F;生成 [0,n] 范围的整数  设n&#x3D;100</span><br><span class="line">        System.out.println(random.nextInt(100 + 1));</span><br><span class="line">        &#x2F;&#x2F;生成 [0,n) 范围的整数  设n&#x3D;100</span><br><span class="line">        System.out.println(random.nextInt(100));</span><br><span class="line">        &#x2F;&#x2F;生成 [m,n] 范围的整数  设n&#x3D;100 m&#x3D;40</span><br><span class="line">        System.out.println((random.nextInt(100 - 40 + 1) + 40));</span><br><span class="line">        &#x2F;&#x2F;随机生成一个整数 long范围</span><br><span class="line">        System.out.print(random.nextLong());</span><br><span class="line">        &#x2F;&#x2F;生成[0,1.0)范围的float型小数</span><br><span class="line">        System.out.println(random.nextFloat());</span><br><span class="line">        &#x2F;&#x2F;生成[0,1.0)范围的double型小数</span><br><span class="line">        System.out.println(random.nextDouble());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ javac RandomDemo.java</span><br><span class="line">$ java RandomDemo</span><br><span class="line">272128541</span><br><span class="line">67</span><br><span class="line">93</span><br><span class="line">66</span><br><span class="line">-23177167376469717070.93104035</span><br><span class="line">0.20044632645967309</span><br></pre></td></tr></table></figure><blockquote><p>ps 多关注 (new Random).nextInt() 这个生产随机数的 规则 [m,n] 例如 m=x n&gt;m :x可以是任何数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java System </tag>
            
            <tag> java Random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员常用算法</title>
      <link href="2019/12/13/algorithm-2019-12-14/"/>
      <url>2019/12/13/algorithm-2019-12-14/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法（Algorithm）是指解题方案的准确而完整的描述,是一系列解决问题的清晰指令,算法代表着用系统的方法描述解决问题的策略机制.<br>也就是说,能够对一定规范的输入,在有限时间内获得所要求的输出.<br>如果一个算法有缺陷,或不适合于某个问题,执行这个算法将不会解决这个问题.<br>不同的算法可能用不同的时间、空间或效率来完成同样的任务.<br>一个算法的优劣可以用空间复杂度于时间复杂度来衡量<br>—-维基百科</p></blockquote><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数<br>但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法<br>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中<br>从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序<br>时间复杂度为 O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：<br>第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），<br>而第二部分就只包含这一个元素（即待插入元素）。<br>在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。<br>插入排序的基本思想是：每步将一个待排序的记录<br>按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p></blockquote><p>排序过程步骤:</p><ol><li>从第一个元素开始, 该元素可以认为已经被排序  </li><li>取出下一个元素, 在已经排序的元素序列中从后向前扫描  </li><li>如果该元素(已排序)大于新元素,将该元素移到下一位置</li><li>重复步骤3, 直到找到已排序的元素小于或者等于新元素的位置  </li><li>将新元素插入到该位置后  </li><li>重复步骤2~5  </li></ol><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;对已经排序好的元素比较，找到一个比插入元素大的元素 交换位置</span><br><span class="line">                if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                    temp &#x3D; arr[i];</span><br><span class="line">                    arr[i] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;5, 3, 4, 1, 2&#125;;</span><br><span class="line">        sort(ints);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列<br>依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从 A 到 Z）错误就把他们交换过来<br>走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成-<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样<br>故名“冒泡排序”。</p></blockquote><p>冒泡排序的运行过程如下:</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 </li></ul><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void sort(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前元素比后一位元素大 交换位置</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;5, 3, 4, 1, 2&#125;;</span><br><span class="line">        sort(ints);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法<br>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用<br>将已有序的子序列合并，得到完全有序的序列；<br>即先使每个子序列有序，再使子序列段间有序。<br>若将两个有序表合并成一个有序表，称为二路归并。</p></blockquote><p>排序过程:</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤 3 直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void mergeSort(int[] arrays, int left, int right) &#123;</span><br><span class="line">&#x2F;&#x2F;        如果数组还可以拆分</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            &#x2F;&#x2F;数组的中间位置</span><br><span class="line">            int middle &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F;拆分左边数组</span><br><span class="line">            mergeSort(arrays, left, middle);</span><br><span class="line">            &#x2F;&#x2F;拆分右边数组</span><br><span class="line">            mergeSort(arrays, middle + 1, right);</span><br><span class="line">            &#x2F;&#x2F;合并</span><br><span class="line">            merge(arrays, left, middle, right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 合并数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void merge(int[] arr, int left, int middle, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F;申请合并空间 大小为两个已经排序序列之和</span><br><span class="line">        int[] temp &#x3D; new int[right - left + 1];</span><br><span class="line">        &#x2F;&#x2F;i 和 j为两个已经排好序的数组的起始位置</span><br><span class="line">        int i &#x3D; left;</span><br><span class="line">        int j &#x3D; middle + 1;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;排序</span><br><span class="line">        while (i &lt;&#x3D; middle &amp;&amp; j &lt;&#x3D; right) &#123;</span><br><span class="line">            &#x2F;&#x2F;将比较小的数组放入合并空间</span><br><span class="line">            if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[k++] &#x3D; arr[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[k++] &#x3D; arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将左边剩余元素写入合并空间</span><br><span class="line">        while (i &lt;&#x3D; middle) &#123;</span><br><span class="line">            temp[k++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将右边剩余的元素写入合并空间</span><br><span class="line">        while (j &lt;&#x3D; right) &#123;</span><br><span class="line">            temp[k++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将排序后的数组写回原来的数组</span><br><span class="line">        for (int l &#x3D; 0; l &lt; temp.length; l++) &#123;</span><br><span class="line">            arr[l + left] &#x3D; temp[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;5, 3, 4, 1, 2&#125;;</span><br><span class="line">        mergeSort(ints,0,ints.length-1);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排<br>一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较<br>。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见<br>。事实上，快速排序 O(nlogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p></blockquote><p>快速排序使用分治法(Divide and conquer) 策略来吧一个序列(List)分为两个子序列(sub-lists)  </p><p>步骤如下 :</p><ol><li>从数列中挑出一个元素，称为“基准”（pivot），</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><blockquote><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p></blockquote><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void sort(int[] arr, int head, int tail) &#123;</span><br><span class="line">        if (head &gt;&#x3D; tail || arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置数组的起始位置 i 结束位置j 基准 pivot 为数组的中间</span><br><span class="line">        int i &#x3D; head, j &#x3D; tail, pivot &#x3D; arr[(head + tail) &#x2F; 2];</span><br><span class="line">        while (i &lt;&#x3D; j) &#123;</span><br><span class="line">            &#x2F;&#x2F;当数组小于基准 循环结束后 相当于i所处的位置的值为大于基准的元素</span><br><span class="line">            while (arr[i] &lt; pivot) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当数组大于基准 循环结束后 相当于j所处的位置的值为小于于基准的元素</span><br><span class="line">            while (arr[j] &gt; pivot) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果i&lt;j 那么则将交互i j对应位置的值</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int t &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; t;</span><br><span class="line">                &#x2F;&#x2F;将指针继续移动</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; else if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">&#x2F;&#x2F;如果i&#x3D;j 那么说明本次排序已经结束 将i++ 如果这里不使用i++ 那么后面的sort(arr,i,tail)将改为arr(arr,i+1,tail)</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;继续将数组分割  </span><br><span class="line">        sort(arr, head, j);</span><br><span class="line">        sort(arr, i, tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;5, 3, 4, 1, 2&#125;;</span><br><span class="line">        sort(ints, 0, ints.length - 1);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><blockquote><p>线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。</p></blockquote><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LinearSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;5, 3, 4, 1, 2&#125;;</span><br><span class="line">        System.out.println(search(ints, 4));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int search(int[] arr, int key) &#123;</span><br><span class="line">        &#x2F;&#x2F;循环</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;比较是否等于key</span><br><span class="line">            if (arr[i] &#x3D;&#x3D; key) &#123;</span><br><span class="line">                return arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找不到就返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><p>在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search）<br>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束<br>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较<br>如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p></blockquote><p>示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int search(int[] arr, int key) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; arr.length - 1;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int middle &#x3D; (high + low) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F;如果相等 返回值</span><br><span class="line">            if (key &#x3D;&#x3D; arr[middle]) &#123;</span><br><span class="line">                return key;</span><br><span class="line">            &#125; else if (key &lt; arr[middle]) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果key小于中间值，那么改变high，值可能在左边部（比较小的部分）</span><br><span class="line">                high &#x3D; middle - 1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果key大于中间值，那么改变low，值可能在右边部（比较大的部分）</span><br><span class="line">                low &#x3D; middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        System.out.println(search(ints, 4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 基础算法 </tag>
            
            <tag> 算法实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于java Arrays、StringBuilder 类的使用</title>
      <link href="2019/12/11/java-Arrays-StringBuilder-2019-12-11/"/>
      <url>2019/12/11/java-Arrays-StringBuilder-2019-12-11/</url>
      
        <content type="html"><![CDATA[<h2 id="关于java-Arrays、StringBuilder-类的使用"><a href="#关于java-Arrays、StringBuilder-类的使用" class="headerlink" title="关于java Arrays、StringBuilder 类的使用"></a>关于java Arrays、StringBuilder 类的使用</h2><blockquote><p>记录 java Arrays、StringBuilder 两个类的使用方法</p></blockquote><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><blockquote><p>Arrays 类包含用于操作数组的各种方法（例如排序和搜索）。还包含一个静态工厂，允许将数组转为list</p></blockquote><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><T>List<T> asList(T…a)</td><td align="left">返回由指定数组构造的list</td></tr><tr><td align="left">void sort(Object[] a)</td><td align="left">对数组进行排序</td></tr><tr><td align="left">void fill(Object[] a, Object val)</td><td align="left">对数组的所有元素都赋上相同的值</td></tr><tr><td align="left">boolean equals(Object[] a, Object[] a2)</td><td align="left">检查两个数组是否相等</td></tr><tr><td align="left">int binarySearch(Object[] a, Object key)</td><td align="left">对排序后的数组使用二分法查找数据</td></tr></tbody></table><p>示例代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class ArraysDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[10];</span><br><span class="line">        &#x2F;&#x2F;将数组元素都设为9</span><br><span class="line">        Arrays.fill(arr, 9);</span><br><span class="line">        System.out.println(&quot;fill:&quot; + Arrays.toString(arr));</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用100以内的随机数赋值数组</span><br><span class="line">            arr[i] &#x3D; random.nextInt(101);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;重新赋值后的数组</span><br><span class="line">        System.out.println(&quot;重新赋值：&quot; + Arrays.toString(arr));</span><br><span class="line">        &#x2F;&#x2F;将索引为5的元素设为50</span><br><span class="line">        arr[5] &#x3D; 50;</span><br><span class="line">        &#x2F;&#x2F;排序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        &#x2F;&#x2F;排序后的数组</span><br><span class="line">        System.out.println(&quot;sort排序后：&quot; + Arrays.toString(arr));</span><br><span class="line">        &#x2F;&#x2F;查找50的位置</span><br><span class="line">        int i &#x3D; Arrays.binarySearch(arr, 50);</span><br><span class="line">        System.out.println(&quot;值为50的元素索引：&quot;+i);</span><br><span class="line">        &#x2F;&#x2F;复制一份新数组</span><br><span class="line">        int[] newArr &#x3D; Arrays.copyOf(arr, arr.length);</span><br><span class="line">        &#x2F;&#x2F;比较</span><br><span class="line">        System.out.println(&quot;equals:&quot;+Arrays.equals(arr, newArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ javac ArraysDemo.java</span><br><span class="line">$ java ArraysDemo</span><br><span class="line">fill:[9, 9, 9, 9, 9, 9, 9, 9, 9, 9]</span><br><span class="line">重新赋值：[69, 83, 40, 58, 94, 42, 2, 53, 43, 83]</span><br><span class="line">sort排序后：[2, 40, 43, 50, 53, 58, 69, 83, 83, 94]</span><br><span class="line">值为50的元素索引：3</span><br><span class="line">equals:true</span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><blockquote><p>StringBuilder 类是可变的。它是 String 的对等类，它可以增加和编写字符的可变序列，并且能够将字符插入到字符串中间或附加到字符串末尾（当然是不用创建其他对象的）  </p></blockquote><p>StringBuilder 的构造方法：  </p><table><thead><tr><th align="left">构造方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">StringBuider()</td><td align="left">构造一个其中不带字符的StringBuilder, 其容量为16个字符</td></tr><tr><td align="left">StringBuilder(CharSequenceseq)</td><td align="left">构造一个StringBuilder, 它包含与指定的CHarSequence相同的字符</td></tr><tr><td align="left">StringBuilder(int capacity)</td><td align="left">构造一个具有指定初始容量的StringBuilder</td></tr><tr><td align="left">StringBuilder(String str)</td><td align="left">并将其内容初始化为指定的字符串内容</td></tr></tbody></table><p>StringBuilder 类的常用方法:  </p><table><thead><tr><th align="left">方法</th><th align="left">返回值</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">insert(int offsetm, Object obj)</td><td align="left">StringBuilder</td><td align="left">在offsetm的位置插入字符串obj</td></tr><tr><td align="left">append(Object obj)</td><td align="left">StringBuilder</td><td align="left">在字符串末尾追加字符串 obj</td></tr><tr><td align="left">length()</td><td align="left">int</td><td align="left">确定StringBuilder 对象的长度</td></tr><tr><td align="left">setCharAt(int index,char ch)</td><td align="left">void</td><td align="left">使用ch指定的新值设置index指定的位置上的字符</td></tr><tr><td align="left">toString()</td><td align="left">String</td><td align="left">转换为字符串形式</td></tr><tr><td align="left">reverse()</td><td align="left">StringBuilder</td><td align="left">反转字符串</td></tr><tr><td align="left">delete(int start, int end)</td><td align="left">StringBuilder</td><td align="left">删除调用对象中从start位置开始直到end指定的索引(end-1)位置的字符序列</td></tr><tr><td align="left">replace(int start, int end, String str)</td><td align="left">StringBuilder</td><td align="left">使用一组字符替换另一组字符。将用替换字符串从start指定的位置开始替换，直到end直到的位置结束</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java Arrays </tag>
            
            <tag> java StringBuilder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 java ArrayList</title>
      <link href="2019/12/09/java-ArrayList-2019-12-10/"/>
      <url>2019/12/09/java-ArrayList-2019-12-10/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList-类的使用示例"><a href="#ArrayList-类的使用示例" class="headerlink" title="ArrayList 类的使用示例"></a>ArrayList 类的使用示例</h2><p>List是一个借口,<strong><em>不能实例化</em></strong>,需要一个具体类来实现实例化.<br>List集合中的对象按照一定的顺序排放,里面的内容可以重复.<br>List借口实现的类有：ArrayList(实现动态数组),Vector(实现动态数组),LinkedList(实现链表),Stack(实现堆栈).  </p><p>List在Collection基础上增加的方法：  </p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(int index, E element)</td><td>void</td><td>在列表的指定位置插入指定元素(可选操作)</td></tr><tr><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td></tr><tr><td>get(int index)</td><td>E</td><td>返回列表中指定位置的元素</td></tr><tr><td>indexOf(Object o)</td><td>int</td><td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td></tr><tr><td>lastIndexOf(Object o)</td><td>int</td><td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td></tr><tr><td>listIterator()</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序)</td></tr><tr><td>listIterator(int index)</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序）,从列表的指定位置开始</td></tr><tr><td>remove(int index)</td><td>E</td><td>移除列表中指定位置的元素（可选操作）</td></tr><tr><td>set(int index,E element)</td><td>E</td><td>用指定元素替换列表中指定位置的元素（可选操作)</td></tr><tr><td>subList(int fromIndex, int toIndex)</td><td>List<E></td><td>返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图</td></tr></tbody></table><blockquote><p>ArrayList 类实现了一个可增长的动态数组, 位于java.util.ArrayList<E>.<br>实现了List接口, 它可以存储不同的类型的对象（包括null在内）,<br>而数组则只能存放特点数据类型的值  </p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>学校的教务系统会对学生进行统一的管理，每一个学生都会有一个学号和学生姓名<br>我们在维护整个系统的时候，大多数操作是对学生的添加、插入、删除、修改等操作  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 学生类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Student(String id, String name)&#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&#39;&quot; + id + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对学生操作类，通过学生列表来管理学生  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ListTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;集合后面的&lt;&gt;代表泛型的意思</span><br><span class="line">    &#x2F;&#x2F;泛型是规定了集合元素的类型</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于存放学生的List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ListTest() &#123;</span><br><span class="line">        this.students &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于往students中添加学生</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个学生对象，并通过调用add方法，添加到学生管理List中</span><br><span class="line">        Student st1 &#x3D; new Student(&quot;1&quot;, &quot;张三&quot;);</span><br><span class="line">        students.add(st1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取出 List中的Student对象 索引为0 也就是第一个</span><br><span class="line">        Student temp &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp.id + &quot;:&quot; + temp.name);</span><br><span class="line"></span><br><span class="line">        Student st2 &#x3D; new Student(&quot;2&quot;, &quot;李四&quot;);</span><br><span class="line">        &#x2F;&#x2F;添加到list中，插入到索引为0的位置，也就是第一个</span><br><span class="line">        students.add(0, st2);</span><br><span class="line">        Student temp2 &#x3D; students.get(0);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp2.id + &quot;:&quot; + temp2.name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对象数组的形式添加</span><br><span class="line">        Student[] student &#x3D; &#123;new Student(&quot;3&quot;, &quot;王五&quot;), new Student(&quot;4&quot;, &quot;马六&quot;)&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表</span><br><span class="line">        students.addAll(Arrays.asList(student));</span><br><span class="line">        Student temp3 &#x3D; students.get(2);</span><br><span class="line">        Student temp4 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp3.id + &quot;:&quot; + temp3.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp4.id + &quot;:&quot; + temp4.name);</span><br><span class="line">        Student[] student2 &#x3D; &#123;new Student(&quot;5&quot;, &quot;周七&quot;), new Student(&quot;6&quot;, &quot;赵八&quot;)&#125;;</span><br><span class="line">        students.addAll(2, Arrays.asList(student2));</span><br><span class="line">        Student temp5 &#x3D; students.get(2);</span><br><span class="line">        Student temp6 &#x3D; students.get(3);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp5.id + &quot;:&quot; + temp5.name);</span><br><span class="line">        System.out.println(&quot;添加了学生：&quot; + temp6.id + &quot;:&quot; + temp6.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取得List中的元素的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testGet() &#123;</span><br><span class="line">        int size &#x3D; students.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">            Student st &#x3D; students.get(i);</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过迭代器来遍历</span><br><span class="line">     * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testIterator() &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过集合的iterator方法，取得迭代器实例</span><br><span class="line">        Iterator&lt;Student&gt; it &#x3D; students.iterator();</span><br><span class="line">        System.out.println(&quot;有如下学生（通过迭代器访问）：&quot;);</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            Student st &#x3D; it.next();</span><br><span class="line">            System.out.println(&quot;学生&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过for each 方法访问集合元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testForEach() &#123;</span><br><span class="line">        System.out.println(&quot;有如下学生（通过for each）：&quot;);</span><br><span class="line">        for (Student obj : students) &#123;</span><br><span class="line">            Student st &#x3D; obj;</span><br><span class="line">            System.out.println(&quot;学生：&quot; + st.id + &quot;:&quot; + st.name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用java8 Steam将学生排序后输出</span><br><span class="line">        students.stream()&#x2F;&#x2F;创建Stream</span><br><span class="line">                &#x2F;&#x2F;通过学生id排序</span><br><span class="line">                .sorted(Comparator.comparing(x -&gt; x.id))</span><br><span class="line">                &#x2F;&#x2F;输出</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改List中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testModify() &#123;</span><br><span class="line">        students.set(4, new Student(&quot;3&quot;, &quot;吴酒&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除List中的元素</span><br><span class="line">     *</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        Student st &#x3D; students.get(4);</span><br><span class="line">        System.out.println(&quot;我是学生：&quot; + st.id + &quot;:&quot; + st.name + &quot;，我即将被删除&quot;);</span><br><span class="line">        students.remove(st);</span><br><span class="line">        System.out.println(&quot;成功删除学生！&quot;);</span><br><span class="line">        testForEach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListTest lt &#x3D; new ListTest();</span><br><span class="line">        lt.testAdd();</span><br><span class="line">        lt.testGet();</span><br><span class="line">        lt.testIterator();</span><br><span class="line">        lt.testModify();</span><br><span class="line">        lt.testForEach();</span><br><span class="line">        lt.testRemove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ javac Student.java ListTest.java</span><br><span class="line">$ java ListTest</span><br><span class="line"></span><br><span class="line">添加了学生：1:张三</span><br><span class="line">添加了学生：2:李四</span><br><span class="line">添加了学生：3:王五</span><br><span class="line">添加了学生：4:马六</span><br><span class="line">添加了学生：5:周七</span><br><span class="line">添加了学生：6:赵八</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：3:王五</span><br><span class="line">学生：4:马六</span><br><span class="line">有如下学生（通过迭代器访问）：</span><br><span class="line">学生2:李四</span><br><span class="line">学生1:张三</span><br><span class="line">学生5:周七</span><br><span class="line">学生6:赵八</span><br><span class="line">学生3:王五</span><br><span class="line">学生4:马六</span><br><span class="line">有如下学生（通过for each）：</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：3:吴酒</span><br><span class="line">学生：4:马六</span><br><span class="line">Student&#123;id&#x3D;&#39;1&#39;, name&#x3D;&#39;张三&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;2&#39;, name&#x3D;&#39;李四&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;3&#39;, name&#x3D;&#39;吴酒&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;4&#39;, name&#x3D;&#39;马六&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;5&#39;, name&#x3D;&#39;周七&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;6&#39;, name&#x3D;&#39;赵八&#39;&#125;</span><br><span class="line">我是学生：3:吴酒，我即将被删除</span><br><span class="line">成功删除学生！</span><br><span class="line">有如下学生（通过for each）：</span><br><span class="line">学生：2:李四</span><br><span class="line">学生：1:张三</span><br><span class="line">学生：5:周七</span><br><span class="line">学生：6:赵八</span><br><span class="line">学生：4:马六</span><br><span class="line">Student&#123;id&#x3D;&#39;1&#39;, name&#x3D;&#39;张三&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;2&#39;, name&#x3D;&#39;李四&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;4&#39;, name&#x3D;&#39;马六&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;5&#39;, name&#x3D;&#39;周七&#39;&#125;</span><br><span class="line">Student&#123;id&#x3D;&#39;6&#39;, name&#x3D;&#39;赵八&#39;&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中, 用到了Arrays类,Arrays 包含用来操作数组(比如排序和搜索)的各种方法<br>asList()方法用来返回一个受指定数组支持的固定大小的列表  </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置文件详细说明</title>
      <link href="2019/10/19/linux-centos-2018-09-10-1/"/>
      <url>2019/10/19/linux-centos-2018-09-10-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于nginx相关配置"><a href="#关于nginx相关配置" class="headerlink" title="关于nginx相关配置"></a>关于nginx相关配置</h2><blockquote><p>在此记录下Nginx服务器nginx.conf的配置文件说明, 部分注释收集与网络.</p></blockquote><pre><code>  #运行用户user www-data;    #启动进程,通常设置成和cpu的数量相等worker_processes  1;#全局错误日志及PID文件error_log  /var/log/nginx/error.log;pid        /var/run/nginx.pid;#工作模式及连接数上限events &#123;    use   epoll;             #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能    worker_connections  1024;#单个后台worker process进程的最大并发链接数    # multi_accept on; &#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123;     #设定mime类型,类型由mime.type文件定义    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    #设定日志格式    access_log    /var/log/nginx/access.log;    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.    sendfile        on;    #tcp_nopush     on;    #连接超时时间    #keepalive_timeout  0;    keepalive_timeout  65;    tcp_nodelay        on;        #开启gzip压缩    gzip  on;    gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;    #设定请求缓冲    client_header_buffer_size    1k;    large_client_header_buffers  4 4k;    include /etc/nginx/conf.d/*.conf;    include /etc/nginx/sites-enabled/*;    #设定负载均衡的服务器列表     upstream mysvr &#123;    #weigth参数表示权值，权值越高被分配到的几率越大    #本机上的Squid开启3128端口    server 192.168.8.1:3128 weight=5;    server 192.168.8.2:80  weight=1;    server 192.168.8.3:80  weight=6;    &#125;   server &#123;    #侦听80端口        listen       80;        #定义使用www.xx.com访问        server_name  www.xx.com;        #设定本虚拟主机的访问日志        access_log  logs/www.xx.com.access.log  main;    #默认请求    location / &#123;          root   /root;      #定义服务器的默认网站根目录位置          index index.php index.html index.htm;   #定义首页索引文件的名称          fastcgi_pass  www.xx.com;         fastcgi_param  SCRIPT_FILENAME  $document_root/$fastcgi_script_name;           include /etc/nginx/fastcgi_params;        &#125;    # 定义错误提示页面    error_page   500 502 503 504 /50x.html;          location = /50x.html &#123;        root   /root;    &#125;    #静态文件，nginx自己处理    location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;        root /var/www/virtual/htdocs;        #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。        expires 30d;    &#125;    #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.    location ~ \.php$ &#123;        root /root;        fastcgi_pass 127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;        include fastcgi_params;    &#125;    #设定查看Nginx状态的地址    location /NginxStatus &#123;        stub_status            on;        access_log              on;        auth_basic              &quot;NginxStatus&quot;;        auth_basic_user_file  conf/htpasswd;    &#125;    #禁止访问 .htxxx 文件    location ~ /\.ht &#123;        deny all;    &#125;          &#125;&#125;</code></pre><blockquote><p>以上是一些基本的配置,使用Nginx最大的好处就是负载均衡</p></blockquote><blockquote><p>如果要使用负载均衡的话,可以修改配置http节点如下：</p></blockquote><p>#设定http服务器，利用它的反向代理功能提供负载均衡支持<br>    http {<br>     #设定mime类型,类型由mime.type文件定义<br>     include       /etc/nginx/mime.types;<br>     default_type  application/octet-stream;<br>     #设定日志格式<br>     access_log    /var/log/nginx/access.log;</p><pre><code> #省略上文有的一些配置节点 #。。。。。。。。。。 #设定负载均衡的服务器列表  upstream mysvr &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口 server 192.168.8.2x:80  weight=1; server 192.168.8.3x:80  weight=6; &#125;upstream mysvr2 &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.8.x:80  weight=1; server 192.168.8.x:80  weight=6; &#125;#第一个虚拟服务器server &#123; #侦听192.168.8.x的80端口     listen       80;     server_name  192.168.8.x;   #对aspx后缀的进行负载均衡请求 location ~ .*\.aspx$ &#123;      root   /root;      #定义服务器的默认网站根目录位置       index index.php index.html index.htm;   #定义首页索引文件的名称       proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表       #以下是一些反向代理的配置可删除.       proxy_redirect off;       #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP       proxy_set_header Host $host;       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;       client_max_body_size 10m;    #允许客户端请求的最大单文件字节数       client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，       proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)       proxy_send_timeout 90;        #后端服务器数据回传时间(代理发送超时)       proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)       proxy_buffer_size 4k;             #设置代理服务器（nginx）保存用户头信息的缓冲区大小       proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置       proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）       proxy_temp_file_write_size 64k;  #设定缓存文件夹大小，大于这个值，将从upstream服务器传    &#125;   &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> config </tag>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于推荐大家建立个人博客</title>
      <link href="2019/10/19/programlife-2018-12-11-1/"/>
      <url>2019/10/19/programlife-2018-12-11-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>  关于博客 说实在的 很多朋友都在问我 为什么要做一个博客 其实对于每一个程序员来说 个人博客就好像是一个人的身份标识一样</p><p>  当然 更多的是一个人的编程思想 也是一种隔着屏幕的文化交流 同时也是一场知识竞赛 对于我们来说 其实也有很多人 会用印象笔记那样的东西</p><p>  这些都是一种记录方式 而我们制作博客 将文章放在博文上面 同时也是为了帮助别人 </p><h2 id="博客的好处"><a href="#博客的好处" class="headerlink" title="博客的好处"></a>博客的好处</h2><blockquote><p>没有什么是没有意义的 今天你学习的一小部分 积少成多 终会成为你未来前进道路上的助力</p></blockquote><p>  其实对于博客来说的话 有很多种方式可以证明博文是好的 例如记录自己的学习过程 记录自己踩过的坑 当然 你可以说 （我自己用印象笔记**）都可以记录呀 为什么还要花钱租借服务器去搭建博客这种东西 其实在这里 我就要说一句了 </p><p>  其实吧 将文章放在网络上不仅仅可以和各位大佬交流 同时呢也可以帮助到其他人 甚至你的个人博客站点流量高了之后 大家可以申请百度谷歌的广告联盟 这些还能帮助我们盈利 不仅在学习的过程中我们还可以利用知识赚钱（我真是太贼了୧(๑•̀⌄•́๑)૭）） 当然这些都不是最主要的问题</p><p>  还能提高我们的文笔 更多的是一台服务器在我们租借回来之后 我们的实际运用 我就看到身边的很多人 要么只会敲代码 要么只会用工具 若是两者结合一下 那么又是一位大佬啊 可惜 没如果</p><h2 id="为什么要使用服务器"><a href="#为什么要使用服务器" class="headerlink" title="为什么要使用服务器"></a>为什么要使用服务器</h2><p> 相信大家都用 <strong>github</strong> 其实在使用github的过程中 我们会发现 一个小问题（对于刚刚开始学习的小白来说）我们通过zip去下载的方式总是很麻烦 这个时候 我们会发现 github 还给我们提供了git克隆模式 甚至 我们还可以通过 composer 去帮助我们管理整个项目 </p><p>  而本地环境总归还是不能与线上环境相对比的 比如有的坑 就是因为 windows  环境和 linux 的环境问题 PHP就有很多代码运行需要修改 所以 养成一个使用服务器 利用 git 管理项目 代码等好的行为是一个优秀程序员必备的技能之一</p><p> 相对比与公司 我们需要考虑到更多的环境 考虑更多的配置问题 这些对于从未接触过服务器的你来说 难道就是几篇教程就能解决问题么 </p><blockquote><p>实践出真理</p></blockquote><p> 这句话永远都不会过时 就算你是天才 也需要不少的经验值才能将你堆积起来 理论操作时永远成长不起来的 </p><h2 id="价格太贵-腰包无法接受"><a href="#价格太贵-腰包无法接受" class="headerlink" title="价格太贵 腰包无法接受"></a>价格太贵 腰包无法接受</h2><p> 其实说价格这个问题的人 我相信都是不怎么关注服务器的人 2018年 简直就是云计算大爆发的一个时代 在这个时代 很多人因为云计算一夜崛起 也有人因为云计算 突然XX 随着时间的推移 现在2019的到来 区块链 云计算 物联网 网络已经充斥着我们的生活 我们生活中也已经被网络所包围 这是一场机遇 同时也是一场危机 </p><p>  其实只要大家多多关注网络咨询 就能够在百度上面找到很多现在的服务器运营商 他们的价格相对于阿里云 腾讯云来说要低很多 不过同时 也会有各种毛病等 </p><p>  不过阿里 腾讯 偶尔也是会有一些活动的 例如：<br>  <a href="https://promotion.aliyun.com/ntms/act/qwbk.html?accounttraceid=a755f1fa-ac36-4af1-979a-442b1013f494&userCode=4jm8fecv">阿里云新老回馈https://promotion.aliyun.com/ntms/act/qwbk.html?accounttraceid=a755f1fa-ac36-4af1-979a-442b1013f494&amp;userCode=4jm8fecv</a><br>  <a href="https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=4jm8fecv">阿里全民云计算https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=4jm8fecv</a></p><blockquote><p>类似的活动也有很多 包括阿里云 和 腾讯云的 学生机 校园计划等 都可以帮助我们去学习这些方向</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小记 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式（Simple Factory Pattern)</title>
      <link href="2019/09/26/factoryPattern/"/>
      <url>2019/09/26/factoryPattern/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式（Simple-Factory-Pattern"><a href="#简单工厂模式（Simple-Factory-Pattern" class="headerlink" title="简单工厂模式（Simple Factory Pattern)"></a>简单工厂模式（Simple Factory Pattern)</h2><h3 id="1-1-模式动机"><a href="#1-1-模式动机" class="headerlink" title="1.1 模式动机"></a>1.1 模式动机</h3><p>考虑到一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如 圆形按钮、棱角按钮、矩形按钮），这些按钮都来源同一个基类，不过在基础基类之后不同的子类修改了部分属性从而使得他们能够呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道哪些具体的按钮的名字，只需要知道表示这个按钮的一个参数，并提供一个调用方便的方法，把该参数传入方法并返回一个相应的按钮对象，此时，就可以使用简单工厂模式。</p><h3 id="1-2-模式定义"><a href="#1-2-模式定义" class="headerlink" title="1.2 模式定义"></a>1.2 模式定义</h3><p>简单工厂模式（Simple Factory Pattern）: 又称之为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3 id="1-3-模式结构"><a href="#1-3-模式结构" class="headerlink" title="1.3 模式结构"></a>1.3 模式结构</h3><p>简单工厂模式包含如下角色：</p><ul><li><p>Factory:工厂角色<br>  工厂角色负责实现创建所有实例的内部逻辑</p></li><li><p>Product:抽象产品角色<br>  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p></li><li><p>ConcreateProduct:具体产品角色<br>  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例<br><img src= "/img/loading.gif" data-lazy-src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt="class SimpleFactory"></p><h3 id="1-4-时序图"><a href="#1-4-时序图" class="headerlink" title="1.4 时序图"></a>1.4 时序图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_SimpleFactory.jpg" alt="sd seq_SimpleFactory"></p><h3 id="1-5-代码分析"><a href="#1-5-代码分析" class="headerlink" title="1.5 代码分析"></a>1.5 代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> # include &quot;Factory.h&quot;</span><br><span class="line"> # include &quot;ConcreteProductA.h&quot;</span><br><span class="line"> # include &quot;ConcreteProductB.h&quot;</span><br><span class="line"> Product* Factory::createProduct(string proname)&#123;</span><br><span class="line">    if(&quot;A&quot; &#x3D;&#x3D; proname)</span><br><span class="line">    &#123;</span><br><span class="line">        return new ContreteProductA();</span><br><span class="line">     &#125;else if(&quot;B&quot; &#x3D;&#x3D; proname)&#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-模式分析"><a href="#1-6-模式分析" class="headerlink" title="1.6 模式分析"></a>1.6 模式分析</h3></li><li><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</p></li><li><p>在调用工厂类的工厂方法时，由于工厂方法时静态方法，使用起来很方便，可以通过类名直接调，而且只需要传入一个简单的参数即可，在实际开发过程中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无需修改任何源代码。</p></li><li><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而不需要知道其创建细节</p></li></ul><h3 id="1-7-实例"><a href="#1-7-实例" class="headerlink" title="1.7 实例"></a>1.7 实例</h3><blockquote><p>略</p></blockquote><h3 id="1-8-简单工厂模式的优点"><a href="#1-8-简单工厂模式的优点" class="headerlink" title="1.8 简单工厂模式的优点"></a>1.8 简单工厂模式的优点</h3><ul><li>工作累含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><h3 id="1-9-简单工厂模式的缺点"><a href="#1-9-简单工厂模式的缺点" class="headerlink" title="1.9 简单工厂模式的缺点"></a>1.9 简单工厂模式的缺点</h3><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都会受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多的时候，有可能会造成工厂逻辑过于复杂，不利于系统的扩展和维护</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构</li></ul><h3 id="1-10-适用环境"><a href="#1-10-适用环境" class="headerlink" title="1.10 适用环境"></a>1.10 适用环境</h3><p>在一下情况下可以使用简单工厂模式：</p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h3 id="1-11-模式应用"><a href="#1-11-模式应用" class="headerlink" title="1.11 模式应用"></a>1.11 模式应用</h3><ol><li>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat, 它用于格式化一个本地日期或者时间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final static DateFormat getDateInstance();</span><br><span class="line">public final static DateFormat getDateInstance(int style);</span><br><span class="line">public final static DateFormat getDateInstance(int style,Locale locale);</span><br></pre></td></tr></table></figure></li><li>Java 加密技术<br>获取不同的加密算法的密钥生成器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KetGenerator ketGen&#x3D;KetGenerator.getInstance(&quot;DESede&quot;);</span><br></pre></td></tr></table></figure>创建密码器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher cp&#x3D;Cipher.getInstance(&quot;DESede&quot;);</span><br></pre></td></tr></table></figure><h3 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12 总结"></a>1.12 总结</h3></li></ol><ul><li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建于对象的使用过程分离。</li><li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数。对于如何创建对象不关心。’</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lumen + dingo 搭建api服务器</title>
      <link href="2019/06/27/dingo/"/>
      <url>2019/06/27/dingo/</url>
      
        <content type="html"><![CDATA[<h1 id="lumen-dingo-搭建api服务器"><a href="#lumen-dingo-搭建api服务器" class="headerlink" title="lumen + dingo 搭建api服务器"></a>lumen + dingo 搭建api服务器</h1><p><u>网上现在关于lumen的教程还是蛮少的，不过很少有初级PHP人员直接接触lumen，估计这也是一个问题吧！作为一个菜鸟，因为公司项目重构，所以我走上了lumen的流行</u></p><hr><blockquote><p>lumen <a href="https://github.com/laravel/lumen">lumen git地址</a> 全部关于lumen的介绍以及说明都有</p></blockquote><hr><p><u>至于 dingo/api 是一个基于larveral和lumen的api工具 可以帮助我们快速构建api服务</u></p><hr><blockquote><p>dingo/api <a href="https://github.com/dingo/api">dingo/api git地址</a> 全部关于dingo组件</p></blockquote><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先 ，通过使用composer安装laravel安装器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require &quot;laravel&#x2F;lumen-installer&quot;</span><br></pre></td></tr></table></figure><p>然后我们通过安装器进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lumen new blog</span><br></pre></td></tr></table></figure><p>其次我们也可以通过composer创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist laravel&#x2F;lumen blog</span><br></pre></td></tr></table></figure><h3 id="本地开发环境"><a href="#本地开发环境" class="headerlink" title="本地开发环境"></a>本地开发环境</h3><p>如果你本地安装了PHP，并且你想使用PHP内置的服务器来为你提供应用服务，<code>php -S localhost:8000 -t public</code>命令。该命令会在  <code>http://localhost:8000</code>上启动开发服务器</p><blockquote><p>lumen 和 laravel 虽然是同一个框架系列但是不属于同样的结构 lumen更像是一个laravel的儿子，一个专属于api开发的框架 所以在文件结构上的处理和方式也有很多不同</p></blockquote><p>Lumen 框架所有的配置信息都是存在 .env 文件中。一旦 Lumen 成功安装，你同时也要 配置本地环境。</p><h3 id="dingo-install"><a href="#dingo-install" class="headerlink" title="dingo install"></a>dingo install</h3><p>首先去dingo的git上面查看当前版本 我这里安装的是2.2以上的版本</p><p>至于dingo的版本安装失败 请参考<a href="https://learnku.com/courses/laravel-package/api-development-kit-dingoapi/">https://learnku.com/courses/laravel-package/api-development-kit-dingoapi/</a></p><p>安装dingo 有两种方法 这两种方法基本上百度都能找到</p><p>一种是在composer.json文件中进行修改 然后composer update：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">    &quot;dingo&#x2F;api&quot;: &quot;^2.2&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另一种就是直接使用 composer 直接将包引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require dingo&#x2F;api</span><br></pre></td></tr></table></figure><p>当我们安装 dingo 之后我们需要对dingo进行注册 我们使用 laravel 需要将配置文件引入进来，当然我们当前使用的是lumen</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;register(Dingo\Api\Provider\LumenServiceProvider::class);</span><br></pre></td></tr></table></figure><h4 id="关于Facades"><a href="#关于Facades" class="headerlink" title="关于Facades"></a>关于Facades</h4><p>API 自带了两个  <strong>Facade</strong> ，你可以自己选择使用</p><p><code>Dingo\Api\Facade\API</code></p><p>这个调度器的 <strong>Facade</strong> ，并提供了一些好用的辅助方法</p><p><code>Dingo\Api\Facade\Route</code></p><p>你可以使用这个 <strong>Facade</strong> 来获取API的当前路由、请求、检查当前的路由名称等</p><h4 id="Dingo-配置"><a href="#Dingo-配置" class="headerlink" title="Dingo 配置"></a>Dingo 配置</h4><hr><p>大部分的配置信息都是预先配置好了的，为的是让你能快速上手你的 API 项目。你可以通过 <code>·env</code> 文件来自定义大部分配置。但是，有一些配置微调需要你发布配置文件（Laravel）或者在 <code>bootstrap/app.php</code> 文件中配置 （Lumen）。你也可以使用 <code>AppServiceProvider</code> 中的 <code>boot</code> 方法来做设置。</p><h5 id="Standards-Tree-标准树"><a href="#Standards-Tree-标准树" class="headerlink" title="Standards Tree 标准树"></a>Standards Tree 标准树</h5><hr><p>这有三个不同的树<code>x</code>,<code>prs</code>,和,<code>vnd</code>.你使用的标准树需要取决于你开发的项目</p><p>关于版本描述，请自行参考官网配置</p><h5 id="配置-env"><a href="#配置-env" class="headerlink" title="配置.env"></a>配置.env</h5><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API_STANDARDS_TREE&#x3D;vnd</span><br></pre></td></tr></table></figure><p><strong>子类型通常是应用程序或项目的短名称，都是小写的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API_SUBTYPE&#x3D;myapp</span><br></pre></td></tr></table></figure><p><strong>前缀和子域</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">API_PREFIX&#x3D;api</span><br><span class="line">API_DOMAIN&#x3D;api.myapp.com</span><br></pre></td></tr></table></figure><blockquote><p>当然域名和前缀只能用一个</p></blockquote><h6 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h6><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API_VERSION&#x3D;v1</span><br></pre></td></tr></table></figure><h6 id="最后配置格式"><a href="#最后配置格式" class="headerlink" title="最后配置格式"></a>最后配置格式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># dingo </span><br><span class="line">API_STANDARDS_TREE&#x3D;prs </span><br><span class="line">API_SUBTYPE&#x3D;package </span><br><span class="line">API_PREFIX&#x3D;api </span><br><span class="line">API_VERSION&#x3D;v1 </span><br><span class="line">API_DEBUG&#x3D;true</span><br></pre></td></tr></table></figure><p>这几个配置非常的重要， API 版本的切换会利用到这些配置，不配置是会报错的。</p><p>接下来就可以进行接口测试了。具体测试 基本上官网文档都讲解的非常明白。具体请自行参考官网配置</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> lumen </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> dingo </tag>
            
            <tag> lumen </tag>
            
            <tag> api server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql FIND_IN_SET使用方法</title>
      <link href="2019/06/16/mysql-2019-06-17/"/>
      <url>2019/06/16/mysql-2019-06-17/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-FIND-IN-SET使用方法"><a href="#mysql-FIND-IN-SET使用方法" class="headerlink" title="mysql FIND_IN_SET使用方法"></a>mysql FIND_IN_SET使用方法</h1><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在最近的一次项目中，遇到一个场景，在一个审批中可能存在两个人同时进行审批，按照原先项目的思路，我决定对该项目的字段进行修改</p><ol><li>首先在原有字段上进行修改<blockquote><p>原有字段存在单个人的id 我们在单个id时对该id进行存储 然后 用户登录时，我们获取用户的id 然后对该id 进行验证</p></blockquote></li><li>对此进行修改 我直接将原有的bigint类型修改成为varchar字段<blockquote><p>如 原字段 存储用户1 = id = 1<br>现在字段 存储 用户1 = id = 1  多用户 用户1、用户2 = id = 1,2</p></blockquote></li></ol><h4 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h4><p>问题出现在id如果是按照in去查询 那么我们永远只能查询到id在前的无法查询到第一个id 后面的id</p><p>百度了一下 在mysql的手册中找到了FIND_IN_SET() 方法</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FIND_IN_SET(str,strlist)</span><br></pre></td></tr></table></figure><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><ol><li>假如字符串str在由N子链组成的字符串列表strlist中，则返回值的范围在1到N之间。</li><li>一个字符串列表就是一个由一些被‘,’符号分开的自链组成的字符串。</li><li>如果第一个参数是一个常数字符串，而第二个是typeSET列，则FIND_IN_SET()函数被优化，使用比特计算。</li><li>如果str不在strlist或strlist为空字符串，则返回值为0。</li><li>如任意一个参数为NULL，则返回值为NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</li></ol><p><strong><em>strlist</em></strong>：一个由英文逗号“,”链接的字符串，例如：”a,b,c,d”，该字符串形式上类似于SET类型的值被逗号给链接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：SELECT FIND_IN_SET(&#39;b&#39;,&#39;a,b,c,d&#39;) &#x2F;&#x2F; 返回2，即为第二个值</span><br></pre></td></tr></table></figure><h4 id="关于mysql中的-IN和FIND-IN-SET的查询问题"><a href="#关于mysql中的-IN和FIND-IN-SET的查询问题" class="headerlink" title="关于mysql中的 IN和FIND_IN_SET的查询问题"></a>关于mysql中的 IN和FIND_IN_SET的查询问题</h4><p>原来以为mysql可以进行这样的查询<br>select id, list, name from table where ‘daodao’ IN (list);</p><blockquote><p>注：table含有三个字段id:int,  list:varchar(255),  name:varchar(255)</p></blockquote><p>实际上这样是不行的，这样只有当’daodao’是list中的第一个元素(我测试的时候貌似是第一个也是不行的，只有当list字段的值等于daodao时才是对的)时，查询才有效，否则都的不到结果，即使’daodao’真的在list中</p><blockquote><p>结尾大家可以测试一下 我在网上也找到相同的文章 比较详细的那种<a href="http://blog.sina.com.cn/s/blog_5b5460eb0100e5r9.html">http://blog.sina.com.cn/s/blog_5b5460eb0100e5r9.html</a></p></blockquote><p>总结：所以如果list是常量，则可以直接用IN， 否则要用FIND_IN_SET()函数</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MYSQL </tag>
            
            <tag> SELECT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 关联查询 查询字段存在null赋值0</title>
      <link href="2019/06/13/mysql-2019-06-14-1/"/>
      <url>2019/06/13/mysql-2019-06-14-1/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-5-6-以上"><a href="#mysql-5-6-以上" class="headerlink" title="mysql 5.6 以上"></a>mysql 5.6 以上</h1><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>在读取数据库中 我们会发现 有的字段我们虽然默认为0 但是在关联查询时 主表查询从表如果查询不到数据 那么数据就会为空 而在前端展示不好看 所以我们能不能直接赋值</p></blockquote><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>~ mysql 版本 5.6以上</p><h4 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1,字段2,ifNull(字段3,0) as 字段3(别名) from 表名</span><br></pre></td></tr></table></figure><h4 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h4><p>~ sqlserver</p><h4 id="查询条件-1"><a href="#查询条件-1" class="headerlink" title="查询条件"></a>查询条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1,字段2,isNull(字段3,0) as 字段3(别名) from 表名</span><br></pre></td></tr></table></figure><h4 id="环境-2"><a href="#环境-2" class="headerlink" title="环境"></a>环境</h4><p>~ oracle</p><h4 id="查询条件-2"><a href="#查询条件-2" class="headerlink" title="查询条件"></a>查询条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1,字段2,nvl(字段3,0) from 表名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MYSQL </tag>
            
            <tag> SELECT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧用CAS解决数据一致性问题</title>
      <link href="2019/01/07/server-2019-01-08-1/"/>
      <url>2019/01/07/server-2019-01-08-1/</url>
      
        <content type="html"><![CDATA[<h2 id="巧用CAS解决数据一致性问题"><a href="#巧用CAS解决数据一致性问题" class="headerlink" title="巧用CAS解决数据一致性问题"></a>巧用CAS解决数据一致性问题</h2><p>58沈剑 架构师之路 <em>2015-11-05</em></p><p><strong>缘起</strong>：在高并发的分布式环境下，对于数据的查询与修改容易引发一致性问题，本文将分享一种非常简单但有效的优化方法。</p><h2 id="一、业务场景"><a href="#一、业务场景" class="headerlink" title="一、业务场景"></a>一、业务场景</h2><p>业务场景为，购买商品的过程要对余额进行查询与修改，大致的业务流程如下：</p><p>（1）从数据库查询用户现有余额 <code>SELECT money FROM t_yue WHERE uid=$uid</code>，不妨设查询出来的<code>$old_money=100元</code></p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4I1sPicaUAxOQdJlauicU6gv8QTnjGws7T5Vy6F34vYicm1t04RJMIibhYXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>（2）业务层实施业务逻辑，比如购买一个80元的商品，并且打九折</p><pre><code>if($old\_money&gt; 80\*0.9) $new\_money=$old_money-80\*0.9=28</code></pre><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4IyibMRTgtommicU61DeN1mia9BSguDFdo8gqoKwI4JbqBEiarwvibbv8NZCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>（3）将数据库中的余额进行修改 <code>UPDAtE t\_yue SET money=$new\_money WHERE uid=$uid</code></p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4IHJ5mYyJyHSibGSKrt045nETHicY3ibkK2mcmVM96Gp5DksK3CmWQFRaxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>在并发量低的情况下，这个流程没有任何问题，原有金额100元，购买了80元的九折商品（72元），剩余28元。</p><h2 id="二、潜在的问题"><a href="#二、潜在的问题" class="headerlink" title="二、潜在的问题"></a>二、潜在的问题</h2><p>在分布式环境中，如果并发量很大，<strong>这种“查询**</strong>+<strong>**修改”的业务很容易出现数据不一致</strong>。极限情况下，可能出现这样的异常流程：</p><p>（1）业务1和业务2同时查询余额，是100元</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4IymrTyYQ14y38RQUysvfIGzN0xdeALkZTrcSib1HfTV74ZnoAdOUl6sw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>（2）业务1和业务2进行逻辑计算，算出各自业务的余额，假设业务1算出的余额是28元，业务2算出的余额是38元</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4I5B5FxMuV8ibD0NMVFynD8hLfuJKZF5FNhBIP7uMKibia7T9da6u5js0lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>（3）业务1对数据库中的余额先进行修改，设置成28元。</p><p>业务2对数据库中的余额后进行修改，设置成38元。</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwqEGDX16FzribBMJ3okQE4IQY7wn9PTNr4ictHrFGndTzQgx1th35gNWRUoEpvtCR3b9gSlv3HIRyg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">  </p><p>此时异常出现了，原有金额100元，业务1扣除了72元，业务2扣除了62元，最后剩余38元。</p><h2 id="三、问题原因"><a href="#三、问题原因" class="headerlink" title="三、问题原因"></a>三、问题原因</h2><blockquote><p>高并发环境下，对同一个数据的<strong>并发读</strong>（两边都读出余额是100）与<strong>并发写</strong>（一个写回28，一个写回38）导致的数据一致性问题。</p></blockquote><h2 id="四、原因分析"><a href="#四、原因分析" class="headerlink" title="四、原因分析"></a>四、原因分析</h2><p>业务1的写回：原有金额100，这是一个初始状态，写回金额28，理论上只有在原有金额为100的时候才允许写回成功，这一步没问题。</p><p>业务2的写回：的原有金额100，这是一个初始状态，写回金额38，理论上只有在原有金额为100的时候才允许写回成功，可实际上，这个时候数据库中的金额已经变为28了，这一步的写操作不应该成功。</p><h2 id="五、简易解决方案"><a href="#五、简易解决方案" class="headerlink" title="五、简易解决方案"></a>五、简易解决方案</h2><p>在set写回的时候，加上初始状态的条件compare，只有初始状态不变时，才允许set写回成功，这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。</p><h2 id="六、业务的升级"><a href="#六、业务的升级" class="headerlink" title="六、业务的升级"></a>六、业务的升级</h2><p>业务线使用CAS解决高并发时数据一致性问题，只需要在进行set操作时，compare一下初始值，如果初始值变换，不允许set成功。</p><p>对于上文中的业务场景，只需要将“<code>UPDAtEt\_yue SET money=$new\_money WHERE uid=$uid</code>”升级为</p><pre><code>“UPDAtE t\_yue SETmoney=$new\_money WHERE uid=$uid **AND money=$old_money**”即可。</code></pre><p>并发操作发生时：</p><p>业务1执行 =&gt; <code>UPDAtE t_yue **SET money=28** WHERE uid=$uid **AND money=100**</code></p><p>业务2执行 =&gt; <code>UPDAtE t_yue **SET money=38** WHERE uid=$uid **AND money=100**</code></p><p><del>【这两个操作同时进行时，只能有一个执行成功】</del>。</p><h2 id="七、怎么判断哪个执行成功，哪个执行失败"><a href="#七、怎么判断哪个执行成功，哪个执行失败" class="headerlink" title="七、怎么判断哪个执行成功，哪个执行失败"></a>七、怎么判断哪个执行成功，哪个执行失败</h2><p>set操作，其实无所谓成功或者失败，业务能通过affect rows得知哪个修改没有成功：</p><p>执行成功的业务，affect rows为1</p><p>执行失败的业务，affect rows为0</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><blockquote><p>高并发“查询并修改”的场景，可以用CAS（Compare and Set）的方式解决数据一致性问题。对应到业务，即在set的时候，加上初始条件的比对。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> CAS </tag>
            
            <tag> 服务架构 </tag>
            
            <tag> 架构师 </tag>
            
            <tag> CAS 算法 </tag>
            
            <tag> MYSQL 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网架构，如何进行容量设计？</title>
      <link href="2019/01/07/server-2019-01-08-2/"/>
      <url>2019/01/07/server-2019-01-08-2/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网架构，如何进行容量设计？"><a href="#互联网架构，如何进行容量设计？" class="headerlink" title="互联网架构，如何进行容量设计？"></a>互联网架构，如何进行容量设计？</h2><p>原创： 58沈剑 架构师之路 <em>2016-08-23</em></p><h2 id="一，需求缘起"><a href="#一，需求缘起" class="headerlink" title="一，需求缘起"></a>一，需求缘起</h2><hr><p>互联网公司，这样的场景是否似曾相识：</p><p>场景一：pm要做一个很大的运营活动，技术老大杀过来，问了两个问题：</p><p>（1）机器能抗住么？</p><p>（2）如果扛不住，需要加多少台机器？</p><p>场景二：系统设计阶段，技术老大杀过来，又问了两个问题：</p><p>（1）数据库需要分库么？</p><p>（2）如果需要分库，需要分几个库？</p><p>技术上来说，这些都是系统容量预估的问题，<strong>容量设计是架构师必备的技能之一</strong>。常见的容量评估包括数据量、并发量、带宽、CPU/MEM/DISK等，今天分享的内容，就以【并发量】为例，看看如何回答好这两个问题。</p><h2 id="二，容量评估的步骤与方法"><a href="#二，容量评估的步骤与方法" class="headerlink" title="二，容量评估的步骤与方法"></a>二，容量评估的步骤与方法</h2><hr><h3 id="【步骤一：评估总访问量】"><a href="#【步骤一：评估总访问量】" class="headerlink" title="【步骤一：评估总访问量】"></a>【步骤一：评估总访问量】</h3><p>如何知道总访问量？对于一个运营活动的访问量评估，或者一个系统上线后PV的评估，有什么好的方法？</p><p>答案是：询问业务方，询问运营同学，询问产品同学，看对运营活动或者产品上线后的预期是什么。</p><p>举例：58要做一个APP-push的运营活动，计划在30分钟内完成5000w用户的push推送，预计push消息点击率10%，求push落地页系统的总访问量？</p><p>回答：5000w*10% = 500w</p><h3 id="【步骤二：评估平均访问量QPS】"><a href="#【步骤二：评估平均访问量QPS】" class="headerlink" title="【步骤二：评估平均访问量QPS】"></a>【步骤二：评估平均访问量QPS】</h3><p>如何知道平均访问量QPS？</p><p>答案是：有了总量，除以总时间即可，如果按照天评估，一天按照4w秒计算。</p><p>举例1：push落地页系统30分钟的总访问量是500w，求平均访问量QPS</p><p>回答：500w/(30*60) = 2778，大概3000QPS</p><p>举例2：主站首页估计日均pv 8000w，求平均访问QPS</p><p>回答：一天按照4w秒算，8000w/4w=2000，大概2000QPS</p><p>提问：为什么一天按照4w秒计算？</p><p>回答：一天共24小时<em>60分钟</em>60秒=8w秒，一般假设所有请求都发生在白天，所以一般来说一天只按照4w秒评估</p><h3 id="【步骤三：评估高峰QPS】"><a href="#【步骤三：评估高峰QPS】" class="headerlink" title="【步骤三：评估高峰QPS】"></a>【步骤三：评估高峰QPS】</h3><p>系统容量规划时，不能只考虑平均QPS，而是要抗住高峰的QPS，如何知道高峰QPS呢？</p><p>答案是：根据业务特性，通过业务访问曲线评估</p><p>举例：日均QPS为2000，业务访问趋势图如下图，求峰值QPS预估？</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxczfXmIbibeElVSyejm94IVGW27GbsibXTG7r3jicMoMnZhl3gXLtbyYZSQ2A1aRuHawUGgPgZeib50g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"><br>回答：从图中可以看出，峰值QPS大概是均值QPS的2.5倍，日均QPS为2000，于是评估出峰值QPS为5000。</p><p>说明：有一些业务例如“秒杀业务”比较难画出业务访问趋势图，这类业务的容量评估不在此列。</p><h3 id="【步骤四：评估系统、单机极限QPS】"><a href="#【步骤四：评估系统、单机极限QPS】" class="headerlink" title="【步骤四：评估系统、单机极限QPS】"></a>【步骤四：评估系统、单机极限QPS】</h3><p>如何评估一个业务，一个服务单机能的极限QPS呢？</p><p>答案是：压力测试</p><p>在一个服务上线前，一般来说是需要进行压力测试的（很多创业型公司，业务迭代很快的系统可能没有这一步，那就悲剧了），以APP-push运营活动落地页为例（日均QPS2000，峰值QPS5000），这个系统的架构可能是这样的：</p><p><img src= "/img/loading.gif" data-lazy-src="http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxczfXmIbibeElVSyejm94IVg2icic0NINcKROXhl3DULNmiboVH4z43wyyQ2IFyEWic43KDFgPcbUoS7Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"><br>1）访问端是APP</p><p>2）运营活动H5落地页是一个web站点</p><p>3）H5落地页由缓存cache、数据库db中的数据拼装而成</p><p>通过压力测试发现，web层是瓶颈，tomcat压测单机只能抗住1200的QPS（一般来说，1%的流量到数据库，数据库500QPS还是能轻松抗住的，cache的话QPS能抗住，需要评估cache的带宽，假设不是瓶颈），我们就得到了web单机极限的QPS是1200。一般来说，线上系统是不会跑满到极限的，打个8折，单机线上允许跑到QPS1000。</p><h3 id="【步骤五：根据线上冗余度回答两个问题】"><a href="#【步骤五：根据线上冗余度回答两个问题】" class="headerlink" title="【步骤五：根据线上冗余度回答两个问题】"></a>【步骤五：根据线上冗余度回答两个问题】</h3><p>好了，上述步骤1-4已经得到了峰值QPS是5000，单机QPS是1000，假设线上部署了2台服务，就能自信自如的回答技术老大提出的问题了：</p><p>（1）机器能抗住么？ -&gt; 峰值5000，单机1000，线上2台，扛不住</p><p>（2）如果扛不住，需要加多少台机器？ -&gt; 需要额外3台，提前预留1台更好，给4台更稳</p><p>除了并发量的容量预估，数据量、带宽、CPU/MEM/DISK等评估亦可遵循类似的步骤。</p><h2 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h2><hr><p>互联网架构设计如何进行容量评估：</p><h4 id="【步骤一：评估总访问量】-gt-询问业务、产品、运营"><a href="#【步骤一：评估总访问量】-gt-询问业务、产品、运营" class="headerlink" title="【步骤一：评估总访问量】  -&gt; 询问业务、产品、运营"></a>【步骤一：评估总访问量】  -&gt; 询问业务、产品、运营</h4><h4 id="【步骤二：评估平均访问量QPS】-gt-除以时间，一天算4w秒"><a href="#【步骤二：评估平均访问量QPS】-gt-除以时间，一天算4w秒" class="headerlink" title="【步骤二：评估平均访问量QPS】 -&gt; 除以时间，一天算4w秒"></a>【步骤二：评估平均访问量QPS】 -&gt; 除以时间，一天算4w秒</h4><h4 id="【步骤三：评估高峰QPS】-gt-根据业务曲线图来"><a href="#【步骤三：评估高峰QPS】-gt-根据业务曲线图来" class="headerlink" title="【步骤三：评估高峰QPS】  -&gt; 根据业务曲线图来"></a>【步骤三：评估高峰QPS】  -&gt; 根据业务曲线图来</h4><h4 id="【步骤四：评估系统、单机极限QPS】-gt-压测很重要"><a href="#【步骤四：评估系统、单机极限QPS】-gt-压测很重要" class="headerlink" title="【步骤四：评估系统、单机极限QPS】  -&gt; 压测很重要"></a>【步骤四：评估系统、单机极限QPS】  -&gt; 压测很重要</h4><h4 id="【步骤五：根据线上冗余度回答两个问题】-gt-估计冗余度与线上冗余度差值"><a href="#【步骤五：根据线上冗余度回答两个问题】-gt-估计冗余度与线上冗余度差值" class="headerlink" title="【步骤五：根据线上冗余度回答两个问题】 -&gt; 估计冗余度与线上冗余度差值"></a>【步骤五：根据线上冗余度回答两个问题】 -&gt; 估计冗余度与线上冗余度差值</h4>]]></content>
      
      
      <categories>
          
          <category> 服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务架构 </tag>
            
            <tag> 架构师 </tag>
            
            <tag> 容量设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>究竟啥才是互联网架构“高可用”</title>
      <link href="2019/01/07/server-2019-01-08-3/"/>
      <url>2019/01/07/server-2019-01-08-3/</url>
      
        <content type="html"><![CDATA[<h2 id="究竟啥才是互联网架构“高可用”"><a href="#究竟啥才是互联网架构“高可用”" class="headerlink" title="究竟啥才是互联网架构“高可用”"></a>究竟啥才是互联网架构“高可用”</h2><p>原创： 58沈剑 架构师之路 <em>2016-12-05</em></p><h2 id="一、什么是高可用"><a href="#一、什么是高可用" class="headerlink" title="一、什么是高可用"></a>一、什么是高可用</h2><p><strong>高可用HA**</strong>（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>假设系统一直能够提供服务，我们说系统的可用性是100%。</p><p>如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。</p><p>很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。</p><p>百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过<a href="http://www.baidu.com/">www.baidu.com</a> 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度HA最高的褒奖。</p><h2 id="二、如何保障系统的高可用"><a href="#二、如何保障系统的高可用" class="headerlink" title="二、如何保障系统的高可用"></a>二、如何保障系统的高可用</h2><p>我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。</p><p><strong>保证系统高可用，架构设计的核心准则是：冗余。</strong></p><p>有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。</p><p>接下来我们看下典型互联网架构中，如何通过<strong>冗余+自动故障转移</strong>来保证系统的高可用特性。</p><h2 id="三、常见的互联网分层架构"><a href="#三、常见的互联网分层架构" class="headerlink" title="三、常见的互联网分层架构"></a>三、常见的互联网分层架构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLV5xf.jpg"><br>常见互联网分布式架构如上，分为：</p><p>（1）<strong>客户端层</strong>：典型调用方是浏览器browser或者手机应用APP</p><p>（2）<strong>反向代理层</strong>：系统入口，反向代理</p><p>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回html或者json</p><p>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层</p><p>（5）<strong>数据**</strong>-<strong>**缓存层</strong>：缓存加速访问存储</p><p>（6）<strong>数据**</strong>-<strong>**数据库层</strong>：数据库固化数据存储</p><p>整个系统的高可用，又是通过每一层的<strong>冗余**</strong>+<strong>**自动故障转移</strong>来综合实现的。</p><h2 id="四、分层高可用架构实践"><a href="#四、分层高可用架构实践" class="headerlink" title="四、分层高可用架构实践"></a>四、分层高可用架构实践</h2><p><strong>【客户端层-&gt;**</strong>反向代理层】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLZMee.png"><br>【客户端层】到【反向代理层】的<strong>高可用</strong>，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLZYSP.png"><br><strong>自动故障转移</strong>：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p><p><strong>【反向代理层-&gt;**</strong>站点层】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeknS.png"><br>【反向代理层】到【站点层】的<strong>高可用</strong>，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeets.png"><br><strong>自动故障转移</strong>：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。</p><p><strong>【站点层-&gt;**</strong>服务层】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLemhn.png"><br>【站点层】到【服务层】的<strong>高可用</strong>，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeMcV.png"><br><strong>自动故障转移</strong>：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。</p><p><strong>【服务层&gt;**</strong>缓存层】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLe1nU.png"><br>【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。</p><p>缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeJAJ.png"><br>缓存层也可以通过支持主从同步的缓存集群来解决缓存层的<strong>高可用</strong>问题。</p><p>以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeYN9.png"><br><strong>自动故障转移</strong>：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。</p><p>说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。</p><p>这类允许“cache miss”的业务场景，缓存架构的建议是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeU91.png"><br>将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLedc6.png"><br><strong>缓存实例挂了屏蔽</strong>：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。</p><p><strong>【服务层&gt;**</strong>数据库层】的高可用**</p><p>大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。</p><p><strong>【服务层&gt;**</strong>数据库层“读”】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLe29I.png"><br>【服务层】到【数据库读】的<strong>高可用</strong>，是通过读库的冗余来实现的。</p><p>既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLeR3t.png"><br><strong>自动故障转移</strong>：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。</p><p><strong>【服务层&gt;**</strong>数据库层“写”】的高可用**</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLe4u8.png"><br>【服务层】到【数据库写】的<strong>高可用</strong>，是通过写库的冗余来实现的。</p><p>以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2020/01/14/lLe7Nj.png"><br><strong>自动故障转移</strong>：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>方法论上，高可用是通过<strong>冗余**</strong>+<strong>**自动故障转移</strong>来实现的。</p><p>整个互联网分层系统架构的高可用，又是通过每一层的<strong>冗余**</strong>+<strong>**自动故障转移</strong>来综合实现的，具体的：</p><p>（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><p>（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移</p><p>（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移</p><p>（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性</p><p>（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移</p><p>（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><p>末了，希望文章的思路是清晰的，希望大家对高可用的概念和实践有个系统的认识，感谢大家。</p><p>==【完】==</p>]]></content>
      
      
      <categories>
          
          <category> 服务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务架构 </tag>
            
            <tag> 架构师 </tag>
            
            <tag> 高可用服务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 CentOS7 中安装 Nodejs</title>
      <link href="2018/12/27/linux-centos-2018-12-28-1/"/>
      <url>2018/12/27/linux-centos-2018-12-28-1/</url>
      
        <content type="html"><![CDATA[<p>安装版本：10.13.0</p><h2 id="一、安装必要的编译软件包"><a href="#一、安装必要的编译软件包" class="headerlink" title="一、安装必要的编译软件包"></a>一、安装必要的编译软件包</h2><p>sudo yum install gcc gcc-c++</p><h2 id="二、从源码下载Nodejs"><a href="#二、从源码下载Nodejs" class="headerlink" title="二、从源码下载Nodejs"></a>二、从源码下载Nodejs</h2><pre><code>cd /usr/local/srcwget https://npm.taobao.org/mirrors/node/v10.13.0/node-v10.13.0.tar.gz</code></pre><h2 id="三、解压-nodejs-安装包"><a href="#三、解压-nodejs-安装包" class="headerlink" title="三、解压 nodejs 安装包"></a>三、解压 nodejs 安装包</h2><pre><code>tar xvf node-v10.13.0.tar.gz</code></pre><h2 id="四、进入解压的-node-文件夹，开始编译"><a href="#四、进入解压的-node-文件夹，开始编译" class="headerlink" title="四、进入解压的 node 文件夹，开始编译"></a>四、进入解压的 node 文件夹，开始编译</h2><pre><code>cd node-v10.13.0/./configuremake</code></pre><blockquote><p>注：make过程较为耗时，可能需要30分钟以上</p></blockquote><p> 如果编译过程中报 C++ Compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)，那需要先升级一下 gcc，编译正常的话请忽略直接跳至第五步开始安装</p><p>检查 gcc 的版本</p><pre><code>gcc -v</code></pre><p>如果版本号低于4.9.4，请先升级gcc</p><h2 id="五、安装Nodejs"><a href="#五、安装Nodejs" class="headerlink" title="五、安装Nodejs"></a>五、安装Nodejs</h2><pre><code>sudo make install</code></pre><h2 id="六、到此就已经安装完毕了"><a href="#六、到此就已经安装完毕了" class="headerlink" title="六、到此就已经安装完毕了"></a>六、到此就已经安装完毕了</h2>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> nodejs </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Centos7 中安装 gcc</title>
      <link href="2018/12/26/linux-centos-2018-12-27-1/"/>
      <url>2018/12/26/linux-centos-2018-12-27-1/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在-Centos7-中安装-gcc"><a href="#如何在-Centos7-中安装-gcc" class="headerlink" title="如何在 Centos7 中安装 gcc"></a>如何在 Centos7 中安装 gcc</h1><p>系统环境：<strong>Centos7.4</strong><br>今天在安装 <strong>Nodejs8.7</strong> 的时候，报了一个警告：<br><strong>WARNING: C++ Compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)</strong></p><p>然后，查了一下自己系统上安装的版本：4.8.5<br>好吧，不能用 yum 升级了，那就手动安装了吧</p><h2 id="一、选择需要升级的版本"><a href="#一、选择需要升级的版本" class="headerlink" title="一、选择需要升级的版本"></a>一、选择需要升级的版本</h2><p>gcc ftp 下载地址列表<br>(我选择了5.4.0)</p><h2 id="二、获取安装包并解压"><a href="#二、获取安装包并解压" class="headerlink" title="二、获取安装包并解压"></a>二、获取安装包并解压</h2><pre><code>cd /usr/local/srcwget https://ftp.gnu.org/gnu/gcc/gcc-5.4.0/gcc-5.4.0.tar.bz2tar -jxvf gcc-5.4.0.tar.bz2</code></pre><p>注：bz2是一种压缩文件格式，若无法解压，安装 bzip2 即可：yum -y install bzip2</p><h2 id="三、进入解压后的gcc文件夹，下载供编译需求的依赖项"><a href="#三、进入解压后的gcc文件夹，下载供编译需求的依赖项" class="headerlink" title="三、进入解压后的gcc文件夹，下载供编译需求的依赖项"></a>三、进入解压后的gcc文件夹，下载供编译需求的依赖项</h2><pre><code>cd gcc-build-5.4.0./contrib/download_prerequisites</code></pre><h2 id="四、建立一个文件夹存放编译文件"><a href="#四、建立一个文件夹存放编译文件" class="headerlink" title="四、建立一个文件夹存放编译文件"></a>四、建立一个文件夹存放编译文件</h2><pre><code>mkdir gcc-build-5.4.0cd gcc-build-5.4.0</code></pre><h2 id="五、生成-Makefile-文件"><a href="#五、生成-Makefile-文件" class="headerlink" title="五、生成 Makefile 文件"></a>五、生成 Makefile 文件</h2><pre><code>make</code></pre><p>注：这个过程非常耗时，我的1核1G内存大约花了一个来小时</p><h2 id="六、安装"><a href="#六、安装" class="headerlink" title="六、安装"></a>六、安装</h2><pre><code>sudo make install</code></pre><h2 id="七、重启服务器，验证版本"><a href="#七、重启服务器，验证版本" class="headerlink" title="七、重启服务器，验证版本"></a>七、重启服务器，验证版本</h2><pre><code>gcc -v</code></pre><p>等了那么久，总算是成功了，很激动对不对？<br>但是！<br>我执行到上边以后，屁颠屁颠的跑去编译 nodejs 了，耍出了一个错误：</p><pre><code>/usr/local/src/node-v8.7.0/out/Release/mksnapshot: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&#39; not found (required by /usr/local/src/node-v8.7.0/out/Release/mksnapshot)</code></pre><p>编译失败~ 劳资等了30分钟</p><p>好吧，出了问题终究是要解决的<br>问题原因：升级gcc时，生成的动态库没有替换老版本 gcc 动态库导致的<br>解决方案：将gcc最新版本的动态库替换系统中老版本的动态库。<br>(1). 查找编译gcc时生成的最新动态库</p><pre><code>find / -name &quot;libstdc++.so*&quot;</code></pre><p>(2) 将找到的动态库<code>libstdc++.so.6.0.21</code>复制到<code>/usr/lib64</code></p><pre><code>cp /usr/local/src/gcc-5.4.0/gcc-build-5.4.0/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6.0.21 /usr/lib64</code></pre><p>(3). 切换工作目录至/usr/lib64，删除原来的软连接， 将默认库的软连接指向最新动态库。</p><pre><code>cd /usr/lib64rm -rf libstdc++.so.6ln -s libstdc++.so.6.0.21 libstdc++.so.6</code></pre><p>到这里才算是收工了。</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
          <category> gcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>360产品经理：我是如何用增长黑客思维，24小时内收获2000+份高质量简历</title>
      <link href="2018/12/19/product-2018-12-20-1/"/>
      <url>2018/12/19/product-2018-12-20-1/</url>
      
        <content type="html"><![CDATA[<h1 id="360产品经理：我是如何用增长黑客思维，24小时内收获2000-份高质量简历"><a href="#360产品经理：我是如何用增长黑客思维，24小时内收获2000-份高质量简历" class="headerlink" title="360产品经理：我是如何用增长黑客思维，24小时内收获2000+份高质量简历"></a>360产品经理：我是如何用增长黑客思维，24小时内收获2000+份高质量简历</h1><blockquote><p>本文转载自：<a href="http://www.woshipm.com/operate/1748503.html">http://www.woshipm.com/operate/1748503.html</a></p></blockquote><blockquote><p>作者：金师兴 职位：360产品经理 时间：2018-12-19</p></blockquote><blockquote><p>前不久，我实操案例写了一篇《我是如何用增长黑客思维，13天收获2,000+高质量简历》[1]，吸引了大量业内负责用户增长的前辈、同学与我讨论交流。但我发现13天时间，周期还是太长了。今年我再次实践增长黑客，使用微信群裂变的方法，把时间压缩到了24小时。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/9v28AXtspKhNjOeQFSjY.jpg"></p><p>  时间回到2018年7月13日，作为360产品委员会的秘书成员，我正在负责360全国高校hackaday产品创新大赛，HR小姐姐找到我“360校招内推又要开始了哦，今年准备推荐多少师弟师妹^_^。”</p><p>  留下我的委屈问号脸“今年没有那么赋闲呀”。</p><p>  盘算了下，由于要组织hackaday比赛，只有一天的时间可以用来内推。那么今年务必力求高效，速战速决。</p><p>  最终通过微信群快速裂变，当天共吸引6739名学生，裂变了82个微信群，收获2739份学生简历。详细裂变数据如下图所示，可以明显从趋势图后半段中看出，裂变人数开始迅速暴增，由于裂变速度过快，我及时关闭了实验。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/7i96o3eT7oeOxwZq7NTw.png"><br><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/FE1FQFtEkdYX1E3tGEur.png"></p><p>我使用了一个群裂变管理工具，来解放双手：</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/xolHZRs7mQl5A0XiUe0o.png"></p><p>微信群裂变的案例很多，那我今天的案例盘点有什么不同呢？<br>我会更加侧重用户的心理拿捏、裂变过程的踩坑和难点、从产品经理的角度剖析案例背后的原理和方法论，并更加关注用户留存。针对大家很关心的：冷启动怎么做、裂变活动带来一堆“无价值死群”等增长瓶颈问题，文后有专门的段落一起探讨。<br>我们都知道，每个增长任务都有一个<strong>北极星指标(North Star Metric)**，本次裂变活动的北极星指标是“收集到的学生简历数量”，它就像</strong>北极星一般，指引着增长的方向，并时刻评估增长的效果[2]**。<br>核心裂变路径如下图所示：</p><h2 id="一、梳理用户画像和产品价值"><a href="#一、梳理用户画像和产品价值" class="headerlink" title="一、梳理用户画像和产品价值"></a>一、梳理用户画像和产品价值</h2><p>我们目标用户的画像是：</p><ul><li>22<del>23岁或26</del>27岁，国内外知名院校毕业，尤其以计算机方向为主，或学校普通但能力突出的学生；</li><li>群体集中，愿意尝鲜，热爱分享，活跃在微信群、朋友圈；</li><li>对师兄师姐非常信任，甚至盲目跟随，把师兄师姐的话奉为真理。</li></ul><p>本次裂变的产品是“360内推”，那么产品价值包括：</p><ol><li>对于学生而言，360作为国内顶尖的互联网企业，360的offer是一个不错的选择；</li><li>内推是绿色通道，并且从时间上，内推比普通校招提前，参加内推可抢先一步，不用挤校招的独木桥；</li><li>内推免笔试。</li></ol><h2 id="二、寻找裂变点"><a href="#二、寻找裂变点" class="headerlink" title="二、寻找裂变点"></a>二、寻找裂变点</h2><p>我们常说的裂变点有两类，<strong>一类是基于“利益链”，一类是基于“关系链”</strong>。如下图所示[3]，是一些我们常见的在朋友圈刷屏的裂变活动。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/Rpo6JZdmLSOUc1s50i6O.png"></p><p>当然有的裂变，会同时使用到“关系链”和“利益链”。咱们本次的裂变，主要用到“利益链”，裂变点是：“抢占内推的名额”，而“关系链”的部分则非常少，这一点出乎我的意料，为什么呢？<br>这里也是本次裂变中踩到的一个坑，我后面会举案例单独分析。</p><h2 id="三、冷启动"><a href="#三、冷启动" class="headerlink" title="三、冷启动"></a>三、冷启动</h2><p>现在已经知道，我们需要什么样的用户，冷启动的下一步是寻找流量池。很多人关心冷启动从哪里寻找目标种子用户，需要多少量级，才能撑起来上万人的裂变活动？</p><p>我曾请教一位业内知名的增长负责人，他告诉我，每次百万量级的活动，他会通过供应商，付费让1000人转发活动海报到朋友圈，完成冷启动。我想，不同垂直行业和主题的裂变活动，需要的冷启动量级是不同的。咱们今天案例的冷启动，我仅使用了一个70人的北邮师弟师妹微信群。<br>这个群，有两个特点：</p><ol><li>群成员都是18年参加校招的学生；</li><li>由于我是老师邀请进群，并且在群内分享过求职经验，师弟师妹对我非常信任。</li></ol><p>因此，这里构成了两个非常核心的要素：<strong>精准用户+取得用户信任。</strong></p><p>如何快速取得用户信任？</p><h2 id="四、取得用户信任"><a href="#四、取得用户信任" class="headerlink" title="四、取得用户信任"></a>四、取得用户信任</h2><p>刚刚说到，对于认识我的人，是信任我的。但对于陌生的师弟师妹，如何取得他们的信任呢？</p><p>首先，我需要一个身份，我给自身的定位是：北邮17届电子院毕业师兄。这一下子就拉近了距离，并且打消了师弟师妹对于“我为什么要组织内推”的疑虑。我的另一个身份是360员工，因此我创建的群名是：“360师兄帮你内推群”。<br>其次，我的身份需要背书，如何背书？</p><pre><code>其一、我的公司邮箱就是最好的背书。其二、学生把群二维码，转发到自己的社交圈，他帮我做了背书。其三，引导学生在群里提问讨论，也起到了良好的背书作用。</code></pre><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/vTbz8BXM7eLtvK3adDdS.png"></p><p>用户信任是一件非常微妙的事情，信任的发生常常就在几秒内。有人问我，让用户产生信任的关键时间点是什么时候？</p><p>在腾讯有一个产品理论，如果用户第一次体验产品留下了坏印象，那后续很难再召回这名用户。同样的，在本案例中，如果无法在新访客刚进群的短暂时间内，让用户第一时间体会到产品价值，下一个动作，很可能是点击返回，再也不会打开，甚至直接退群。</p><p>我们把这个现象称之为：<strong>3秒钟流失。</strong>那么如何在3秒钟内，取得新访客的信任？<br>新访客有3个关键<strong>action：</strong></p><ol><li>关键<strong>action 1</strong>：当学生在朋友圈/微信群，看到同学转发的内推群二维码，立即扫码进群，这是基于朋友之间的相互信任，会消耗他们之间的社交货币，这里考验海报的设计。</li><li>关键<strong>action 2</strong>：进群后看到群通知，按提示发送简历到我的公司邮箱，这是基于公司邮箱的背书和信任，这里考验文案的设计。</li><li>关键<strong>action 3</strong>：要求学生转发群二维码，到自己的社交圈，我会优先帮其内推。但在这一步遇到了阻力。问题出在哪里，这里要回归到一个命题：你是否了解你的用户？这里考验裂变点的设计。</li></ol><h2 id="五、了解你的用户"><a href="#五、了解你的用户" class="headerlink" title="五、了解你的用户"></a>五、了解你的用户</h2><p>难道我还不够了解吗，我就是从学生时代过来的，刚刚我们还做了那么详细的用户画像分析。很遗憾，实际情况确实是我不够了解。<strong>因为此时的我们高高在上，已不在学生的处境，无法体会学生那种焦虑、着急、迷茫、独享的微妙心理</strong>。<br>那这个问题怎么解？<br>我的方法也很简单粗暴，直接加学生微信私聊。<br>沟通后，我得出结论：<strong>“对于学生而言，内推是非常宝贵且私密的渠道，不希望和其他同学共享，因为如果内推的人多了，自己便失去了优势”</strong>。<br>这便是前文提到的：<strong>为什么本案例不是以用户关系链为主的裂变，因为这里面用户想要去炫耀和求关注的成份很少。</strong></p><p>我立即修改策略：“转发的同学，邀请进内部消息群单独辅导，未第一时间转发的同学，将被移除出群聊”。根据<strong>卡尼曼</strong>的**“损失厌恶”经济学原理，当人们面对损失时，会加倍意识到事物的价值[4]**。其实留在微信群内，可能也没有什么用处，但退出微信群，则极大地激发了学生的转发动力。</p><p>新版群通知文案发布后，转发的学生开始成倍增长，转发率平均达到20%以上：平均一个100人的内推微信群，有20~30人进行了转发（这里有个小细节，如果要求转发到朋友圈，大多数同学会设置分组或仅自己可见，但转发到校招群、年级群，学生的顾虑要小很多，并且用户更加垂直，有效转化率要高得多）。</p><h2 id="六、信任危机"><a href="#六、信任危机" class="headerlink" title="六、信任危机"></a>六、信任危机</h2><p>之后便是enjoy时刻，群成员十几分钟满员，机器人快速将群二维码切换至新群，微信群数量开始暴涨，并似乎已不受控制。但流量一旦扩大，各类问题也会随之暴露出来。这些问题中，最紧要的便是信任危机问题。<br>虽然很多时候，用户只是猜忌，并无任何依据，但却快速得到大众的相信，个别问题甚至会因为盲从被无限放大（参考《乌合之众》）。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/Jxv3txqjVmWJ8hRr8j78.png"></p><p>从微信群截图中可以看到，随着各类人员进群，群里的成员，开始质疑。这些质疑的声音中，有的是用户正常的诉求，当然有的是恶搞。那么，遇到信任危机如何处理？</p><p>首先，我们万不可玻璃心，应当正面看待辣眼睛的吐槽。老周经常跟我们说：不要怕被用户骂，相反我们应该感到高兴，被用户骂，至少证明了我们存在的价值，用户是关注我们的。关键是要弄清楚用户骂的道理在哪里，怎么改进。而那些用户都懒得骂的产品，要惨多了。<br>那么，遇到信任危机，应当如何化解呢？</p><p>笨办法往往十分管用。我耐心地向同学们，解答校招内推相关知识，很容易便消除了误会。好的社群是自组织生态，但也容易被“坏人”利用，带乱节奏，因此社群的运营维护，是必不可少的。切不可掉以轻心，以为裂变成功便可高枕无忧，相反，裂变成功只是服务用户的开始。</p><h2 id="七、AB测试"><a href="#七、AB测试" class="headerlink" title="七、AB测试"></a>七、AB测试</h2><p>在做裂变的过程中，我们经常会用到AB测试的方法：两张大体相同的海报，仅仅是一句文案的差别，都可能会有巨大的数据差异反馈。</p><p>大家请看下图，我做的两版海报，可以猜测一下数据差异。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/QJjpJALxON8bLJ8Pipu4.png"></p><p>右边的海报，扫码率比左边提升了近3倍。左边的图片，看不懂具体是内推什么？<br>右边的图，标注了360公司，并且二维码保留了微信的原生样式，3秒钟内不用刻意去识别，就知道是一个微信群二维码，而用户天生对入群围观有极大的兴趣。<br>虽然数据有了大幅提高，但仍不够理想，病毒系数K值仍达不到裂变所需的最低值。经过反思，由于海报形式太像广告，回归本源才是真谛。下图是最终的分享图片，扫码率能达到5%<del>10%（例如分享图片到活跃度一般的100人校招微信群，有5</del>10人会扫码进内推群）。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/BO4tQ5cQHmUjJgiuJbQg.png"></p><p>再来说文案设计：<br>大家请看下面，用户刚进群时，我们@他的通知文案：</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/bArkClGJkaTR4O0nwUxK.png"></p><p>首先明确给出内推方式，在3秒钟内取得新访客的信任。其次，介绍岗位信息，帮助用户完成投递，同时也是进一步获取用户的信任。紧接着，我们趁热打铁，提醒他帮忙邀请同学进群。下面我列出了3种邀请文案：<br>文案一：动之以情，晓之以理，用师兄的情怀感动对方。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/NV3H3qQ3uN2bmsU8Hle6.png"></p><p>文案二：明确告诉他群满100人后开始清理。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/g22UtKG965jq4MMj2Ocx.png"></p><p>文案三：邀请进入高级群，同时也提醒不分享将被移除。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/p4PVtYWIF2jrwAy3tI5J.png"></p><p>以上三种文案，有两种都失败了，并且我都找到了原因。大家可以自行分析下，如果是你，你会怎么设计文案？</p><blockquote><p>Tips：满100人后开始清理——这个方法有一个致命的问题。</p></blockquote><h2 id="八、渠道决定了用户质量"><a href="#八、渠道决定了用户质量" class="headerlink" title="八、渠道决定了用户质量"></a>八、渠道决定了用户质量</h2><p>有一些做裂变活动的同学很苦恼，由于用户质量不高，进群的用户中，不少是广告党。或者，活动虽然传播开了，但转化非常差，并没有收获到多少真正有效的目标用户。在本案例中，最终收获到的简历质量都非常高，大比例来自北邮、中科院大学、哈工大、湖大、清华、华科、西电的同学。<br>那么如何控制用户质量？如下图所示，老话说：<strong>物以类聚人以群分，优质的用户身边围绕着优质的用户，因此用户圈层是非常明显的，所以切记全面撒网、乱投渠道</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/NQeR5zktS6g2QRA846Vn.png"></p><p>具体怎么说？</p><p>首先，我们控制住了最初的投放渠道，保证生源优质，其次，通过文案和转发限制，保证二次传播吸引进来的也是优质用户。九、关于留存<br>经常听到不少同学反馈，做完一场裂变活动，剩下一堆不活跃的“死群”，用户的留存极差无比。我有两个提高留存的办法，可以教给大家：</p><ul><li>转化为个人微信号好友；</li><li>转移用户到高级群。</li></ul><p>我们都知道，<strong>戴夫·麦克卢尔（Dave McClure）提出的海盗指标AARRR模型：获客(Acquisition)、激活 (Activation)、留存(Retention)、变现(Revenue)、推荐(Referral)。</strong></p><p>但在实践过程中我们发现，如果产品留存不佳，用户进得快、出地也快，最后只会剩下一地鸡毛。张溪梦前辈提出了RARRA模型，把留存提到了首要的位置[5]。没有留存，增长数据只会越推越差，进入死循环。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/fAtuSzU9f2Ypa1pOh5eH.png"></p><p><strong>so, AARRR vs. RARRA: Which is Better?[6]</strong></p><p><img src= "/img/loading.gif" data-lazy-src="http://image.woshipm.com/wp-files/2018/12/oGzMBKaL11aXI0QKERR3.png"></p><blockquote><blockquote><p>思考：如果我们用篮子打水，能留下几分水？</p></blockquote></blockquote><blockquote><p>注：业内流传的Facebook留存率421规则：一款合格的产品，次日、7日、30日分别是40%、20%、10%（留存率）。</p></blockquote><h2 id="十、增长的本质"><a href="#十、增长的本质" class="headerlink" title="十、增长的本质"></a>十、增长的本质</h2><p>我始终认为，<strong>增长的本质是：“让用户相信你的内容是有价值的”</strong>，这句话贯穿今天分享的整个裂变活动，具体拆分来看分别是：用户、价值、相信。</p><p>###（1）了解你的用户</p><p>首先，要十分明确我们产品的目标受众，产品在为谁创造价值。进一步的，我们要能够洞察用户的心理，简单做法就是直接找核心用户单聊。否则，我们无法模拟用户在面对我们的产品，做出选择时的真实状态，也会导致我们无法制定出合理的增长策略。</p><h3 id="（2）相对的产品价值"><a href="#（2）相对的产品价值" class="headerlink" title="（2）相对的产品价值"></a>（2）相对的产品价值</h3><p>产品本身十分有价值，但产品的价值又是相对的，老话说“垃圾放对了位置，是宝藏”，反之也成立。如果对方不是我们的目标用户，那么即使提供再好的服务，对于他而言，也是没有价值的，正所谓对牛弹琴。</p><h3 id="（3）增长的核心是信任"><a href="#（3）增长的核心是信任" class="headerlink" title="（3）增长的核心是信任"></a>（3）增长的核心是信任</h3><p>如上述裂变活动中，毕竟个人简历是非常隐私的资料，没有信任的基础，增长就是一句空话。<br>通过上面的盘点，相信大家可以看出，增长裂变并没有想象中的那么困难。期待各位能触类旁通，复用到自己的行业和场景，人人都可实操。借这个机会，向本案例中，感受到不友好体验的同学们，对你们说一声抱歉。</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><blockquote><p>[1]360产品经理：我是如何用增长黑客思维，13天收获2,000+高质量简历：<a href="http://www.woshipm.com/operate/1064186.html">http://www.woshipm.com/operate/1064186.html</a><br>[2]蝌蚪互娱“黑客增长”系列（一）：黑客增长与北极星指标、OKRs、啊哈(AHA)时刻：<a href="http://blog.kedouhuyu.com/blog/16">http://blog.kedouhuyu.com/blog/16</a><br>[3]百度脑图：<a href="http://naotu.baidu.com/home">http://naotu.baidu.com/home</a><br>[4][PDF]损失厌恶与偏好异质性 – 浙江大学：<a href="http://oldmypage.zju.edu.cn/attachments/2014-10/07-1412682184-679644.pdf">http://oldmypage.zju.edu.cn/attachments/2014-10/07-1412682184-679644.pdf</a><br>[5]增长质变 – 从 AARRR 到 RARRA | GrowingIO 张溪梦：<a href="https://blog.growingio.com/growth/365">https://blog.growingio.com/growth/365</a><br>[6]AARRR vs. RARRA: Which is Better?：<a href="https://clevertap.com/blog/aarrr-metrics-vs-rarra-framework/">https://clevertap.com/blog/aarrr-metrics-vs-rarra-framework/</a><br>作者：金师兴，360 视频信息流业务线导航事业部 产品经理，负责千万级用户量信息流产品用户增长；2015年创立班马科技，获教育部和中关村资助；360公司产品委员会秘书成员。</p></blockquote><blockquote><p>本文由 @金师兴 原创发布于人人都是产品经理。 <a href="http://www.woshipm.com/operate/1748503.html">http://www.woshipm.com/operate/1748503.html</a><br>题图来自Unsplash，基于CC0协议</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品 </tag>
            
            <tag> 裂变 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文让你彻底搞清楚javascript中的require、import与export</title>
      <link href="2018/12/06/JavaScript-require-import-export-2018-12-06/"/>
      <url>2018/12/06/JavaScript-require-import-export-2018-12-06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章主要给大家介绍了关于javascript中require、import与export的相关资料，文中通过示例代码介绍的非常详细，对打击大的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要给大家介绍了关于javascript中require、import与export的相关内容，分享出来供大家参考学习，下面话不多说了，来一起看看详细的介绍吧。</p></blockquote><h2 id="为什么有模块概念"><a href="#为什么有模块概念" class="headerlink" title="为什么有模块概念"></a>为什么有模块概念</h2><p>理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p><p>但是，Javascript不是一种模块化编程语言，在es6以前，它是不支持”类”（class），所以也就没有”模块”（module）了。</p><h2 id="require时代"><a href="#require时代" class="headerlink" title="require时代"></a>require时代</h2><p>Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。</p><p><strong>* 原始写法 *</strong></p><p>模块就是实现特定功能的一组方法。<br>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123;</span><br><span class="line">　&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">function m2()&#123;</span><br><span class="line">　&#x2F;&#x2F;...　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数 <strong>* m1() *</strong> 和 <strong>* m2() *</strong> ，组成一个模块。使用的时候，直接调用就行了。</p><p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p><h2 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h2><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; new Object(&#123;</span><br><span class="line">_count : 0,</span><br><span class="line">　m1 : function ()&#123;</span><br><span class="line">　　&#x2F;&#x2F;...</span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : function ()&#123;</span><br><span class="line">　　&#x2F;&#x2F;...</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的函数 <strong>* m1() *</strong> 和 <strong>* m2() *</strong>  ，都封装在module1对象里。使用的时候，就是调用这个对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();    </span><br></pre></td></tr></table></figure><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module._count &#x3D; 1;</span><br></pre></td></tr></table></figure><h2 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h2><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var module &#x3D; (function() &#123;</span><br><span class="line">var _count &#x3D; 0;</span><br><span class="line">var m1 &#x3D; function() &#123;</span><br><span class="line">alert(_count)</span><br><span class="line">&#125;</span><br><span class="line">var m2 &#x3D; function() &#123;</span><br><span class="line">alert(_count + 1)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return &#123;</span><br><span class="line">m1: m1,</span><br><span class="line">m2: m2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>使用上面的写法，外部代码无法读取内部的_count变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　console.info(module._count); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure><p><strong>* module *</strong> 就是Javascript模块的基本写法。</p><h2 id="主流模块规范"><a href="#主流模块规范" class="headerlink" title="主流模块规范"></a>主流模块规范</h2><p>在es6以前，还没有提出一套官方的规范,从社区和框架推广程度而言,目前通行的javascript模块规范有两种：CommonJS 和 AMD</p><h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>[photos des=”node.js”]<br><img src= "/img/loading.gif" data-lazy-src="http://img.degenerate.cn/javascript/ayitg239.bmp"><br>[/photos]</p><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p><p>这标志”Javascript模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p><p>node编程中最重要的思想之一就是模块，而正是这个思想，让JavaScript的大规模工程成为可能。模块化编程在js界流行，也是基于此，随后在浏览器端，requirejs和seajs之类的工具包也出现了，可以说在对应规范下，require统治了ES6之前的所有模块化编程，即使现在，在ES6 module被完全实现之前，还是这样。</p><p>在CommonJS中,暴露模块使用 <strong>* module.exports *</strong> 和 <strong>* exports *</strong> ，很多人不明白暴露对象为什么会有两个,后面会介绍区别</p><p>在CommonJS中，有一个全局性方法 <strong>* require() *</strong> ，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var math &#x3D; require(&#39;math&#39;);</span><br></pre></td></tr></table></figure><p>然后，就可以调用模块提供的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　var math &#x3D; require(&#39;math&#39;);</span><br><span class="line">　math.add(2,3); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure><p>正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格</p><h2 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h2><p>[photos des=”requrie.js”]<br><img src= "/img/loading.gif" data-lazy-src="http://img.degenerate.cn/javascript/5lofrnpn.bmp"><br>[/photos]</p><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p><p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var math &#x3D; require(&#39;math&#39;);</span><br><span class="line">math.add(2, 3);</span><br></pre></td></tr></table></figure><p>第二行<strong>math.add(2, 3)</strong> ，在第一行**require(‘math’)**之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p><p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>模块必须采用特定的define()函数来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure><ol><li>id:字符串，模块名称(可选)</li><li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li><li>factory: 工厂方法，返回一个模块函数</li></ol><p>如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; math.js</span><br><span class="line">　　define(function ()&#123;</span><br><span class="line">　　　　var add &#x3D; function (x,y)&#123;</span><br><span class="line">　　　　　　return x+y;</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　add: add</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure><p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([&#39;Lib&#39;], function(Lib)&#123;</span><br><span class="line">　　　　function foo()&#123;</span><br><span class="line">　　　　　　Lib.doSomething();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　foo : foo</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure><p>当require()函数加载上面这个模块的时候，就会先加载Lib.js文件。</p><p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require([module], callback);</span><br></pre></td></tr></table></figure><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&#39;math&#39;], function (math) &#123;</span><br><span class="line">　math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p><p>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。</p><h2 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h2><p>[photos des=”CMD”]<br><img src= "/img/loading.gif" data-lazy-src="http://img.degenerate.cn/javascript/lld60uma.bmp"><br>[/photos]</p><p><strong>CMD (Common Module Definition)</strong>, 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">var clock &#x3D; require(&#39;clock&#39;);</span><br><span class="line">clock.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure><ul><li>id:字符串，模块名称(可选)</li><li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li><li>factory: 工厂方法，返回一个模块函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) &#123;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 模块代码</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">&#x2F;&#x2F; 模块代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>注意：带 id 和 dependencies 参数的 define 用法不属于 CMD 规范，而属于 Modules/Transport 规范。</li></ul><h2 id="CMD与AMD区别"><a href="#CMD与AMD区别" class="headerlink" title="CMD与AMD区别"></a>CMD与AMD区别</h2><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p><p>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</p><p>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p><p>现阶段的标准</p><p>[photos des=”ES6”]<br><img src= "/img/loading.gif" data-lazy-src="http://img.degenerate.cn/javascript/d83wlrxw.bmp"><br>[/photos]</p><p>ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块，但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口。</p><h2 id="export导出模块"><a href="#export导出模块" class="headerlink" title="export导出模块"></a>export导出模块</h2><p>export语法声明用于导出函数、对象、指定文件（或模块）的原始值。</p><p>注意：在node中使用的是exports,不要混淆了</p><p>export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export &#123; name1, name2, …, nameN &#125;;</span><br><span class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</span><br><span class="line">export let name1, name2, …, nameN; &#x2F;&#x2F; also var</span><br><span class="line">export let name1 &#x3D; …, name2 &#x3D; …, …, nameN; &#x2F;&#x2F; also var, const</span><br><span class="line"> </span><br><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; &#x2F;&#x2F; also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; &#x2F;&#x2F; also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br><span class="line"> </span><br><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br></pre></td></tr></table></figure><ul><li>name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用</li><li>default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入</li><li>－继承模块并导出继承模块所有的方法和属性</li><li>as－重命名导出“标识符”</li><li>from－从已经存在的模块、脚本文件…导出</li></ul><h2 id="命名式导出"><a href="#命名式导出" class="headerlink" title="命名式导出"></a>命名式导出</h2><p>模块可以通过export前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export &#123; myFunction &#125;; &#x2F;&#x2F; 导出一个已定义的函数</span><br><span class="line">export const foo &#x3D; Math.sqrt(2); &#x2F;&#x2F; 导出一个常量</span><br></pre></td></tr></table></figure><p>我们可以使用*和from关键字来实现的模块的继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export * from &#39;article&#39;;</span><br></pre></td></tr></table></figure><p>模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;IT笔录&#39;;</span><br><span class="line">var domain &#x3D; &#39;http:&#x2F;&#x2F;itbilu.com&#39;;</span><br><span class="line"> </span><br><span class="line">export &#123;name, domain&#125;; &#x2F;&#x2F; 相当于导出</span><br><span class="line">&#123;name:name,domain:domain&#125;</span><br></pre></td></tr></table></figure><p>模块导出时，我们可以使用as关键字对导出成员进行重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;IT笔录&#39;;</span><br><span class="line">var domain &#x3D; &#39;http:&#x2F;&#x2F;itbilu.com&#39;;</span><br><span class="line"> </span><br><span class="line">export &#123;name as siteName, domain&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：下面的语法有严重错误的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误演示</span><br><span class="line">export 1; &#x2F;&#x2F; 绝对不可以</span><br><span class="line"> </span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">export a;</span><br></pre></td></tr></table></figure><p>export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应</p><p>export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123;fun as default,a,b,c&#125;;</span><br></pre></td></tr></table></figure><h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default function() &#123;&#125;; &#x2F;&#x2F; 可以导出一个函数</span><br><span class="line">export default class()&#123;&#125;; &#x2F;&#x2F; 也可以出一个类</span><br></pre></td></tr></table></figure><h2 id="命名式导出与默认导出"><a href="#命名式导出与默认导出" class="headerlink" title="命名式导出与默认导出"></a>命名式导出与默认导出</h2><p>默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了default名称的命名导出。</p><p>下面两种导出方式是等价的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const D &#x3D; 123;</span><br><span class="line"> </span><br><span class="line">export default D;</span><br><span class="line">export &#123; D as default &#125;;</span><br></pre></td></tr></table></figure><h2 id="export使用示例"><a href="#export使用示例" class="headerlink" title="export使用示例"></a>export使用示例</h2><p>使用名称导出一个模块时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &quot;my-module.js&quot; 模块</span><br><span class="line">export function cube(x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br><span class="line">const foo &#x3D; Math.PI + Math.SQRT2;</span><br><span class="line">export &#123; foo &#125;;</span><br></pre></td></tr></table></figure><p>在另一个模块（脚本文件）中，我们可以像下面这样引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; cube, foo &#125; from &#39;my-module&#39;;</span><br><span class="line">console.log(cube(3)); &#x2F;&#x2F; 27</span><br><span class="line">console.log(foo); &#x2F;&#x2F; 4.555806215962888</span><br></pre></td></tr></table></figure><p>使用默认导出一个模块时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &quot;my-module.js&quot;模块</span><br><span class="line">export default function (x) &#123;</span><br><span class="line">return x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用 &quot;my-module.js&quot;模块</span><br><span class="line">import cube from &#39;my-module&#39;;</span><br><span class="line">console.log(cube(3)); &#x2F;&#x2F; 27</span><br></pre></td></tr></table></figure><h2 id="import引入模块"><a href="#import引入模块" class="headerlink" title="import引入模块"></a>import引入模块</h2><p>import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p><p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p><p>import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import defaultMember from &quot;module-name&quot;;</span><br><span class="line">import * as name from &quot;module-name&quot;;</span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, * as name from &quot;module-name&quot;;</span><br><span class="line">import &quot;module-name&quot;;</span><br></pre></td></tr></table></figure><ul><li>name－从将要导入模块中收到的导出值的名称</li><li>member, memberN－从导出模块，导入指定名称的多个成员</li><li>defaultMember－从导出模块，导入默认导出成员</li><li>alias, aliasN－别名，对指定导入成员进行的重命名</li><li>module-name－要导入的模块。是一个文件名</li><li>as－重命名导入成员名称（“标识符”）</li><li>from－从已经存在的模块、脚本文件等导入</li></ul><h2 id="命名式导入"><a href="#命名式导入" class="headerlink" title="命名式导入"></a>命名式导入</h2><p>我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员：</p><p><strong>注意：</strong>花括号里面的变量与export后面的变量一一对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;myMember&#125; from &quot;my-module&quot;;</span><br><span class="line">import &#123;foo, bar&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><p>通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as myModule from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><p>导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><p>导入多个成员时，同样可以使用别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short&#125; from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><p>导入一个模块，但不进行任何绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。</p><p>直接导入默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault from &quot;my-module&quot;;</span><br></pre></td></tr></table></figure><p>也可以在命名空间导入和名称导入中，同时使用默认导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, * as myModule from &quot;my-module&quot;; &#x2F;&#x2F; myModule 做为命名空间使用</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import myDefault, &#123;foo, bar&#125; from &quot;my-module&quot;; &#x2F;&#x2F; 指定成员导入</span><br></pre></td></tr></table></figure><h4 id="import使用示例"><a href="#import使用示例" class="headerlink" title="import使用示例"></a>import使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; --file.js--</span><br><span class="line">function getJSON(url, callback) &#123;</span><br><span class="line">let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">callback(this.responseText)</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export function getUsefulContents(url, callback) &#123;</span><br><span class="line">getJSON(url, data &#x3D;&gt; callback(JSON.parse(data)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; --main.js--</span><br><span class="line">import &#123; getUsefulContents &#125; from &quot;file&quot;;</span><br><span class="line">getUsefulContents(&quot;http:&#x2F;&#x2F;itbilu.com&quot;, data &#x3D;&gt; &#123;</span><br><span class="line">doSomethingUseful(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; d.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 等效于：</span><br><span class="line">function a() &#123;&#125;;</span><br><span class="line">export &#123;a as default&#125;;</span><br></pre></td></tr></table></figure><h4 id="在import的时候，可以这样用："><a href="#在import的时候，可以这样用：" class="headerlink" title="在import的时候，可以这样用："></a>在import的时候，可以这样用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import a from &#39;.&#x2F;d&#39;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 等效于，或者说就是下面这种写法的简写，是同一个意思</span><br><span class="line">import &#123;default as a&#125; from &#39;.&#x2F;d&#39;;</span><br></pre></td></tr></table></figure><p>这个语法糖的好处就是import的时候，可以省去花括号{}。</p><p>简单的说，如果import的时候，你发现某个变量没有花括号括起来（没有*号），那么你在脑海中应该把它还原成有花括号的as语法。</p><p>所以，下面这种写法你也应该理解了吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $,&#123;each,map&#125; from &#39;jquery&#39;;</span><br></pre></td></tr></table></figure><p>import后面第一个$是{defalut as $}的替代写法。</p><h4 id="as关键字"><a href="#as关键字" class="headerlink" title="as关键字"></a>as关键字</h4><p>as简单的说就是取一个别名,export中可以用，import中其实可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var a &#x3D; function() &#123;&#125;;</span><br><span class="line">export &#123;a as fun&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">import &#123;fun as a&#125; from &#39;.&#x2F;a&#39;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>上面这段代码，export的时候，对外提供的接口是fun，它是a.js内部a这个函数的别名，但是在模块外面，认不到a，只能认到fun。</p><p>import中的as就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个c.js也通过了fun这个接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; c.js</span><br><span class="line">export function fun() &#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果在b.js中同时使用a和c这两个模块，就必须想办法解决接口重名的问题，as就解决了。</p><h2 id="CommonJS中module-exports-与-exports的区别"><a href="#CommonJS中module-exports-与-exports的区别" class="headerlink" title="CommonJS中module.exports 与 exports的区别"></a>CommonJS中module.exports 与 exports的区别</h2><h4 id="Module-exports"><a href="#Module-exports" class="headerlink" title="Module.exports"></a>Module.exports</h4><p>The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what you want to do.</p><blockquote><p>译文：module.exports对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给module.exports。 注意，将期望的对象赋值给exports会简单地重新绑定到本地exports变量上，这可能不是你想要的。</p></blockquote><h4 id="Module-exports-1"><a href="#Module-exports-1" class="headerlink" title="Module.exports"></a>Module.exports</h4><p>The exports variable is available within a module’s file-level scope, and is assigned the value of module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = … can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new value is assigned to exports, it is no longer bound to module.exports:</p><blockquote><p>译文：exports变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。它有一个快捷方式，以便 module.exports.f = … 可以被更简洁地写成exports.f = … 。 注意，就像任何变量，如果一个新的值被赋值给exports，它就不再绑定到module.exports(其实是exports.属性会自动挂载到没有命名冲突的module.exports.属性)</p></blockquote><p>从<a href="http://nodejs.cn/api/modules.html#modules_module_exports">Api</a>文档上面的可以看出，从require导入方式去理解，关键有两个变量(全局变量module.exports，局部变量exports)、一个返回值(module.exports)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function require(...) &#123;</span><br><span class="line">var module &#x3D; &#123; exports: &#123;&#125; &#125;;</span><br><span class="line">((module, exports) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 你的被引入代码 Start</span><br><span class="line">&#x2F;&#x2F; var exports &#x3D; module.exports &#x3D; &#123;&#125;; (默认都有的)</span><br><span class="line">function some_func() &#123;&#125;;</span><br><span class="line">exports &#x3D; some_func;</span><br><span class="line">&#x2F;&#x2F; 此时，exports不再挂载到module.exports，</span><br><span class="line">&#x2F;&#x2F; export将导出&#123;&#125;默认对象</span><br><span class="line">module.exports &#x3D; some_func;</span><br><span class="line">&#x2F;&#x2F; 此时，这个模块将导出some_func对象，覆盖exports上的some_func</span><br><span class="line">&#x2F;&#x2F; 你的被引入代码 End</span><br><span class="line">&#125;)(module, module.exports);</span><br><span class="line">&#x2F;&#x2F; 不管是exports还是module.exports，最后返回的还是module.exports</span><br><span class="line">return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="demo-js"><a href="#demo-js" class="headerlink" title="demo.js:"></a>demo.js:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(exports); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">console.log(module.exports); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">console.log(exports &#x3D;&#x3D;&#x3D; module.exports); &#x2F;&#x2F; true</span><br><span class="line">console.log(exports &#x3D;&#x3D; module.exports); &#x2F;&#x2F; true</span><br><span class="line">console.log(module);</span><br><span class="line">&#x2F;**</span><br><span class="line">Module &#123;</span><br><span class="line">id: &#39;.&#39;,</span><br><span class="line">exports: &#123;&#125;,</span><br><span class="line">parent: null,</span><br><span class="line">filename: &#39;&#x2F;Users&#x2F;larben&#x2F;Desktop&#x2F;demo.js&#39;,</span><br><span class="line">loaded: false,</span><br><span class="line">children: [],</span><br><span class="line">paths:</span><br><span class="line">[ &#39;&#x2F;Users&#x2F;larben&#x2F;Desktop&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;Users&#x2F;larben&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;Users&#x2F;node_modules&#39;,</span><br><span class="line">&#39;&#x2F;node_modules&#39; ] &#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>注意</p><p>每个js文件一创建，都有一个var exports = module.exports = {} , 使exports和module.exports都指向一个空对象。</p><p>module.exports和exports所指向的内存地址相同</p><p>本文转载自：<a href="https://www.jb51.net/article/124442.htm">https://www.jb51.net/article/124442.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> web </tag>
            
            <tag> require </tag>
            
            <tag> import </tag>
            
            <tag> export </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商商品数据库设计</title>
      <link href="2018/10/22/product-2018-10-23-1/"/>
      <url>2018/10/22/product-2018-10-23-1/</url>
      
        <content type="html"><![CDATA[<h2 id="sku"><a href="#sku" class="headerlink" title="sku"></a>sku</h2><blockquote><p>在电商系统中，商品模型至关重要，是整个电商的核心，下面通过一个简单的分析，设计一个基础的商品模型。</p></blockquote><h2 id="商品模型的演化"><a href="#商品模型的演化" class="headerlink" title="商品模型的演化"></a>商品模型的演化</h2><pre><code>在以前，那时 CMS 很流行，最常见的模型是栏目 - 文章模型。于是做电商的时候，自然就继承了这种一对多的关系。只是栏目变成了分类，文章变成了商品。商品也具备了独特的业务属性。现在很多电商网站上左侧的菜单，也就是这个分类。</code></pre><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kn6zSs.jpg"></p><p>  后来我们慢慢发现一个问题，只有分类并不能适应所有的需求，比如 nike 鞋和 nikeT 恤，用户可能希望先看 nike 的所有商品，这个模型就不能满足。<br>  我们想在这个关系中，加入“品牌”概念。于是：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Knch7T.jpg"></p><p>  这样基本用户可以在首页上通过分类或者品牌找到自己想要的商品，也可以直接查看热门的商品和新上架的商品。<br>  但是问题也来了，用户在进入分类后，展示在用户面前的是很多很多商品，用户希望再通过筛选查询出更接近他目标的商品。<br>  于是优秀的产品设计师，设计出了类似这样的 UI：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/KngQvn.jpg"></p><p>  用户可以通过这些筛选条件进一步缩小自己的目标范围，那么问题又来了，这样的产品需求排在程序员面前，怎么去实现它？<br>  经过分析，我们找出了一个方法，我们知道商品之间的属性可能存在着较大的差别，比如牛仔裤它有版型、腰型、裤长等属性；<br>  而电脑它有 CPU、显卡等属性，各类商品的属性是不同的。<br>  再进一步想，休闲裤也版型、腰型、裤长等属性；台式电脑或者笔记本电脑都有 CPU、显卡等属性。<br>  所以我们得出：一个分类对应若干属性，而一个属性，对应若干属性选项，而一个具体商品又对应若干属性选项（例如具体一条牛仔裤，他的裤长：7 分，裤型：直筒）。<br>  有点绕，仔细品味一下。  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kng8bV.jpg"></p><p>  从图上可以看出，分类和属性的关系（例如：“牛仔裤”分类下有裤型、裤长、版型等属性）、属性和属性选项的关系（例如：裤长属性有长款、九分裤、七分裤的选项）、商品和属性选项的关系（例如某条牛仔裤的裤长是 7 分裤）。<br>  至此，我们知道一个商品的分类、品牌以及它有什么属性和对应的属性值。那么通过筛选条件，自然就可以查询出指定的商品。<br>  这里特别说一句，价格也是属性，不要设想用商品表中的价格字段去做计算。<br>  这不利于查询也增加了复杂度，让商家编辑人员用属性来设置并保证他的正确性。  </p><p>  有了这个模型，我们大概就可以看到以下界面（请不要太关注左边，重点在右边和下面）：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kngt5F.jpg"></p><p>  这个页面展示商品的所有信息，按照之前的设计好像都可以满足。<br>  但是我们似乎感觉错过了什么，在图上右边我们发现该商品当前的颜色和尺寸，并且允许用户可以选择其他的颜色和尺寸。<br>  这给我们带来了疑惑，这里的“颜色”和“尺寸”是什么，一件商品的不同颜色不同尺寸是算一个商品还是多个商品。<br>  经过思考后，我们发现我们混淆了两个概念——“商品”和“货品”。不同规格的货品作为独立的商品。<br>  比如一条裤子的有 L 尺寸、M 尺寸、一个 U 盘有 16G 还是 32G 的，都是同样的货品，不同规格的商品。<br>  可以认为货品和商品是一对多的关系。<br>  弄清了这个概念，处理这个需求就容易多了，这里的“颜色”、“尺寸”我们就作为“规格”来处理，而红色、黑色；L 号、M 号我们视为规格的选项或者说规格值。<br>  一件货品对应若干规格，而具有某一规格值的货品就是商品。  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kng2Pe.jpg"></p><p>  好了，现在好像差不多了。<br>  基于这个模型可以满足基本的商品搜索、展示的需求。<br>  搜索引擎也可以根据这个模型数据生成对应的商品索引，达到准确搜索的目的。<br>  商品模块还会和其他模块一起协作，比如用户系统、订单系统、支付系统等。<br>  一般情况下我们会把商品业务独立出来做成“商品中心”的服务，集中处理商品查询、更新、发布等业务，支撑其他业务。  </p><h2 id="从-SPU、SKU-开始"><a href="#从-SPU、SKU-开始" class="headerlink" title="从 SPU、SKU 开始"></a>从 SPU、SKU 开始</h2><p>  首先我们需要澄清上篇中的这两个概念，在上篇文章中“货品”是指一种概念物品，这种物品并不是一个具体的实物，当它具备具体的属性、价格时，才是一种实物，也就是商品。<br>  “商品”就是库存中一个具体的实物。<br>  例如：iphone6，就是一种货品，但用户购买的并不是货品而是商品，也就是用户最终购买的可能是：金色 -16G- 移动版 iphone6。<br>  换句话来说，货品是一种产品的称谓（如 iphone6），商品是用户购买的具体实物，具备特定的属性（如：金色 -16G- 移动版）。<br>  如果觉得这样理解还是比较混，那么忘记这两个概念，下面讲标准化的名称。  </p><p>  我们刚才说的 iphone6，书面称谓叫“SPU” Standard Product Unit （标准化产品单元），它是最接近用户认知的产品单元，比如用户说，我想买个 iphone4、iphone6、小米 4，这些都是 SPU，也就是用户普遍认知范围内的一种产品。<br>  然而在电商系统中只有 SPU 并没有什么卵用，用户购买时肯定要确定，需要什么颜色、多少 G 的，支持什么网络。<br>  所以，例如金色 -16G- 移动版 iphone6，就需要一个名称去规范它，这个名称叫“SKU” Stock Keeping Unit(库存单元)，换句话理解就是库存里面存的东西，库存里存在东西肯定是具体的某种规格的 iphone6。基于这个理解，我们先画下图：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kng4KI.jpg"></p><p>  SPU,SKU 两个表，有各自的编码，这方便库存统计以及后台系统的管理，另外价格字段是在 SKU 中，这应该好理解，不同规格的 iphone6 肯定价格不一样，另外 SPU 与分类和品牌关联.<br>  如 iphone6 属于“手机”分类，“苹果”品牌。当然一个 SPU 也可能属于多个分类，可以做成多对多的关系。有了这个基础，我们再来看电商商品详情页是怎么设计的：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/KngqPg.jpg"></p><p>  我们看到这个页面其实是一个 SKU 的详情页，因为它指定了价格、颜色、版本、容量等信息，不同的颜色、版本、容量其实是不同的价格，不同的 SKU。<br>  我们如果要实现这个设计，我们需要加两个概念，就是“属性”和“属性选项”。<br>  “属性”正如这里的颜色、版本、容量。而“属性选项”则是金色、银色、移动 4G 版、16gb、64gb 等。可以看出“属性”和“属性选项”是一对多的关系，<br>  而“属性选项”和 SKU 则是多对多关系，一个金色 -16G- 移动版 iphone6，具备“金色”、“16G”，“移动版”多个选项，而一个“金色”选项除了对应 iphone6 还可以对于 iphone4。我们继续画图：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/KngLGQ.jpg"></p><p>  需要注意的是，属性是对于一个分类的，这样设计的目的主要是为了属性能归类管理，也方便在添加产品时，通过分类对属性进行筛选。<br>  例如，“手机”分类有颜色、版本、容量等属性，而“衬衫”分类有“颜色”、“尺寸”。这里有博友可能有疑问，如果属性和分类是一对多的关系，那么属性表将会出现一些冗余，比如“手机”、“衬衫”都有颜色属性，但是在属性表中就会两条颜色的记录甚至更多。这里其实可以设计为多对多的关系。<br>  一对多的关系，可以在商品规模小、数据量不太大的电商上适应，这样的好处是，可以让产品发布者更好的管理属性选项和发布产品，因为即便是两个颜色的属性，但他们的属性选项确可以不同，对于“手机”来说，可能只有黑、白、金、银等颜色，但对于“衬衫”分类来说选项就可以有“红橙黄绿青蓝紫”甚至有“花格”。<br>  所以可以考虑牺牲冗余来提高商家发布者的体验。接下来我们来看另外一个特性——“规格”：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kngzq0.jpg"></p><p>  “规格”代表这一个 SKU 具体的各项参数，是一个详细的产品规格说明，用户可以通过这些参数与其他同类手机做对比。<br>  这些参数中，部分参数将参与列表页的筛选条件中  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kn2CIU.jpg"></p><p>  我们可以注意到两幅图，有些规格并不能对应上。<br>  这是因为我们在规格表中可以设置哪些规格显示在详细页中，哪些规格显示在列表筛选条件中。<br>  最终的商品模型就是这样：  </p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.ax1x.com/2019/10/19/Kn2iiF.jpg"></p><p>  好了，这个电商商品模型的雏形就有了，但一个成熟的大型电商系统模型要比这个复杂的多，光是一个价格都会有一个单独的模块进行管理，比如市场价、进货价、成本价等，要进行成本核算，要与营销活动结合，双 11 折扣，或者与其他商品打包购买价格更便宜等。<br>  总之，需要根据业务的需要进行一步一步的扩展和设计。以后有机会介绍下电商中订单模型。  </p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> sku </tag>
            
            <tag> spu </tag>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 PHP 的数据爬取（QueryList）</title>
      <link href="2018/09/14/php-querylist-2018-09-14/"/>
      <url>2018/09/14/php-querylist-2018-09-14/</url>
      
        <content type="html"><![CDATA[<h2 id="基于PHP的数据爬取"><a href="#基于PHP的数据爬取" class="headerlink" title="基于PHP的数据爬取"></a>基于PHP的数据爬取</h2><p><a href="https://www.querylist.cc/">官方网站站点</a></p><blockquote><p>简单、 灵活、强大的PHP采集工具，让采集更简单一点。</p></blockquote><p>简介：<br>  QueryList使用jQuery选择器来做采集，让你告别复杂的正则表达式；QueryList具有jQuery一样的DOM操作能力、Http网络操作能力、乱码解决能力、内容过滤能力以及可扩展能力；可以轻松实现诸如：模拟登陆、伪造浏览器、HTTP代理等意复杂的网络请求；拥有丰富的插件，支持多线程采集以及使用PhantomJS采集JavaScript动态渲染的页面。</p><p>安装</p><p>通过Composer安装:</p><pre><code>composer require jaeger/querylist</code></pre><p>使用教程：</p><p>直接上代码：</p><pre><code>  &lt;?phpinclude &#39;./vendor/autoload.php&#39;;// 使用composer安装后引入目录use QL\QueryList;// 使用插件$html = file_get_contents(&#39;https://www.biqudu.com/14_14778/&#39;);// 手动获取页面$data = QueryList::html($html);// 得到页面内容$data = QueryList::setHtml(&#39;https://www.biqudu.com/14_14778/&#39;);// 等同于上面的html()$data-&gt;rules([    // 采集所有a标签的href属性    &#39;link&#39; =&gt; [&#39;a&#39;,&#39;href&#39;],    // 采集所有a标签的文本内容    &#39;text&#39; =&gt; [&#39;a&#39;,&#39;text&#39;]    ]);// 此处$data = 上面已经获取到网页内容之后的对象// 设置采集规则 替代了传统正则$data-&gt;query();// 此处$data = 上面已经获取到网页内容之后的对象 // query 执行操作$data-&gt;getData();// 此处$data = 上面已经获取到网页内容之后的对象// 得到数据结果$data-&gt;all();// 此处$data = 上面已经获取到网页内容之后的对象// 将数据转换成二维数组print_r($data-&gt;all());// 打印结果</code></pre><span id="more"></span><p>上面的基本使用方法就是这样了 这样我们已经可以抓取到一定的数据了</p><p>如果你对爬取数据感兴趣 欢迎前往官网查看文档 <a href="https://doc.querylist.cc/">超级传送门（点我）</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> QueryList </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> querylist </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 数据抓取 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
